// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/monitoring/v3/service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_google_2fmonitoring_2fv3_2fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_google_2fmonitoring_2fv3_2fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/resource.pb.h"
#include <google/protobuf/duration.pb.h>
#include "google/type/calendar_period.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_google_2fmonitoring_2fv3_2fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_google_2fmonitoring_2fv3_2fservice_2eproto;
namespace google {
namespace monitoring {
namespace v3 {
class BasicSli;
struct BasicSliDefaultTypeInternal;
extern BasicSliDefaultTypeInternal _BasicSli_default_instance_;
class BasicSli_AvailabilityCriteria;
struct BasicSli_AvailabilityCriteriaDefaultTypeInternal;
extern BasicSli_AvailabilityCriteriaDefaultTypeInternal _BasicSli_AvailabilityCriteria_default_instance_;
class BasicSli_LatencyCriteria;
struct BasicSli_LatencyCriteriaDefaultTypeInternal;
extern BasicSli_LatencyCriteriaDefaultTypeInternal _BasicSli_LatencyCriteria_default_instance_;
class DistributionCut;
struct DistributionCutDefaultTypeInternal;
extern DistributionCutDefaultTypeInternal _DistributionCut_default_instance_;
class Range;
struct RangeDefaultTypeInternal;
extern RangeDefaultTypeInternal _Range_default_instance_;
class RequestBasedSli;
struct RequestBasedSliDefaultTypeInternal;
extern RequestBasedSliDefaultTypeInternal _RequestBasedSli_default_instance_;
class Service;
struct ServiceDefaultTypeInternal;
extern ServiceDefaultTypeInternal _Service_default_instance_;
class ServiceLevelIndicator;
struct ServiceLevelIndicatorDefaultTypeInternal;
extern ServiceLevelIndicatorDefaultTypeInternal _ServiceLevelIndicator_default_instance_;
class ServiceLevelObjective;
struct ServiceLevelObjectiveDefaultTypeInternal;
extern ServiceLevelObjectiveDefaultTypeInternal _ServiceLevelObjective_default_instance_;
class ServiceLevelObjective_UserLabelsEntry_DoNotUse;
struct ServiceLevelObjective_UserLabelsEntry_DoNotUseDefaultTypeInternal;
extern ServiceLevelObjective_UserLabelsEntry_DoNotUseDefaultTypeInternal _ServiceLevelObjective_UserLabelsEntry_DoNotUse_default_instance_;
class Service_AppEngine;
struct Service_AppEngineDefaultTypeInternal;
extern Service_AppEngineDefaultTypeInternal _Service_AppEngine_default_instance_;
class Service_CloudEndpoints;
struct Service_CloudEndpointsDefaultTypeInternal;
extern Service_CloudEndpointsDefaultTypeInternal _Service_CloudEndpoints_default_instance_;
class Service_ClusterIstio;
struct Service_ClusterIstioDefaultTypeInternal;
extern Service_ClusterIstioDefaultTypeInternal _Service_ClusterIstio_default_instance_;
class Service_Custom;
struct Service_CustomDefaultTypeInternal;
extern Service_CustomDefaultTypeInternal _Service_Custom_default_instance_;
class Service_IstioCanonicalService;
struct Service_IstioCanonicalServiceDefaultTypeInternal;
extern Service_IstioCanonicalServiceDefaultTypeInternal _Service_IstioCanonicalService_default_instance_;
class Service_MeshIstio;
struct Service_MeshIstioDefaultTypeInternal;
extern Service_MeshIstioDefaultTypeInternal _Service_MeshIstio_default_instance_;
class Service_Telemetry;
struct Service_TelemetryDefaultTypeInternal;
extern Service_TelemetryDefaultTypeInternal _Service_Telemetry_default_instance_;
class Service_UserLabelsEntry_DoNotUse;
struct Service_UserLabelsEntry_DoNotUseDefaultTypeInternal;
extern Service_UserLabelsEntry_DoNotUseDefaultTypeInternal _Service_UserLabelsEntry_DoNotUse_default_instance_;
class TimeSeriesRatio;
struct TimeSeriesRatioDefaultTypeInternal;
extern TimeSeriesRatioDefaultTypeInternal _TimeSeriesRatio_default_instance_;
class WindowsBasedSli;
struct WindowsBasedSliDefaultTypeInternal;
extern WindowsBasedSliDefaultTypeInternal _WindowsBasedSli_default_instance_;
class WindowsBasedSli_MetricRange;
struct WindowsBasedSli_MetricRangeDefaultTypeInternal;
extern WindowsBasedSli_MetricRangeDefaultTypeInternal _WindowsBasedSli_MetricRange_default_instance_;
class WindowsBasedSli_PerformanceThreshold;
struct WindowsBasedSli_PerformanceThresholdDefaultTypeInternal;
extern WindowsBasedSli_PerformanceThresholdDefaultTypeInternal _WindowsBasedSli_PerformanceThreshold_default_instance_;
}  // namespace v3
}  // namespace monitoring
}  // namespace google
PROTOBUF_NAMESPACE_OPEN
template<> ::google::monitoring::v3::BasicSli* Arena::CreateMaybeMessage<::google::monitoring::v3::BasicSli>(Arena*);
template<> ::google::monitoring::v3::BasicSli_AvailabilityCriteria* Arena::CreateMaybeMessage<::google::monitoring::v3::BasicSli_AvailabilityCriteria>(Arena*);
template<> ::google::monitoring::v3::BasicSli_LatencyCriteria* Arena::CreateMaybeMessage<::google::monitoring::v3::BasicSli_LatencyCriteria>(Arena*);
template<> ::google::monitoring::v3::DistributionCut* Arena::CreateMaybeMessage<::google::monitoring::v3::DistributionCut>(Arena*);
template<> ::google::monitoring::v3::Range* Arena::CreateMaybeMessage<::google::monitoring::v3::Range>(Arena*);
template<> ::google::monitoring::v3::RequestBasedSli* Arena::CreateMaybeMessage<::google::monitoring::v3::RequestBasedSli>(Arena*);
template<> ::google::monitoring::v3::Service* Arena::CreateMaybeMessage<::google::monitoring::v3::Service>(Arena*);
template<> ::google::monitoring::v3::ServiceLevelIndicator* Arena::CreateMaybeMessage<::google::monitoring::v3::ServiceLevelIndicator>(Arena*);
template<> ::google::monitoring::v3::ServiceLevelObjective* Arena::CreateMaybeMessage<::google::monitoring::v3::ServiceLevelObjective>(Arena*);
template<> ::google::monitoring::v3::ServiceLevelObjective_UserLabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::google::monitoring::v3::ServiceLevelObjective_UserLabelsEntry_DoNotUse>(Arena*);
template<> ::google::monitoring::v3::Service_AppEngine* Arena::CreateMaybeMessage<::google::monitoring::v3::Service_AppEngine>(Arena*);
template<> ::google::monitoring::v3::Service_CloudEndpoints* Arena::CreateMaybeMessage<::google::monitoring::v3::Service_CloudEndpoints>(Arena*);
template<> ::google::monitoring::v3::Service_ClusterIstio* Arena::CreateMaybeMessage<::google::monitoring::v3::Service_ClusterIstio>(Arena*);
template<> ::google::monitoring::v3::Service_Custom* Arena::CreateMaybeMessage<::google::monitoring::v3::Service_Custom>(Arena*);
template<> ::google::monitoring::v3::Service_IstioCanonicalService* Arena::CreateMaybeMessage<::google::monitoring::v3::Service_IstioCanonicalService>(Arena*);
template<> ::google::monitoring::v3::Service_MeshIstio* Arena::CreateMaybeMessage<::google::monitoring::v3::Service_MeshIstio>(Arena*);
template<> ::google::monitoring::v3::Service_Telemetry* Arena::CreateMaybeMessage<::google::monitoring::v3::Service_Telemetry>(Arena*);
template<> ::google::monitoring::v3::Service_UserLabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::google::monitoring::v3::Service_UserLabelsEntry_DoNotUse>(Arena*);
template<> ::google::monitoring::v3::TimeSeriesRatio* Arena::CreateMaybeMessage<::google::monitoring::v3::TimeSeriesRatio>(Arena*);
template<> ::google::monitoring::v3::WindowsBasedSli* Arena::CreateMaybeMessage<::google::monitoring::v3::WindowsBasedSli>(Arena*);
template<> ::google::monitoring::v3::WindowsBasedSli_MetricRange* Arena::CreateMaybeMessage<::google::monitoring::v3::WindowsBasedSli_MetricRange>(Arena*);
template<> ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* Arena::CreateMaybeMessage<::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace google {
namespace monitoring {
namespace v3 {

enum ServiceLevelObjective_View : int {
  ServiceLevelObjective_View_VIEW_UNSPECIFIED = 0,
  ServiceLevelObjective_View_FULL = 2,
  ServiceLevelObjective_View_EXPLICIT = 1,
  ServiceLevelObjective_View_ServiceLevelObjective_View_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ServiceLevelObjective_View_ServiceLevelObjective_View_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ServiceLevelObjective_View_IsValid(int value);
constexpr ServiceLevelObjective_View ServiceLevelObjective_View_View_MIN = ServiceLevelObjective_View_VIEW_UNSPECIFIED;
constexpr ServiceLevelObjective_View ServiceLevelObjective_View_View_MAX = ServiceLevelObjective_View_FULL;
constexpr int ServiceLevelObjective_View_View_ARRAYSIZE = ServiceLevelObjective_View_View_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceLevelObjective_View_descriptor();
template<typename T>
inline const std::string& ServiceLevelObjective_View_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceLevelObjective_View>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceLevelObjective_View_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServiceLevelObjective_View_descriptor(), enum_t_value);
}
inline bool ServiceLevelObjective_View_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceLevelObjective_View* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServiceLevelObjective_View>(
    ServiceLevelObjective_View_descriptor(), name, value);
}
// ===================================================================

class Service_Custom final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:google.monitoring.v3.Service.Custom) */ {
 public:
  inline Service_Custom() : Service_Custom(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Service_Custom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Service_Custom(const Service_Custom& from);
  Service_Custom(Service_Custom&& from) noexcept
    : Service_Custom() {
    *this = ::std::move(from);
  }

  inline Service_Custom& operator=(const Service_Custom& from) {
    CopyFrom(from);
    return *this;
  }
  inline Service_Custom& operator=(Service_Custom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Service_Custom& default_instance() {
    return *internal_default_instance();
  }
  static inline const Service_Custom* internal_default_instance() {
    return reinterpret_cast<const Service_Custom*>(
               &_Service_Custom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Service_Custom& a, Service_Custom& b) {
    a.Swap(&b);
  }
  inline void Swap(Service_Custom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Service_Custom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Service_Custom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Service_Custom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Service_Custom& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Service_Custom& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.Service.Custom";
  }
  protected:
  explicit Service_Custom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.Service.Custom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class Service_AppEngine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.Service.AppEngine) */ {
 public:
  inline Service_AppEngine() : Service_AppEngine(nullptr) {}
  ~Service_AppEngine() override;
  explicit PROTOBUF_CONSTEXPR Service_AppEngine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Service_AppEngine(const Service_AppEngine& from);
  Service_AppEngine(Service_AppEngine&& from) noexcept
    : Service_AppEngine() {
    *this = ::std::move(from);
  }

  inline Service_AppEngine& operator=(const Service_AppEngine& from) {
    CopyFrom(from);
    return *this;
  }
  inline Service_AppEngine& operator=(Service_AppEngine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Service_AppEngine& default_instance() {
    return *internal_default_instance();
  }
  static inline const Service_AppEngine* internal_default_instance() {
    return reinterpret_cast<const Service_AppEngine*>(
               &_Service_AppEngine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Service_AppEngine& a, Service_AppEngine& b) {
    a.Swap(&b);
  }
  inline void Swap(Service_AppEngine* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Service_AppEngine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Service_AppEngine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Service_AppEngine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Service_AppEngine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Service_AppEngine& from) {
    Service_AppEngine::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Service_AppEngine* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.Service.AppEngine";
  }
  protected:
  explicit Service_AppEngine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleIdFieldNumber = 1,
  };
  // string module_id = 1;
  void clear_module_id();
  const std::string& module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_id();
  PROTOBUF_NODISCARD std::string* release_module_id();
  void set_allocated_module_id(std::string* module_id);
  private:
  const std::string& _internal_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_id(const std::string& value);
  std::string* _internal_mutable_module_id();
  public:

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.Service.AppEngine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class Service_CloudEndpoints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.Service.CloudEndpoints) */ {
 public:
  inline Service_CloudEndpoints() : Service_CloudEndpoints(nullptr) {}
  ~Service_CloudEndpoints() override;
  explicit PROTOBUF_CONSTEXPR Service_CloudEndpoints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Service_CloudEndpoints(const Service_CloudEndpoints& from);
  Service_CloudEndpoints(Service_CloudEndpoints&& from) noexcept
    : Service_CloudEndpoints() {
    *this = ::std::move(from);
  }

  inline Service_CloudEndpoints& operator=(const Service_CloudEndpoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline Service_CloudEndpoints& operator=(Service_CloudEndpoints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Service_CloudEndpoints& default_instance() {
    return *internal_default_instance();
  }
  static inline const Service_CloudEndpoints* internal_default_instance() {
    return reinterpret_cast<const Service_CloudEndpoints*>(
               &_Service_CloudEndpoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Service_CloudEndpoints& a, Service_CloudEndpoints& b) {
    a.Swap(&b);
  }
  inline void Swap(Service_CloudEndpoints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Service_CloudEndpoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Service_CloudEndpoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Service_CloudEndpoints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Service_CloudEndpoints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Service_CloudEndpoints& from) {
    Service_CloudEndpoints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Service_CloudEndpoints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.Service.CloudEndpoints";
  }
  protected:
  explicit Service_CloudEndpoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 1,
  };
  // string service = 1;
  void clear_service();
  const std::string& service() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service();
  PROTOBUF_NODISCARD std::string* release_service();
  void set_allocated_service(std::string* service);
  private:
  const std::string& _internal_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service(const std::string& value);
  std::string* _internal_mutable_service();
  public:

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.Service.CloudEndpoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class Service_ClusterIstio final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.Service.ClusterIstio) */ {
 public:
  inline Service_ClusterIstio() : Service_ClusterIstio(nullptr) {}
  ~Service_ClusterIstio() override;
  explicit PROTOBUF_CONSTEXPR Service_ClusterIstio(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Service_ClusterIstio(const Service_ClusterIstio& from);
  Service_ClusterIstio(Service_ClusterIstio&& from) noexcept
    : Service_ClusterIstio() {
    *this = ::std::move(from);
  }

  inline Service_ClusterIstio& operator=(const Service_ClusterIstio& from) {
    CopyFrom(from);
    return *this;
  }
  inline Service_ClusterIstio& operator=(Service_ClusterIstio&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Service_ClusterIstio& default_instance() {
    return *internal_default_instance();
  }
  static inline const Service_ClusterIstio* internal_default_instance() {
    return reinterpret_cast<const Service_ClusterIstio*>(
               &_Service_ClusterIstio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Service_ClusterIstio& a, Service_ClusterIstio& b) {
    a.Swap(&b);
  }
  inline void Swap(Service_ClusterIstio* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Service_ClusterIstio* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Service_ClusterIstio* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Service_ClusterIstio>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Service_ClusterIstio& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Service_ClusterIstio& from) {
    Service_ClusterIstio::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Service_ClusterIstio* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.Service.ClusterIstio";
  }
  protected:
  explicit Service_ClusterIstio(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kClusterNameFieldNumber = 2,
    kServiceNamespaceFieldNumber = 3,
    kServiceNameFieldNumber = 4,
  };
  // string location = 1;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // string cluster_name = 2;
  void clear_cluster_name();
  const std::string& cluster_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cluster_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cluster_name();
  PROTOBUF_NODISCARD std::string* release_cluster_name();
  void set_allocated_cluster_name(std::string* cluster_name);
  private:
  const std::string& _internal_cluster_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cluster_name(const std::string& value);
  std::string* _internal_mutable_cluster_name();
  public:

  // string service_namespace = 3;
  void clear_service_namespace();
  const std::string& service_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_namespace();
  PROTOBUF_NODISCARD std::string* release_service_namespace();
  void set_allocated_service_namespace(std::string* service_namespace);
  private:
  const std::string& _internal_service_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_namespace(const std::string& value);
  std::string* _internal_mutable_service_namespace();
  public:

  // string service_name = 4;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.Service.ClusterIstio)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cluster_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_namespace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class Service_MeshIstio final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.Service.MeshIstio) */ {
 public:
  inline Service_MeshIstio() : Service_MeshIstio(nullptr) {}
  ~Service_MeshIstio() override;
  explicit PROTOBUF_CONSTEXPR Service_MeshIstio(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Service_MeshIstio(const Service_MeshIstio& from);
  Service_MeshIstio(Service_MeshIstio&& from) noexcept
    : Service_MeshIstio() {
    *this = ::std::move(from);
  }

  inline Service_MeshIstio& operator=(const Service_MeshIstio& from) {
    CopyFrom(from);
    return *this;
  }
  inline Service_MeshIstio& operator=(Service_MeshIstio&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Service_MeshIstio& default_instance() {
    return *internal_default_instance();
  }
  static inline const Service_MeshIstio* internal_default_instance() {
    return reinterpret_cast<const Service_MeshIstio*>(
               &_Service_MeshIstio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Service_MeshIstio& a, Service_MeshIstio& b) {
    a.Swap(&b);
  }
  inline void Swap(Service_MeshIstio* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Service_MeshIstio* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Service_MeshIstio* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Service_MeshIstio>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Service_MeshIstio& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Service_MeshIstio& from) {
    Service_MeshIstio::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Service_MeshIstio* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.Service.MeshIstio";
  }
  protected:
  explicit Service_MeshIstio(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMeshUidFieldNumber = 1,
    kServiceNamespaceFieldNumber = 3,
    kServiceNameFieldNumber = 4,
  };
  // string mesh_uid = 1;
  void clear_mesh_uid();
  const std::string& mesh_uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mesh_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mesh_uid();
  PROTOBUF_NODISCARD std::string* release_mesh_uid();
  void set_allocated_mesh_uid(std::string* mesh_uid);
  private:
  const std::string& _internal_mesh_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mesh_uid(const std::string& value);
  std::string* _internal_mutable_mesh_uid();
  public:

  // string service_namespace = 3;
  void clear_service_namespace();
  const std::string& service_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_namespace();
  PROTOBUF_NODISCARD std::string* release_service_namespace();
  void set_allocated_service_namespace(std::string* service_namespace);
  private:
  const std::string& _internal_service_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_namespace(const std::string& value);
  std::string* _internal_mutable_service_namespace();
  public:

  // string service_name = 4;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.Service.MeshIstio)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mesh_uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_namespace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class Service_IstioCanonicalService final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.Service.IstioCanonicalService) */ {
 public:
  inline Service_IstioCanonicalService() : Service_IstioCanonicalService(nullptr) {}
  ~Service_IstioCanonicalService() override;
  explicit PROTOBUF_CONSTEXPR Service_IstioCanonicalService(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Service_IstioCanonicalService(const Service_IstioCanonicalService& from);
  Service_IstioCanonicalService(Service_IstioCanonicalService&& from) noexcept
    : Service_IstioCanonicalService() {
    *this = ::std::move(from);
  }

  inline Service_IstioCanonicalService& operator=(const Service_IstioCanonicalService& from) {
    CopyFrom(from);
    return *this;
  }
  inline Service_IstioCanonicalService& operator=(Service_IstioCanonicalService&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Service_IstioCanonicalService& default_instance() {
    return *internal_default_instance();
  }
  static inline const Service_IstioCanonicalService* internal_default_instance() {
    return reinterpret_cast<const Service_IstioCanonicalService*>(
               &_Service_IstioCanonicalService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Service_IstioCanonicalService& a, Service_IstioCanonicalService& b) {
    a.Swap(&b);
  }
  inline void Swap(Service_IstioCanonicalService* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Service_IstioCanonicalService* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Service_IstioCanonicalService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Service_IstioCanonicalService>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Service_IstioCanonicalService& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Service_IstioCanonicalService& from) {
    Service_IstioCanonicalService::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Service_IstioCanonicalService* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.Service.IstioCanonicalService";
  }
  protected:
  explicit Service_IstioCanonicalService(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMeshUidFieldNumber = 1,
    kCanonicalServiceNamespaceFieldNumber = 3,
    kCanonicalServiceFieldNumber = 4,
  };
  // string mesh_uid = 1;
  void clear_mesh_uid();
  const std::string& mesh_uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mesh_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mesh_uid();
  PROTOBUF_NODISCARD std::string* release_mesh_uid();
  void set_allocated_mesh_uid(std::string* mesh_uid);
  private:
  const std::string& _internal_mesh_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mesh_uid(const std::string& value);
  std::string* _internal_mutable_mesh_uid();
  public:

  // string canonical_service_namespace = 3;
  void clear_canonical_service_namespace();
  const std::string& canonical_service_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_canonical_service_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_canonical_service_namespace();
  PROTOBUF_NODISCARD std::string* release_canonical_service_namespace();
  void set_allocated_canonical_service_namespace(std::string* canonical_service_namespace);
  private:
  const std::string& _internal_canonical_service_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_canonical_service_namespace(const std::string& value);
  std::string* _internal_mutable_canonical_service_namespace();
  public:

  // string canonical_service = 4;
  void clear_canonical_service();
  const std::string& canonical_service() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_canonical_service(ArgT0&& arg0, ArgT... args);
  std::string* mutable_canonical_service();
  PROTOBUF_NODISCARD std::string* release_canonical_service();
  void set_allocated_canonical_service(std::string* canonical_service);
  private:
  const std::string& _internal_canonical_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_canonical_service(const std::string& value);
  std::string* _internal_mutable_canonical_service();
  public:

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.Service.IstioCanonicalService)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mesh_uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr canonical_service_namespace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr canonical_service_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class Service_Telemetry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.Service.Telemetry) */ {
 public:
  inline Service_Telemetry() : Service_Telemetry(nullptr) {}
  ~Service_Telemetry() override;
  explicit PROTOBUF_CONSTEXPR Service_Telemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Service_Telemetry(const Service_Telemetry& from);
  Service_Telemetry(Service_Telemetry&& from) noexcept
    : Service_Telemetry() {
    *this = ::std::move(from);
  }

  inline Service_Telemetry& operator=(const Service_Telemetry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Service_Telemetry& operator=(Service_Telemetry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Service_Telemetry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Service_Telemetry* internal_default_instance() {
    return reinterpret_cast<const Service_Telemetry*>(
               &_Service_Telemetry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Service_Telemetry& a, Service_Telemetry& b) {
    a.Swap(&b);
  }
  inline void Swap(Service_Telemetry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Service_Telemetry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Service_Telemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Service_Telemetry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Service_Telemetry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Service_Telemetry& from) {
    Service_Telemetry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Service_Telemetry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.Service.Telemetry";
  }
  protected:
  explicit Service_Telemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceNameFieldNumber = 1,
  };
  // string resource_name = 1;
  void clear_resource_name();
  const std::string& resource_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_name();
  PROTOBUF_NODISCARD std::string* release_resource_name();
  void set_allocated_resource_name(std::string* resource_name);
  private:
  const std::string& _internal_resource_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_name(const std::string& value);
  std::string* _internal_mutable_resource_name();
  public:

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.Service.Telemetry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class Service_UserLabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Service_UserLabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Service_UserLabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Service_UserLabelsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Service_UserLabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Service_UserLabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Service_UserLabelsEntry_DoNotUse& other);
  static const Service_UserLabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Service_UserLabelsEntry_DoNotUse*>(&_Service_UserLabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.monitoring.v3.Service.UserLabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.monitoring.v3.Service.UserLabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};

// -------------------------------------------------------------------

class Service final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.Service) */ {
 public:
  inline Service() : Service(nullptr) {}
  ~Service() override;
  explicit PROTOBUF_CONSTEXPR Service(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Service(const Service& from);
  Service(Service&& from) noexcept
    : Service() {
    *this = ::std::move(from);
  }

  inline Service& operator=(const Service& from) {
    CopyFrom(from);
    return *this;
  }
  inline Service& operator=(Service&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Service& default_instance() {
    return *internal_default_instance();
  }
  enum IdentifierCase {
    kCustom = 6,
    kAppEngine = 7,
    kCloudEndpoints = 8,
    kClusterIstio = 9,
    kMeshIstio = 10,
    kIstioCanonicalService = 11,
    IDENTIFIER_NOT_SET = 0,
  };

  static inline const Service* internal_default_instance() {
    return reinterpret_cast<const Service*>(
               &_Service_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Service& a, Service& b) {
    a.Swap(&b);
  }
  inline void Swap(Service* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Service* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Service* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Service>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Service& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Service& from) {
    Service::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Service* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.Service";
  }
  protected:
  explicit Service(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Service_Custom Custom;
  typedef Service_AppEngine AppEngine;
  typedef Service_CloudEndpoints CloudEndpoints;
  typedef Service_ClusterIstio ClusterIstio;
  typedef Service_MeshIstio MeshIstio;
  typedef Service_IstioCanonicalService IstioCanonicalService;
  typedef Service_Telemetry Telemetry;

  // accessors -------------------------------------------------------

  enum : int {
    kUserLabelsFieldNumber = 14,
    kNameFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kTelemetryFieldNumber = 13,
    kCustomFieldNumber = 6,
    kAppEngineFieldNumber = 7,
    kCloudEndpointsFieldNumber = 8,
    kClusterIstioFieldNumber = 9,
    kMeshIstioFieldNumber = 10,
    kIstioCanonicalServiceFieldNumber = 11,
  };
  // map<string, string> user_labels = 14;
  int user_labels_size() const;
  private:
  int _internal_user_labels_size() const;
  public:
  void clear_user_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_user_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_user_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      user_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_user_labels();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string display_name = 2;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // .google.monitoring.v3.Service.Telemetry telemetry = 13;
  bool has_telemetry() const;
  private:
  bool _internal_has_telemetry() const;
  public:
  void clear_telemetry();
  const ::google::monitoring::v3::Service_Telemetry& telemetry() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::Service_Telemetry* release_telemetry();
  ::google::monitoring::v3::Service_Telemetry* mutable_telemetry();
  void set_allocated_telemetry(::google::monitoring::v3::Service_Telemetry* telemetry);
  private:
  const ::google::monitoring::v3::Service_Telemetry& _internal_telemetry() const;
  ::google::monitoring::v3::Service_Telemetry* _internal_mutable_telemetry();
  public:
  void unsafe_arena_set_allocated_telemetry(
      ::google::monitoring::v3::Service_Telemetry* telemetry);
  ::google::monitoring::v3::Service_Telemetry* unsafe_arena_release_telemetry();

  // .google.monitoring.v3.Service.Custom custom = 6;
  bool has_custom() const;
  private:
  bool _internal_has_custom() const;
  public:
  void clear_custom();
  const ::google::monitoring::v3::Service_Custom& custom() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::Service_Custom* release_custom();
  ::google::monitoring::v3::Service_Custom* mutable_custom();
  void set_allocated_custom(::google::monitoring::v3::Service_Custom* custom);
  private:
  const ::google::monitoring::v3::Service_Custom& _internal_custom() const;
  ::google::monitoring::v3::Service_Custom* _internal_mutable_custom();
  public:
  void unsafe_arena_set_allocated_custom(
      ::google::monitoring::v3::Service_Custom* custom);
  ::google::monitoring::v3::Service_Custom* unsafe_arena_release_custom();

  // .google.monitoring.v3.Service.AppEngine app_engine = 7;
  bool has_app_engine() const;
  private:
  bool _internal_has_app_engine() const;
  public:
  void clear_app_engine();
  const ::google::monitoring::v3::Service_AppEngine& app_engine() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::Service_AppEngine* release_app_engine();
  ::google::monitoring::v3::Service_AppEngine* mutable_app_engine();
  void set_allocated_app_engine(::google::monitoring::v3::Service_AppEngine* app_engine);
  private:
  const ::google::monitoring::v3::Service_AppEngine& _internal_app_engine() const;
  ::google::monitoring::v3::Service_AppEngine* _internal_mutable_app_engine();
  public:
  void unsafe_arena_set_allocated_app_engine(
      ::google::monitoring::v3::Service_AppEngine* app_engine);
  ::google::monitoring::v3::Service_AppEngine* unsafe_arena_release_app_engine();

  // .google.monitoring.v3.Service.CloudEndpoints cloud_endpoints = 8;
  bool has_cloud_endpoints() const;
  private:
  bool _internal_has_cloud_endpoints() const;
  public:
  void clear_cloud_endpoints();
  const ::google::monitoring::v3::Service_CloudEndpoints& cloud_endpoints() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::Service_CloudEndpoints* release_cloud_endpoints();
  ::google::monitoring::v3::Service_CloudEndpoints* mutable_cloud_endpoints();
  void set_allocated_cloud_endpoints(::google::monitoring::v3::Service_CloudEndpoints* cloud_endpoints);
  private:
  const ::google::monitoring::v3::Service_CloudEndpoints& _internal_cloud_endpoints() const;
  ::google::monitoring::v3::Service_CloudEndpoints* _internal_mutable_cloud_endpoints();
  public:
  void unsafe_arena_set_allocated_cloud_endpoints(
      ::google::monitoring::v3::Service_CloudEndpoints* cloud_endpoints);
  ::google::monitoring::v3::Service_CloudEndpoints* unsafe_arena_release_cloud_endpoints();

  // .google.monitoring.v3.Service.ClusterIstio cluster_istio = 9;
  bool has_cluster_istio() const;
  private:
  bool _internal_has_cluster_istio() const;
  public:
  void clear_cluster_istio();
  const ::google::monitoring::v3::Service_ClusterIstio& cluster_istio() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::Service_ClusterIstio* release_cluster_istio();
  ::google::monitoring::v3::Service_ClusterIstio* mutable_cluster_istio();
  void set_allocated_cluster_istio(::google::monitoring::v3::Service_ClusterIstio* cluster_istio);
  private:
  const ::google::monitoring::v3::Service_ClusterIstio& _internal_cluster_istio() const;
  ::google::monitoring::v3::Service_ClusterIstio* _internal_mutable_cluster_istio();
  public:
  void unsafe_arena_set_allocated_cluster_istio(
      ::google::monitoring::v3::Service_ClusterIstio* cluster_istio);
  ::google::monitoring::v3::Service_ClusterIstio* unsafe_arena_release_cluster_istio();

  // .google.monitoring.v3.Service.MeshIstio mesh_istio = 10;
  bool has_mesh_istio() const;
  private:
  bool _internal_has_mesh_istio() const;
  public:
  void clear_mesh_istio();
  const ::google::monitoring::v3::Service_MeshIstio& mesh_istio() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::Service_MeshIstio* release_mesh_istio();
  ::google::monitoring::v3::Service_MeshIstio* mutable_mesh_istio();
  void set_allocated_mesh_istio(::google::monitoring::v3::Service_MeshIstio* mesh_istio);
  private:
  const ::google::monitoring::v3::Service_MeshIstio& _internal_mesh_istio() const;
  ::google::monitoring::v3::Service_MeshIstio* _internal_mutable_mesh_istio();
  public:
  void unsafe_arena_set_allocated_mesh_istio(
      ::google::monitoring::v3::Service_MeshIstio* mesh_istio);
  ::google::monitoring::v3::Service_MeshIstio* unsafe_arena_release_mesh_istio();

  // .google.monitoring.v3.Service.IstioCanonicalService istio_canonical_service = 11;
  bool has_istio_canonical_service() const;
  private:
  bool _internal_has_istio_canonical_service() const;
  public:
  void clear_istio_canonical_service();
  const ::google::monitoring::v3::Service_IstioCanonicalService& istio_canonical_service() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::Service_IstioCanonicalService* release_istio_canonical_service();
  ::google::monitoring::v3::Service_IstioCanonicalService* mutable_istio_canonical_service();
  void set_allocated_istio_canonical_service(::google::monitoring::v3::Service_IstioCanonicalService* istio_canonical_service);
  private:
  const ::google::monitoring::v3::Service_IstioCanonicalService& _internal_istio_canonical_service() const;
  ::google::monitoring::v3::Service_IstioCanonicalService* _internal_mutable_istio_canonical_service();
  public:
  void unsafe_arena_set_allocated_istio_canonical_service(
      ::google::monitoring::v3::Service_IstioCanonicalService* istio_canonical_service);
  ::google::monitoring::v3::Service_IstioCanonicalService* unsafe_arena_release_istio_canonical_service();

  void clear_identifier();
  IdentifierCase identifier_case() const;
  // @@protoc_insertion_point(class_scope:google.monitoring.v3.Service)
 private:
  class _Internal;
  void set_has_custom();
  void set_has_app_engine();
  void set_has_cloud_endpoints();
  void set_has_cluster_istio();
  void set_has_mesh_istio();
  void set_has_istio_canonical_service();

  inline bool has_identifier() const;
  inline void clear_has_identifier();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Service_UserLabelsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> user_labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::google::monitoring::v3::Service_Telemetry* telemetry_;
    union IdentifierUnion {
      constexpr IdentifierUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::google::monitoring::v3::Service_Custom* custom_;
      ::google::monitoring::v3::Service_AppEngine* app_engine_;
      ::google::monitoring::v3::Service_CloudEndpoints* cloud_endpoints_;
      ::google::monitoring::v3::Service_ClusterIstio* cluster_istio_;
      ::google::monitoring::v3::Service_MeshIstio* mesh_istio_;
      ::google::monitoring::v3::Service_IstioCanonicalService* istio_canonical_service_;
    } identifier_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ServiceLevelObjective_UserLabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ServiceLevelObjective_UserLabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ServiceLevelObjective_UserLabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ServiceLevelObjective_UserLabelsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ServiceLevelObjective_UserLabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ServiceLevelObjective_UserLabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ServiceLevelObjective_UserLabelsEntry_DoNotUse& other);
  static const ServiceLevelObjective_UserLabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ServiceLevelObjective_UserLabelsEntry_DoNotUse*>(&_ServiceLevelObjective_UserLabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.monitoring.v3.ServiceLevelObjective.UserLabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.monitoring.v3.ServiceLevelObjective.UserLabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};

// -------------------------------------------------------------------

class ServiceLevelObjective final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.ServiceLevelObjective) */ {
 public:
  inline ServiceLevelObjective() : ServiceLevelObjective(nullptr) {}
  ~ServiceLevelObjective() override;
  explicit PROTOBUF_CONSTEXPR ServiceLevelObjective(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceLevelObjective(const ServiceLevelObjective& from);
  ServiceLevelObjective(ServiceLevelObjective&& from) noexcept
    : ServiceLevelObjective() {
    *this = ::std::move(from);
  }

  inline ServiceLevelObjective& operator=(const ServiceLevelObjective& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceLevelObjective& operator=(ServiceLevelObjective&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceLevelObjective& default_instance() {
    return *internal_default_instance();
  }
  enum PeriodCase {
    kRollingPeriod = 5,
    kCalendarPeriod = 6,
    PERIOD_NOT_SET = 0,
  };

  static inline const ServiceLevelObjective* internal_default_instance() {
    return reinterpret_cast<const ServiceLevelObjective*>(
               &_ServiceLevelObjective_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ServiceLevelObjective& a, ServiceLevelObjective& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceLevelObjective* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceLevelObjective* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceLevelObjective* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceLevelObjective>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceLevelObjective& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceLevelObjective& from) {
    ServiceLevelObjective::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceLevelObjective* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.ServiceLevelObjective";
  }
  protected:
  explicit ServiceLevelObjective(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef ServiceLevelObjective_View View;
  static constexpr View VIEW_UNSPECIFIED =
    ServiceLevelObjective_View_VIEW_UNSPECIFIED;
  static constexpr View FULL =
    ServiceLevelObjective_View_FULL;
  static constexpr View EXPLICIT =
    ServiceLevelObjective_View_EXPLICIT;
  static inline bool View_IsValid(int value) {
    return ServiceLevelObjective_View_IsValid(value);
  }
  static constexpr View View_MIN =
    ServiceLevelObjective_View_View_MIN;
  static constexpr View View_MAX =
    ServiceLevelObjective_View_View_MAX;
  static constexpr int View_ARRAYSIZE =
    ServiceLevelObjective_View_View_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  View_descriptor() {
    return ServiceLevelObjective_View_descriptor();
  }
  template<typename T>
  static inline const std::string& View_Name(T enum_t_value) {
    static_assert(::std::is_same<T, View>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function View_Name.");
    return ServiceLevelObjective_View_Name(enum_t_value);
  }
  static inline bool View_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      View* value) {
    return ServiceLevelObjective_View_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUserLabelsFieldNumber = 12,
    kNameFieldNumber = 1,
    kDisplayNameFieldNumber = 11,
    kServiceLevelIndicatorFieldNumber = 3,
    kGoalFieldNumber = 4,
    kRollingPeriodFieldNumber = 5,
    kCalendarPeriodFieldNumber = 6,
  };
  // map<string, string> user_labels = 12;
  int user_labels_size() const;
  private:
  int _internal_user_labels_size() const;
  public:
  void clear_user_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_user_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_user_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      user_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_user_labels();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string display_name = 11;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // .google.monitoring.v3.ServiceLevelIndicator service_level_indicator = 3;
  bool has_service_level_indicator() const;
  private:
  bool _internal_has_service_level_indicator() const;
  public:
  void clear_service_level_indicator();
  const ::google::monitoring::v3::ServiceLevelIndicator& service_level_indicator() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::ServiceLevelIndicator* release_service_level_indicator();
  ::google::monitoring::v3::ServiceLevelIndicator* mutable_service_level_indicator();
  void set_allocated_service_level_indicator(::google::monitoring::v3::ServiceLevelIndicator* service_level_indicator);
  private:
  const ::google::monitoring::v3::ServiceLevelIndicator& _internal_service_level_indicator() const;
  ::google::monitoring::v3::ServiceLevelIndicator* _internal_mutable_service_level_indicator();
  public:
  void unsafe_arena_set_allocated_service_level_indicator(
      ::google::monitoring::v3::ServiceLevelIndicator* service_level_indicator);
  ::google::monitoring::v3::ServiceLevelIndicator* unsafe_arena_release_service_level_indicator();

  // double goal = 4;
  void clear_goal();
  double goal() const;
  void set_goal(double value);
  private:
  double _internal_goal() const;
  void _internal_set_goal(double value);
  public:

  // .google.protobuf.Duration rolling_period = 5;
  bool has_rolling_period() const;
  private:
  bool _internal_has_rolling_period() const;
  public:
  void clear_rolling_period();
  const ::PROTOBUF_NAMESPACE_ID::Duration& rolling_period() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_rolling_period();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_rolling_period();
  void set_allocated_rolling_period(::PROTOBUF_NAMESPACE_ID::Duration* rolling_period);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_rolling_period() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_rolling_period();
  public:
  void unsafe_arena_set_allocated_rolling_period(
      ::PROTOBUF_NAMESPACE_ID::Duration* rolling_period);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_rolling_period();

  // .google.type.CalendarPeriod calendar_period = 6;
  bool has_calendar_period() const;
  private:
  bool _internal_has_calendar_period() const;
  public:
  void clear_calendar_period();
  ::google::type::CalendarPeriod calendar_period() const;
  void set_calendar_period(::google::type::CalendarPeriod value);
  private:
  ::google::type::CalendarPeriod _internal_calendar_period() const;
  void _internal_set_calendar_period(::google::type::CalendarPeriod value);
  public:

  void clear_period();
  PeriodCase period_case() const;
  // @@protoc_insertion_point(class_scope:google.monitoring.v3.ServiceLevelObjective)
 private:
  class _Internal;
  void set_has_rolling_period();
  void set_has_calendar_period();

  inline bool has_period() const;
  inline void clear_has_period();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ServiceLevelObjective_UserLabelsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> user_labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::google::monitoring::v3::ServiceLevelIndicator* service_level_indicator_;
    double goal_;
    union PeriodUnion {
      constexpr PeriodUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::Duration* rolling_period_;
      int calendar_period_;
    } period_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ServiceLevelIndicator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.ServiceLevelIndicator) */ {
 public:
  inline ServiceLevelIndicator() : ServiceLevelIndicator(nullptr) {}
  ~ServiceLevelIndicator() override;
  explicit PROTOBUF_CONSTEXPR ServiceLevelIndicator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceLevelIndicator(const ServiceLevelIndicator& from);
  ServiceLevelIndicator(ServiceLevelIndicator&& from) noexcept
    : ServiceLevelIndicator() {
    *this = ::std::move(from);
  }

  inline ServiceLevelIndicator& operator=(const ServiceLevelIndicator& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceLevelIndicator& operator=(ServiceLevelIndicator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceLevelIndicator& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kBasicSli = 4,
    kRequestBased = 1,
    kWindowsBased = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const ServiceLevelIndicator* internal_default_instance() {
    return reinterpret_cast<const ServiceLevelIndicator*>(
               &_ServiceLevelIndicator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ServiceLevelIndicator& a, ServiceLevelIndicator& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceLevelIndicator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceLevelIndicator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceLevelIndicator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceLevelIndicator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceLevelIndicator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceLevelIndicator& from) {
    ServiceLevelIndicator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceLevelIndicator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.ServiceLevelIndicator";
  }
  protected:
  explicit ServiceLevelIndicator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasicSliFieldNumber = 4,
    kRequestBasedFieldNumber = 1,
    kWindowsBasedFieldNumber = 2,
  };
  // .google.monitoring.v3.BasicSli basic_sli = 4;
  bool has_basic_sli() const;
  private:
  bool _internal_has_basic_sli() const;
  public:
  void clear_basic_sli();
  const ::google::monitoring::v3::BasicSli& basic_sli() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::BasicSli* release_basic_sli();
  ::google::monitoring::v3::BasicSli* mutable_basic_sli();
  void set_allocated_basic_sli(::google::monitoring::v3::BasicSli* basic_sli);
  private:
  const ::google::monitoring::v3::BasicSli& _internal_basic_sli() const;
  ::google::monitoring::v3::BasicSli* _internal_mutable_basic_sli();
  public:
  void unsafe_arena_set_allocated_basic_sli(
      ::google::monitoring::v3::BasicSli* basic_sli);
  ::google::monitoring::v3::BasicSli* unsafe_arena_release_basic_sli();

  // .google.monitoring.v3.RequestBasedSli request_based = 1;
  bool has_request_based() const;
  private:
  bool _internal_has_request_based() const;
  public:
  void clear_request_based();
  const ::google::monitoring::v3::RequestBasedSli& request_based() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::RequestBasedSli* release_request_based();
  ::google::monitoring::v3::RequestBasedSli* mutable_request_based();
  void set_allocated_request_based(::google::monitoring::v3::RequestBasedSli* request_based);
  private:
  const ::google::monitoring::v3::RequestBasedSli& _internal_request_based() const;
  ::google::monitoring::v3::RequestBasedSli* _internal_mutable_request_based();
  public:
  void unsafe_arena_set_allocated_request_based(
      ::google::monitoring::v3::RequestBasedSli* request_based);
  ::google::monitoring::v3::RequestBasedSli* unsafe_arena_release_request_based();

  // .google.monitoring.v3.WindowsBasedSli windows_based = 2;
  bool has_windows_based() const;
  private:
  bool _internal_has_windows_based() const;
  public:
  void clear_windows_based();
  const ::google::monitoring::v3::WindowsBasedSli& windows_based() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::WindowsBasedSli* release_windows_based();
  ::google::monitoring::v3::WindowsBasedSli* mutable_windows_based();
  void set_allocated_windows_based(::google::monitoring::v3::WindowsBasedSli* windows_based);
  private:
  const ::google::monitoring::v3::WindowsBasedSli& _internal_windows_based() const;
  ::google::monitoring::v3::WindowsBasedSli* _internal_mutable_windows_based();
  public:
  void unsafe_arena_set_allocated_windows_based(
      ::google::monitoring::v3::WindowsBasedSli* windows_based);
  ::google::monitoring::v3::WindowsBasedSli* unsafe_arena_release_windows_based();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:google.monitoring.v3.ServiceLevelIndicator)
 private:
  class _Internal;
  void set_has_basic_sli();
  void set_has_request_based();
  void set_has_windows_based();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::google::monitoring::v3::BasicSli* basic_sli_;
      ::google::monitoring::v3::RequestBasedSli* request_based_;
      ::google::monitoring::v3::WindowsBasedSli* windows_based_;
    } type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class BasicSli_AvailabilityCriteria final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:google.monitoring.v3.BasicSli.AvailabilityCriteria) */ {
 public:
  inline BasicSli_AvailabilityCriteria() : BasicSli_AvailabilityCriteria(nullptr) {}
  explicit PROTOBUF_CONSTEXPR BasicSli_AvailabilityCriteria(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BasicSli_AvailabilityCriteria(const BasicSli_AvailabilityCriteria& from);
  BasicSli_AvailabilityCriteria(BasicSli_AvailabilityCriteria&& from) noexcept
    : BasicSli_AvailabilityCriteria() {
    *this = ::std::move(from);
  }

  inline BasicSli_AvailabilityCriteria& operator=(const BasicSli_AvailabilityCriteria& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasicSli_AvailabilityCriteria& operator=(BasicSli_AvailabilityCriteria&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BasicSli_AvailabilityCriteria& default_instance() {
    return *internal_default_instance();
  }
  static inline const BasicSli_AvailabilityCriteria* internal_default_instance() {
    return reinterpret_cast<const BasicSli_AvailabilityCriteria*>(
               &_BasicSli_AvailabilityCriteria_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BasicSli_AvailabilityCriteria& a, BasicSli_AvailabilityCriteria& b) {
    a.Swap(&b);
  }
  inline void Swap(BasicSli_AvailabilityCriteria* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasicSli_AvailabilityCriteria* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BasicSli_AvailabilityCriteria* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BasicSli_AvailabilityCriteria>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BasicSli_AvailabilityCriteria& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BasicSli_AvailabilityCriteria& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.BasicSli.AvailabilityCriteria";
  }
  protected:
  explicit BasicSli_AvailabilityCriteria(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.BasicSli.AvailabilityCriteria)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class BasicSli_LatencyCriteria final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.BasicSli.LatencyCriteria) */ {
 public:
  inline BasicSli_LatencyCriteria() : BasicSli_LatencyCriteria(nullptr) {}
  ~BasicSli_LatencyCriteria() override;
  explicit PROTOBUF_CONSTEXPR BasicSli_LatencyCriteria(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BasicSli_LatencyCriteria(const BasicSli_LatencyCriteria& from);
  BasicSli_LatencyCriteria(BasicSli_LatencyCriteria&& from) noexcept
    : BasicSli_LatencyCriteria() {
    *this = ::std::move(from);
  }

  inline BasicSli_LatencyCriteria& operator=(const BasicSli_LatencyCriteria& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasicSli_LatencyCriteria& operator=(BasicSli_LatencyCriteria&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BasicSli_LatencyCriteria& default_instance() {
    return *internal_default_instance();
  }
  static inline const BasicSli_LatencyCriteria* internal_default_instance() {
    return reinterpret_cast<const BasicSli_LatencyCriteria*>(
               &_BasicSli_LatencyCriteria_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BasicSli_LatencyCriteria& a, BasicSli_LatencyCriteria& b) {
    a.Swap(&b);
  }
  inline void Swap(BasicSli_LatencyCriteria* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasicSli_LatencyCriteria* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BasicSli_LatencyCriteria* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BasicSli_LatencyCriteria>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BasicSli_LatencyCriteria& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BasicSli_LatencyCriteria& from) {
    BasicSli_LatencyCriteria::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasicSli_LatencyCriteria* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.BasicSli.LatencyCriteria";
  }
  protected:
  explicit BasicSli_LatencyCriteria(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThresholdFieldNumber = 3,
  };
  // .google.protobuf.Duration threshold = 3;
  bool has_threshold() const;
  private:
  bool _internal_has_threshold() const;
  public:
  void clear_threshold();
  const ::PROTOBUF_NAMESPACE_ID::Duration& threshold() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_threshold();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_threshold();
  void set_allocated_threshold(::PROTOBUF_NAMESPACE_ID::Duration* threshold);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_threshold() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_threshold();
  public:
  void unsafe_arena_set_allocated_threshold(
      ::PROTOBUF_NAMESPACE_ID::Duration* threshold);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_threshold();

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.BasicSli.LatencyCriteria)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Duration* threshold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class BasicSli final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.BasicSli) */ {
 public:
  inline BasicSli() : BasicSli(nullptr) {}
  ~BasicSli() override;
  explicit PROTOBUF_CONSTEXPR BasicSli(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BasicSli(const BasicSli& from);
  BasicSli(BasicSli&& from) noexcept
    : BasicSli() {
    *this = ::std::move(from);
  }

  inline BasicSli& operator=(const BasicSli& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasicSli& operator=(BasicSli&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BasicSli& default_instance() {
    return *internal_default_instance();
  }
  enum SliCriteriaCase {
    kAvailability = 2,
    kLatency = 3,
    SLI_CRITERIA_NOT_SET = 0,
  };

  static inline const BasicSli* internal_default_instance() {
    return reinterpret_cast<const BasicSli*>(
               &_BasicSli_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BasicSli& a, BasicSli& b) {
    a.Swap(&b);
  }
  inline void Swap(BasicSli* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasicSli* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BasicSli* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BasicSli>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BasicSli& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BasicSli& from) {
    BasicSli::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasicSli* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.BasicSli";
  }
  protected:
  explicit BasicSli(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BasicSli_AvailabilityCriteria AvailabilityCriteria;
  typedef BasicSli_LatencyCriteria LatencyCriteria;

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 7,
    kLocationFieldNumber = 8,
    kVersionFieldNumber = 9,
    kAvailabilityFieldNumber = 2,
    kLatencyFieldNumber = 3,
  };
  // repeated string method = 7;
  int method_size() const;
  private:
  int _internal_method_size() const;
  public:
  void clear_method();
  const std::string& method(int index) const;
  std::string* mutable_method(int index);
  void set_method(int index, const std::string& value);
  void set_method(int index, std::string&& value);
  void set_method(int index, const char* value);
  void set_method(int index, const char* value, size_t size);
  std::string* add_method();
  void add_method(const std::string& value);
  void add_method(std::string&& value);
  void add_method(const char* value);
  void add_method(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& method() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_method();
  private:
  const std::string& _internal_method(int index) const;
  std::string* _internal_add_method();
  public:

  // repeated string location = 8;
  int location_size() const;
  private:
  int _internal_location_size() const;
  public:
  void clear_location();
  const std::string& location(int index) const;
  std::string* mutable_location(int index);
  void set_location(int index, const std::string& value);
  void set_location(int index, std::string&& value);
  void set_location(int index, const char* value);
  void set_location(int index, const char* value, size_t size);
  std::string* add_location();
  void add_location(const std::string& value);
  void add_location(std::string&& value);
  void add_location(const char* value);
  void add_location(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& location() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_location();
  private:
  const std::string& _internal_location(int index) const;
  std::string* _internal_add_location();
  public:

  // repeated string version = 9;
  int version_size() const;
  private:
  int _internal_version_size() const;
  public:
  void clear_version();
  const std::string& version(int index) const;
  std::string* mutable_version(int index);
  void set_version(int index, const std::string& value);
  void set_version(int index, std::string&& value);
  void set_version(int index, const char* value);
  void set_version(int index, const char* value, size_t size);
  std::string* add_version();
  void add_version(const std::string& value);
  void add_version(std::string&& value);
  void add_version(const char* value);
  void add_version(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& version() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_version();
  private:
  const std::string& _internal_version(int index) const;
  std::string* _internal_add_version();
  public:

  // .google.monitoring.v3.BasicSli.AvailabilityCriteria availability = 2;
  bool has_availability() const;
  private:
  bool _internal_has_availability() const;
  public:
  void clear_availability();
  const ::google::monitoring::v3::BasicSli_AvailabilityCriteria& availability() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::BasicSli_AvailabilityCriteria* release_availability();
  ::google::monitoring::v3::BasicSli_AvailabilityCriteria* mutable_availability();
  void set_allocated_availability(::google::monitoring::v3::BasicSli_AvailabilityCriteria* availability);
  private:
  const ::google::monitoring::v3::BasicSli_AvailabilityCriteria& _internal_availability() const;
  ::google::monitoring::v3::BasicSli_AvailabilityCriteria* _internal_mutable_availability();
  public:
  void unsafe_arena_set_allocated_availability(
      ::google::monitoring::v3::BasicSli_AvailabilityCriteria* availability);
  ::google::monitoring::v3::BasicSli_AvailabilityCriteria* unsafe_arena_release_availability();

  // .google.monitoring.v3.BasicSli.LatencyCriteria latency = 3;
  bool has_latency() const;
  private:
  bool _internal_has_latency() const;
  public:
  void clear_latency();
  const ::google::monitoring::v3::BasicSli_LatencyCriteria& latency() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::BasicSli_LatencyCriteria* release_latency();
  ::google::monitoring::v3::BasicSli_LatencyCriteria* mutable_latency();
  void set_allocated_latency(::google::monitoring::v3::BasicSli_LatencyCriteria* latency);
  private:
  const ::google::monitoring::v3::BasicSli_LatencyCriteria& _internal_latency() const;
  ::google::monitoring::v3::BasicSli_LatencyCriteria* _internal_mutable_latency();
  public:
  void unsafe_arena_set_allocated_latency(
      ::google::monitoring::v3::BasicSli_LatencyCriteria* latency);
  ::google::monitoring::v3::BasicSli_LatencyCriteria* unsafe_arena_release_latency();

  void clear_sli_criteria();
  SliCriteriaCase sli_criteria_case() const;
  // @@protoc_insertion_point(class_scope:google.monitoring.v3.BasicSli)
 private:
  class _Internal;
  void set_has_availability();
  void set_has_latency();

  inline bool has_sli_criteria() const;
  inline void clear_has_sli_criteria();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> method_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> location_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> version_;
    union SliCriteriaUnion {
      constexpr SliCriteriaUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::google::monitoring::v3::BasicSli_AvailabilityCriteria* availability_;
      ::google::monitoring::v3::BasicSli_LatencyCriteria* latency_;
    } sli_criteria_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class Range final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.Range) */ {
 public:
  inline Range() : Range(nullptr) {}
  ~Range() override;
  explicit PROTOBUF_CONSTEXPR Range(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Range(const Range& from);
  Range(Range&& from) noexcept
    : Range() {
    *this = ::std::move(from);
  }

  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }
  inline Range& operator=(Range&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Range& default_instance() {
    return *internal_default_instance();
  }
  static inline const Range* internal_default_instance() {
    return reinterpret_cast<const Range*>(
               &_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Range& a, Range& b) {
    a.Swap(&b);
  }
  inline void Swap(Range* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Range* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Range* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Range>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Range& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Range& from) {
    Range::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Range* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.Range";
  }
  protected:
  explicit Range(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
  };
  // double min = 1;
  void clear_min();
  double min() const;
  void set_min(double value);
  private:
  double _internal_min() const;
  void _internal_set_min(double value);
  public:

  // double max = 2;
  void clear_max();
  double max() const;
  void set_max(double value);
  private:
  double _internal_max() const;
  void _internal_set_max(double value);
  public:

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.Range)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double min_;
    double max_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class RequestBasedSli final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.RequestBasedSli) */ {
 public:
  inline RequestBasedSli() : RequestBasedSli(nullptr) {}
  ~RequestBasedSli() override;
  explicit PROTOBUF_CONSTEXPR RequestBasedSli(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestBasedSli(const RequestBasedSli& from);
  RequestBasedSli(RequestBasedSli&& from) noexcept
    : RequestBasedSli() {
    *this = ::std::move(from);
  }

  inline RequestBasedSli& operator=(const RequestBasedSli& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestBasedSli& operator=(RequestBasedSli&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestBasedSli& default_instance() {
    return *internal_default_instance();
  }
  enum MethodCase {
    kGoodTotalRatio = 1,
    kDistributionCut = 3,
    METHOD_NOT_SET = 0,
  };

  static inline const RequestBasedSli* internal_default_instance() {
    return reinterpret_cast<const RequestBasedSli*>(
               &_RequestBasedSli_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RequestBasedSli& a, RequestBasedSli& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestBasedSli* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestBasedSli* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestBasedSli* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestBasedSli>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestBasedSli& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestBasedSli& from) {
    RequestBasedSli::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestBasedSli* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.RequestBasedSli";
  }
  protected:
  explicit RequestBasedSli(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoodTotalRatioFieldNumber = 1,
    kDistributionCutFieldNumber = 3,
  };
  // .google.monitoring.v3.TimeSeriesRatio good_total_ratio = 1;
  bool has_good_total_ratio() const;
  private:
  bool _internal_has_good_total_ratio() const;
  public:
  void clear_good_total_ratio();
  const ::google::monitoring::v3::TimeSeriesRatio& good_total_ratio() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::TimeSeriesRatio* release_good_total_ratio();
  ::google::monitoring::v3::TimeSeriesRatio* mutable_good_total_ratio();
  void set_allocated_good_total_ratio(::google::monitoring::v3::TimeSeriesRatio* good_total_ratio);
  private:
  const ::google::monitoring::v3::TimeSeriesRatio& _internal_good_total_ratio() const;
  ::google::monitoring::v3::TimeSeriesRatio* _internal_mutable_good_total_ratio();
  public:
  void unsafe_arena_set_allocated_good_total_ratio(
      ::google::monitoring::v3::TimeSeriesRatio* good_total_ratio);
  ::google::monitoring::v3::TimeSeriesRatio* unsafe_arena_release_good_total_ratio();

  // .google.monitoring.v3.DistributionCut distribution_cut = 3;
  bool has_distribution_cut() const;
  private:
  bool _internal_has_distribution_cut() const;
  public:
  void clear_distribution_cut();
  const ::google::monitoring::v3::DistributionCut& distribution_cut() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::DistributionCut* release_distribution_cut();
  ::google::monitoring::v3::DistributionCut* mutable_distribution_cut();
  void set_allocated_distribution_cut(::google::monitoring::v3::DistributionCut* distribution_cut);
  private:
  const ::google::monitoring::v3::DistributionCut& _internal_distribution_cut() const;
  ::google::monitoring::v3::DistributionCut* _internal_mutable_distribution_cut();
  public:
  void unsafe_arena_set_allocated_distribution_cut(
      ::google::monitoring::v3::DistributionCut* distribution_cut);
  ::google::monitoring::v3::DistributionCut* unsafe_arena_release_distribution_cut();

  void clear_method();
  MethodCase method_case() const;
  // @@protoc_insertion_point(class_scope:google.monitoring.v3.RequestBasedSli)
 private:
  class _Internal;
  void set_has_good_total_ratio();
  void set_has_distribution_cut();

  inline bool has_method() const;
  inline void clear_has_method();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MethodUnion {
      constexpr MethodUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::google::monitoring::v3::TimeSeriesRatio* good_total_ratio_;
      ::google::monitoring::v3::DistributionCut* distribution_cut_;
    } method_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class TimeSeriesRatio final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.TimeSeriesRatio) */ {
 public:
  inline TimeSeriesRatio() : TimeSeriesRatio(nullptr) {}
  ~TimeSeriesRatio() override;
  explicit PROTOBUF_CONSTEXPR TimeSeriesRatio(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeSeriesRatio(const TimeSeriesRatio& from);
  TimeSeriesRatio(TimeSeriesRatio&& from) noexcept
    : TimeSeriesRatio() {
    *this = ::std::move(from);
  }

  inline TimeSeriesRatio& operator=(const TimeSeriesRatio& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeSeriesRatio& operator=(TimeSeriesRatio&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeSeriesRatio& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeSeriesRatio* internal_default_instance() {
    return reinterpret_cast<const TimeSeriesRatio*>(
               &_TimeSeriesRatio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TimeSeriesRatio& a, TimeSeriesRatio& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeSeriesRatio* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeSeriesRatio* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeSeriesRatio* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeSeriesRatio>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeSeriesRatio& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimeSeriesRatio& from) {
    TimeSeriesRatio::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeSeriesRatio* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.TimeSeriesRatio";
  }
  protected:
  explicit TimeSeriesRatio(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoodServiceFilterFieldNumber = 4,
    kBadServiceFilterFieldNumber = 5,
    kTotalServiceFilterFieldNumber = 6,
  };
  // string good_service_filter = 4;
  void clear_good_service_filter();
  const std::string& good_service_filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_good_service_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_good_service_filter();
  PROTOBUF_NODISCARD std::string* release_good_service_filter();
  void set_allocated_good_service_filter(std::string* good_service_filter);
  private:
  const std::string& _internal_good_service_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_good_service_filter(const std::string& value);
  std::string* _internal_mutable_good_service_filter();
  public:

  // string bad_service_filter = 5;
  void clear_bad_service_filter();
  const std::string& bad_service_filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bad_service_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bad_service_filter();
  PROTOBUF_NODISCARD std::string* release_bad_service_filter();
  void set_allocated_bad_service_filter(std::string* bad_service_filter);
  private:
  const std::string& _internal_bad_service_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bad_service_filter(const std::string& value);
  std::string* _internal_mutable_bad_service_filter();
  public:

  // string total_service_filter = 6;
  void clear_total_service_filter();
  const std::string& total_service_filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_total_service_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_total_service_filter();
  PROTOBUF_NODISCARD std::string* release_total_service_filter();
  void set_allocated_total_service_filter(std::string* total_service_filter);
  private:
  const std::string& _internal_total_service_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_total_service_filter(const std::string& value);
  std::string* _internal_mutable_total_service_filter();
  public:

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.TimeSeriesRatio)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr good_service_filter_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bad_service_filter_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_service_filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class DistributionCut final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.DistributionCut) */ {
 public:
  inline DistributionCut() : DistributionCut(nullptr) {}
  ~DistributionCut() override;
  explicit PROTOBUF_CONSTEXPR DistributionCut(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DistributionCut(const DistributionCut& from);
  DistributionCut(DistributionCut&& from) noexcept
    : DistributionCut() {
    *this = ::std::move(from);
  }

  inline DistributionCut& operator=(const DistributionCut& from) {
    CopyFrom(from);
    return *this;
  }
  inline DistributionCut& operator=(DistributionCut&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DistributionCut& default_instance() {
    return *internal_default_instance();
  }
  static inline const DistributionCut* internal_default_instance() {
    return reinterpret_cast<const DistributionCut*>(
               &_DistributionCut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DistributionCut& a, DistributionCut& b) {
    a.Swap(&b);
  }
  inline void Swap(DistributionCut* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DistributionCut* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DistributionCut* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DistributionCut>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DistributionCut& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DistributionCut& from) {
    DistributionCut::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DistributionCut* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.DistributionCut";
  }
  protected:
  explicit DistributionCut(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDistributionFilterFieldNumber = 4,
    kRangeFieldNumber = 5,
  };
  // string distribution_filter = 4;
  void clear_distribution_filter();
  const std::string& distribution_filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_distribution_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_distribution_filter();
  PROTOBUF_NODISCARD std::string* release_distribution_filter();
  void set_allocated_distribution_filter(std::string* distribution_filter);
  private:
  const std::string& _internal_distribution_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_distribution_filter(const std::string& value);
  std::string* _internal_mutable_distribution_filter();
  public:

  // .google.monitoring.v3.Range range = 5;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::google::monitoring::v3::Range& range() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::Range* release_range();
  ::google::monitoring::v3::Range* mutable_range();
  void set_allocated_range(::google::monitoring::v3::Range* range);
  private:
  const ::google::monitoring::v3::Range& _internal_range() const;
  ::google::monitoring::v3::Range* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::google::monitoring::v3::Range* range);
  ::google::monitoring::v3::Range* unsafe_arena_release_range();

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.DistributionCut)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr distribution_filter_;
    ::google::monitoring::v3::Range* range_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class WindowsBasedSli_PerformanceThreshold final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.WindowsBasedSli.PerformanceThreshold) */ {
 public:
  inline WindowsBasedSli_PerformanceThreshold() : WindowsBasedSli_PerformanceThreshold(nullptr) {}
  ~WindowsBasedSli_PerformanceThreshold() override;
  explicit PROTOBUF_CONSTEXPR WindowsBasedSli_PerformanceThreshold(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowsBasedSli_PerformanceThreshold(const WindowsBasedSli_PerformanceThreshold& from);
  WindowsBasedSli_PerformanceThreshold(WindowsBasedSli_PerformanceThreshold&& from) noexcept
    : WindowsBasedSli_PerformanceThreshold() {
    *this = ::std::move(from);
  }

  inline WindowsBasedSli_PerformanceThreshold& operator=(const WindowsBasedSli_PerformanceThreshold& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowsBasedSli_PerformanceThreshold& operator=(WindowsBasedSli_PerformanceThreshold&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowsBasedSli_PerformanceThreshold& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kPerformance = 1,
    kBasicSliPerformance = 3,
    TYPE_NOT_SET = 0,
  };

  static inline const WindowsBasedSli_PerformanceThreshold* internal_default_instance() {
    return reinterpret_cast<const WindowsBasedSli_PerformanceThreshold*>(
               &_WindowsBasedSli_PerformanceThreshold_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(WindowsBasedSli_PerformanceThreshold& a, WindowsBasedSli_PerformanceThreshold& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowsBasedSli_PerformanceThreshold* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowsBasedSli_PerformanceThreshold* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowsBasedSli_PerformanceThreshold* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WindowsBasedSli_PerformanceThreshold>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WindowsBasedSli_PerformanceThreshold& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WindowsBasedSli_PerformanceThreshold& from) {
    WindowsBasedSli_PerformanceThreshold::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WindowsBasedSli_PerformanceThreshold* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.WindowsBasedSli.PerformanceThreshold";
  }
  protected:
  explicit WindowsBasedSli_PerformanceThreshold(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThresholdFieldNumber = 2,
    kPerformanceFieldNumber = 1,
    kBasicSliPerformanceFieldNumber = 3,
  };
  // double threshold = 2;
  void clear_threshold();
  double threshold() const;
  void set_threshold(double value);
  private:
  double _internal_threshold() const;
  void _internal_set_threshold(double value);
  public:

  // .google.monitoring.v3.RequestBasedSli performance = 1;
  bool has_performance() const;
  private:
  bool _internal_has_performance() const;
  public:
  void clear_performance();
  const ::google::monitoring::v3::RequestBasedSli& performance() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::RequestBasedSli* release_performance();
  ::google::monitoring::v3::RequestBasedSli* mutable_performance();
  void set_allocated_performance(::google::monitoring::v3::RequestBasedSli* performance);
  private:
  const ::google::monitoring::v3::RequestBasedSli& _internal_performance() const;
  ::google::monitoring::v3::RequestBasedSli* _internal_mutable_performance();
  public:
  void unsafe_arena_set_allocated_performance(
      ::google::monitoring::v3::RequestBasedSli* performance);
  ::google::monitoring::v3::RequestBasedSli* unsafe_arena_release_performance();

  // .google.monitoring.v3.BasicSli basic_sli_performance = 3;
  bool has_basic_sli_performance() const;
  private:
  bool _internal_has_basic_sli_performance() const;
  public:
  void clear_basic_sli_performance();
  const ::google::monitoring::v3::BasicSli& basic_sli_performance() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::BasicSli* release_basic_sli_performance();
  ::google::monitoring::v3::BasicSli* mutable_basic_sli_performance();
  void set_allocated_basic_sli_performance(::google::monitoring::v3::BasicSli* basic_sli_performance);
  private:
  const ::google::monitoring::v3::BasicSli& _internal_basic_sli_performance() const;
  ::google::monitoring::v3::BasicSli* _internal_mutable_basic_sli_performance();
  public:
  void unsafe_arena_set_allocated_basic_sli_performance(
      ::google::monitoring::v3::BasicSli* basic_sli_performance);
  ::google::monitoring::v3::BasicSli* unsafe_arena_release_basic_sli_performance();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:google.monitoring.v3.WindowsBasedSli.PerformanceThreshold)
 private:
  class _Internal;
  void set_has_performance();
  void set_has_basic_sli_performance();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double threshold_;
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::google::monitoring::v3::RequestBasedSli* performance_;
      ::google::monitoring::v3::BasicSli* basic_sli_performance_;
    } type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class WindowsBasedSli_MetricRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.WindowsBasedSli.MetricRange) */ {
 public:
  inline WindowsBasedSli_MetricRange() : WindowsBasedSli_MetricRange(nullptr) {}
  ~WindowsBasedSli_MetricRange() override;
  explicit PROTOBUF_CONSTEXPR WindowsBasedSli_MetricRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowsBasedSli_MetricRange(const WindowsBasedSli_MetricRange& from);
  WindowsBasedSli_MetricRange(WindowsBasedSli_MetricRange&& from) noexcept
    : WindowsBasedSli_MetricRange() {
    *this = ::std::move(from);
  }

  inline WindowsBasedSli_MetricRange& operator=(const WindowsBasedSli_MetricRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowsBasedSli_MetricRange& operator=(WindowsBasedSli_MetricRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowsBasedSli_MetricRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowsBasedSli_MetricRange* internal_default_instance() {
    return reinterpret_cast<const WindowsBasedSli_MetricRange*>(
               &_WindowsBasedSli_MetricRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(WindowsBasedSli_MetricRange& a, WindowsBasedSli_MetricRange& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowsBasedSli_MetricRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowsBasedSli_MetricRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowsBasedSli_MetricRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WindowsBasedSli_MetricRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WindowsBasedSli_MetricRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WindowsBasedSli_MetricRange& from) {
    WindowsBasedSli_MetricRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WindowsBasedSli_MetricRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.WindowsBasedSli.MetricRange";
  }
  protected:
  explicit WindowsBasedSli_MetricRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeSeriesFieldNumber = 1,
    kRangeFieldNumber = 4,
  };
  // string time_series = 1;
  void clear_time_series();
  const std::string& time_series() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_series(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_series();
  PROTOBUF_NODISCARD std::string* release_time_series();
  void set_allocated_time_series(std::string* time_series);
  private:
  const std::string& _internal_time_series() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_series(const std::string& value);
  std::string* _internal_mutable_time_series();
  public:

  // .google.monitoring.v3.Range range = 4;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::google::monitoring::v3::Range& range() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::Range* release_range();
  ::google::monitoring::v3::Range* mutable_range();
  void set_allocated_range(::google::monitoring::v3::Range* range);
  private:
  const ::google::monitoring::v3::Range& _internal_range() const;
  ::google::monitoring::v3::Range* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::google::monitoring::v3::Range* range);
  ::google::monitoring::v3::Range* unsafe_arena_release_range();

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.WindowsBasedSli.MetricRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_series_;
    ::google::monitoring::v3::Range* range_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// -------------------------------------------------------------------

class WindowsBasedSli final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.WindowsBasedSli) */ {
 public:
  inline WindowsBasedSli() : WindowsBasedSli(nullptr) {}
  ~WindowsBasedSli() override;
  explicit PROTOBUF_CONSTEXPR WindowsBasedSli(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowsBasedSli(const WindowsBasedSli& from);
  WindowsBasedSli(WindowsBasedSli&& from) noexcept
    : WindowsBasedSli() {
    *this = ::std::move(from);
  }

  inline WindowsBasedSli& operator=(const WindowsBasedSli& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowsBasedSli& operator=(WindowsBasedSli&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowsBasedSli& default_instance() {
    return *internal_default_instance();
  }
  enum WindowCriterionCase {
    kGoodBadMetricFilter = 5,
    kGoodTotalRatioThreshold = 2,
    kMetricMeanInRange = 6,
    kMetricSumInRange = 7,
    WINDOW_CRITERION_NOT_SET = 0,
  };

  static inline const WindowsBasedSli* internal_default_instance() {
    return reinterpret_cast<const WindowsBasedSli*>(
               &_WindowsBasedSli_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(WindowsBasedSli& a, WindowsBasedSli& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowsBasedSli* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowsBasedSli* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowsBasedSli* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WindowsBasedSli>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WindowsBasedSli& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WindowsBasedSli& from) {
    WindowsBasedSli::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WindowsBasedSli* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.WindowsBasedSli";
  }
  protected:
  explicit WindowsBasedSli(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WindowsBasedSli_PerformanceThreshold PerformanceThreshold;
  typedef WindowsBasedSli_MetricRange MetricRange;

  // accessors -------------------------------------------------------

  enum : int {
    kWindowPeriodFieldNumber = 4,
    kGoodBadMetricFilterFieldNumber = 5,
    kGoodTotalRatioThresholdFieldNumber = 2,
    kMetricMeanInRangeFieldNumber = 6,
    kMetricSumInRangeFieldNumber = 7,
  };
  // .google.protobuf.Duration window_period = 4;
  bool has_window_period() const;
  private:
  bool _internal_has_window_period() const;
  public:
  void clear_window_period();
  const ::PROTOBUF_NAMESPACE_ID::Duration& window_period() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_window_period();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_window_period();
  void set_allocated_window_period(::PROTOBUF_NAMESPACE_ID::Duration* window_period);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_window_period() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_window_period();
  public:
  void unsafe_arena_set_allocated_window_period(
      ::PROTOBUF_NAMESPACE_ID::Duration* window_period);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_window_period();

  // string good_bad_metric_filter = 5;
  bool has_good_bad_metric_filter() const;
  private:
  bool _internal_has_good_bad_metric_filter() const;
  public:
  void clear_good_bad_metric_filter();
  const std::string& good_bad_metric_filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_good_bad_metric_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_good_bad_metric_filter();
  PROTOBUF_NODISCARD std::string* release_good_bad_metric_filter();
  void set_allocated_good_bad_metric_filter(std::string* good_bad_metric_filter);
  private:
  const std::string& _internal_good_bad_metric_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_good_bad_metric_filter(const std::string& value);
  std::string* _internal_mutable_good_bad_metric_filter();
  public:

  // .google.monitoring.v3.WindowsBasedSli.PerformanceThreshold good_total_ratio_threshold = 2;
  bool has_good_total_ratio_threshold() const;
  private:
  bool _internal_has_good_total_ratio_threshold() const;
  public:
  void clear_good_total_ratio_threshold();
  const ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold& good_total_ratio_threshold() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* release_good_total_ratio_threshold();
  ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* mutable_good_total_ratio_threshold();
  void set_allocated_good_total_ratio_threshold(::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* good_total_ratio_threshold);
  private:
  const ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold& _internal_good_total_ratio_threshold() const;
  ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* _internal_mutable_good_total_ratio_threshold();
  public:
  void unsafe_arena_set_allocated_good_total_ratio_threshold(
      ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* good_total_ratio_threshold);
  ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* unsafe_arena_release_good_total_ratio_threshold();

  // .google.monitoring.v3.WindowsBasedSli.MetricRange metric_mean_in_range = 6;
  bool has_metric_mean_in_range() const;
  private:
  bool _internal_has_metric_mean_in_range() const;
  public:
  void clear_metric_mean_in_range();
  const ::google::monitoring::v3::WindowsBasedSli_MetricRange& metric_mean_in_range() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::WindowsBasedSli_MetricRange* release_metric_mean_in_range();
  ::google::monitoring::v3::WindowsBasedSli_MetricRange* mutable_metric_mean_in_range();
  void set_allocated_metric_mean_in_range(::google::monitoring::v3::WindowsBasedSli_MetricRange* metric_mean_in_range);
  private:
  const ::google::monitoring::v3::WindowsBasedSli_MetricRange& _internal_metric_mean_in_range() const;
  ::google::monitoring::v3::WindowsBasedSli_MetricRange* _internal_mutable_metric_mean_in_range();
  public:
  void unsafe_arena_set_allocated_metric_mean_in_range(
      ::google::monitoring::v3::WindowsBasedSli_MetricRange* metric_mean_in_range);
  ::google::monitoring::v3::WindowsBasedSli_MetricRange* unsafe_arena_release_metric_mean_in_range();

  // .google.monitoring.v3.WindowsBasedSli.MetricRange metric_sum_in_range = 7;
  bool has_metric_sum_in_range() const;
  private:
  bool _internal_has_metric_sum_in_range() const;
  public:
  void clear_metric_sum_in_range();
  const ::google::monitoring::v3::WindowsBasedSli_MetricRange& metric_sum_in_range() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::WindowsBasedSli_MetricRange* release_metric_sum_in_range();
  ::google::monitoring::v3::WindowsBasedSli_MetricRange* mutable_metric_sum_in_range();
  void set_allocated_metric_sum_in_range(::google::monitoring::v3::WindowsBasedSli_MetricRange* metric_sum_in_range);
  private:
  const ::google::monitoring::v3::WindowsBasedSli_MetricRange& _internal_metric_sum_in_range() const;
  ::google::monitoring::v3::WindowsBasedSli_MetricRange* _internal_mutable_metric_sum_in_range();
  public:
  void unsafe_arena_set_allocated_metric_sum_in_range(
      ::google::monitoring::v3::WindowsBasedSli_MetricRange* metric_sum_in_range);
  ::google::monitoring::v3::WindowsBasedSli_MetricRange* unsafe_arena_release_metric_sum_in_range();

  void clear_window_criterion();
  WindowCriterionCase window_criterion_case() const;
  // @@protoc_insertion_point(class_scope:google.monitoring.v3.WindowsBasedSli)
 private:
  class _Internal;
  void set_has_good_bad_metric_filter();
  void set_has_good_total_ratio_threshold();
  void set_has_metric_mean_in_range();
  void set_has_metric_sum_in_range();

  inline bool has_window_criterion() const;
  inline void clear_has_window_criterion();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Duration* window_period_;
    union WindowCriterionUnion {
      constexpr WindowCriterionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr good_bad_metric_filter_;
      ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* good_total_ratio_threshold_;
      ::google::monitoring::v3::WindowsBasedSli_MetricRange* metric_mean_in_range_;
      ::google::monitoring::v3::WindowsBasedSli_MetricRange* metric_sum_in_range_;
    } window_criterion_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Service_Custom

// -------------------------------------------------------------------

// Service_AppEngine

// string module_id = 1;
inline void Service_AppEngine::clear_module_id() {
  _impl_.module_id_.ClearToEmpty();
}
inline const std::string& Service_AppEngine::module_id() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.AppEngine.module_id)
  return _internal_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service_AppEngine::set_module_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Service.AppEngine.module_id)
}
inline std::string* Service_AppEngine::mutable_module_id() {
  std::string* _s = _internal_mutable_module_id();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.AppEngine.module_id)
  return _s;
}
inline const std::string& Service_AppEngine::_internal_module_id() const {
  return _impl_.module_id_.Get();
}
inline void Service_AppEngine::_internal_set_module_id(const std::string& value) {
  
  _impl_.module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Service_AppEngine::_internal_mutable_module_id() {
  
  return _impl_.module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Service_AppEngine::release_module_id() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.AppEngine.module_id)
  return _impl_.module_id_.Release();
}
inline void Service_AppEngine::set_allocated_module_id(std::string* module_id) {
  if (module_id != nullptr) {
    
  } else {
    
  }
  _impl_.module_id_.SetAllocated(module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.module_id_.IsDefault()) {
    _impl_.module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.AppEngine.module_id)
}

// -------------------------------------------------------------------

// Service_CloudEndpoints

// string service = 1;
inline void Service_CloudEndpoints::clear_service() {
  _impl_.service_.ClearToEmpty();
}
inline const std::string& Service_CloudEndpoints::service() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.CloudEndpoints.service)
  return _internal_service();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service_CloudEndpoints::set_service(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Service.CloudEndpoints.service)
}
inline std::string* Service_CloudEndpoints::mutable_service() {
  std::string* _s = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.CloudEndpoints.service)
  return _s;
}
inline const std::string& Service_CloudEndpoints::_internal_service() const {
  return _impl_.service_.Get();
}
inline void Service_CloudEndpoints::_internal_set_service(const std::string& value) {
  
  _impl_.service_.Set(value, GetArenaForAllocation());
}
inline std::string* Service_CloudEndpoints::_internal_mutable_service() {
  
  return _impl_.service_.Mutable(GetArenaForAllocation());
}
inline std::string* Service_CloudEndpoints::release_service() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.CloudEndpoints.service)
  return _impl_.service_.Release();
}
inline void Service_CloudEndpoints::set_allocated_service(std::string* service) {
  if (service != nullptr) {
    
  } else {
    
  }
  _impl_.service_.SetAllocated(service, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_.IsDefault()) {
    _impl_.service_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.CloudEndpoints.service)
}

// -------------------------------------------------------------------

// Service_ClusterIstio

// string location = 1;
inline void Service_ClusterIstio::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& Service_ClusterIstio::location() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.ClusterIstio.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service_ClusterIstio::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Service.ClusterIstio.location)
}
inline std::string* Service_ClusterIstio::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.ClusterIstio.location)
  return _s;
}
inline const std::string& Service_ClusterIstio::_internal_location() const {
  return _impl_.location_.Get();
}
inline void Service_ClusterIstio::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* Service_ClusterIstio::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* Service_ClusterIstio::release_location() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.ClusterIstio.location)
  return _impl_.location_.Release();
}
inline void Service_ClusterIstio::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.ClusterIstio.location)
}

// string cluster_name = 2;
inline void Service_ClusterIstio::clear_cluster_name() {
  _impl_.cluster_name_.ClearToEmpty();
}
inline const std::string& Service_ClusterIstio::cluster_name() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.ClusterIstio.cluster_name)
  return _internal_cluster_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service_ClusterIstio::set_cluster_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cluster_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Service.ClusterIstio.cluster_name)
}
inline std::string* Service_ClusterIstio::mutable_cluster_name() {
  std::string* _s = _internal_mutable_cluster_name();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.ClusterIstio.cluster_name)
  return _s;
}
inline const std::string& Service_ClusterIstio::_internal_cluster_name() const {
  return _impl_.cluster_name_.Get();
}
inline void Service_ClusterIstio::_internal_set_cluster_name(const std::string& value) {
  
  _impl_.cluster_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Service_ClusterIstio::_internal_mutable_cluster_name() {
  
  return _impl_.cluster_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Service_ClusterIstio::release_cluster_name() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.ClusterIstio.cluster_name)
  return _impl_.cluster_name_.Release();
}
inline void Service_ClusterIstio::set_allocated_cluster_name(std::string* cluster_name) {
  if (cluster_name != nullptr) {
    
  } else {
    
  }
  _impl_.cluster_name_.SetAllocated(cluster_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cluster_name_.IsDefault()) {
    _impl_.cluster_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.ClusterIstio.cluster_name)
}

// string service_namespace = 3;
inline void Service_ClusterIstio::clear_service_namespace() {
  _impl_.service_namespace_.ClearToEmpty();
}
inline const std::string& Service_ClusterIstio::service_namespace() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.ClusterIstio.service_namespace)
  return _internal_service_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service_ClusterIstio::set_service_namespace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Service.ClusterIstio.service_namespace)
}
inline std::string* Service_ClusterIstio::mutable_service_namespace() {
  std::string* _s = _internal_mutable_service_namespace();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.ClusterIstio.service_namespace)
  return _s;
}
inline const std::string& Service_ClusterIstio::_internal_service_namespace() const {
  return _impl_.service_namespace_.Get();
}
inline void Service_ClusterIstio::_internal_set_service_namespace(const std::string& value) {
  
  _impl_.service_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* Service_ClusterIstio::_internal_mutable_service_namespace() {
  
  return _impl_.service_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* Service_ClusterIstio::release_service_namespace() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.ClusterIstio.service_namespace)
  return _impl_.service_namespace_.Release();
}
inline void Service_ClusterIstio::set_allocated_service_namespace(std::string* service_namespace) {
  if (service_namespace != nullptr) {
    
  } else {
    
  }
  _impl_.service_namespace_.SetAllocated(service_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_namespace_.IsDefault()) {
    _impl_.service_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.ClusterIstio.service_namespace)
}

// string service_name = 4;
inline void Service_ClusterIstio::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& Service_ClusterIstio::service_name() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.ClusterIstio.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service_ClusterIstio::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Service.ClusterIstio.service_name)
}
inline std::string* Service_ClusterIstio::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.ClusterIstio.service_name)
  return _s;
}
inline const std::string& Service_ClusterIstio::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void Service_ClusterIstio::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Service_ClusterIstio::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Service_ClusterIstio::release_service_name() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.ClusterIstio.service_name)
  return _impl_.service_name_.Release();
}
inline void Service_ClusterIstio::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.ClusterIstio.service_name)
}

// -------------------------------------------------------------------

// Service_MeshIstio

// string mesh_uid = 1;
inline void Service_MeshIstio::clear_mesh_uid() {
  _impl_.mesh_uid_.ClearToEmpty();
}
inline const std::string& Service_MeshIstio::mesh_uid() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.MeshIstio.mesh_uid)
  return _internal_mesh_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service_MeshIstio::set_mesh_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mesh_uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Service.MeshIstio.mesh_uid)
}
inline std::string* Service_MeshIstio::mutable_mesh_uid() {
  std::string* _s = _internal_mutable_mesh_uid();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.MeshIstio.mesh_uid)
  return _s;
}
inline const std::string& Service_MeshIstio::_internal_mesh_uid() const {
  return _impl_.mesh_uid_.Get();
}
inline void Service_MeshIstio::_internal_set_mesh_uid(const std::string& value) {
  
  _impl_.mesh_uid_.Set(value, GetArenaForAllocation());
}
inline std::string* Service_MeshIstio::_internal_mutable_mesh_uid() {
  
  return _impl_.mesh_uid_.Mutable(GetArenaForAllocation());
}
inline std::string* Service_MeshIstio::release_mesh_uid() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.MeshIstio.mesh_uid)
  return _impl_.mesh_uid_.Release();
}
inline void Service_MeshIstio::set_allocated_mesh_uid(std::string* mesh_uid) {
  if (mesh_uid != nullptr) {
    
  } else {
    
  }
  _impl_.mesh_uid_.SetAllocated(mesh_uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mesh_uid_.IsDefault()) {
    _impl_.mesh_uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.MeshIstio.mesh_uid)
}

// string service_namespace = 3;
inline void Service_MeshIstio::clear_service_namespace() {
  _impl_.service_namespace_.ClearToEmpty();
}
inline const std::string& Service_MeshIstio::service_namespace() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.MeshIstio.service_namespace)
  return _internal_service_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service_MeshIstio::set_service_namespace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Service.MeshIstio.service_namespace)
}
inline std::string* Service_MeshIstio::mutable_service_namespace() {
  std::string* _s = _internal_mutable_service_namespace();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.MeshIstio.service_namespace)
  return _s;
}
inline const std::string& Service_MeshIstio::_internal_service_namespace() const {
  return _impl_.service_namespace_.Get();
}
inline void Service_MeshIstio::_internal_set_service_namespace(const std::string& value) {
  
  _impl_.service_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* Service_MeshIstio::_internal_mutable_service_namespace() {
  
  return _impl_.service_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* Service_MeshIstio::release_service_namespace() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.MeshIstio.service_namespace)
  return _impl_.service_namespace_.Release();
}
inline void Service_MeshIstio::set_allocated_service_namespace(std::string* service_namespace) {
  if (service_namespace != nullptr) {
    
  } else {
    
  }
  _impl_.service_namespace_.SetAllocated(service_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_namespace_.IsDefault()) {
    _impl_.service_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.MeshIstio.service_namespace)
}

// string service_name = 4;
inline void Service_MeshIstio::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& Service_MeshIstio::service_name() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.MeshIstio.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service_MeshIstio::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Service.MeshIstio.service_name)
}
inline std::string* Service_MeshIstio::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.MeshIstio.service_name)
  return _s;
}
inline const std::string& Service_MeshIstio::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void Service_MeshIstio::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Service_MeshIstio::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Service_MeshIstio::release_service_name() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.MeshIstio.service_name)
  return _impl_.service_name_.Release();
}
inline void Service_MeshIstio::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.MeshIstio.service_name)
}

// -------------------------------------------------------------------

// Service_IstioCanonicalService

// string mesh_uid = 1;
inline void Service_IstioCanonicalService::clear_mesh_uid() {
  _impl_.mesh_uid_.ClearToEmpty();
}
inline const std::string& Service_IstioCanonicalService::mesh_uid() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.IstioCanonicalService.mesh_uid)
  return _internal_mesh_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service_IstioCanonicalService::set_mesh_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mesh_uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Service.IstioCanonicalService.mesh_uid)
}
inline std::string* Service_IstioCanonicalService::mutable_mesh_uid() {
  std::string* _s = _internal_mutable_mesh_uid();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.IstioCanonicalService.mesh_uid)
  return _s;
}
inline const std::string& Service_IstioCanonicalService::_internal_mesh_uid() const {
  return _impl_.mesh_uid_.Get();
}
inline void Service_IstioCanonicalService::_internal_set_mesh_uid(const std::string& value) {
  
  _impl_.mesh_uid_.Set(value, GetArenaForAllocation());
}
inline std::string* Service_IstioCanonicalService::_internal_mutable_mesh_uid() {
  
  return _impl_.mesh_uid_.Mutable(GetArenaForAllocation());
}
inline std::string* Service_IstioCanonicalService::release_mesh_uid() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.IstioCanonicalService.mesh_uid)
  return _impl_.mesh_uid_.Release();
}
inline void Service_IstioCanonicalService::set_allocated_mesh_uid(std::string* mesh_uid) {
  if (mesh_uid != nullptr) {
    
  } else {
    
  }
  _impl_.mesh_uid_.SetAllocated(mesh_uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mesh_uid_.IsDefault()) {
    _impl_.mesh_uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.IstioCanonicalService.mesh_uid)
}

// string canonical_service_namespace = 3;
inline void Service_IstioCanonicalService::clear_canonical_service_namespace() {
  _impl_.canonical_service_namespace_.ClearToEmpty();
}
inline const std::string& Service_IstioCanonicalService::canonical_service_namespace() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.IstioCanonicalService.canonical_service_namespace)
  return _internal_canonical_service_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service_IstioCanonicalService::set_canonical_service_namespace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.canonical_service_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Service.IstioCanonicalService.canonical_service_namespace)
}
inline std::string* Service_IstioCanonicalService::mutable_canonical_service_namespace() {
  std::string* _s = _internal_mutable_canonical_service_namespace();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.IstioCanonicalService.canonical_service_namespace)
  return _s;
}
inline const std::string& Service_IstioCanonicalService::_internal_canonical_service_namespace() const {
  return _impl_.canonical_service_namespace_.Get();
}
inline void Service_IstioCanonicalService::_internal_set_canonical_service_namespace(const std::string& value) {
  
  _impl_.canonical_service_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* Service_IstioCanonicalService::_internal_mutable_canonical_service_namespace() {
  
  return _impl_.canonical_service_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* Service_IstioCanonicalService::release_canonical_service_namespace() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.IstioCanonicalService.canonical_service_namespace)
  return _impl_.canonical_service_namespace_.Release();
}
inline void Service_IstioCanonicalService::set_allocated_canonical_service_namespace(std::string* canonical_service_namespace) {
  if (canonical_service_namespace != nullptr) {
    
  } else {
    
  }
  _impl_.canonical_service_namespace_.SetAllocated(canonical_service_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.canonical_service_namespace_.IsDefault()) {
    _impl_.canonical_service_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.IstioCanonicalService.canonical_service_namespace)
}

// string canonical_service = 4;
inline void Service_IstioCanonicalService::clear_canonical_service() {
  _impl_.canonical_service_.ClearToEmpty();
}
inline const std::string& Service_IstioCanonicalService::canonical_service() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.IstioCanonicalService.canonical_service)
  return _internal_canonical_service();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service_IstioCanonicalService::set_canonical_service(ArgT0&& arg0, ArgT... args) {
 
 _impl_.canonical_service_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Service.IstioCanonicalService.canonical_service)
}
inline std::string* Service_IstioCanonicalService::mutable_canonical_service() {
  std::string* _s = _internal_mutable_canonical_service();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.IstioCanonicalService.canonical_service)
  return _s;
}
inline const std::string& Service_IstioCanonicalService::_internal_canonical_service() const {
  return _impl_.canonical_service_.Get();
}
inline void Service_IstioCanonicalService::_internal_set_canonical_service(const std::string& value) {
  
  _impl_.canonical_service_.Set(value, GetArenaForAllocation());
}
inline std::string* Service_IstioCanonicalService::_internal_mutable_canonical_service() {
  
  return _impl_.canonical_service_.Mutable(GetArenaForAllocation());
}
inline std::string* Service_IstioCanonicalService::release_canonical_service() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.IstioCanonicalService.canonical_service)
  return _impl_.canonical_service_.Release();
}
inline void Service_IstioCanonicalService::set_allocated_canonical_service(std::string* canonical_service) {
  if (canonical_service != nullptr) {
    
  } else {
    
  }
  _impl_.canonical_service_.SetAllocated(canonical_service, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.canonical_service_.IsDefault()) {
    _impl_.canonical_service_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.IstioCanonicalService.canonical_service)
}

// -------------------------------------------------------------------

// Service_Telemetry

// string resource_name = 1;
inline void Service_Telemetry::clear_resource_name() {
  _impl_.resource_name_.ClearToEmpty();
}
inline const std::string& Service_Telemetry::resource_name() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.Telemetry.resource_name)
  return _internal_resource_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service_Telemetry::set_resource_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resource_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Service.Telemetry.resource_name)
}
inline std::string* Service_Telemetry::mutable_resource_name() {
  std::string* _s = _internal_mutable_resource_name();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.Telemetry.resource_name)
  return _s;
}
inline const std::string& Service_Telemetry::_internal_resource_name() const {
  return _impl_.resource_name_.Get();
}
inline void Service_Telemetry::_internal_set_resource_name(const std::string& value) {
  
  _impl_.resource_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Service_Telemetry::_internal_mutable_resource_name() {
  
  return _impl_.resource_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Service_Telemetry::release_resource_name() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.Telemetry.resource_name)
  return _impl_.resource_name_.Release();
}
inline void Service_Telemetry::set_allocated_resource_name(std::string* resource_name) {
  if (resource_name != nullptr) {
    
  } else {
    
  }
  _impl_.resource_name_.SetAllocated(resource_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_name_.IsDefault()) {
    _impl_.resource_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.Telemetry.resource_name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Service

// string name = 1;
inline void Service::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Service::name() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Service.name)
}
inline std::string* Service::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.name)
  return _s;
}
inline const std::string& Service::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Service::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Service::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Service::release_name() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.name)
  return _impl_.name_.Release();
}
inline void Service::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.name)
}

// string display_name = 2;
inline void Service::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& Service::display_name() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Service::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Service.display_name)
}
inline std::string* Service::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.display_name)
  return _s;
}
inline const std::string& Service::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void Service::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Service::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Service::release_display_name() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.display_name)
  return _impl_.display_name_.Release();
}
inline void Service::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.display_name)
}

// .google.monitoring.v3.Service.Custom custom = 6;
inline bool Service::_internal_has_custom() const {
  return identifier_case() == kCustom;
}
inline bool Service::has_custom() const {
  return _internal_has_custom();
}
inline void Service::set_has_custom() {
  _impl_._oneof_case_[0] = kCustom;
}
inline void Service::clear_custom() {
  if (_internal_has_custom()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.identifier_.custom_;
    }
    clear_has_identifier();
  }
}
inline ::google::monitoring::v3::Service_Custom* Service::release_custom() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.custom)
  if (_internal_has_custom()) {
    clear_has_identifier();
    ::google::monitoring::v3::Service_Custom* temp = _impl_.identifier_.custom_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.identifier_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::Service_Custom& Service::_internal_custom() const {
  return _internal_has_custom()
      ? *_impl_.identifier_.custom_
      : reinterpret_cast< ::google::monitoring::v3::Service_Custom&>(::google::monitoring::v3::_Service_Custom_default_instance_);
}
inline const ::google::monitoring::v3::Service_Custom& Service::custom() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.custom)
  return _internal_custom();
}
inline ::google::monitoring::v3::Service_Custom* Service::unsafe_arena_release_custom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.Service.custom)
  if (_internal_has_custom()) {
    clear_has_identifier();
    ::google::monitoring::v3::Service_Custom* temp = _impl_.identifier_.custom_;
    _impl_.identifier_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Service::unsafe_arena_set_allocated_custom(::google::monitoring::v3::Service_Custom* custom) {
  clear_identifier();
  if (custom) {
    set_has_custom();
    _impl_.identifier_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.Service.custom)
}
inline ::google::monitoring::v3::Service_Custom* Service::_internal_mutable_custom() {
  if (!_internal_has_custom()) {
    clear_identifier();
    set_has_custom();
    _impl_.identifier_.custom_ = CreateMaybeMessage< ::google::monitoring::v3::Service_Custom >(GetArenaForAllocation());
  }
  return _impl_.identifier_.custom_;
}
inline ::google::monitoring::v3::Service_Custom* Service::mutable_custom() {
  ::google::monitoring::v3::Service_Custom* _msg = _internal_mutable_custom();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.custom)
  return _msg;
}

// .google.monitoring.v3.Service.AppEngine app_engine = 7;
inline bool Service::_internal_has_app_engine() const {
  return identifier_case() == kAppEngine;
}
inline bool Service::has_app_engine() const {
  return _internal_has_app_engine();
}
inline void Service::set_has_app_engine() {
  _impl_._oneof_case_[0] = kAppEngine;
}
inline void Service::clear_app_engine() {
  if (_internal_has_app_engine()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.identifier_.app_engine_;
    }
    clear_has_identifier();
  }
}
inline ::google::monitoring::v3::Service_AppEngine* Service::release_app_engine() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.app_engine)
  if (_internal_has_app_engine()) {
    clear_has_identifier();
    ::google::monitoring::v3::Service_AppEngine* temp = _impl_.identifier_.app_engine_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.identifier_.app_engine_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::Service_AppEngine& Service::_internal_app_engine() const {
  return _internal_has_app_engine()
      ? *_impl_.identifier_.app_engine_
      : reinterpret_cast< ::google::monitoring::v3::Service_AppEngine&>(::google::monitoring::v3::_Service_AppEngine_default_instance_);
}
inline const ::google::monitoring::v3::Service_AppEngine& Service::app_engine() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.app_engine)
  return _internal_app_engine();
}
inline ::google::monitoring::v3::Service_AppEngine* Service::unsafe_arena_release_app_engine() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.Service.app_engine)
  if (_internal_has_app_engine()) {
    clear_has_identifier();
    ::google::monitoring::v3::Service_AppEngine* temp = _impl_.identifier_.app_engine_;
    _impl_.identifier_.app_engine_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Service::unsafe_arena_set_allocated_app_engine(::google::monitoring::v3::Service_AppEngine* app_engine) {
  clear_identifier();
  if (app_engine) {
    set_has_app_engine();
    _impl_.identifier_.app_engine_ = app_engine;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.Service.app_engine)
}
inline ::google::monitoring::v3::Service_AppEngine* Service::_internal_mutable_app_engine() {
  if (!_internal_has_app_engine()) {
    clear_identifier();
    set_has_app_engine();
    _impl_.identifier_.app_engine_ = CreateMaybeMessage< ::google::monitoring::v3::Service_AppEngine >(GetArenaForAllocation());
  }
  return _impl_.identifier_.app_engine_;
}
inline ::google::monitoring::v3::Service_AppEngine* Service::mutable_app_engine() {
  ::google::monitoring::v3::Service_AppEngine* _msg = _internal_mutable_app_engine();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.app_engine)
  return _msg;
}

// .google.monitoring.v3.Service.CloudEndpoints cloud_endpoints = 8;
inline bool Service::_internal_has_cloud_endpoints() const {
  return identifier_case() == kCloudEndpoints;
}
inline bool Service::has_cloud_endpoints() const {
  return _internal_has_cloud_endpoints();
}
inline void Service::set_has_cloud_endpoints() {
  _impl_._oneof_case_[0] = kCloudEndpoints;
}
inline void Service::clear_cloud_endpoints() {
  if (_internal_has_cloud_endpoints()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.identifier_.cloud_endpoints_;
    }
    clear_has_identifier();
  }
}
inline ::google::monitoring::v3::Service_CloudEndpoints* Service::release_cloud_endpoints() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.cloud_endpoints)
  if (_internal_has_cloud_endpoints()) {
    clear_has_identifier();
    ::google::monitoring::v3::Service_CloudEndpoints* temp = _impl_.identifier_.cloud_endpoints_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.identifier_.cloud_endpoints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::Service_CloudEndpoints& Service::_internal_cloud_endpoints() const {
  return _internal_has_cloud_endpoints()
      ? *_impl_.identifier_.cloud_endpoints_
      : reinterpret_cast< ::google::monitoring::v3::Service_CloudEndpoints&>(::google::monitoring::v3::_Service_CloudEndpoints_default_instance_);
}
inline const ::google::monitoring::v3::Service_CloudEndpoints& Service::cloud_endpoints() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.cloud_endpoints)
  return _internal_cloud_endpoints();
}
inline ::google::monitoring::v3::Service_CloudEndpoints* Service::unsafe_arena_release_cloud_endpoints() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.Service.cloud_endpoints)
  if (_internal_has_cloud_endpoints()) {
    clear_has_identifier();
    ::google::monitoring::v3::Service_CloudEndpoints* temp = _impl_.identifier_.cloud_endpoints_;
    _impl_.identifier_.cloud_endpoints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Service::unsafe_arena_set_allocated_cloud_endpoints(::google::monitoring::v3::Service_CloudEndpoints* cloud_endpoints) {
  clear_identifier();
  if (cloud_endpoints) {
    set_has_cloud_endpoints();
    _impl_.identifier_.cloud_endpoints_ = cloud_endpoints;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.Service.cloud_endpoints)
}
inline ::google::monitoring::v3::Service_CloudEndpoints* Service::_internal_mutable_cloud_endpoints() {
  if (!_internal_has_cloud_endpoints()) {
    clear_identifier();
    set_has_cloud_endpoints();
    _impl_.identifier_.cloud_endpoints_ = CreateMaybeMessage< ::google::monitoring::v3::Service_CloudEndpoints >(GetArenaForAllocation());
  }
  return _impl_.identifier_.cloud_endpoints_;
}
inline ::google::monitoring::v3::Service_CloudEndpoints* Service::mutable_cloud_endpoints() {
  ::google::monitoring::v3::Service_CloudEndpoints* _msg = _internal_mutable_cloud_endpoints();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.cloud_endpoints)
  return _msg;
}

// .google.monitoring.v3.Service.ClusterIstio cluster_istio = 9;
inline bool Service::_internal_has_cluster_istio() const {
  return identifier_case() == kClusterIstio;
}
inline bool Service::has_cluster_istio() const {
  return _internal_has_cluster_istio();
}
inline void Service::set_has_cluster_istio() {
  _impl_._oneof_case_[0] = kClusterIstio;
}
inline void Service::clear_cluster_istio() {
  if (_internal_has_cluster_istio()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.identifier_.cluster_istio_;
    }
    clear_has_identifier();
  }
}
inline ::google::monitoring::v3::Service_ClusterIstio* Service::release_cluster_istio() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.cluster_istio)
  if (_internal_has_cluster_istio()) {
    clear_has_identifier();
    ::google::monitoring::v3::Service_ClusterIstio* temp = _impl_.identifier_.cluster_istio_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.identifier_.cluster_istio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::Service_ClusterIstio& Service::_internal_cluster_istio() const {
  return _internal_has_cluster_istio()
      ? *_impl_.identifier_.cluster_istio_
      : reinterpret_cast< ::google::monitoring::v3::Service_ClusterIstio&>(::google::monitoring::v3::_Service_ClusterIstio_default_instance_);
}
inline const ::google::monitoring::v3::Service_ClusterIstio& Service::cluster_istio() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.cluster_istio)
  return _internal_cluster_istio();
}
inline ::google::monitoring::v3::Service_ClusterIstio* Service::unsafe_arena_release_cluster_istio() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.Service.cluster_istio)
  if (_internal_has_cluster_istio()) {
    clear_has_identifier();
    ::google::monitoring::v3::Service_ClusterIstio* temp = _impl_.identifier_.cluster_istio_;
    _impl_.identifier_.cluster_istio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Service::unsafe_arena_set_allocated_cluster_istio(::google::monitoring::v3::Service_ClusterIstio* cluster_istio) {
  clear_identifier();
  if (cluster_istio) {
    set_has_cluster_istio();
    _impl_.identifier_.cluster_istio_ = cluster_istio;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.Service.cluster_istio)
}
inline ::google::monitoring::v3::Service_ClusterIstio* Service::_internal_mutable_cluster_istio() {
  if (!_internal_has_cluster_istio()) {
    clear_identifier();
    set_has_cluster_istio();
    _impl_.identifier_.cluster_istio_ = CreateMaybeMessage< ::google::monitoring::v3::Service_ClusterIstio >(GetArenaForAllocation());
  }
  return _impl_.identifier_.cluster_istio_;
}
inline ::google::monitoring::v3::Service_ClusterIstio* Service::mutable_cluster_istio() {
  ::google::monitoring::v3::Service_ClusterIstio* _msg = _internal_mutable_cluster_istio();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.cluster_istio)
  return _msg;
}

// .google.monitoring.v3.Service.MeshIstio mesh_istio = 10;
inline bool Service::_internal_has_mesh_istio() const {
  return identifier_case() == kMeshIstio;
}
inline bool Service::has_mesh_istio() const {
  return _internal_has_mesh_istio();
}
inline void Service::set_has_mesh_istio() {
  _impl_._oneof_case_[0] = kMeshIstio;
}
inline void Service::clear_mesh_istio() {
  if (_internal_has_mesh_istio()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.identifier_.mesh_istio_;
    }
    clear_has_identifier();
  }
}
inline ::google::monitoring::v3::Service_MeshIstio* Service::release_mesh_istio() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.mesh_istio)
  if (_internal_has_mesh_istio()) {
    clear_has_identifier();
    ::google::monitoring::v3::Service_MeshIstio* temp = _impl_.identifier_.mesh_istio_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.identifier_.mesh_istio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::Service_MeshIstio& Service::_internal_mesh_istio() const {
  return _internal_has_mesh_istio()
      ? *_impl_.identifier_.mesh_istio_
      : reinterpret_cast< ::google::monitoring::v3::Service_MeshIstio&>(::google::monitoring::v3::_Service_MeshIstio_default_instance_);
}
inline const ::google::monitoring::v3::Service_MeshIstio& Service::mesh_istio() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.mesh_istio)
  return _internal_mesh_istio();
}
inline ::google::monitoring::v3::Service_MeshIstio* Service::unsafe_arena_release_mesh_istio() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.Service.mesh_istio)
  if (_internal_has_mesh_istio()) {
    clear_has_identifier();
    ::google::monitoring::v3::Service_MeshIstio* temp = _impl_.identifier_.mesh_istio_;
    _impl_.identifier_.mesh_istio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Service::unsafe_arena_set_allocated_mesh_istio(::google::monitoring::v3::Service_MeshIstio* mesh_istio) {
  clear_identifier();
  if (mesh_istio) {
    set_has_mesh_istio();
    _impl_.identifier_.mesh_istio_ = mesh_istio;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.Service.mesh_istio)
}
inline ::google::monitoring::v3::Service_MeshIstio* Service::_internal_mutable_mesh_istio() {
  if (!_internal_has_mesh_istio()) {
    clear_identifier();
    set_has_mesh_istio();
    _impl_.identifier_.mesh_istio_ = CreateMaybeMessage< ::google::monitoring::v3::Service_MeshIstio >(GetArenaForAllocation());
  }
  return _impl_.identifier_.mesh_istio_;
}
inline ::google::monitoring::v3::Service_MeshIstio* Service::mutable_mesh_istio() {
  ::google::monitoring::v3::Service_MeshIstio* _msg = _internal_mutable_mesh_istio();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.mesh_istio)
  return _msg;
}

// .google.monitoring.v3.Service.IstioCanonicalService istio_canonical_service = 11;
inline bool Service::_internal_has_istio_canonical_service() const {
  return identifier_case() == kIstioCanonicalService;
}
inline bool Service::has_istio_canonical_service() const {
  return _internal_has_istio_canonical_service();
}
inline void Service::set_has_istio_canonical_service() {
  _impl_._oneof_case_[0] = kIstioCanonicalService;
}
inline void Service::clear_istio_canonical_service() {
  if (_internal_has_istio_canonical_service()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.identifier_.istio_canonical_service_;
    }
    clear_has_identifier();
  }
}
inline ::google::monitoring::v3::Service_IstioCanonicalService* Service::release_istio_canonical_service() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.istio_canonical_service)
  if (_internal_has_istio_canonical_service()) {
    clear_has_identifier();
    ::google::monitoring::v3::Service_IstioCanonicalService* temp = _impl_.identifier_.istio_canonical_service_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.identifier_.istio_canonical_service_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::Service_IstioCanonicalService& Service::_internal_istio_canonical_service() const {
  return _internal_has_istio_canonical_service()
      ? *_impl_.identifier_.istio_canonical_service_
      : reinterpret_cast< ::google::monitoring::v3::Service_IstioCanonicalService&>(::google::monitoring::v3::_Service_IstioCanonicalService_default_instance_);
}
inline const ::google::monitoring::v3::Service_IstioCanonicalService& Service::istio_canonical_service() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.istio_canonical_service)
  return _internal_istio_canonical_service();
}
inline ::google::monitoring::v3::Service_IstioCanonicalService* Service::unsafe_arena_release_istio_canonical_service() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.Service.istio_canonical_service)
  if (_internal_has_istio_canonical_service()) {
    clear_has_identifier();
    ::google::monitoring::v3::Service_IstioCanonicalService* temp = _impl_.identifier_.istio_canonical_service_;
    _impl_.identifier_.istio_canonical_service_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Service::unsafe_arena_set_allocated_istio_canonical_service(::google::monitoring::v3::Service_IstioCanonicalService* istio_canonical_service) {
  clear_identifier();
  if (istio_canonical_service) {
    set_has_istio_canonical_service();
    _impl_.identifier_.istio_canonical_service_ = istio_canonical_service;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.Service.istio_canonical_service)
}
inline ::google::monitoring::v3::Service_IstioCanonicalService* Service::_internal_mutable_istio_canonical_service() {
  if (!_internal_has_istio_canonical_service()) {
    clear_identifier();
    set_has_istio_canonical_service();
    _impl_.identifier_.istio_canonical_service_ = CreateMaybeMessage< ::google::monitoring::v3::Service_IstioCanonicalService >(GetArenaForAllocation());
  }
  return _impl_.identifier_.istio_canonical_service_;
}
inline ::google::monitoring::v3::Service_IstioCanonicalService* Service::mutable_istio_canonical_service() {
  ::google::monitoring::v3::Service_IstioCanonicalService* _msg = _internal_mutable_istio_canonical_service();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.istio_canonical_service)
  return _msg;
}

// .google.monitoring.v3.Service.Telemetry telemetry = 13;
inline bool Service::_internal_has_telemetry() const {
  return this != internal_default_instance() && _impl_.telemetry_ != nullptr;
}
inline bool Service::has_telemetry() const {
  return _internal_has_telemetry();
}
inline void Service::clear_telemetry() {
  if (GetArenaForAllocation() == nullptr && _impl_.telemetry_ != nullptr) {
    delete _impl_.telemetry_;
  }
  _impl_.telemetry_ = nullptr;
}
inline const ::google::monitoring::v3::Service_Telemetry& Service::_internal_telemetry() const {
  const ::google::monitoring::v3::Service_Telemetry* p = _impl_.telemetry_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::monitoring::v3::Service_Telemetry&>(
      ::google::monitoring::v3::_Service_Telemetry_default_instance_);
}
inline const ::google::monitoring::v3::Service_Telemetry& Service::telemetry() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Service.telemetry)
  return _internal_telemetry();
}
inline void Service::unsafe_arena_set_allocated_telemetry(
    ::google::monitoring::v3::Service_Telemetry* telemetry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.telemetry_);
  }
  _impl_.telemetry_ = telemetry;
  if (telemetry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.Service.telemetry)
}
inline ::google::monitoring::v3::Service_Telemetry* Service::release_telemetry() {
  
  ::google::monitoring::v3::Service_Telemetry* temp = _impl_.telemetry_;
  _impl_.telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::monitoring::v3::Service_Telemetry* Service::unsafe_arena_release_telemetry() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.Service.telemetry)
  
  ::google::monitoring::v3::Service_Telemetry* temp = _impl_.telemetry_;
  _impl_.telemetry_ = nullptr;
  return temp;
}
inline ::google::monitoring::v3::Service_Telemetry* Service::_internal_mutable_telemetry() {
  
  if (_impl_.telemetry_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::monitoring::v3::Service_Telemetry>(GetArenaForAllocation());
    _impl_.telemetry_ = p;
  }
  return _impl_.telemetry_;
}
inline ::google::monitoring::v3::Service_Telemetry* Service::mutable_telemetry() {
  ::google::monitoring::v3::Service_Telemetry* _msg = _internal_mutable_telemetry();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.Service.telemetry)
  return _msg;
}
inline void Service::set_allocated_telemetry(::google::monitoring::v3::Service_Telemetry* telemetry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.telemetry_;
  }
  if (telemetry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(telemetry);
    if (message_arena != submessage_arena) {
      telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, telemetry, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.telemetry_ = telemetry;
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.Service.telemetry)
}

// map<string, string> user_labels = 14;
inline int Service::_internal_user_labels_size() const {
  return _impl_.user_labels_.size();
}
inline int Service::user_labels_size() const {
  return _internal_user_labels_size();
}
inline void Service::clear_user_labels() {
  _impl_.user_labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Service::_internal_user_labels() const {
  return _impl_.user_labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Service::user_labels() const {
  // @@protoc_insertion_point(field_map:google.monitoring.v3.Service.user_labels)
  return _internal_user_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Service::_internal_mutable_user_labels() {
  return _impl_.user_labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Service::mutable_user_labels() {
  // @@protoc_insertion_point(field_mutable_map:google.monitoring.v3.Service.user_labels)
  return _internal_mutable_user_labels();
}

inline bool Service::has_identifier() const {
  return identifier_case() != IDENTIFIER_NOT_SET;
}
inline void Service::clear_has_identifier() {
  _impl_._oneof_case_[0] = IDENTIFIER_NOT_SET;
}
inline Service::IdentifierCase Service::identifier_case() const {
  return Service::IdentifierCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ServiceLevelObjective

// string name = 1;
inline void ServiceLevelObjective::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ServiceLevelObjective::name() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.ServiceLevelObjective.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceLevelObjective::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.ServiceLevelObjective.name)
}
inline std::string* ServiceLevelObjective::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.ServiceLevelObjective.name)
  return _s;
}
inline const std::string& ServiceLevelObjective::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ServiceLevelObjective::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceLevelObjective::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceLevelObjective::release_name() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.ServiceLevelObjective.name)
  return _impl_.name_.Release();
}
inline void ServiceLevelObjective::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.ServiceLevelObjective.name)
}

// string display_name = 11;
inline void ServiceLevelObjective::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& ServiceLevelObjective::display_name() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.ServiceLevelObjective.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceLevelObjective::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.ServiceLevelObjective.display_name)
}
inline std::string* ServiceLevelObjective::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.ServiceLevelObjective.display_name)
  return _s;
}
inline const std::string& ServiceLevelObjective::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void ServiceLevelObjective::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceLevelObjective::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceLevelObjective::release_display_name() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.ServiceLevelObjective.display_name)
  return _impl_.display_name_.Release();
}
inline void ServiceLevelObjective::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.ServiceLevelObjective.display_name)
}

// .google.monitoring.v3.ServiceLevelIndicator service_level_indicator = 3;
inline bool ServiceLevelObjective::_internal_has_service_level_indicator() const {
  return this != internal_default_instance() && _impl_.service_level_indicator_ != nullptr;
}
inline bool ServiceLevelObjective::has_service_level_indicator() const {
  return _internal_has_service_level_indicator();
}
inline void ServiceLevelObjective::clear_service_level_indicator() {
  if (GetArenaForAllocation() == nullptr && _impl_.service_level_indicator_ != nullptr) {
    delete _impl_.service_level_indicator_;
  }
  _impl_.service_level_indicator_ = nullptr;
}
inline const ::google::monitoring::v3::ServiceLevelIndicator& ServiceLevelObjective::_internal_service_level_indicator() const {
  const ::google::monitoring::v3::ServiceLevelIndicator* p = _impl_.service_level_indicator_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::monitoring::v3::ServiceLevelIndicator&>(
      ::google::monitoring::v3::_ServiceLevelIndicator_default_instance_);
}
inline const ::google::monitoring::v3::ServiceLevelIndicator& ServiceLevelObjective::service_level_indicator() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.ServiceLevelObjective.service_level_indicator)
  return _internal_service_level_indicator();
}
inline void ServiceLevelObjective::unsafe_arena_set_allocated_service_level_indicator(
    ::google::monitoring::v3::ServiceLevelIndicator* service_level_indicator) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_level_indicator_);
  }
  _impl_.service_level_indicator_ = service_level_indicator;
  if (service_level_indicator) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.ServiceLevelObjective.service_level_indicator)
}
inline ::google::monitoring::v3::ServiceLevelIndicator* ServiceLevelObjective::release_service_level_indicator() {
  
  ::google::monitoring::v3::ServiceLevelIndicator* temp = _impl_.service_level_indicator_;
  _impl_.service_level_indicator_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::monitoring::v3::ServiceLevelIndicator* ServiceLevelObjective::unsafe_arena_release_service_level_indicator() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.ServiceLevelObjective.service_level_indicator)
  
  ::google::monitoring::v3::ServiceLevelIndicator* temp = _impl_.service_level_indicator_;
  _impl_.service_level_indicator_ = nullptr;
  return temp;
}
inline ::google::monitoring::v3::ServiceLevelIndicator* ServiceLevelObjective::_internal_mutable_service_level_indicator() {
  
  if (_impl_.service_level_indicator_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::monitoring::v3::ServiceLevelIndicator>(GetArenaForAllocation());
    _impl_.service_level_indicator_ = p;
  }
  return _impl_.service_level_indicator_;
}
inline ::google::monitoring::v3::ServiceLevelIndicator* ServiceLevelObjective::mutable_service_level_indicator() {
  ::google::monitoring::v3::ServiceLevelIndicator* _msg = _internal_mutable_service_level_indicator();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.ServiceLevelObjective.service_level_indicator)
  return _msg;
}
inline void ServiceLevelObjective::set_allocated_service_level_indicator(::google::monitoring::v3::ServiceLevelIndicator* service_level_indicator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.service_level_indicator_;
  }
  if (service_level_indicator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(service_level_indicator);
    if (message_arena != submessage_arena) {
      service_level_indicator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_level_indicator, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.service_level_indicator_ = service_level_indicator;
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.ServiceLevelObjective.service_level_indicator)
}

// double goal = 4;
inline void ServiceLevelObjective::clear_goal() {
  _impl_.goal_ = 0;
}
inline double ServiceLevelObjective::_internal_goal() const {
  return _impl_.goal_;
}
inline double ServiceLevelObjective::goal() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.ServiceLevelObjective.goal)
  return _internal_goal();
}
inline void ServiceLevelObjective::_internal_set_goal(double value) {
  
  _impl_.goal_ = value;
}
inline void ServiceLevelObjective::set_goal(double value) {
  _internal_set_goal(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.ServiceLevelObjective.goal)
}

// .google.protobuf.Duration rolling_period = 5;
inline bool ServiceLevelObjective::_internal_has_rolling_period() const {
  return period_case() == kRollingPeriod;
}
inline bool ServiceLevelObjective::has_rolling_period() const {
  return _internal_has_rolling_period();
}
inline void ServiceLevelObjective::set_has_rolling_period() {
  _impl_._oneof_case_[0] = kRollingPeriod;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ServiceLevelObjective::release_rolling_period() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.ServiceLevelObjective.rolling_period)
  if (_internal_has_rolling_period()) {
    clear_has_period();
    ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.period_.rolling_period_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.period_.rolling_period_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ServiceLevelObjective::_internal_rolling_period() const {
  return _internal_has_rolling_period()
      ? *_impl_.period_.rolling_period_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Duration&>(::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ServiceLevelObjective::rolling_period() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.ServiceLevelObjective.rolling_period)
  return _internal_rolling_period();
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ServiceLevelObjective::unsafe_arena_release_rolling_period() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.ServiceLevelObjective.rolling_period)
  if (_internal_has_rolling_period()) {
    clear_has_period();
    ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.period_.rolling_period_;
    _impl_.period_.rolling_period_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServiceLevelObjective::unsafe_arena_set_allocated_rolling_period(::PROTOBUF_NAMESPACE_ID::Duration* rolling_period) {
  clear_period();
  if (rolling_period) {
    set_has_rolling_period();
    _impl_.period_.rolling_period_ = rolling_period;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.ServiceLevelObjective.rolling_period)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ServiceLevelObjective::_internal_mutable_rolling_period() {
  if (!_internal_has_rolling_period()) {
    clear_period();
    set_has_rolling_period();
    _impl_.period_.rolling_period_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Duration >(GetArenaForAllocation());
  }
  return _impl_.period_.rolling_period_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ServiceLevelObjective::mutable_rolling_period() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_rolling_period();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.ServiceLevelObjective.rolling_period)
  return _msg;
}

// .google.type.CalendarPeriod calendar_period = 6;
inline bool ServiceLevelObjective::_internal_has_calendar_period() const {
  return period_case() == kCalendarPeriod;
}
inline bool ServiceLevelObjective::has_calendar_period() const {
  return _internal_has_calendar_period();
}
inline void ServiceLevelObjective::set_has_calendar_period() {
  _impl_._oneof_case_[0] = kCalendarPeriod;
}
inline void ServiceLevelObjective::clear_calendar_period() {
  if (_internal_has_calendar_period()) {
    _impl_.period_.calendar_period_ = 0;
    clear_has_period();
  }
}
inline ::google::type::CalendarPeriod ServiceLevelObjective::_internal_calendar_period() const {
  if (_internal_has_calendar_period()) {
    return static_cast< ::google::type::CalendarPeriod >(_impl_.period_.calendar_period_);
  }
  return static_cast< ::google::type::CalendarPeriod >(0);
}
inline ::google::type::CalendarPeriod ServiceLevelObjective::calendar_period() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.ServiceLevelObjective.calendar_period)
  return _internal_calendar_period();
}
inline void ServiceLevelObjective::_internal_set_calendar_period(::google::type::CalendarPeriod value) {
  if (!_internal_has_calendar_period()) {
    clear_period();
    set_has_calendar_period();
  }
  _impl_.period_.calendar_period_ = value;
}
inline void ServiceLevelObjective::set_calendar_period(::google::type::CalendarPeriod value) {
  _internal_set_calendar_period(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.ServiceLevelObjective.calendar_period)
}

// map<string, string> user_labels = 12;
inline int ServiceLevelObjective::_internal_user_labels_size() const {
  return _impl_.user_labels_.size();
}
inline int ServiceLevelObjective::user_labels_size() const {
  return _internal_user_labels_size();
}
inline void ServiceLevelObjective::clear_user_labels() {
  _impl_.user_labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ServiceLevelObjective::_internal_user_labels() const {
  return _impl_.user_labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ServiceLevelObjective::user_labels() const {
  // @@protoc_insertion_point(field_map:google.monitoring.v3.ServiceLevelObjective.user_labels)
  return _internal_user_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ServiceLevelObjective::_internal_mutable_user_labels() {
  return _impl_.user_labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ServiceLevelObjective::mutable_user_labels() {
  // @@protoc_insertion_point(field_mutable_map:google.monitoring.v3.ServiceLevelObjective.user_labels)
  return _internal_mutable_user_labels();
}

inline bool ServiceLevelObjective::has_period() const {
  return period_case() != PERIOD_NOT_SET;
}
inline void ServiceLevelObjective::clear_has_period() {
  _impl_._oneof_case_[0] = PERIOD_NOT_SET;
}
inline ServiceLevelObjective::PeriodCase ServiceLevelObjective::period_case() const {
  return ServiceLevelObjective::PeriodCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServiceLevelIndicator

// .google.monitoring.v3.BasicSli basic_sli = 4;
inline bool ServiceLevelIndicator::_internal_has_basic_sli() const {
  return type_case() == kBasicSli;
}
inline bool ServiceLevelIndicator::has_basic_sli() const {
  return _internal_has_basic_sli();
}
inline void ServiceLevelIndicator::set_has_basic_sli() {
  _impl_._oneof_case_[0] = kBasicSli;
}
inline void ServiceLevelIndicator::clear_basic_sli() {
  if (_internal_has_basic_sli()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.basic_sli_;
    }
    clear_has_type();
  }
}
inline ::google::monitoring::v3::BasicSli* ServiceLevelIndicator::release_basic_sli() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.ServiceLevelIndicator.basic_sli)
  if (_internal_has_basic_sli()) {
    clear_has_type();
    ::google::monitoring::v3::BasicSli* temp = _impl_.type_.basic_sli_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.basic_sli_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::BasicSli& ServiceLevelIndicator::_internal_basic_sli() const {
  return _internal_has_basic_sli()
      ? *_impl_.type_.basic_sli_
      : reinterpret_cast< ::google::monitoring::v3::BasicSli&>(::google::monitoring::v3::_BasicSli_default_instance_);
}
inline const ::google::monitoring::v3::BasicSli& ServiceLevelIndicator::basic_sli() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.ServiceLevelIndicator.basic_sli)
  return _internal_basic_sli();
}
inline ::google::monitoring::v3::BasicSli* ServiceLevelIndicator::unsafe_arena_release_basic_sli() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.ServiceLevelIndicator.basic_sli)
  if (_internal_has_basic_sli()) {
    clear_has_type();
    ::google::monitoring::v3::BasicSli* temp = _impl_.type_.basic_sli_;
    _impl_.type_.basic_sli_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServiceLevelIndicator::unsafe_arena_set_allocated_basic_sli(::google::monitoring::v3::BasicSli* basic_sli) {
  clear_type();
  if (basic_sli) {
    set_has_basic_sli();
    _impl_.type_.basic_sli_ = basic_sli;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.ServiceLevelIndicator.basic_sli)
}
inline ::google::monitoring::v3::BasicSli* ServiceLevelIndicator::_internal_mutable_basic_sli() {
  if (!_internal_has_basic_sli()) {
    clear_type();
    set_has_basic_sli();
    _impl_.type_.basic_sli_ = CreateMaybeMessage< ::google::monitoring::v3::BasicSli >(GetArenaForAllocation());
  }
  return _impl_.type_.basic_sli_;
}
inline ::google::monitoring::v3::BasicSli* ServiceLevelIndicator::mutable_basic_sli() {
  ::google::monitoring::v3::BasicSli* _msg = _internal_mutable_basic_sli();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.ServiceLevelIndicator.basic_sli)
  return _msg;
}

// .google.monitoring.v3.RequestBasedSli request_based = 1;
inline bool ServiceLevelIndicator::_internal_has_request_based() const {
  return type_case() == kRequestBased;
}
inline bool ServiceLevelIndicator::has_request_based() const {
  return _internal_has_request_based();
}
inline void ServiceLevelIndicator::set_has_request_based() {
  _impl_._oneof_case_[0] = kRequestBased;
}
inline void ServiceLevelIndicator::clear_request_based() {
  if (_internal_has_request_based()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.request_based_;
    }
    clear_has_type();
  }
}
inline ::google::monitoring::v3::RequestBasedSli* ServiceLevelIndicator::release_request_based() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.ServiceLevelIndicator.request_based)
  if (_internal_has_request_based()) {
    clear_has_type();
    ::google::monitoring::v3::RequestBasedSli* temp = _impl_.type_.request_based_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.request_based_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::RequestBasedSli& ServiceLevelIndicator::_internal_request_based() const {
  return _internal_has_request_based()
      ? *_impl_.type_.request_based_
      : reinterpret_cast< ::google::monitoring::v3::RequestBasedSli&>(::google::monitoring::v3::_RequestBasedSli_default_instance_);
}
inline const ::google::monitoring::v3::RequestBasedSli& ServiceLevelIndicator::request_based() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.ServiceLevelIndicator.request_based)
  return _internal_request_based();
}
inline ::google::monitoring::v3::RequestBasedSli* ServiceLevelIndicator::unsafe_arena_release_request_based() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.ServiceLevelIndicator.request_based)
  if (_internal_has_request_based()) {
    clear_has_type();
    ::google::monitoring::v3::RequestBasedSli* temp = _impl_.type_.request_based_;
    _impl_.type_.request_based_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServiceLevelIndicator::unsafe_arena_set_allocated_request_based(::google::monitoring::v3::RequestBasedSli* request_based) {
  clear_type();
  if (request_based) {
    set_has_request_based();
    _impl_.type_.request_based_ = request_based;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.ServiceLevelIndicator.request_based)
}
inline ::google::monitoring::v3::RequestBasedSli* ServiceLevelIndicator::_internal_mutable_request_based() {
  if (!_internal_has_request_based()) {
    clear_type();
    set_has_request_based();
    _impl_.type_.request_based_ = CreateMaybeMessage< ::google::monitoring::v3::RequestBasedSli >(GetArenaForAllocation());
  }
  return _impl_.type_.request_based_;
}
inline ::google::monitoring::v3::RequestBasedSli* ServiceLevelIndicator::mutable_request_based() {
  ::google::monitoring::v3::RequestBasedSli* _msg = _internal_mutable_request_based();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.ServiceLevelIndicator.request_based)
  return _msg;
}

// .google.monitoring.v3.WindowsBasedSli windows_based = 2;
inline bool ServiceLevelIndicator::_internal_has_windows_based() const {
  return type_case() == kWindowsBased;
}
inline bool ServiceLevelIndicator::has_windows_based() const {
  return _internal_has_windows_based();
}
inline void ServiceLevelIndicator::set_has_windows_based() {
  _impl_._oneof_case_[0] = kWindowsBased;
}
inline void ServiceLevelIndicator::clear_windows_based() {
  if (_internal_has_windows_based()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.windows_based_;
    }
    clear_has_type();
  }
}
inline ::google::monitoring::v3::WindowsBasedSli* ServiceLevelIndicator::release_windows_based() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.ServiceLevelIndicator.windows_based)
  if (_internal_has_windows_based()) {
    clear_has_type();
    ::google::monitoring::v3::WindowsBasedSli* temp = _impl_.type_.windows_based_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.windows_based_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::WindowsBasedSli& ServiceLevelIndicator::_internal_windows_based() const {
  return _internal_has_windows_based()
      ? *_impl_.type_.windows_based_
      : reinterpret_cast< ::google::monitoring::v3::WindowsBasedSli&>(::google::monitoring::v3::_WindowsBasedSli_default_instance_);
}
inline const ::google::monitoring::v3::WindowsBasedSli& ServiceLevelIndicator::windows_based() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.ServiceLevelIndicator.windows_based)
  return _internal_windows_based();
}
inline ::google::monitoring::v3::WindowsBasedSli* ServiceLevelIndicator::unsafe_arena_release_windows_based() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.ServiceLevelIndicator.windows_based)
  if (_internal_has_windows_based()) {
    clear_has_type();
    ::google::monitoring::v3::WindowsBasedSli* temp = _impl_.type_.windows_based_;
    _impl_.type_.windows_based_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServiceLevelIndicator::unsafe_arena_set_allocated_windows_based(::google::monitoring::v3::WindowsBasedSli* windows_based) {
  clear_type();
  if (windows_based) {
    set_has_windows_based();
    _impl_.type_.windows_based_ = windows_based;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.ServiceLevelIndicator.windows_based)
}
inline ::google::monitoring::v3::WindowsBasedSli* ServiceLevelIndicator::_internal_mutable_windows_based() {
  if (!_internal_has_windows_based()) {
    clear_type();
    set_has_windows_based();
    _impl_.type_.windows_based_ = CreateMaybeMessage< ::google::monitoring::v3::WindowsBasedSli >(GetArenaForAllocation());
  }
  return _impl_.type_.windows_based_;
}
inline ::google::monitoring::v3::WindowsBasedSli* ServiceLevelIndicator::mutable_windows_based() {
  ::google::monitoring::v3::WindowsBasedSli* _msg = _internal_mutable_windows_based();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.ServiceLevelIndicator.windows_based)
  return _msg;
}

inline bool ServiceLevelIndicator::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void ServiceLevelIndicator::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline ServiceLevelIndicator::TypeCase ServiceLevelIndicator::type_case() const {
  return ServiceLevelIndicator::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BasicSli_AvailabilityCriteria

// -------------------------------------------------------------------

// BasicSli_LatencyCriteria

// .google.protobuf.Duration threshold = 3;
inline bool BasicSli_LatencyCriteria::_internal_has_threshold() const {
  return this != internal_default_instance() && _impl_.threshold_ != nullptr;
}
inline bool BasicSli_LatencyCriteria::has_threshold() const {
  return _internal_has_threshold();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& BasicSli_LatencyCriteria::_internal_threshold() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.threshold_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& BasicSli_LatencyCriteria::threshold() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.BasicSli.LatencyCriteria.threshold)
  return _internal_threshold();
}
inline void BasicSli_LatencyCriteria::unsafe_arena_set_allocated_threshold(
    ::PROTOBUF_NAMESPACE_ID::Duration* threshold) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.threshold_);
  }
  _impl_.threshold_ = threshold;
  if (threshold) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.BasicSli.LatencyCriteria.threshold)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* BasicSli_LatencyCriteria::release_threshold() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.threshold_;
  _impl_.threshold_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* BasicSli_LatencyCriteria::unsafe_arena_release_threshold() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.BasicSli.LatencyCriteria.threshold)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.threshold_;
  _impl_.threshold_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* BasicSli_LatencyCriteria::_internal_mutable_threshold() {
  
  if (_impl_.threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.threshold_ = p;
  }
  return _impl_.threshold_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* BasicSli_LatencyCriteria::mutable_threshold() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_threshold();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.BasicSli.LatencyCriteria.threshold)
  return _msg;
}
inline void BasicSli_LatencyCriteria::set_allocated_threshold(::PROTOBUF_NAMESPACE_ID::Duration* threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.threshold_);
  }
  if (threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(threshold));
    if (message_arena != submessage_arena) {
      threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, threshold, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.threshold_ = threshold;
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.BasicSli.LatencyCriteria.threshold)
}

// -------------------------------------------------------------------

// BasicSli

// repeated string method = 7;
inline int BasicSli::_internal_method_size() const {
  return _impl_.method_.size();
}
inline int BasicSli::method_size() const {
  return _internal_method_size();
}
inline void BasicSli::clear_method() {
  _impl_.method_.Clear();
}
inline std::string* BasicSli::add_method() {
  std::string* _s = _internal_add_method();
  // @@protoc_insertion_point(field_add_mutable:google.monitoring.v3.BasicSli.method)
  return _s;
}
inline const std::string& BasicSli::_internal_method(int index) const {
  return _impl_.method_.Get(index);
}
inline const std::string& BasicSli::method(int index) const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.BasicSli.method)
  return _internal_method(index);
}
inline std::string* BasicSli::mutable_method(int index) {
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.BasicSli.method)
  return _impl_.method_.Mutable(index);
}
inline void BasicSli::set_method(int index, const std::string& value) {
  _impl_.method_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.BasicSli.method)
}
inline void BasicSli::set_method(int index, std::string&& value) {
  _impl_.method_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.monitoring.v3.BasicSli.method)
}
inline void BasicSli::set_method(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.method_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.monitoring.v3.BasicSli.method)
}
inline void BasicSli::set_method(int index, const char* value, size_t size) {
  _impl_.method_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.monitoring.v3.BasicSli.method)
}
inline std::string* BasicSli::_internal_add_method() {
  return _impl_.method_.Add();
}
inline void BasicSli::add_method(const std::string& value) {
  _impl_.method_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.monitoring.v3.BasicSli.method)
}
inline void BasicSli::add_method(std::string&& value) {
  _impl_.method_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.monitoring.v3.BasicSli.method)
}
inline void BasicSli::add_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.method_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.monitoring.v3.BasicSli.method)
}
inline void BasicSli::add_method(const char* value, size_t size) {
  _impl_.method_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.monitoring.v3.BasicSli.method)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BasicSli::method() const {
  // @@protoc_insertion_point(field_list:google.monitoring.v3.BasicSli.method)
  return _impl_.method_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BasicSli::mutable_method() {
  // @@protoc_insertion_point(field_mutable_list:google.monitoring.v3.BasicSli.method)
  return &_impl_.method_;
}

// repeated string location = 8;
inline int BasicSli::_internal_location_size() const {
  return _impl_.location_.size();
}
inline int BasicSli::location_size() const {
  return _internal_location_size();
}
inline void BasicSli::clear_location() {
  _impl_.location_.Clear();
}
inline std::string* BasicSli::add_location() {
  std::string* _s = _internal_add_location();
  // @@protoc_insertion_point(field_add_mutable:google.monitoring.v3.BasicSli.location)
  return _s;
}
inline const std::string& BasicSli::_internal_location(int index) const {
  return _impl_.location_.Get(index);
}
inline const std::string& BasicSli::location(int index) const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.BasicSli.location)
  return _internal_location(index);
}
inline std::string* BasicSli::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.BasicSli.location)
  return _impl_.location_.Mutable(index);
}
inline void BasicSli::set_location(int index, const std::string& value) {
  _impl_.location_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.BasicSli.location)
}
inline void BasicSli::set_location(int index, std::string&& value) {
  _impl_.location_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.monitoring.v3.BasicSli.location)
}
inline void BasicSli::set_location(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.location_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.monitoring.v3.BasicSli.location)
}
inline void BasicSli::set_location(int index, const char* value, size_t size) {
  _impl_.location_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.monitoring.v3.BasicSli.location)
}
inline std::string* BasicSli::_internal_add_location() {
  return _impl_.location_.Add();
}
inline void BasicSli::add_location(const std::string& value) {
  _impl_.location_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.monitoring.v3.BasicSli.location)
}
inline void BasicSli::add_location(std::string&& value) {
  _impl_.location_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.monitoring.v3.BasicSli.location)
}
inline void BasicSli::add_location(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.location_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.monitoring.v3.BasicSli.location)
}
inline void BasicSli::add_location(const char* value, size_t size) {
  _impl_.location_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.monitoring.v3.BasicSli.location)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BasicSli::location() const {
  // @@protoc_insertion_point(field_list:google.monitoring.v3.BasicSli.location)
  return _impl_.location_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BasicSli::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:google.monitoring.v3.BasicSli.location)
  return &_impl_.location_;
}

// repeated string version = 9;
inline int BasicSli::_internal_version_size() const {
  return _impl_.version_.size();
}
inline int BasicSli::version_size() const {
  return _internal_version_size();
}
inline void BasicSli::clear_version() {
  _impl_.version_.Clear();
}
inline std::string* BasicSli::add_version() {
  std::string* _s = _internal_add_version();
  // @@protoc_insertion_point(field_add_mutable:google.monitoring.v3.BasicSli.version)
  return _s;
}
inline const std::string& BasicSli::_internal_version(int index) const {
  return _impl_.version_.Get(index);
}
inline const std::string& BasicSli::version(int index) const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.BasicSli.version)
  return _internal_version(index);
}
inline std::string* BasicSli::mutable_version(int index) {
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.BasicSli.version)
  return _impl_.version_.Mutable(index);
}
inline void BasicSli::set_version(int index, const std::string& value) {
  _impl_.version_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.BasicSli.version)
}
inline void BasicSli::set_version(int index, std::string&& value) {
  _impl_.version_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.monitoring.v3.BasicSli.version)
}
inline void BasicSli::set_version(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.version_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.monitoring.v3.BasicSli.version)
}
inline void BasicSli::set_version(int index, const char* value, size_t size) {
  _impl_.version_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.monitoring.v3.BasicSli.version)
}
inline std::string* BasicSli::_internal_add_version() {
  return _impl_.version_.Add();
}
inline void BasicSli::add_version(const std::string& value) {
  _impl_.version_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.monitoring.v3.BasicSli.version)
}
inline void BasicSli::add_version(std::string&& value) {
  _impl_.version_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.monitoring.v3.BasicSli.version)
}
inline void BasicSli::add_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.version_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.monitoring.v3.BasicSli.version)
}
inline void BasicSli::add_version(const char* value, size_t size) {
  _impl_.version_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.monitoring.v3.BasicSli.version)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BasicSli::version() const {
  // @@protoc_insertion_point(field_list:google.monitoring.v3.BasicSli.version)
  return _impl_.version_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BasicSli::mutable_version() {
  // @@protoc_insertion_point(field_mutable_list:google.monitoring.v3.BasicSli.version)
  return &_impl_.version_;
}

// .google.monitoring.v3.BasicSli.AvailabilityCriteria availability = 2;
inline bool BasicSli::_internal_has_availability() const {
  return sli_criteria_case() == kAvailability;
}
inline bool BasicSli::has_availability() const {
  return _internal_has_availability();
}
inline void BasicSli::set_has_availability() {
  _impl_._oneof_case_[0] = kAvailability;
}
inline void BasicSli::clear_availability() {
  if (_internal_has_availability()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sli_criteria_.availability_;
    }
    clear_has_sli_criteria();
  }
}
inline ::google::monitoring::v3::BasicSli_AvailabilityCriteria* BasicSli::release_availability() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.BasicSli.availability)
  if (_internal_has_availability()) {
    clear_has_sli_criteria();
    ::google::monitoring::v3::BasicSli_AvailabilityCriteria* temp = _impl_.sli_criteria_.availability_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sli_criteria_.availability_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::BasicSli_AvailabilityCriteria& BasicSli::_internal_availability() const {
  return _internal_has_availability()
      ? *_impl_.sli_criteria_.availability_
      : reinterpret_cast< ::google::monitoring::v3::BasicSli_AvailabilityCriteria&>(::google::monitoring::v3::_BasicSli_AvailabilityCriteria_default_instance_);
}
inline const ::google::monitoring::v3::BasicSli_AvailabilityCriteria& BasicSli::availability() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.BasicSli.availability)
  return _internal_availability();
}
inline ::google::monitoring::v3::BasicSli_AvailabilityCriteria* BasicSli::unsafe_arena_release_availability() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.BasicSli.availability)
  if (_internal_has_availability()) {
    clear_has_sli_criteria();
    ::google::monitoring::v3::BasicSli_AvailabilityCriteria* temp = _impl_.sli_criteria_.availability_;
    _impl_.sli_criteria_.availability_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BasicSli::unsafe_arena_set_allocated_availability(::google::monitoring::v3::BasicSli_AvailabilityCriteria* availability) {
  clear_sli_criteria();
  if (availability) {
    set_has_availability();
    _impl_.sli_criteria_.availability_ = availability;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.BasicSli.availability)
}
inline ::google::monitoring::v3::BasicSli_AvailabilityCriteria* BasicSli::_internal_mutable_availability() {
  if (!_internal_has_availability()) {
    clear_sli_criteria();
    set_has_availability();
    _impl_.sli_criteria_.availability_ = CreateMaybeMessage< ::google::monitoring::v3::BasicSli_AvailabilityCriteria >(GetArenaForAllocation());
  }
  return _impl_.sli_criteria_.availability_;
}
inline ::google::monitoring::v3::BasicSli_AvailabilityCriteria* BasicSli::mutable_availability() {
  ::google::monitoring::v3::BasicSli_AvailabilityCriteria* _msg = _internal_mutable_availability();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.BasicSli.availability)
  return _msg;
}

// .google.monitoring.v3.BasicSli.LatencyCriteria latency = 3;
inline bool BasicSli::_internal_has_latency() const {
  return sli_criteria_case() == kLatency;
}
inline bool BasicSli::has_latency() const {
  return _internal_has_latency();
}
inline void BasicSli::set_has_latency() {
  _impl_._oneof_case_[0] = kLatency;
}
inline void BasicSli::clear_latency() {
  if (_internal_has_latency()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.sli_criteria_.latency_;
    }
    clear_has_sli_criteria();
  }
}
inline ::google::monitoring::v3::BasicSli_LatencyCriteria* BasicSli::release_latency() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.BasicSli.latency)
  if (_internal_has_latency()) {
    clear_has_sli_criteria();
    ::google::monitoring::v3::BasicSli_LatencyCriteria* temp = _impl_.sli_criteria_.latency_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.sli_criteria_.latency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::BasicSli_LatencyCriteria& BasicSli::_internal_latency() const {
  return _internal_has_latency()
      ? *_impl_.sli_criteria_.latency_
      : reinterpret_cast< ::google::monitoring::v3::BasicSli_LatencyCriteria&>(::google::monitoring::v3::_BasicSli_LatencyCriteria_default_instance_);
}
inline const ::google::monitoring::v3::BasicSli_LatencyCriteria& BasicSli::latency() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.BasicSli.latency)
  return _internal_latency();
}
inline ::google::monitoring::v3::BasicSli_LatencyCriteria* BasicSli::unsafe_arena_release_latency() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.BasicSli.latency)
  if (_internal_has_latency()) {
    clear_has_sli_criteria();
    ::google::monitoring::v3::BasicSli_LatencyCriteria* temp = _impl_.sli_criteria_.latency_;
    _impl_.sli_criteria_.latency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BasicSli::unsafe_arena_set_allocated_latency(::google::monitoring::v3::BasicSli_LatencyCriteria* latency) {
  clear_sli_criteria();
  if (latency) {
    set_has_latency();
    _impl_.sli_criteria_.latency_ = latency;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.BasicSli.latency)
}
inline ::google::monitoring::v3::BasicSli_LatencyCriteria* BasicSli::_internal_mutable_latency() {
  if (!_internal_has_latency()) {
    clear_sli_criteria();
    set_has_latency();
    _impl_.sli_criteria_.latency_ = CreateMaybeMessage< ::google::monitoring::v3::BasicSli_LatencyCriteria >(GetArenaForAllocation());
  }
  return _impl_.sli_criteria_.latency_;
}
inline ::google::monitoring::v3::BasicSli_LatencyCriteria* BasicSli::mutable_latency() {
  ::google::monitoring::v3::BasicSli_LatencyCriteria* _msg = _internal_mutable_latency();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.BasicSli.latency)
  return _msg;
}

inline bool BasicSli::has_sli_criteria() const {
  return sli_criteria_case() != SLI_CRITERIA_NOT_SET;
}
inline void BasicSli::clear_has_sli_criteria() {
  _impl_._oneof_case_[0] = SLI_CRITERIA_NOT_SET;
}
inline BasicSli::SliCriteriaCase BasicSli::sli_criteria_case() const {
  return BasicSli::SliCriteriaCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Range

// double min = 1;
inline void Range::clear_min() {
  _impl_.min_ = 0;
}
inline double Range::_internal_min() const {
  return _impl_.min_;
}
inline double Range::min() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Range.min)
  return _internal_min();
}
inline void Range::_internal_set_min(double value) {
  
  _impl_.min_ = value;
}
inline void Range::set_min(double value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Range.min)
}

// double max = 2;
inline void Range::clear_max() {
  _impl_.max_ = 0;
}
inline double Range::_internal_max() const {
  return _impl_.max_;
}
inline double Range::max() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.Range.max)
  return _internal_max();
}
inline void Range::_internal_set_max(double value) {
  
  _impl_.max_ = value;
}
inline void Range::set_max(double value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.Range.max)
}

// -------------------------------------------------------------------

// RequestBasedSli

// .google.monitoring.v3.TimeSeriesRatio good_total_ratio = 1;
inline bool RequestBasedSli::_internal_has_good_total_ratio() const {
  return method_case() == kGoodTotalRatio;
}
inline bool RequestBasedSli::has_good_total_ratio() const {
  return _internal_has_good_total_ratio();
}
inline void RequestBasedSli::set_has_good_total_ratio() {
  _impl_._oneof_case_[0] = kGoodTotalRatio;
}
inline void RequestBasedSli::clear_good_total_ratio() {
  if (_internal_has_good_total_ratio()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.method_.good_total_ratio_;
    }
    clear_has_method();
  }
}
inline ::google::monitoring::v3::TimeSeriesRatio* RequestBasedSli::release_good_total_ratio() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.RequestBasedSli.good_total_ratio)
  if (_internal_has_good_total_ratio()) {
    clear_has_method();
    ::google::monitoring::v3::TimeSeriesRatio* temp = _impl_.method_.good_total_ratio_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_.good_total_ratio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::TimeSeriesRatio& RequestBasedSli::_internal_good_total_ratio() const {
  return _internal_has_good_total_ratio()
      ? *_impl_.method_.good_total_ratio_
      : reinterpret_cast< ::google::monitoring::v3::TimeSeriesRatio&>(::google::monitoring::v3::_TimeSeriesRatio_default_instance_);
}
inline const ::google::monitoring::v3::TimeSeriesRatio& RequestBasedSli::good_total_ratio() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.RequestBasedSli.good_total_ratio)
  return _internal_good_total_ratio();
}
inline ::google::monitoring::v3::TimeSeriesRatio* RequestBasedSli::unsafe_arena_release_good_total_ratio() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.RequestBasedSli.good_total_ratio)
  if (_internal_has_good_total_ratio()) {
    clear_has_method();
    ::google::monitoring::v3::TimeSeriesRatio* temp = _impl_.method_.good_total_ratio_;
    _impl_.method_.good_total_ratio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RequestBasedSli::unsafe_arena_set_allocated_good_total_ratio(::google::monitoring::v3::TimeSeriesRatio* good_total_ratio) {
  clear_method();
  if (good_total_ratio) {
    set_has_good_total_ratio();
    _impl_.method_.good_total_ratio_ = good_total_ratio;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.RequestBasedSli.good_total_ratio)
}
inline ::google::monitoring::v3::TimeSeriesRatio* RequestBasedSli::_internal_mutable_good_total_ratio() {
  if (!_internal_has_good_total_ratio()) {
    clear_method();
    set_has_good_total_ratio();
    _impl_.method_.good_total_ratio_ = CreateMaybeMessage< ::google::monitoring::v3::TimeSeriesRatio >(GetArenaForAllocation());
  }
  return _impl_.method_.good_total_ratio_;
}
inline ::google::monitoring::v3::TimeSeriesRatio* RequestBasedSli::mutable_good_total_ratio() {
  ::google::monitoring::v3::TimeSeriesRatio* _msg = _internal_mutable_good_total_ratio();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.RequestBasedSli.good_total_ratio)
  return _msg;
}

// .google.monitoring.v3.DistributionCut distribution_cut = 3;
inline bool RequestBasedSli::_internal_has_distribution_cut() const {
  return method_case() == kDistributionCut;
}
inline bool RequestBasedSli::has_distribution_cut() const {
  return _internal_has_distribution_cut();
}
inline void RequestBasedSli::set_has_distribution_cut() {
  _impl_._oneof_case_[0] = kDistributionCut;
}
inline void RequestBasedSli::clear_distribution_cut() {
  if (_internal_has_distribution_cut()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.method_.distribution_cut_;
    }
    clear_has_method();
  }
}
inline ::google::monitoring::v3::DistributionCut* RequestBasedSli::release_distribution_cut() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.RequestBasedSli.distribution_cut)
  if (_internal_has_distribution_cut()) {
    clear_has_method();
    ::google::monitoring::v3::DistributionCut* temp = _impl_.method_.distribution_cut_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_.distribution_cut_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::DistributionCut& RequestBasedSli::_internal_distribution_cut() const {
  return _internal_has_distribution_cut()
      ? *_impl_.method_.distribution_cut_
      : reinterpret_cast< ::google::monitoring::v3::DistributionCut&>(::google::monitoring::v3::_DistributionCut_default_instance_);
}
inline const ::google::monitoring::v3::DistributionCut& RequestBasedSli::distribution_cut() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.RequestBasedSli.distribution_cut)
  return _internal_distribution_cut();
}
inline ::google::monitoring::v3::DistributionCut* RequestBasedSli::unsafe_arena_release_distribution_cut() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.RequestBasedSli.distribution_cut)
  if (_internal_has_distribution_cut()) {
    clear_has_method();
    ::google::monitoring::v3::DistributionCut* temp = _impl_.method_.distribution_cut_;
    _impl_.method_.distribution_cut_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RequestBasedSli::unsafe_arena_set_allocated_distribution_cut(::google::monitoring::v3::DistributionCut* distribution_cut) {
  clear_method();
  if (distribution_cut) {
    set_has_distribution_cut();
    _impl_.method_.distribution_cut_ = distribution_cut;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.RequestBasedSli.distribution_cut)
}
inline ::google::monitoring::v3::DistributionCut* RequestBasedSli::_internal_mutable_distribution_cut() {
  if (!_internal_has_distribution_cut()) {
    clear_method();
    set_has_distribution_cut();
    _impl_.method_.distribution_cut_ = CreateMaybeMessage< ::google::monitoring::v3::DistributionCut >(GetArenaForAllocation());
  }
  return _impl_.method_.distribution_cut_;
}
inline ::google::monitoring::v3::DistributionCut* RequestBasedSli::mutable_distribution_cut() {
  ::google::monitoring::v3::DistributionCut* _msg = _internal_mutable_distribution_cut();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.RequestBasedSli.distribution_cut)
  return _msg;
}

inline bool RequestBasedSli::has_method() const {
  return method_case() != METHOD_NOT_SET;
}
inline void RequestBasedSli::clear_has_method() {
  _impl_._oneof_case_[0] = METHOD_NOT_SET;
}
inline RequestBasedSli::MethodCase RequestBasedSli::method_case() const {
  return RequestBasedSli::MethodCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TimeSeriesRatio

// string good_service_filter = 4;
inline void TimeSeriesRatio::clear_good_service_filter() {
  _impl_.good_service_filter_.ClearToEmpty();
}
inline const std::string& TimeSeriesRatio::good_service_filter() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.TimeSeriesRatio.good_service_filter)
  return _internal_good_service_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TimeSeriesRatio::set_good_service_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.good_service_filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.TimeSeriesRatio.good_service_filter)
}
inline std::string* TimeSeriesRatio::mutable_good_service_filter() {
  std::string* _s = _internal_mutable_good_service_filter();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.TimeSeriesRatio.good_service_filter)
  return _s;
}
inline const std::string& TimeSeriesRatio::_internal_good_service_filter() const {
  return _impl_.good_service_filter_.Get();
}
inline void TimeSeriesRatio::_internal_set_good_service_filter(const std::string& value) {
  
  _impl_.good_service_filter_.Set(value, GetArenaForAllocation());
}
inline std::string* TimeSeriesRatio::_internal_mutable_good_service_filter() {
  
  return _impl_.good_service_filter_.Mutable(GetArenaForAllocation());
}
inline std::string* TimeSeriesRatio::release_good_service_filter() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.TimeSeriesRatio.good_service_filter)
  return _impl_.good_service_filter_.Release();
}
inline void TimeSeriesRatio::set_allocated_good_service_filter(std::string* good_service_filter) {
  if (good_service_filter != nullptr) {
    
  } else {
    
  }
  _impl_.good_service_filter_.SetAllocated(good_service_filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.good_service_filter_.IsDefault()) {
    _impl_.good_service_filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.TimeSeriesRatio.good_service_filter)
}

// string bad_service_filter = 5;
inline void TimeSeriesRatio::clear_bad_service_filter() {
  _impl_.bad_service_filter_.ClearToEmpty();
}
inline const std::string& TimeSeriesRatio::bad_service_filter() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.TimeSeriesRatio.bad_service_filter)
  return _internal_bad_service_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TimeSeriesRatio::set_bad_service_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bad_service_filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.TimeSeriesRatio.bad_service_filter)
}
inline std::string* TimeSeriesRatio::mutable_bad_service_filter() {
  std::string* _s = _internal_mutable_bad_service_filter();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.TimeSeriesRatio.bad_service_filter)
  return _s;
}
inline const std::string& TimeSeriesRatio::_internal_bad_service_filter() const {
  return _impl_.bad_service_filter_.Get();
}
inline void TimeSeriesRatio::_internal_set_bad_service_filter(const std::string& value) {
  
  _impl_.bad_service_filter_.Set(value, GetArenaForAllocation());
}
inline std::string* TimeSeriesRatio::_internal_mutable_bad_service_filter() {
  
  return _impl_.bad_service_filter_.Mutable(GetArenaForAllocation());
}
inline std::string* TimeSeriesRatio::release_bad_service_filter() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.TimeSeriesRatio.bad_service_filter)
  return _impl_.bad_service_filter_.Release();
}
inline void TimeSeriesRatio::set_allocated_bad_service_filter(std::string* bad_service_filter) {
  if (bad_service_filter != nullptr) {
    
  } else {
    
  }
  _impl_.bad_service_filter_.SetAllocated(bad_service_filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bad_service_filter_.IsDefault()) {
    _impl_.bad_service_filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.TimeSeriesRatio.bad_service_filter)
}

// string total_service_filter = 6;
inline void TimeSeriesRatio::clear_total_service_filter() {
  _impl_.total_service_filter_.ClearToEmpty();
}
inline const std::string& TimeSeriesRatio::total_service_filter() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.TimeSeriesRatio.total_service_filter)
  return _internal_total_service_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TimeSeriesRatio::set_total_service_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.total_service_filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.TimeSeriesRatio.total_service_filter)
}
inline std::string* TimeSeriesRatio::mutable_total_service_filter() {
  std::string* _s = _internal_mutable_total_service_filter();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.TimeSeriesRatio.total_service_filter)
  return _s;
}
inline const std::string& TimeSeriesRatio::_internal_total_service_filter() const {
  return _impl_.total_service_filter_.Get();
}
inline void TimeSeriesRatio::_internal_set_total_service_filter(const std::string& value) {
  
  _impl_.total_service_filter_.Set(value, GetArenaForAllocation());
}
inline std::string* TimeSeriesRatio::_internal_mutable_total_service_filter() {
  
  return _impl_.total_service_filter_.Mutable(GetArenaForAllocation());
}
inline std::string* TimeSeriesRatio::release_total_service_filter() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.TimeSeriesRatio.total_service_filter)
  return _impl_.total_service_filter_.Release();
}
inline void TimeSeriesRatio::set_allocated_total_service_filter(std::string* total_service_filter) {
  if (total_service_filter != nullptr) {
    
  } else {
    
  }
  _impl_.total_service_filter_.SetAllocated(total_service_filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.total_service_filter_.IsDefault()) {
    _impl_.total_service_filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.TimeSeriesRatio.total_service_filter)
}

// -------------------------------------------------------------------

// DistributionCut

// string distribution_filter = 4;
inline void DistributionCut::clear_distribution_filter() {
  _impl_.distribution_filter_.ClearToEmpty();
}
inline const std::string& DistributionCut::distribution_filter() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.DistributionCut.distribution_filter)
  return _internal_distribution_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DistributionCut::set_distribution_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.distribution_filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.DistributionCut.distribution_filter)
}
inline std::string* DistributionCut::mutable_distribution_filter() {
  std::string* _s = _internal_mutable_distribution_filter();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.DistributionCut.distribution_filter)
  return _s;
}
inline const std::string& DistributionCut::_internal_distribution_filter() const {
  return _impl_.distribution_filter_.Get();
}
inline void DistributionCut::_internal_set_distribution_filter(const std::string& value) {
  
  _impl_.distribution_filter_.Set(value, GetArenaForAllocation());
}
inline std::string* DistributionCut::_internal_mutable_distribution_filter() {
  
  return _impl_.distribution_filter_.Mutable(GetArenaForAllocation());
}
inline std::string* DistributionCut::release_distribution_filter() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.DistributionCut.distribution_filter)
  return _impl_.distribution_filter_.Release();
}
inline void DistributionCut::set_allocated_distribution_filter(std::string* distribution_filter) {
  if (distribution_filter != nullptr) {
    
  } else {
    
  }
  _impl_.distribution_filter_.SetAllocated(distribution_filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.distribution_filter_.IsDefault()) {
    _impl_.distribution_filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.DistributionCut.distribution_filter)
}

// .google.monitoring.v3.Range range = 5;
inline bool DistributionCut::_internal_has_range() const {
  return this != internal_default_instance() && _impl_.range_ != nullptr;
}
inline bool DistributionCut::has_range() const {
  return _internal_has_range();
}
inline void DistributionCut::clear_range() {
  if (GetArenaForAllocation() == nullptr && _impl_.range_ != nullptr) {
    delete _impl_.range_;
  }
  _impl_.range_ = nullptr;
}
inline const ::google::monitoring::v3::Range& DistributionCut::_internal_range() const {
  const ::google::monitoring::v3::Range* p = _impl_.range_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::monitoring::v3::Range&>(
      ::google::monitoring::v3::_Range_default_instance_);
}
inline const ::google::monitoring::v3::Range& DistributionCut::range() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.DistributionCut.range)
  return _internal_range();
}
inline void DistributionCut::unsafe_arena_set_allocated_range(
    ::google::monitoring::v3::Range* range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.range_);
  }
  _impl_.range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.DistributionCut.range)
}
inline ::google::monitoring::v3::Range* DistributionCut::release_range() {
  
  ::google::monitoring::v3::Range* temp = _impl_.range_;
  _impl_.range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::monitoring::v3::Range* DistributionCut::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.DistributionCut.range)
  
  ::google::monitoring::v3::Range* temp = _impl_.range_;
  _impl_.range_ = nullptr;
  return temp;
}
inline ::google::monitoring::v3::Range* DistributionCut::_internal_mutable_range() {
  
  if (_impl_.range_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::monitoring::v3::Range>(GetArenaForAllocation());
    _impl_.range_ = p;
  }
  return _impl_.range_;
}
inline ::google::monitoring::v3::Range* DistributionCut::mutable_range() {
  ::google::monitoring::v3::Range* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.DistributionCut.range)
  return _msg;
}
inline void DistributionCut::set_allocated_range(::google::monitoring::v3::Range* range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.range_;
  }
  if (range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(range);
    if (message_arena != submessage_arena) {
      range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.range_ = range;
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.DistributionCut.range)
}

// -------------------------------------------------------------------

// WindowsBasedSli_PerformanceThreshold

// .google.monitoring.v3.RequestBasedSli performance = 1;
inline bool WindowsBasedSli_PerformanceThreshold::_internal_has_performance() const {
  return type_case() == kPerformance;
}
inline bool WindowsBasedSli_PerformanceThreshold::has_performance() const {
  return _internal_has_performance();
}
inline void WindowsBasedSli_PerformanceThreshold::set_has_performance() {
  _impl_._oneof_case_[0] = kPerformance;
}
inline void WindowsBasedSli_PerformanceThreshold::clear_performance() {
  if (_internal_has_performance()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.performance_;
    }
    clear_has_type();
  }
}
inline ::google::monitoring::v3::RequestBasedSli* WindowsBasedSli_PerformanceThreshold::release_performance() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.WindowsBasedSli.PerformanceThreshold.performance)
  if (_internal_has_performance()) {
    clear_has_type();
    ::google::monitoring::v3::RequestBasedSli* temp = _impl_.type_.performance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.performance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::RequestBasedSli& WindowsBasedSli_PerformanceThreshold::_internal_performance() const {
  return _internal_has_performance()
      ? *_impl_.type_.performance_
      : reinterpret_cast< ::google::monitoring::v3::RequestBasedSli&>(::google::monitoring::v3::_RequestBasedSli_default_instance_);
}
inline const ::google::monitoring::v3::RequestBasedSli& WindowsBasedSli_PerformanceThreshold::performance() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.WindowsBasedSli.PerformanceThreshold.performance)
  return _internal_performance();
}
inline ::google::monitoring::v3::RequestBasedSli* WindowsBasedSli_PerformanceThreshold::unsafe_arena_release_performance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.WindowsBasedSli.PerformanceThreshold.performance)
  if (_internal_has_performance()) {
    clear_has_type();
    ::google::monitoring::v3::RequestBasedSli* temp = _impl_.type_.performance_;
    _impl_.type_.performance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WindowsBasedSli_PerformanceThreshold::unsafe_arena_set_allocated_performance(::google::monitoring::v3::RequestBasedSli* performance) {
  clear_type();
  if (performance) {
    set_has_performance();
    _impl_.type_.performance_ = performance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.WindowsBasedSli.PerformanceThreshold.performance)
}
inline ::google::monitoring::v3::RequestBasedSli* WindowsBasedSli_PerformanceThreshold::_internal_mutable_performance() {
  if (!_internal_has_performance()) {
    clear_type();
    set_has_performance();
    _impl_.type_.performance_ = CreateMaybeMessage< ::google::monitoring::v3::RequestBasedSli >(GetArenaForAllocation());
  }
  return _impl_.type_.performance_;
}
inline ::google::monitoring::v3::RequestBasedSli* WindowsBasedSli_PerformanceThreshold::mutable_performance() {
  ::google::monitoring::v3::RequestBasedSli* _msg = _internal_mutable_performance();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.WindowsBasedSli.PerformanceThreshold.performance)
  return _msg;
}

// .google.monitoring.v3.BasicSli basic_sli_performance = 3;
inline bool WindowsBasedSli_PerformanceThreshold::_internal_has_basic_sli_performance() const {
  return type_case() == kBasicSliPerformance;
}
inline bool WindowsBasedSli_PerformanceThreshold::has_basic_sli_performance() const {
  return _internal_has_basic_sli_performance();
}
inline void WindowsBasedSli_PerformanceThreshold::set_has_basic_sli_performance() {
  _impl_._oneof_case_[0] = kBasicSliPerformance;
}
inline void WindowsBasedSli_PerformanceThreshold::clear_basic_sli_performance() {
  if (_internal_has_basic_sli_performance()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.basic_sli_performance_;
    }
    clear_has_type();
  }
}
inline ::google::monitoring::v3::BasicSli* WindowsBasedSli_PerformanceThreshold::release_basic_sli_performance() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.WindowsBasedSli.PerformanceThreshold.basic_sli_performance)
  if (_internal_has_basic_sli_performance()) {
    clear_has_type();
    ::google::monitoring::v3::BasicSli* temp = _impl_.type_.basic_sli_performance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.basic_sli_performance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::BasicSli& WindowsBasedSli_PerformanceThreshold::_internal_basic_sli_performance() const {
  return _internal_has_basic_sli_performance()
      ? *_impl_.type_.basic_sli_performance_
      : reinterpret_cast< ::google::monitoring::v3::BasicSli&>(::google::monitoring::v3::_BasicSli_default_instance_);
}
inline const ::google::monitoring::v3::BasicSli& WindowsBasedSli_PerformanceThreshold::basic_sli_performance() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.WindowsBasedSli.PerformanceThreshold.basic_sli_performance)
  return _internal_basic_sli_performance();
}
inline ::google::monitoring::v3::BasicSli* WindowsBasedSli_PerformanceThreshold::unsafe_arena_release_basic_sli_performance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.WindowsBasedSli.PerformanceThreshold.basic_sli_performance)
  if (_internal_has_basic_sli_performance()) {
    clear_has_type();
    ::google::monitoring::v3::BasicSli* temp = _impl_.type_.basic_sli_performance_;
    _impl_.type_.basic_sli_performance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WindowsBasedSli_PerformanceThreshold::unsafe_arena_set_allocated_basic_sli_performance(::google::monitoring::v3::BasicSli* basic_sli_performance) {
  clear_type();
  if (basic_sli_performance) {
    set_has_basic_sli_performance();
    _impl_.type_.basic_sli_performance_ = basic_sli_performance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.WindowsBasedSli.PerformanceThreshold.basic_sli_performance)
}
inline ::google::monitoring::v3::BasicSli* WindowsBasedSli_PerformanceThreshold::_internal_mutable_basic_sli_performance() {
  if (!_internal_has_basic_sli_performance()) {
    clear_type();
    set_has_basic_sli_performance();
    _impl_.type_.basic_sli_performance_ = CreateMaybeMessage< ::google::monitoring::v3::BasicSli >(GetArenaForAllocation());
  }
  return _impl_.type_.basic_sli_performance_;
}
inline ::google::monitoring::v3::BasicSli* WindowsBasedSli_PerformanceThreshold::mutable_basic_sli_performance() {
  ::google::monitoring::v3::BasicSli* _msg = _internal_mutable_basic_sli_performance();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.WindowsBasedSli.PerformanceThreshold.basic_sli_performance)
  return _msg;
}

// double threshold = 2;
inline void WindowsBasedSli_PerformanceThreshold::clear_threshold() {
  _impl_.threshold_ = 0;
}
inline double WindowsBasedSli_PerformanceThreshold::_internal_threshold() const {
  return _impl_.threshold_;
}
inline double WindowsBasedSli_PerformanceThreshold::threshold() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.WindowsBasedSli.PerformanceThreshold.threshold)
  return _internal_threshold();
}
inline void WindowsBasedSli_PerformanceThreshold::_internal_set_threshold(double value) {
  
  _impl_.threshold_ = value;
}
inline void WindowsBasedSli_PerformanceThreshold::set_threshold(double value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.WindowsBasedSli.PerformanceThreshold.threshold)
}

inline bool WindowsBasedSli_PerformanceThreshold::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void WindowsBasedSli_PerformanceThreshold::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline WindowsBasedSli_PerformanceThreshold::TypeCase WindowsBasedSli_PerformanceThreshold::type_case() const {
  return WindowsBasedSli_PerformanceThreshold::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// WindowsBasedSli_MetricRange

// string time_series = 1;
inline void WindowsBasedSli_MetricRange::clear_time_series() {
  _impl_.time_series_.ClearToEmpty();
}
inline const std::string& WindowsBasedSli_MetricRange::time_series() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.WindowsBasedSli.MetricRange.time_series)
  return _internal_time_series();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WindowsBasedSli_MetricRange::set_time_series(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_series_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.WindowsBasedSli.MetricRange.time_series)
}
inline std::string* WindowsBasedSli_MetricRange::mutable_time_series() {
  std::string* _s = _internal_mutable_time_series();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.WindowsBasedSli.MetricRange.time_series)
  return _s;
}
inline const std::string& WindowsBasedSli_MetricRange::_internal_time_series() const {
  return _impl_.time_series_.Get();
}
inline void WindowsBasedSli_MetricRange::_internal_set_time_series(const std::string& value) {
  
  _impl_.time_series_.Set(value, GetArenaForAllocation());
}
inline std::string* WindowsBasedSli_MetricRange::_internal_mutable_time_series() {
  
  return _impl_.time_series_.Mutable(GetArenaForAllocation());
}
inline std::string* WindowsBasedSli_MetricRange::release_time_series() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.WindowsBasedSli.MetricRange.time_series)
  return _impl_.time_series_.Release();
}
inline void WindowsBasedSli_MetricRange::set_allocated_time_series(std::string* time_series) {
  if (time_series != nullptr) {
    
  } else {
    
  }
  _impl_.time_series_.SetAllocated(time_series, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_series_.IsDefault()) {
    _impl_.time_series_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.WindowsBasedSli.MetricRange.time_series)
}

// .google.monitoring.v3.Range range = 4;
inline bool WindowsBasedSli_MetricRange::_internal_has_range() const {
  return this != internal_default_instance() && _impl_.range_ != nullptr;
}
inline bool WindowsBasedSli_MetricRange::has_range() const {
  return _internal_has_range();
}
inline void WindowsBasedSli_MetricRange::clear_range() {
  if (GetArenaForAllocation() == nullptr && _impl_.range_ != nullptr) {
    delete _impl_.range_;
  }
  _impl_.range_ = nullptr;
}
inline const ::google::monitoring::v3::Range& WindowsBasedSli_MetricRange::_internal_range() const {
  const ::google::monitoring::v3::Range* p = _impl_.range_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::monitoring::v3::Range&>(
      ::google::monitoring::v3::_Range_default_instance_);
}
inline const ::google::monitoring::v3::Range& WindowsBasedSli_MetricRange::range() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.WindowsBasedSli.MetricRange.range)
  return _internal_range();
}
inline void WindowsBasedSli_MetricRange::unsafe_arena_set_allocated_range(
    ::google::monitoring::v3::Range* range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.range_);
  }
  _impl_.range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.WindowsBasedSli.MetricRange.range)
}
inline ::google::monitoring::v3::Range* WindowsBasedSli_MetricRange::release_range() {
  
  ::google::monitoring::v3::Range* temp = _impl_.range_;
  _impl_.range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::monitoring::v3::Range* WindowsBasedSli_MetricRange::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.WindowsBasedSli.MetricRange.range)
  
  ::google::monitoring::v3::Range* temp = _impl_.range_;
  _impl_.range_ = nullptr;
  return temp;
}
inline ::google::monitoring::v3::Range* WindowsBasedSli_MetricRange::_internal_mutable_range() {
  
  if (_impl_.range_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::monitoring::v3::Range>(GetArenaForAllocation());
    _impl_.range_ = p;
  }
  return _impl_.range_;
}
inline ::google::monitoring::v3::Range* WindowsBasedSli_MetricRange::mutable_range() {
  ::google::monitoring::v3::Range* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.WindowsBasedSli.MetricRange.range)
  return _msg;
}
inline void WindowsBasedSli_MetricRange::set_allocated_range(::google::monitoring::v3::Range* range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.range_;
  }
  if (range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(range);
    if (message_arena != submessage_arena) {
      range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.range_ = range;
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.WindowsBasedSli.MetricRange.range)
}

// -------------------------------------------------------------------

// WindowsBasedSli

// string good_bad_metric_filter = 5;
inline bool WindowsBasedSli::_internal_has_good_bad_metric_filter() const {
  return window_criterion_case() == kGoodBadMetricFilter;
}
inline bool WindowsBasedSli::has_good_bad_metric_filter() const {
  return _internal_has_good_bad_metric_filter();
}
inline void WindowsBasedSli::set_has_good_bad_metric_filter() {
  _impl_._oneof_case_[0] = kGoodBadMetricFilter;
}
inline void WindowsBasedSli::clear_good_bad_metric_filter() {
  if (_internal_has_good_bad_metric_filter()) {
    _impl_.window_criterion_.good_bad_metric_filter_.Destroy();
    clear_has_window_criterion();
  }
}
inline const std::string& WindowsBasedSli::good_bad_metric_filter() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.WindowsBasedSli.good_bad_metric_filter)
  return _internal_good_bad_metric_filter();
}
template <typename ArgT0, typename... ArgT>
inline void WindowsBasedSli::set_good_bad_metric_filter(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_good_bad_metric_filter()) {
    clear_window_criterion();
    set_has_good_bad_metric_filter();
    _impl_.window_criterion_.good_bad_metric_filter_.InitDefault();
  }
  _impl_.window_criterion_.good_bad_metric_filter_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.WindowsBasedSli.good_bad_metric_filter)
}
inline std::string* WindowsBasedSli::mutable_good_bad_metric_filter() {
  std::string* _s = _internal_mutable_good_bad_metric_filter();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.WindowsBasedSli.good_bad_metric_filter)
  return _s;
}
inline const std::string& WindowsBasedSli::_internal_good_bad_metric_filter() const {
  if (_internal_has_good_bad_metric_filter()) {
    return _impl_.window_criterion_.good_bad_metric_filter_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void WindowsBasedSli::_internal_set_good_bad_metric_filter(const std::string& value) {
  if (!_internal_has_good_bad_metric_filter()) {
    clear_window_criterion();
    set_has_good_bad_metric_filter();
    _impl_.window_criterion_.good_bad_metric_filter_.InitDefault();
  }
  _impl_.window_criterion_.good_bad_metric_filter_.Set(value, GetArenaForAllocation());
}
inline std::string* WindowsBasedSli::_internal_mutable_good_bad_metric_filter() {
  if (!_internal_has_good_bad_metric_filter()) {
    clear_window_criterion();
    set_has_good_bad_metric_filter();
    _impl_.window_criterion_.good_bad_metric_filter_.InitDefault();
  }
  return _impl_.window_criterion_.good_bad_metric_filter_.Mutable(      GetArenaForAllocation());
}
inline std::string* WindowsBasedSli::release_good_bad_metric_filter() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.WindowsBasedSli.good_bad_metric_filter)
  if (_internal_has_good_bad_metric_filter()) {
    clear_has_window_criterion();
    return _impl_.window_criterion_.good_bad_metric_filter_.Release();
  } else {
    return nullptr;
  }
}
inline void WindowsBasedSli::set_allocated_good_bad_metric_filter(std::string* good_bad_metric_filter) {
  if (has_window_criterion()) {
    clear_window_criterion();
  }
  if (good_bad_metric_filter != nullptr) {
    set_has_good_bad_metric_filter();
    _impl_.window_criterion_.good_bad_metric_filter_.InitAllocated(good_bad_metric_filter, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.WindowsBasedSli.good_bad_metric_filter)
}

// .google.monitoring.v3.WindowsBasedSli.PerformanceThreshold good_total_ratio_threshold = 2;
inline bool WindowsBasedSli::_internal_has_good_total_ratio_threshold() const {
  return window_criterion_case() == kGoodTotalRatioThreshold;
}
inline bool WindowsBasedSli::has_good_total_ratio_threshold() const {
  return _internal_has_good_total_ratio_threshold();
}
inline void WindowsBasedSli::set_has_good_total_ratio_threshold() {
  _impl_._oneof_case_[0] = kGoodTotalRatioThreshold;
}
inline void WindowsBasedSli::clear_good_total_ratio_threshold() {
  if (_internal_has_good_total_ratio_threshold()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.window_criterion_.good_total_ratio_threshold_;
    }
    clear_has_window_criterion();
  }
}
inline ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* WindowsBasedSli::release_good_total_ratio_threshold() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.WindowsBasedSli.good_total_ratio_threshold)
  if (_internal_has_good_total_ratio_threshold()) {
    clear_has_window_criterion();
    ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* temp = _impl_.window_criterion_.good_total_ratio_threshold_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.window_criterion_.good_total_ratio_threshold_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold& WindowsBasedSli::_internal_good_total_ratio_threshold() const {
  return _internal_has_good_total_ratio_threshold()
      ? *_impl_.window_criterion_.good_total_ratio_threshold_
      : reinterpret_cast< ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold&>(::google::monitoring::v3::_WindowsBasedSli_PerformanceThreshold_default_instance_);
}
inline const ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold& WindowsBasedSli::good_total_ratio_threshold() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.WindowsBasedSli.good_total_ratio_threshold)
  return _internal_good_total_ratio_threshold();
}
inline ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* WindowsBasedSli::unsafe_arena_release_good_total_ratio_threshold() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.WindowsBasedSli.good_total_ratio_threshold)
  if (_internal_has_good_total_ratio_threshold()) {
    clear_has_window_criterion();
    ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* temp = _impl_.window_criterion_.good_total_ratio_threshold_;
    _impl_.window_criterion_.good_total_ratio_threshold_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WindowsBasedSli::unsafe_arena_set_allocated_good_total_ratio_threshold(::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* good_total_ratio_threshold) {
  clear_window_criterion();
  if (good_total_ratio_threshold) {
    set_has_good_total_ratio_threshold();
    _impl_.window_criterion_.good_total_ratio_threshold_ = good_total_ratio_threshold;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.WindowsBasedSli.good_total_ratio_threshold)
}
inline ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* WindowsBasedSli::_internal_mutable_good_total_ratio_threshold() {
  if (!_internal_has_good_total_ratio_threshold()) {
    clear_window_criterion();
    set_has_good_total_ratio_threshold();
    _impl_.window_criterion_.good_total_ratio_threshold_ = CreateMaybeMessage< ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold >(GetArenaForAllocation());
  }
  return _impl_.window_criterion_.good_total_ratio_threshold_;
}
inline ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* WindowsBasedSli::mutable_good_total_ratio_threshold() {
  ::google::monitoring::v3::WindowsBasedSli_PerformanceThreshold* _msg = _internal_mutable_good_total_ratio_threshold();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.WindowsBasedSli.good_total_ratio_threshold)
  return _msg;
}

// .google.monitoring.v3.WindowsBasedSli.MetricRange metric_mean_in_range = 6;
inline bool WindowsBasedSli::_internal_has_metric_mean_in_range() const {
  return window_criterion_case() == kMetricMeanInRange;
}
inline bool WindowsBasedSli::has_metric_mean_in_range() const {
  return _internal_has_metric_mean_in_range();
}
inline void WindowsBasedSli::set_has_metric_mean_in_range() {
  _impl_._oneof_case_[0] = kMetricMeanInRange;
}
inline void WindowsBasedSli::clear_metric_mean_in_range() {
  if (_internal_has_metric_mean_in_range()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.window_criterion_.metric_mean_in_range_;
    }
    clear_has_window_criterion();
  }
}
inline ::google::monitoring::v3::WindowsBasedSli_MetricRange* WindowsBasedSli::release_metric_mean_in_range() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.WindowsBasedSli.metric_mean_in_range)
  if (_internal_has_metric_mean_in_range()) {
    clear_has_window_criterion();
    ::google::monitoring::v3::WindowsBasedSli_MetricRange* temp = _impl_.window_criterion_.metric_mean_in_range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.window_criterion_.metric_mean_in_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::WindowsBasedSli_MetricRange& WindowsBasedSli::_internal_metric_mean_in_range() const {
  return _internal_has_metric_mean_in_range()
      ? *_impl_.window_criterion_.metric_mean_in_range_
      : reinterpret_cast< ::google::monitoring::v3::WindowsBasedSli_MetricRange&>(::google::monitoring::v3::_WindowsBasedSli_MetricRange_default_instance_);
}
inline const ::google::monitoring::v3::WindowsBasedSli_MetricRange& WindowsBasedSli::metric_mean_in_range() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.WindowsBasedSli.metric_mean_in_range)
  return _internal_metric_mean_in_range();
}
inline ::google::monitoring::v3::WindowsBasedSli_MetricRange* WindowsBasedSli::unsafe_arena_release_metric_mean_in_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.WindowsBasedSli.metric_mean_in_range)
  if (_internal_has_metric_mean_in_range()) {
    clear_has_window_criterion();
    ::google::monitoring::v3::WindowsBasedSli_MetricRange* temp = _impl_.window_criterion_.metric_mean_in_range_;
    _impl_.window_criterion_.metric_mean_in_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WindowsBasedSli::unsafe_arena_set_allocated_metric_mean_in_range(::google::monitoring::v3::WindowsBasedSli_MetricRange* metric_mean_in_range) {
  clear_window_criterion();
  if (metric_mean_in_range) {
    set_has_metric_mean_in_range();
    _impl_.window_criterion_.metric_mean_in_range_ = metric_mean_in_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.WindowsBasedSli.metric_mean_in_range)
}
inline ::google::monitoring::v3::WindowsBasedSli_MetricRange* WindowsBasedSli::_internal_mutable_metric_mean_in_range() {
  if (!_internal_has_metric_mean_in_range()) {
    clear_window_criterion();
    set_has_metric_mean_in_range();
    _impl_.window_criterion_.metric_mean_in_range_ = CreateMaybeMessage< ::google::monitoring::v3::WindowsBasedSli_MetricRange >(GetArenaForAllocation());
  }
  return _impl_.window_criterion_.metric_mean_in_range_;
}
inline ::google::monitoring::v3::WindowsBasedSli_MetricRange* WindowsBasedSli::mutable_metric_mean_in_range() {
  ::google::monitoring::v3::WindowsBasedSli_MetricRange* _msg = _internal_mutable_metric_mean_in_range();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.WindowsBasedSli.metric_mean_in_range)
  return _msg;
}

// .google.monitoring.v3.WindowsBasedSli.MetricRange metric_sum_in_range = 7;
inline bool WindowsBasedSli::_internal_has_metric_sum_in_range() const {
  return window_criterion_case() == kMetricSumInRange;
}
inline bool WindowsBasedSli::has_metric_sum_in_range() const {
  return _internal_has_metric_sum_in_range();
}
inline void WindowsBasedSli::set_has_metric_sum_in_range() {
  _impl_._oneof_case_[0] = kMetricSumInRange;
}
inline void WindowsBasedSli::clear_metric_sum_in_range() {
  if (_internal_has_metric_sum_in_range()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.window_criterion_.metric_sum_in_range_;
    }
    clear_has_window_criterion();
  }
}
inline ::google::monitoring::v3::WindowsBasedSli_MetricRange* WindowsBasedSli::release_metric_sum_in_range() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.WindowsBasedSli.metric_sum_in_range)
  if (_internal_has_metric_sum_in_range()) {
    clear_has_window_criterion();
    ::google::monitoring::v3::WindowsBasedSli_MetricRange* temp = _impl_.window_criterion_.metric_sum_in_range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.window_criterion_.metric_sum_in_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::WindowsBasedSli_MetricRange& WindowsBasedSli::_internal_metric_sum_in_range() const {
  return _internal_has_metric_sum_in_range()
      ? *_impl_.window_criterion_.metric_sum_in_range_
      : reinterpret_cast< ::google::monitoring::v3::WindowsBasedSli_MetricRange&>(::google::monitoring::v3::_WindowsBasedSli_MetricRange_default_instance_);
}
inline const ::google::monitoring::v3::WindowsBasedSli_MetricRange& WindowsBasedSli::metric_sum_in_range() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.WindowsBasedSli.metric_sum_in_range)
  return _internal_metric_sum_in_range();
}
inline ::google::monitoring::v3::WindowsBasedSli_MetricRange* WindowsBasedSli::unsafe_arena_release_metric_sum_in_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.WindowsBasedSli.metric_sum_in_range)
  if (_internal_has_metric_sum_in_range()) {
    clear_has_window_criterion();
    ::google::monitoring::v3::WindowsBasedSli_MetricRange* temp = _impl_.window_criterion_.metric_sum_in_range_;
    _impl_.window_criterion_.metric_sum_in_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WindowsBasedSli::unsafe_arena_set_allocated_metric_sum_in_range(::google::monitoring::v3::WindowsBasedSli_MetricRange* metric_sum_in_range) {
  clear_window_criterion();
  if (metric_sum_in_range) {
    set_has_metric_sum_in_range();
    _impl_.window_criterion_.metric_sum_in_range_ = metric_sum_in_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.WindowsBasedSli.metric_sum_in_range)
}
inline ::google::monitoring::v3::WindowsBasedSli_MetricRange* WindowsBasedSli::_internal_mutable_metric_sum_in_range() {
  if (!_internal_has_metric_sum_in_range()) {
    clear_window_criterion();
    set_has_metric_sum_in_range();
    _impl_.window_criterion_.metric_sum_in_range_ = CreateMaybeMessage< ::google::monitoring::v3::WindowsBasedSli_MetricRange >(GetArenaForAllocation());
  }
  return _impl_.window_criterion_.metric_sum_in_range_;
}
inline ::google::monitoring::v3::WindowsBasedSli_MetricRange* WindowsBasedSli::mutable_metric_sum_in_range() {
  ::google::monitoring::v3::WindowsBasedSli_MetricRange* _msg = _internal_mutable_metric_sum_in_range();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.WindowsBasedSli.metric_sum_in_range)
  return _msg;
}

// .google.protobuf.Duration window_period = 4;
inline bool WindowsBasedSli::_internal_has_window_period() const {
  return this != internal_default_instance() && _impl_.window_period_ != nullptr;
}
inline bool WindowsBasedSli::has_window_period() const {
  return _internal_has_window_period();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& WindowsBasedSli::_internal_window_period() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.window_period_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& WindowsBasedSli::window_period() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.WindowsBasedSli.window_period)
  return _internal_window_period();
}
inline void WindowsBasedSli::unsafe_arena_set_allocated_window_period(
    ::PROTOBUF_NAMESPACE_ID::Duration* window_period) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.window_period_);
  }
  _impl_.window_period_ = window_period;
  if (window_period) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.WindowsBasedSli.window_period)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* WindowsBasedSli::release_window_period() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.window_period_;
  _impl_.window_period_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* WindowsBasedSli::unsafe_arena_release_window_period() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.WindowsBasedSli.window_period)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.window_period_;
  _impl_.window_period_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* WindowsBasedSli::_internal_mutable_window_period() {
  
  if (_impl_.window_period_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.window_period_ = p;
  }
  return _impl_.window_period_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* WindowsBasedSli::mutable_window_period() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_window_period();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.WindowsBasedSli.window_period)
  return _msg;
}
inline void WindowsBasedSli::set_allocated_window_period(::PROTOBUF_NAMESPACE_ID::Duration* window_period) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.window_period_);
  }
  if (window_period) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(window_period));
    if (message_arena != submessage_arena) {
      window_period = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, window_period, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.window_period_ = window_period;
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.WindowsBasedSli.window_period)
}

inline bool WindowsBasedSli::has_window_criterion() const {
  return window_criterion_case() != WINDOW_CRITERION_NOT_SET;
}
inline void WindowsBasedSli::clear_has_window_criterion() {
  _impl_._oneof_case_[0] = WINDOW_CRITERION_NOT_SET;
}
inline WindowsBasedSli::WindowCriterionCase WindowsBasedSli::window_criterion_case() const {
  return WindowsBasedSli::WindowCriterionCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v3
}  // namespace monitoring
}  // namespace google

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::google::monitoring::v3::ServiceLevelObjective_View> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::monitoring::v3::ServiceLevelObjective_View>() {
  return ::google::monitoring::v3::ServiceLevelObjective_View_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_google_2fmonitoring_2fv3_2fservice_2eproto
