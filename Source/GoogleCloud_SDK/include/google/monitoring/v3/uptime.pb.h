// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/monitoring/v3/uptime.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_google_2fmonitoring_2fv3_2fuptime_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_google_2fmonitoring_2fv3_2fuptime_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/monitored_resource.pb.h"
#include "google/api/resource.pb.h"
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_google_2fmonitoring_2fv3_2fuptime_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_google_2fmonitoring_2fv3_2fuptime_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_google_2fmonitoring_2fv3_2fuptime_2eproto;
namespace google {
namespace monitoring {
namespace v3 {
class InternalChecker;
struct InternalCheckerDefaultTypeInternal;
extern InternalCheckerDefaultTypeInternal _InternalChecker_default_instance_;
class UptimeCheckConfig;
struct UptimeCheckConfigDefaultTypeInternal;
extern UptimeCheckConfigDefaultTypeInternal _UptimeCheckConfig_default_instance_;
class UptimeCheckConfig_ContentMatcher;
struct UptimeCheckConfig_ContentMatcherDefaultTypeInternal;
extern UptimeCheckConfig_ContentMatcherDefaultTypeInternal _UptimeCheckConfig_ContentMatcher_default_instance_;
class UptimeCheckConfig_HttpCheck;
struct UptimeCheckConfig_HttpCheckDefaultTypeInternal;
extern UptimeCheckConfig_HttpCheckDefaultTypeInternal _UptimeCheckConfig_HttpCheck_default_instance_;
class UptimeCheckConfig_HttpCheck_BasicAuthentication;
struct UptimeCheckConfig_HttpCheck_BasicAuthenticationDefaultTypeInternal;
extern UptimeCheckConfig_HttpCheck_BasicAuthenticationDefaultTypeInternal _UptimeCheckConfig_HttpCheck_BasicAuthentication_default_instance_;
class UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUse;
struct UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUseDefaultTypeInternal;
extern UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUseDefaultTypeInternal _UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUse_default_instance_;
class UptimeCheckConfig_ResourceGroup;
struct UptimeCheckConfig_ResourceGroupDefaultTypeInternal;
extern UptimeCheckConfig_ResourceGroupDefaultTypeInternal _UptimeCheckConfig_ResourceGroup_default_instance_;
class UptimeCheckConfig_TcpCheck;
struct UptimeCheckConfig_TcpCheckDefaultTypeInternal;
extern UptimeCheckConfig_TcpCheckDefaultTypeInternal _UptimeCheckConfig_TcpCheck_default_instance_;
class UptimeCheckIp;
struct UptimeCheckIpDefaultTypeInternal;
extern UptimeCheckIpDefaultTypeInternal _UptimeCheckIp_default_instance_;
}  // namespace v3
}  // namespace monitoring
}  // namespace google
PROTOBUF_NAMESPACE_OPEN
template<> ::google::monitoring::v3::InternalChecker* Arena::CreateMaybeMessage<::google::monitoring::v3::InternalChecker>(Arena*);
template<> ::google::monitoring::v3::UptimeCheckConfig* Arena::CreateMaybeMessage<::google::monitoring::v3::UptimeCheckConfig>(Arena*);
template<> ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher* Arena::CreateMaybeMessage<::google::monitoring::v3::UptimeCheckConfig_ContentMatcher>(Arena*);
template<> ::google::monitoring::v3::UptimeCheckConfig_HttpCheck* Arena::CreateMaybeMessage<::google::monitoring::v3::UptimeCheckConfig_HttpCheck>(Arena*);
template<> ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* Arena::CreateMaybeMessage<::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication>(Arena*);
template<> ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUse* Arena::CreateMaybeMessage<::google::monitoring::v3::UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUse>(Arena*);
template<> ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* Arena::CreateMaybeMessage<::google::monitoring::v3::UptimeCheckConfig_ResourceGroup>(Arena*);
template<> ::google::monitoring::v3::UptimeCheckConfig_TcpCheck* Arena::CreateMaybeMessage<::google::monitoring::v3::UptimeCheckConfig_TcpCheck>(Arena*);
template<> ::google::monitoring::v3::UptimeCheckIp* Arena::CreateMaybeMessage<::google::monitoring::v3::UptimeCheckIp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace google {
namespace monitoring {
namespace v3 {

enum InternalChecker_State : int {
  InternalChecker_State_UNSPECIFIED = 0,
  InternalChecker_State_CREATING = 1,
  InternalChecker_State_RUNNING = 2,
  InternalChecker_State_InternalChecker_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  InternalChecker_State_InternalChecker_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool InternalChecker_State_IsValid(int value);
constexpr InternalChecker_State InternalChecker_State_State_MIN = InternalChecker_State_UNSPECIFIED;
constexpr InternalChecker_State InternalChecker_State_State_MAX = InternalChecker_State_RUNNING;
constexpr int InternalChecker_State_State_ARRAYSIZE = InternalChecker_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InternalChecker_State_descriptor();
template<typename T>
inline const std::string& InternalChecker_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InternalChecker_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InternalChecker_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InternalChecker_State_descriptor(), enum_t_value);
}
inline bool InternalChecker_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InternalChecker_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InternalChecker_State>(
    InternalChecker_State_descriptor(), name, value);
}
enum UptimeCheckConfig_HttpCheck_RequestMethod : int {
  UptimeCheckConfig_HttpCheck_RequestMethod_METHOD_UNSPECIFIED = 0,
  UptimeCheckConfig_HttpCheck_RequestMethod_GET = 1,
  UptimeCheckConfig_HttpCheck_RequestMethod_POST = 2,
  UptimeCheckConfig_HttpCheck_RequestMethod_UptimeCheckConfig_HttpCheck_RequestMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UptimeCheckConfig_HttpCheck_RequestMethod_UptimeCheckConfig_HttpCheck_RequestMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UptimeCheckConfig_HttpCheck_RequestMethod_IsValid(int value);
constexpr UptimeCheckConfig_HttpCheck_RequestMethod UptimeCheckConfig_HttpCheck_RequestMethod_RequestMethod_MIN = UptimeCheckConfig_HttpCheck_RequestMethod_METHOD_UNSPECIFIED;
constexpr UptimeCheckConfig_HttpCheck_RequestMethod UptimeCheckConfig_HttpCheck_RequestMethod_RequestMethod_MAX = UptimeCheckConfig_HttpCheck_RequestMethod_POST;
constexpr int UptimeCheckConfig_HttpCheck_RequestMethod_RequestMethod_ARRAYSIZE = UptimeCheckConfig_HttpCheck_RequestMethod_RequestMethod_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UptimeCheckConfig_HttpCheck_RequestMethod_descriptor();
template<typename T>
inline const std::string& UptimeCheckConfig_HttpCheck_RequestMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UptimeCheckConfig_HttpCheck_RequestMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UptimeCheckConfig_HttpCheck_RequestMethod_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UptimeCheckConfig_HttpCheck_RequestMethod_descriptor(), enum_t_value);
}
inline bool UptimeCheckConfig_HttpCheck_RequestMethod_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UptimeCheckConfig_HttpCheck_RequestMethod* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UptimeCheckConfig_HttpCheck_RequestMethod>(
    UptimeCheckConfig_HttpCheck_RequestMethod_descriptor(), name, value);
}
enum UptimeCheckConfig_HttpCheck_ContentType : int {
  UptimeCheckConfig_HttpCheck_ContentType_TYPE_UNSPECIFIED = 0,
  UptimeCheckConfig_HttpCheck_ContentType_URL_ENCODED = 1,
  UptimeCheckConfig_HttpCheck_ContentType_UptimeCheckConfig_HttpCheck_ContentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UptimeCheckConfig_HttpCheck_ContentType_UptimeCheckConfig_HttpCheck_ContentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UptimeCheckConfig_HttpCheck_ContentType_IsValid(int value);
constexpr UptimeCheckConfig_HttpCheck_ContentType UptimeCheckConfig_HttpCheck_ContentType_ContentType_MIN = UptimeCheckConfig_HttpCheck_ContentType_TYPE_UNSPECIFIED;
constexpr UptimeCheckConfig_HttpCheck_ContentType UptimeCheckConfig_HttpCheck_ContentType_ContentType_MAX = UptimeCheckConfig_HttpCheck_ContentType_URL_ENCODED;
constexpr int UptimeCheckConfig_HttpCheck_ContentType_ContentType_ARRAYSIZE = UptimeCheckConfig_HttpCheck_ContentType_ContentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UptimeCheckConfig_HttpCheck_ContentType_descriptor();
template<typename T>
inline const std::string& UptimeCheckConfig_HttpCheck_ContentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UptimeCheckConfig_HttpCheck_ContentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UptimeCheckConfig_HttpCheck_ContentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UptimeCheckConfig_HttpCheck_ContentType_descriptor(), enum_t_value);
}
inline bool UptimeCheckConfig_HttpCheck_ContentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UptimeCheckConfig_HttpCheck_ContentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UptimeCheckConfig_HttpCheck_ContentType>(
    UptimeCheckConfig_HttpCheck_ContentType_descriptor(), name, value);
}
enum UptimeCheckConfig_ContentMatcher_ContentMatcherOption : int {
  UptimeCheckConfig_ContentMatcher_ContentMatcherOption_CONTENT_MATCHER_OPTION_UNSPECIFIED = 0,
  UptimeCheckConfig_ContentMatcher_ContentMatcherOption_CONTAINS_STRING = 1,
  UptimeCheckConfig_ContentMatcher_ContentMatcherOption_NOT_CONTAINS_STRING = 2,
  UptimeCheckConfig_ContentMatcher_ContentMatcherOption_MATCHES_REGEX = 3,
  UptimeCheckConfig_ContentMatcher_ContentMatcherOption_NOT_MATCHES_REGEX = 4,
  UptimeCheckConfig_ContentMatcher_ContentMatcherOption_UptimeCheckConfig_ContentMatcher_ContentMatcherOption_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UptimeCheckConfig_ContentMatcher_ContentMatcherOption_UptimeCheckConfig_ContentMatcher_ContentMatcherOption_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UptimeCheckConfig_ContentMatcher_ContentMatcherOption_IsValid(int value);
constexpr UptimeCheckConfig_ContentMatcher_ContentMatcherOption UptimeCheckConfig_ContentMatcher_ContentMatcherOption_ContentMatcherOption_MIN = UptimeCheckConfig_ContentMatcher_ContentMatcherOption_CONTENT_MATCHER_OPTION_UNSPECIFIED;
constexpr UptimeCheckConfig_ContentMatcher_ContentMatcherOption UptimeCheckConfig_ContentMatcher_ContentMatcherOption_ContentMatcherOption_MAX = UptimeCheckConfig_ContentMatcher_ContentMatcherOption_NOT_MATCHES_REGEX;
constexpr int UptimeCheckConfig_ContentMatcher_ContentMatcherOption_ContentMatcherOption_ARRAYSIZE = UptimeCheckConfig_ContentMatcher_ContentMatcherOption_ContentMatcherOption_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UptimeCheckConfig_ContentMatcher_ContentMatcherOption_descriptor();
template<typename T>
inline const std::string& UptimeCheckConfig_ContentMatcher_ContentMatcherOption_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UptimeCheckConfig_ContentMatcher_ContentMatcherOption>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UptimeCheckConfig_ContentMatcher_ContentMatcherOption_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UptimeCheckConfig_ContentMatcher_ContentMatcherOption_descriptor(), enum_t_value);
}
inline bool UptimeCheckConfig_ContentMatcher_ContentMatcherOption_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UptimeCheckConfig_ContentMatcher_ContentMatcherOption* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UptimeCheckConfig_ContentMatcher_ContentMatcherOption>(
    UptimeCheckConfig_ContentMatcher_ContentMatcherOption_descriptor(), name, value);
}
enum UptimeCheckRegion : int {
  REGION_UNSPECIFIED = 0,
  USA = 1,
  EUROPE = 2,
  SOUTH_AMERICA = 3,
  ASIA_PACIFIC = 4,
  UptimeCheckRegion_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UptimeCheckRegion_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UptimeCheckRegion_IsValid(int value);
constexpr UptimeCheckRegion UptimeCheckRegion_MIN = REGION_UNSPECIFIED;
constexpr UptimeCheckRegion UptimeCheckRegion_MAX = ASIA_PACIFIC;
constexpr int UptimeCheckRegion_ARRAYSIZE = UptimeCheckRegion_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UptimeCheckRegion_descriptor();
template<typename T>
inline const std::string& UptimeCheckRegion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UptimeCheckRegion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UptimeCheckRegion_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UptimeCheckRegion_descriptor(), enum_t_value);
}
inline bool UptimeCheckRegion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UptimeCheckRegion* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UptimeCheckRegion>(
    UptimeCheckRegion_descriptor(), name, value);
}
enum GroupResourceType : int {
  RESOURCE_TYPE_UNSPECIFIED = 0,
  INSTANCE = 1,
  AWS_ELB_LOAD_BALANCER = 2,
  GroupResourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GroupResourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GroupResourceType_IsValid(int value);
constexpr GroupResourceType GroupResourceType_MIN = RESOURCE_TYPE_UNSPECIFIED;
constexpr GroupResourceType GroupResourceType_MAX = AWS_ELB_LOAD_BALANCER;
constexpr int GroupResourceType_ARRAYSIZE = GroupResourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GroupResourceType_descriptor();
template<typename T>
inline const std::string& GroupResourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GroupResourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GroupResourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GroupResourceType_descriptor(), enum_t_value);
}
inline bool GroupResourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupResourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GroupResourceType>(
    GroupResourceType_descriptor(), name, value);
}
// ===================================================================

class InternalChecker final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.InternalChecker) */ {
 public:
  inline InternalChecker() : InternalChecker(nullptr) {}
  ~InternalChecker() override;
  explicit constexpr InternalChecker(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InternalChecker(const InternalChecker& from);
  InternalChecker(InternalChecker&& from) noexcept
    : InternalChecker() {
    *this = ::std::move(from);
  }

  inline InternalChecker& operator=(const InternalChecker& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternalChecker& operator=(InternalChecker&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InternalChecker& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternalChecker* internal_default_instance() {
    return reinterpret_cast<const InternalChecker*>(
               &_InternalChecker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InternalChecker& a, InternalChecker& b) {
    a.Swap(&b);
  }
  inline void Swap(InternalChecker* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternalChecker* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternalChecker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternalChecker>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InternalChecker& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InternalChecker& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InternalChecker* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.InternalChecker";
  }
  protected:
  explicit InternalChecker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InternalChecker_State State;
  static constexpr State UNSPECIFIED =
    InternalChecker_State_UNSPECIFIED;
  static constexpr State CREATING =
    InternalChecker_State_CREATING;
  static constexpr State RUNNING =
    InternalChecker_State_RUNNING;
  static inline bool State_IsValid(int value) {
    return InternalChecker_State_IsValid(value);
  }
  static constexpr State State_MIN =
    InternalChecker_State_State_MIN;
  static constexpr State State_MAX =
    InternalChecker_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    InternalChecker_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return InternalChecker_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return InternalChecker_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return InternalChecker_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kNetworkFieldNumber = 3,
    kGcpZoneFieldNumber = 4,
    kPeerProjectIdFieldNumber = 6,
    kStateFieldNumber = 7,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string display_name = 2;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // string network = 3;
  void clear_network();
  const std::string& network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* network);
  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(const std::string& value);
  std::string* _internal_mutable_network();
  public:

  // string gcp_zone = 4;
  void clear_gcp_zone();
  const std::string& gcp_zone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gcp_zone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gcp_zone();
  PROTOBUF_NODISCARD std::string* release_gcp_zone();
  void set_allocated_gcp_zone(std::string* gcp_zone);
  private:
  const std::string& _internal_gcp_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gcp_zone(const std::string& value);
  std::string* _internal_mutable_gcp_zone();
  public:

  // string peer_project_id = 6;
  void clear_peer_project_id();
  const std::string& peer_project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer_project_id();
  PROTOBUF_NODISCARD std::string* release_peer_project_id();
  void set_allocated_peer_project_id(std::string* peer_project_id);
  private:
  const std::string& _internal_peer_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer_project_id(const std::string& value);
  std::string* _internal_mutable_peer_project_id();
  public:

  // .google.monitoring.v3.InternalChecker.State state = 7;
  void clear_state();
  ::google::monitoring::v3::InternalChecker_State state() const;
  void set_state(::google::monitoring::v3::InternalChecker_State value);
  private:
  ::google::monitoring::v3::InternalChecker_State _internal_state() const;
  void _internal_set_state(::google::monitoring::v3::InternalChecker_State value);
  public:

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.InternalChecker)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gcp_zone_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_project_id_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fuptime_2eproto;
};
// -------------------------------------------------------------------

class UptimeCheckConfig_ResourceGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.UptimeCheckConfig.ResourceGroup) */ {
 public:
  inline UptimeCheckConfig_ResourceGroup() : UptimeCheckConfig_ResourceGroup(nullptr) {}
  ~UptimeCheckConfig_ResourceGroup() override;
  explicit constexpr UptimeCheckConfig_ResourceGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UptimeCheckConfig_ResourceGroup(const UptimeCheckConfig_ResourceGroup& from);
  UptimeCheckConfig_ResourceGroup(UptimeCheckConfig_ResourceGroup&& from) noexcept
    : UptimeCheckConfig_ResourceGroup() {
    *this = ::std::move(from);
  }

  inline UptimeCheckConfig_ResourceGroup& operator=(const UptimeCheckConfig_ResourceGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline UptimeCheckConfig_ResourceGroup& operator=(UptimeCheckConfig_ResourceGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UptimeCheckConfig_ResourceGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const UptimeCheckConfig_ResourceGroup* internal_default_instance() {
    return reinterpret_cast<const UptimeCheckConfig_ResourceGroup*>(
               &_UptimeCheckConfig_ResourceGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UptimeCheckConfig_ResourceGroup& a, UptimeCheckConfig_ResourceGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(UptimeCheckConfig_ResourceGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UptimeCheckConfig_ResourceGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UptimeCheckConfig_ResourceGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UptimeCheckConfig_ResourceGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UptimeCheckConfig_ResourceGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UptimeCheckConfig_ResourceGroup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UptimeCheckConfig_ResourceGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.UptimeCheckConfig.ResourceGroup";
  }
  protected:
  explicit UptimeCheckConfig_ResourceGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupIdFieldNumber = 1,
    kResourceTypeFieldNumber = 2,
  };
  // string group_id = 1;
  void clear_group_id();
  const std::string& group_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_id();
  PROTOBUF_NODISCARD std::string* release_group_id();
  void set_allocated_group_id(std::string* group_id);
  private:
  const std::string& _internal_group_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_id(const std::string& value);
  std::string* _internal_mutable_group_id();
  public:

  // .google.monitoring.v3.GroupResourceType resource_type = 2;
  void clear_resource_type();
  ::google::monitoring::v3::GroupResourceType resource_type() const;
  void set_resource_type(::google::monitoring::v3::GroupResourceType value);
  private:
  ::google::monitoring::v3::GroupResourceType _internal_resource_type() const;
  void _internal_set_resource_type(::google::monitoring::v3::GroupResourceType value);
  public:

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.UptimeCheckConfig.ResourceGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_id_;
  int resource_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fuptime_2eproto;
};
// -------------------------------------------------------------------

class UptimeCheckConfig_HttpCheck_BasicAuthentication final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication) */ {
 public:
  inline UptimeCheckConfig_HttpCheck_BasicAuthentication() : UptimeCheckConfig_HttpCheck_BasicAuthentication(nullptr) {}
  ~UptimeCheckConfig_HttpCheck_BasicAuthentication() override;
  explicit constexpr UptimeCheckConfig_HttpCheck_BasicAuthentication(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UptimeCheckConfig_HttpCheck_BasicAuthentication(const UptimeCheckConfig_HttpCheck_BasicAuthentication& from);
  UptimeCheckConfig_HttpCheck_BasicAuthentication(UptimeCheckConfig_HttpCheck_BasicAuthentication&& from) noexcept
    : UptimeCheckConfig_HttpCheck_BasicAuthentication() {
    *this = ::std::move(from);
  }

  inline UptimeCheckConfig_HttpCheck_BasicAuthentication& operator=(const UptimeCheckConfig_HttpCheck_BasicAuthentication& from) {
    CopyFrom(from);
    return *this;
  }
  inline UptimeCheckConfig_HttpCheck_BasicAuthentication& operator=(UptimeCheckConfig_HttpCheck_BasicAuthentication&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UptimeCheckConfig_HttpCheck_BasicAuthentication& default_instance() {
    return *internal_default_instance();
  }
  static inline const UptimeCheckConfig_HttpCheck_BasicAuthentication* internal_default_instance() {
    return reinterpret_cast<const UptimeCheckConfig_HttpCheck_BasicAuthentication*>(
               &_UptimeCheckConfig_HttpCheck_BasicAuthentication_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UptimeCheckConfig_HttpCheck_BasicAuthentication& a, UptimeCheckConfig_HttpCheck_BasicAuthentication& b) {
    a.Swap(&b);
  }
  inline void Swap(UptimeCheckConfig_HttpCheck_BasicAuthentication* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UptimeCheckConfig_HttpCheck_BasicAuthentication* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UptimeCheckConfig_HttpCheck_BasicAuthentication* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UptimeCheckConfig_HttpCheck_BasicAuthentication>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UptimeCheckConfig_HttpCheck_BasicAuthentication& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UptimeCheckConfig_HttpCheck_BasicAuthentication& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UptimeCheckConfig_HttpCheck_BasicAuthentication* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication";
  }
  protected:
  explicit UptimeCheckConfig_HttpCheck_BasicAuthentication(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fuptime_2eproto;
};
// -------------------------------------------------------------------

class UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUse();
  explicit constexpr UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUse& other);
  static const UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUse*>(&_UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.monitoring.v3.UptimeCheckConfig.HttpCheck.HeadersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.monitoring.v3.UptimeCheckConfig.HttpCheck.HeadersEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class UptimeCheckConfig_HttpCheck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.UptimeCheckConfig.HttpCheck) */ {
 public:
  inline UptimeCheckConfig_HttpCheck() : UptimeCheckConfig_HttpCheck(nullptr) {}
  ~UptimeCheckConfig_HttpCheck() override;
  explicit constexpr UptimeCheckConfig_HttpCheck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UptimeCheckConfig_HttpCheck(const UptimeCheckConfig_HttpCheck& from);
  UptimeCheckConfig_HttpCheck(UptimeCheckConfig_HttpCheck&& from) noexcept
    : UptimeCheckConfig_HttpCheck() {
    *this = ::std::move(from);
  }

  inline UptimeCheckConfig_HttpCheck& operator=(const UptimeCheckConfig_HttpCheck& from) {
    CopyFrom(from);
    return *this;
  }
  inline UptimeCheckConfig_HttpCheck& operator=(UptimeCheckConfig_HttpCheck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UptimeCheckConfig_HttpCheck& default_instance() {
    return *internal_default_instance();
  }
  static inline const UptimeCheckConfig_HttpCheck* internal_default_instance() {
    return reinterpret_cast<const UptimeCheckConfig_HttpCheck*>(
               &_UptimeCheckConfig_HttpCheck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UptimeCheckConfig_HttpCheck& a, UptimeCheckConfig_HttpCheck& b) {
    a.Swap(&b);
  }
  inline void Swap(UptimeCheckConfig_HttpCheck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UptimeCheckConfig_HttpCheck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UptimeCheckConfig_HttpCheck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UptimeCheckConfig_HttpCheck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UptimeCheckConfig_HttpCheck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UptimeCheckConfig_HttpCheck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UptimeCheckConfig_HttpCheck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.UptimeCheckConfig.HttpCheck";
  }
  protected:
  explicit UptimeCheckConfig_HttpCheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UptimeCheckConfig_HttpCheck_BasicAuthentication BasicAuthentication;

  typedef UptimeCheckConfig_HttpCheck_RequestMethod RequestMethod;
  static constexpr RequestMethod METHOD_UNSPECIFIED =
    UptimeCheckConfig_HttpCheck_RequestMethod_METHOD_UNSPECIFIED;
  static constexpr RequestMethod GET =
    UptimeCheckConfig_HttpCheck_RequestMethod_GET;
  static constexpr RequestMethod POST =
    UptimeCheckConfig_HttpCheck_RequestMethod_POST;
  static inline bool RequestMethod_IsValid(int value) {
    return UptimeCheckConfig_HttpCheck_RequestMethod_IsValid(value);
  }
  static constexpr RequestMethod RequestMethod_MIN =
    UptimeCheckConfig_HttpCheck_RequestMethod_RequestMethod_MIN;
  static constexpr RequestMethod RequestMethod_MAX =
    UptimeCheckConfig_HttpCheck_RequestMethod_RequestMethod_MAX;
  static constexpr int RequestMethod_ARRAYSIZE =
    UptimeCheckConfig_HttpCheck_RequestMethod_RequestMethod_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RequestMethod_descriptor() {
    return UptimeCheckConfig_HttpCheck_RequestMethod_descriptor();
  }
  template<typename T>
  static inline const std::string& RequestMethod_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RequestMethod>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RequestMethod_Name.");
    return UptimeCheckConfig_HttpCheck_RequestMethod_Name(enum_t_value);
  }
  static inline bool RequestMethod_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RequestMethod* value) {
    return UptimeCheckConfig_HttpCheck_RequestMethod_Parse(name, value);
  }

  typedef UptimeCheckConfig_HttpCheck_ContentType ContentType;
  static constexpr ContentType TYPE_UNSPECIFIED =
    UptimeCheckConfig_HttpCheck_ContentType_TYPE_UNSPECIFIED;
  static constexpr ContentType URL_ENCODED =
    UptimeCheckConfig_HttpCheck_ContentType_URL_ENCODED;
  static inline bool ContentType_IsValid(int value) {
    return UptimeCheckConfig_HttpCheck_ContentType_IsValid(value);
  }
  static constexpr ContentType ContentType_MIN =
    UptimeCheckConfig_HttpCheck_ContentType_ContentType_MIN;
  static constexpr ContentType ContentType_MAX =
    UptimeCheckConfig_HttpCheck_ContentType_ContentType_MAX;
  static constexpr int ContentType_ARRAYSIZE =
    UptimeCheckConfig_HttpCheck_ContentType_ContentType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ContentType_descriptor() {
    return UptimeCheckConfig_HttpCheck_ContentType_descriptor();
  }
  template<typename T>
  static inline const std::string& ContentType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ContentType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ContentType_Name.");
    return UptimeCheckConfig_HttpCheck_ContentType_Name(enum_t_value);
  }
  static inline bool ContentType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ContentType* value) {
    return UptimeCheckConfig_HttpCheck_ContentType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeadersFieldNumber = 6,
    kPathFieldNumber = 2,
    kBodyFieldNumber = 10,
    kAuthInfoFieldNumber = 4,
    kPortFieldNumber = 3,
    kUseSslFieldNumber = 1,
    kMaskHeadersFieldNumber = 5,
    kValidateSslFieldNumber = 7,
    kRequestMethodFieldNumber = 8,
    kContentTypeFieldNumber = 9,
  };
  // map<string, string> headers = 6;
  int headers_size() const;
  private:
  int _internal_headers_size() const;
  public:
  void clear_headers();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_headers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_headers();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      headers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_headers();

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // bytes body = 10;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // .google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication auth_info = 4;
  bool has_auth_info() const;
  private:
  bool _internal_has_auth_info() const;
  public:
  void clear_auth_info();
  const ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication& auth_info() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* release_auth_info();
  ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* mutable_auth_info();
  void set_allocated_auth_info(::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* auth_info);
  private:
  const ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication& _internal_auth_info() const;
  ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* _internal_mutable_auth_info();
  public:
  void unsafe_arena_set_allocated_auth_info(
      ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* auth_info);
  ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* unsafe_arena_release_auth_info();

  // int32 port = 3;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // bool use_ssl = 1;
  void clear_use_ssl();
  bool use_ssl() const;
  void set_use_ssl(bool value);
  private:
  bool _internal_use_ssl() const;
  void _internal_set_use_ssl(bool value);
  public:

  // bool mask_headers = 5;
  void clear_mask_headers();
  bool mask_headers() const;
  void set_mask_headers(bool value);
  private:
  bool _internal_mask_headers() const;
  void _internal_set_mask_headers(bool value);
  public:

  // bool validate_ssl = 7;
  void clear_validate_ssl();
  bool validate_ssl() const;
  void set_validate_ssl(bool value);
  private:
  bool _internal_validate_ssl() const;
  void _internal_set_validate_ssl(bool value);
  public:

  // .google.monitoring.v3.UptimeCheckConfig.HttpCheck.RequestMethod request_method = 8;
  void clear_request_method();
  ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_RequestMethod request_method() const;
  void set_request_method(::google::monitoring::v3::UptimeCheckConfig_HttpCheck_RequestMethod value);
  private:
  ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_RequestMethod _internal_request_method() const;
  void _internal_set_request_method(::google::monitoring::v3::UptimeCheckConfig_HttpCheck_RequestMethod value);
  public:

  // .google.monitoring.v3.UptimeCheckConfig.HttpCheck.ContentType content_type = 9;
  void clear_content_type();
  ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_ContentType content_type() const;
  void set_content_type(::google::monitoring::v3::UptimeCheckConfig_HttpCheck_ContentType value);
  private:
  ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_ContentType _internal_content_type() const;
  void _internal_set_content_type(::google::monitoring::v3::UptimeCheckConfig_HttpCheck_ContentType value);
  public:

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.UptimeCheckConfig.HttpCheck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      UptimeCheckConfig_HttpCheck_HeadersEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> headers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
  ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* auth_info_;
  int32_t port_;
  bool use_ssl_;
  bool mask_headers_;
  bool validate_ssl_;
  int request_method_;
  int content_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fuptime_2eproto;
};
// -------------------------------------------------------------------

class UptimeCheckConfig_TcpCheck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.UptimeCheckConfig.TcpCheck) */ {
 public:
  inline UptimeCheckConfig_TcpCheck() : UptimeCheckConfig_TcpCheck(nullptr) {}
  ~UptimeCheckConfig_TcpCheck() override;
  explicit constexpr UptimeCheckConfig_TcpCheck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UptimeCheckConfig_TcpCheck(const UptimeCheckConfig_TcpCheck& from);
  UptimeCheckConfig_TcpCheck(UptimeCheckConfig_TcpCheck&& from) noexcept
    : UptimeCheckConfig_TcpCheck() {
    *this = ::std::move(from);
  }

  inline UptimeCheckConfig_TcpCheck& operator=(const UptimeCheckConfig_TcpCheck& from) {
    CopyFrom(from);
    return *this;
  }
  inline UptimeCheckConfig_TcpCheck& operator=(UptimeCheckConfig_TcpCheck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UptimeCheckConfig_TcpCheck& default_instance() {
    return *internal_default_instance();
  }
  static inline const UptimeCheckConfig_TcpCheck* internal_default_instance() {
    return reinterpret_cast<const UptimeCheckConfig_TcpCheck*>(
               &_UptimeCheckConfig_TcpCheck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UptimeCheckConfig_TcpCheck& a, UptimeCheckConfig_TcpCheck& b) {
    a.Swap(&b);
  }
  inline void Swap(UptimeCheckConfig_TcpCheck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UptimeCheckConfig_TcpCheck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UptimeCheckConfig_TcpCheck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UptimeCheckConfig_TcpCheck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UptimeCheckConfig_TcpCheck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UptimeCheckConfig_TcpCheck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UptimeCheckConfig_TcpCheck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.UptimeCheckConfig.TcpCheck";
  }
  protected:
  explicit UptimeCheckConfig_TcpCheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortFieldNumber = 1,
  };
  // int32 port = 1;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.UptimeCheckConfig.TcpCheck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fuptime_2eproto;
};
// -------------------------------------------------------------------

class UptimeCheckConfig_ContentMatcher final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.UptimeCheckConfig.ContentMatcher) */ {
 public:
  inline UptimeCheckConfig_ContentMatcher() : UptimeCheckConfig_ContentMatcher(nullptr) {}
  ~UptimeCheckConfig_ContentMatcher() override;
  explicit constexpr UptimeCheckConfig_ContentMatcher(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UptimeCheckConfig_ContentMatcher(const UptimeCheckConfig_ContentMatcher& from);
  UptimeCheckConfig_ContentMatcher(UptimeCheckConfig_ContentMatcher&& from) noexcept
    : UptimeCheckConfig_ContentMatcher() {
    *this = ::std::move(from);
  }

  inline UptimeCheckConfig_ContentMatcher& operator=(const UptimeCheckConfig_ContentMatcher& from) {
    CopyFrom(from);
    return *this;
  }
  inline UptimeCheckConfig_ContentMatcher& operator=(UptimeCheckConfig_ContentMatcher&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UptimeCheckConfig_ContentMatcher& default_instance() {
    return *internal_default_instance();
  }
  static inline const UptimeCheckConfig_ContentMatcher* internal_default_instance() {
    return reinterpret_cast<const UptimeCheckConfig_ContentMatcher*>(
               &_UptimeCheckConfig_ContentMatcher_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UptimeCheckConfig_ContentMatcher& a, UptimeCheckConfig_ContentMatcher& b) {
    a.Swap(&b);
  }
  inline void Swap(UptimeCheckConfig_ContentMatcher* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UptimeCheckConfig_ContentMatcher* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UptimeCheckConfig_ContentMatcher* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UptimeCheckConfig_ContentMatcher>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UptimeCheckConfig_ContentMatcher& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UptimeCheckConfig_ContentMatcher& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UptimeCheckConfig_ContentMatcher* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.UptimeCheckConfig.ContentMatcher";
  }
  protected:
  explicit UptimeCheckConfig_ContentMatcher(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UptimeCheckConfig_ContentMatcher_ContentMatcherOption ContentMatcherOption;
  static constexpr ContentMatcherOption CONTENT_MATCHER_OPTION_UNSPECIFIED =
    UptimeCheckConfig_ContentMatcher_ContentMatcherOption_CONTENT_MATCHER_OPTION_UNSPECIFIED;
  static constexpr ContentMatcherOption CONTAINS_STRING =
    UptimeCheckConfig_ContentMatcher_ContentMatcherOption_CONTAINS_STRING;
  static constexpr ContentMatcherOption NOT_CONTAINS_STRING =
    UptimeCheckConfig_ContentMatcher_ContentMatcherOption_NOT_CONTAINS_STRING;
  static constexpr ContentMatcherOption MATCHES_REGEX =
    UptimeCheckConfig_ContentMatcher_ContentMatcherOption_MATCHES_REGEX;
  static constexpr ContentMatcherOption NOT_MATCHES_REGEX =
    UptimeCheckConfig_ContentMatcher_ContentMatcherOption_NOT_MATCHES_REGEX;
  static inline bool ContentMatcherOption_IsValid(int value) {
    return UptimeCheckConfig_ContentMatcher_ContentMatcherOption_IsValid(value);
  }
  static constexpr ContentMatcherOption ContentMatcherOption_MIN =
    UptimeCheckConfig_ContentMatcher_ContentMatcherOption_ContentMatcherOption_MIN;
  static constexpr ContentMatcherOption ContentMatcherOption_MAX =
    UptimeCheckConfig_ContentMatcher_ContentMatcherOption_ContentMatcherOption_MAX;
  static constexpr int ContentMatcherOption_ARRAYSIZE =
    UptimeCheckConfig_ContentMatcher_ContentMatcherOption_ContentMatcherOption_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ContentMatcherOption_descriptor() {
    return UptimeCheckConfig_ContentMatcher_ContentMatcherOption_descriptor();
  }
  template<typename T>
  static inline const std::string& ContentMatcherOption_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ContentMatcherOption>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ContentMatcherOption_Name.");
    return UptimeCheckConfig_ContentMatcher_ContentMatcherOption_Name(enum_t_value);
  }
  static inline bool ContentMatcherOption_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ContentMatcherOption* value) {
    return UptimeCheckConfig_ContentMatcher_ContentMatcherOption_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
    kMatcherFieldNumber = 2,
  };
  // string content = 1;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // .google.monitoring.v3.UptimeCheckConfig.ContentMatcher.ContentMatcherOption matcher = 2;
  void clear_matcher();
  ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher_ContentMatcherOption matcher() const;
  void set_matcher(::google::monitoring::v3::UptimeCheckConfig_ContentMatcher_ContentMatcherOption value);
  private:
  ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher_ContentMatcherOption _internal_matcher() const;
  void _internal_set_matcher(::google::monitoring::v3::UptimeCheckConfig_ContentMatcher_ContentMatcherOption value);
  public:

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.UptimeCheckConfig.ContentMatcher)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  int matcher_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fuptime_2eproto;
};
// -------------------------------------------------------------------

class UptimeCheckConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.UptimeCheckConfig) */ {
 public:
  inline UptimeCheckConfig() : UptimeCheckConfig(nullptr) {}
  ~UptimeCheckConfig() override;
  explicit constexpr UptimeCheckConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UptimeCheckConfig(const UptimeCheckConfig& from);
  UptimeCheckConfig(UptimeCheckConfig&& from) noexcept
    : UptimeCheckConfig() {
    *this = ::std::move(from);
  }

  inline UptimeCheckConfig& operator=(const UptimeCheckConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline UptimeCheckConfig& operator=(UptimeCheckConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UptimeCheckConfig& default_instance() {
    return *internal_default_instance();
  }
  enum ResourceCase {
    kMonitoredResource = 3,
    kResourceGroup = 4,
    RESOURCE_NOT_SET = 0,
  };

  enum CheckRequestTypeCase {
    kHttpCheck = 5,
    kTcpCheck = 6,
    CHECK_REQUEST_TYPE_NOT_SET = 0,
  };

  static inline const UptimeCheckConfig* internal_default_instance() {
    return reinterpret_cast<const UptimeCheckConfig*>(
               &_UptimeCheckConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UptimeCheckConfig& a, UptimeCheckConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(UptimeCheckConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UptimeCheckConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UptimeCheckConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UptimeCheckConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UptimeCheckConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UptimeCheckConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UptimeCheckConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.UptimeCheckConfig";
  }
  protected:
  explicit UptimeCheckConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UptimeCheckConfig_ResourceGroup ResourceGroup;
  typedef UptimeCheckConfig_HttpCheck HttpCheck;
  typedef UptimeCheckConfig_TcpCheck TcpCheck;
  typedef UptimeCheckConfig_ContentMatcher ContentMatcher;

  // accessors -------------------------------------------------------

  enum : int {
    kContentMatchersFieldNumber = 9,
    kSelectedRegionsFieldNumber = 10,
    kInternalCheckersFieldNumber = 14,
    kNameFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kPeriodFieldNumber = 7,
    kTimeoutFieldNumber = 8,
    kIsInternalFieldNumber = 15,
    kMonitoredResourceFieldNumber = 3,
    kResourceGroupFieldNumber = 4,
    kHttpCheckFieldNumber = 5,
    kTcpCheckFieldNumber = 6,
  };
  // repeated .google.monitoring.v3.UptimeCheckConfig.ContentMatcher content_matchers = 9;
  int content_matchers_size() const;
  private:
  int _internal_content_matchers_size() const;
  public:
  void clear_content_matchers();
  ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher* mutable_content_matchers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher >*
      mutable_content_matchers();
  private:
  const ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher& _internal_content_matchers(int index) const;
  ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher* _internal_add_content_matchers();
  public:
  const ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher& content_matchers(int index) const;
  ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher* add_content_matchers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher >&
      content_matchers() const;

  // repeated .google.monitoring.v3.UptimeCheckRegion selected_regions = 10;
  int selected_regions_size() const;
  private:
  int _internal_selected_regions_size() const;
  public:
  void clear_selected_regions();
  private:
  ::google::monitoring::v3::UptimeCheckRegion _internal_selected_regions(int index) const;
  void _internal_add_selected_regions(::google::monitoring::v3::UptimeCheckRegion value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_selected_regions();
  public:
  ::google::monitoring::v3::UptimeCheckRegion selected_regions(int index) const;
  void set_selected_regions(int index, ::google::monitoring::v3::UptimeCheckRegion value);
  void add_selected_regions(::google::monitoring::v3::UptimeCheckRegion value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& selected_regions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_selected_regions();

  // repeated .google.monitoring.v3.InternalChecker internal_checkers = 14 [deprecated = true];
  PROTOBUF_DEPRECATED int internal_checkers_size() const;
  private:
  int _internal_internal_checkers_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_internal_checkers();
  PROTOBUF_DEPRECATED ::google::monitoring::v3::InternalChecker* mutable_internal_checkers(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::monitoring::v3::InternalChecker >*
      mutable_internal_checkers();
  private:
  const ::google::monitoring::v3::InternalChecker& _internal_internal_checkers(int index) const;
  ::google::monitoring::v3::InternalChecker* _internal_add_internal_checkers();
  public:
  PROTOBUF_DEPRECATED const ::google::monitoring::v3::InternalChecker& internal_checkers(int index) const;
  PROTOBUF_DEPRECATED ::google::monitoring::v3::InternalChecker* add_internal_checkers();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::monitoring::v3::InternalChecker >&
      internal_checkers() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string display_name = 2;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // .google.protobuf.Duration period = 7;
  bool has_period() const;
  private:
  bool _internal_has_period() const;
  public:
  void clear_period();
  const ::PROTOBUF_NAMESPACE_ID::Duration& period() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_period();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_period();
  void set_allocated_period(::PROTOBUF_NAMESPACE_ID::Duration* period);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_period() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_period();
  public:
  void unsafe_arena_set_allocated_period(
      ::PROTOBUF_NAMESPACE_ID::Duration* period);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_period();

  // .google.protobuf.Duration timeout = 8;
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_timeout();
  void set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_timeout();
  public:
  void unsafe_arena_set_allocated_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_timeout();

  // bool is_internal = 15 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_is_internal();
  PROTOBUF_DEPRECATED bool is_internal() const;
  PROTOBUF_DEPRECATED void set_is_internal(bool value);
  private:
  bool _internal_is_internal() const;
  void _internal_set_is_internal(bool value);
  public:

  // .google.api.MonitoredResource monitored_resource = 3;
  bool has_monitored_resource() const;
  private:
  bool _internal_has_monitored_resource() const;
  public:
  void clear_monitored_resource();
  const ::google::api::MonitoredResource& monitored_resource() const;
  PROTOBUF_NODISCARD ::google::api::MonitoredResource* release_monitored_resource();
  ::google::api::MonitoredResource* mutable_monitored_resource();
  void set_allocated_monitored_resource(::google::api::MonitoredResource* monitored_resource);
  private:
  const ::google::api::MonitoredResource& _internal_monitored_resource() const;
  ::google::api::MonitoredResource* _internal_mutable_monitored_resource();
  public:
  void unsafe_arena_set_allocated_monitored_resource(
      ::google::api::MonitoredResource* monitored_resource);
  ::google::api::MonitoredResource* unsafe_arena_release_monitored_resource();

  // .google.monitoring.v3.UptimeCheckConfig.ResourceGroup resource_group = 4;
  bool has_resource_group() const;
  private:
  bool _internal_has_resource_group() const;
  public:
  void clear_resource_group();
  const ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup& resource_group() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* release_resource_group();
  ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* mutable_resource_group();
  void set_allocated_resource_group(::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* resource_group);
  private:
  const ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup& _internal_resource_group() const;
  ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* _internal_mutable_resource_group();
  public:
  void unsafe_arena_set_allocated_resource_group(
      ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* resource_group);
  ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* unsafe_arena_release_resource_group();

  // .google.monitoring.v3.UptimeCheckConfig.HttpCheck http_check = 5;
  bool has_http_check() const;
  private:
  bool _internal_has_http_check() const;
  public:
  void clear_http_check();
  const ::google::monitoring::v3::UptimeCheckConfig_HttpCheck& http_check() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::UptimeCheckConfig_HttpCheck* release_http_check();
  ::google::monitoring::v3::UptimeCheckConfig_HttpCheck* mutable_http_check();
  void set_allocated_http_check(::google::monitoring::v3::UptimeCheckConfig_HttpCheck* http_check);
  private:
  const ::google::monitoring::v3::UptimeCheckConfig_HttpCheck& _internal_http_check() const;
  ::google::monitoring::v3::UptimeCheckConfig_HttpCheck* _internal_mutable_http_check();
  public:
  void unsafe_arena_set_allocated_http_check(
      ::google::monitoring::v3::UptimeCheckConfig_HttpCheck* http_check);
  ::google::monitoring::v3::UptimeCheckConfig_HttpCheck* unsafe_arena_release_http_check();

  // .google.monitoring.v3.UptimeCheckConfig.TcpCheck tcp_check = 6;
  bool has_tcp_check() const;
  private:
  bool _internal_has_tcp_check() const;
  public:
  void clear_tcp_check();
  const ::google::monitoring::v3::UptimeCheckConfig_TcpCheck& tcp_check() const;
  PROTOBUF_NODISCARD ::google::monitoring::v3::UptimeCheckConfig_TcpCheck* release_tcp_check();
  ::google::monitoring::v3::UptimeCheckConfig_TcpCheck* mutable_tcp_check();
  void set_allocated_tcp_check(::google::monitoring::v3::UptimeCheckConfig_TcpCheck* tcp_check);
  private:
  const ::google::monitoring::v3::UptimeCheckConfig_TcpCheck& _internal_tcp_check() const;
  ::google::monitoring::v3::UptimeCheckConfig_TcpCheck* _internal_mutable_tcp_check();
  public:
  void unsafe_arena_set_allocated_tcp_check(
      ::google::monitoring::v3::UptimeCheckConfig_TcpCheck* tcp_check);
  ::google::monitoring::v3::UptimeCheckConfig_TcpCheck* unsafe_arena_release_tcp_check();

  void clear_resource();
  ResourceCase resource_case() const;
  void clear_check_request_type();
  CheckRequestTypeCase check_request_type_case() const;
  // @@protoc_insertion_point(class_scope:google.monitoring.v3.UptimeCheckConfig)
 private:
  class _Internal;
  void set_has_monitored_resource();
  void set_has_resource_group();
  void set_has_http_check();
  void set_has_tcp_check();

  inline bool has_resource() const;
  inline void clear_has_resource();

  inline bool has_check_request_type() const;
  inline void clear_has_check_request_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher > content_matchers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> selected_regions_;
  mutable std::atomic<int> _selected_regions_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::monitoring::v3::InternalChecker > internal_checkers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
  ::PROTOBUF_NAMESPACE_ID::Duration* period_;
  ::PROTOBUF_NAMESPACE_ID::Duration* timeout_;
  bool is_internal_;
  union ResourceUnion {
    constexpr ResourceUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::google::api::MonitoredResource* monitored_resource_;
    ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* resource_group_;
  } resource_;
  union CheckRequestTypeUnion {
    constexpr CheckRequestTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::google::monitoring::v3::UptimeCheckConfig_HttpCheck* http_check_;
    ::google::monitoring::v3::UptimeCheckConfig_TcpCheck* tcp_check_;
  } check_request_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[2];

  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fuptime_2eproto;
};
// -------------------------------------------------------------------

class UptimeCheckIp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.monitoring.v3.UptimeCheckIp) */ {
 public:
  inline UptimeCheckIp() : UptimeCheckIp(nullptr) {}
  ~UptimeCheckIp() override;
  explicit constexpr UptimeCheckIp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UptimeCheckIp(const UptimeCheckIp& from);
  UptimeCheckIp(UptimeCheckIp&& from) noexcept
    : UptimeCheckIp() {
    *this = ::std::move(from);
  }

  inline UptimeCheckIp& operator=(const UptimeCheckIp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UptimeCheckIp& operator=(UptimeCheckIp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UptimeCheckIp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UptimeCheckIp* internal_default_instance() {
    return reinterpret_cast<const UptimeCheckIp*>(
               &_UptimeCheckIp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UptimeCheckIp& a, UptimeCheckIp& b) {
    a.Swap(&b);
  }
  inline void Swap(UptimeCheckIp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UptimeCheckIp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UptimeCheckIp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UptimeCheckIp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UptimeCheckIp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UptimeCheckIp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UptimeCheckIp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.monitoring.v3.UptimeCheckIp";
  }
  protected:
  explicit UptimeCheckIp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 2,
    kIpAddressFieldNumber = 3,
    kRegionFieldNumber = 1,
  };
  // string location = 2;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // string ip_address = 3;
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // .google.monitoring.v3.UptimeCheckRegion region = 1;
  void clear_region();
  ::google::monitoring::v3::UptimeCheckRegion region() const;
  void set_region(::google::monitoring::v3::UptimeCheckRegion value);
  private:
  ::google::monitoring::v3::UptimeCheckRegion _internal_region() const;
  void _internal_set_region(::google::monitoring::v3::UptimeCheckRegion value);
  public:

  // @@protoc_insertion_point(class_scope:google.monitoring.v3.UptimeCheckIp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
  int region_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_google_2fmonitoring_2fv3_2fuptime_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InternalChecker

// string name = 1;
inline void InternalChecker::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& InternalChecker::name() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.InternalChecker.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternalChecker::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.InternalChecker.name)
}
inline std::string* InternalChecker::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.InternalChecker.name)
  return _s;
}
inline const std::string& InternalChecker::_internal_name() const {
  return name_.Get();
}
inline void InternalChecker::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InternalChecker::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InternalChecker::release_name() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.InternalChecker.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InternalChecker::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.InternalChecker.name)
}

// string display_name = 2;
inline void InternalChecker::clear_display_name() {
  display_name_.ClearToEmpty();
}
inline const std::string& InternalChecker::display_name() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.InternalChecker.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternalChecker::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.InternalChecker.display_name)
}
inline std::string* InternalChecker::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.InternalChecker.display_name)
  return _s;
}
inline const std::string& InternalChecker::_internal_display_name() const {
  return display_name_.Get();
}
inline void InternalChecker::_internal_set_display_name(const std::string& value) {
  
  display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InternalChecker::_internal_mutable_display_name() {
  
  return display_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InternalChecker::release_display_name() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.InternalChecker.display_name)
  return display_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InternalChecker::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  display_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), display_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (display_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    display_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.InternalChecker.display_name)
}

// string network = 3;
inline void InternalChecker::clear_network() {
  network_.ClearToEmpty();
}
inline const std::string& InternalChecker::network() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.InternalChecker.network)
  return _internal_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternalChecker::set_network(ArgT0&& arg0, ArgT... args) {
 
 network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.InternalChecker.network)
}
inline std::string* InternalChecker::mutable_network() {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.InternalChecker.network)
  return _s;
}
inline const std::string& InternalChecker::_internal_network() const {
  return network_.Get();
}
inline void InternalChecker::_internal_set_network(const std::string& value) {
  
  network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InternalChecker::_internal_mutable_network() {
  
  return network_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InternalChecker::release_network() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.InternalChecker.network)
  return network_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InternalChecker::set_allocated_network(std::string* network) {
  if (network != nullptr) {
    
  } else {
    
  }
  network_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), network,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (network_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    network_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.InternalChecker.network)
}

// string gcp_zone = 4;
inline void InternalChecker::clear_gcp_zone() {
  gcp_zone_.ClearToEmpty();
}
inline const std::string& InternalChecker::gcp_zone() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.InternalChecker.gcp_zone)
  return _internal_gcp_zone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternalChecker::set_gcp_zone(ArgT0&& arg0, ArgT... args) {
 
 gcp_zone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.InternalChecker.gcp_zone)
}
inline std::string* InternalChecker::mutable_gcp_zone() {
  std::string* _s = _internal_mutable_gcp_zone();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.InternalChecker.gcp_zone)
  return _s;
}
inline const std::string& InternalChecker::_internal_gcp_zone() const {
  return gcp_zone_.Get();
}
inline void InternalChecker::_internal_set_gcp_zone(const std::string& value) {
  
  gcp_zone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InternalChecker::_internal_mutable_gcp_zone() {
  
  return gcp_zone_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InternalChecker::release_gcp_zone() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.InternalChecker.gcp_zone)
  return gcp_zone_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InternalChecker::set_allocated_gcp_zone(std::string* gcp_zone) {
  if (gcp_zone != nullptr) {
    
  } else {
    
  }
  gcp_zone_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gcp_zone,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gcp_zone_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gcp_zone_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.InternalChecker.gcp_zone)
}

// string peer_project_id = 6;
inline void InternalChecker::clear_peer_project_id() {
  peer_project_id_.ClearToEmpty();
}
inline const std::string& InternalChecker::peer_project_id() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.InternalChecker.peer_project_id)
  return _internal_peer_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternalChecker::set_peer_project_id(ArgT0&& arg0, ArgT... args) {
 
 peer_project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.InternalChecker.peer_project_id)
}
inline std::string* InternalChecker::mutable_peer_project_id() {
  std::string* _s = _internal_mutable_peer_project_id();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.InternalChecker.peer_project_id)
  return _s;
}
inline const std::string& InternalChecker::_internal_peer_project_id() const {
  return peer_project_id_.Get();
}
inline void InternalChecker::_internal_set_peer_project_id(const std::string& value) {
  
  peer_project_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InternalChecker::_internal_mutable_peer_project_id() {
  
  return peer_project_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InternalChecker::release_peer_project_id() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.InternalChecker.peer_project_id)
  return peer_project_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InternalChecker::set_allocated_peer_project_id(std::string* peer_project_id) {
  if (peer_project_id != nullptr) {
    
  } else {
    
  }
  peer_project_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer_project_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_project_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_project_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.InternalChecker.peer_project_id)
}

// .google.monitoring.v3.InternalChecker.State state = 7;
inline void InternalChecker::clear_state() {
  state_ = 0;
}
inline ::google::monitoring::v3::InternalChecker_State InternalChecker::_internal_state() const {
  return static_cast< ::google::monitoring::v3::InternalChecker_State >(state_);
}
inline ::google::monitoring::v3::InternalChecker_State InternalChecker::state() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.InternalChecker.state)
  return _internal_state();
}
inline void InternalChecker::_internal_set_state(::google::monitoring::v3::InternalChecker_State value) {
  
  state_ = value;
}
inline void InternalChecker::set_state(::google::monitoring::v3::InternalChecker_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.InternalChecker.state)
}

// -------------------------------------------------------------------

// UptimeCheckConfig_ResourceGroup

// string group_id = 1;
inline void UptimeCheckConfig_ResourceGroup::clear_group_id() {
  group_id_.ClearToEmpty();
}
inline const std::string& UptimeCheckConfig_ResourceGroup::group_id() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.ResourceGroup.group_id)
  return _internal_group_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UptimeCheckConfig_ResourceGroup::set_group_id(ArgT0&& arg0, ArgT... args) {
 
 group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.ResourceGroup.group_id)
}
inline std::string* UptimeCheckConfig_ResourceGroup::mutable_group_id() {
  std::string* _s = _internal_mutable_group_id();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.ResourceGroup.group_id)
  return _s;
}
inline const std::string& UptimeCheckConfig_ResourceGroup::_internal_group_id() const {
  return group_id_.Get();
}
inline void UptimeCheckConfig_ResourceGroup::_internal_set_group_id(const std::string& value) {
  
  group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig_ResourceGroup::_internal_mutable_group_id() {
  
  return group_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig_ResourceGroup::release_group_id() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckConfig.ResourceGroup.group_id)
  return group_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UptimeCheckConfig_ResourceGroup::set_allocated_group_id(std::string* group_id) {
  if (group_id != nullptr) {
    
  } else {
    
  }
  group_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.UptimeCheckConfig.ResourceGroup.group_id)
}

// .google.monitoring.v3.GroupResourceType resource_type = 2;
inline void UptimeCheckConfig_ResourceGroup::clear_resource_type() {
  resource_type_ = 0;
}
inline ::google::monitoring::v3::GroupResourceType UptimeCheckConfig_ResourceGroup::_internal_resource_type() const {
  return static_cast< ::google::monitoring::v3::GroupResourceType >(resource_type_);
}
inline ::google::monitoring::v3::GroupResourceType UptimeCheckConfig_ResourceGroup::resource_type() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.ResourceGroup.resource_type)
  return _internal_resource_type();
}
inline void UptimeCheckConfig_ResourceGroup::_internal_set_resource_type(::google::monitoring::v3::GroupResourceType value) {
  
  resource_type_ = value;
}
inline void UptimeCheckConfig_ResourceGroup::set_resource_type(::google::monitoring::v3::GroupResourceType value) {
  _internal_set_resource_type(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.ResourceGroup.resource_type)
}

// -------------------------------------------------------------------

// UptimeCheckConfig_HttpCheck_BasicAuthentication

// string username = 1;
inline void UptimeCheckConfig_HttpCheck_BasicAuthentication::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& UptimeCheckConfig_HttpCheck_BasicAuthentication::username() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UptimeCheckConfig_HttpCheck_BasicAuthentication::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication.username)
}
inline std::string* UptimeCheckConfig_HttpCheck_BasicAuthentication::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication.username)
  return _s;
}
inline const std::string& UptimeCheckConfig_HttpCheck_BasicAuthentication::_internal_username() const {
  return username_.Get();
}
inline void UptimeCheckConfig_HttpCheck_BasicAuthentication::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig_HttpCheck_BasicAuthentication::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig_HttpCheck_BasicAuthentication::release_username() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UptimeCheckConfig_HttpCheck_BasicAuthentication::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication.username)
}

// string password = 2;
inline void UptimeCheckConfig_HttpCheck_BasicAuthentication::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& UptimeCheckConfig_HttpCheck_BasicAuthentication::password() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UptimeCheckConfig_HttpCheck_BasicAuthentication::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication.password)
}
inline std::string* UptimeCheckConfig_HttpCheck_BasicAuthentication::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication.password)
  return _s;
}
inline const std::string& UptimeCheckConfig_HttpCheck_BasicAuthentication::_internal_password() const {
  return password_.Get();
}
inline void UptimeCheckConfig_HttpCheck_BasicAuthentication::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig_HttpCheck_BasicAuthentication::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig_HttpCheck_BasicAuthentication::release_password() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UptimeCheckConfig_HttpCheck_BasicAuthentication::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication.password)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UptimeCheckConfig_HttpCheck

// .google.monitoring.v3.UptimeCheckConfig.HttpCheck.RequestMethod request_method = 8;
inline void UptimeCheckConfig_HttpCheck::clear_request_method() {
  request_method_ = 0;
}
inline ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_RequestMethod UptimeCheckConfig_HttpCheck::_internal_request_method() const {
  return static_cast< ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_RequestMethod >(request_method_);
}
inline ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_RequestMethod UptimeCheckConfig_HttpCheck::request_method() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.HttpCheck.request_method)
  return _internal_request_method();
}
inline void UptimeCheckConfig_HttpCheck::_internal_set_request_method(::google::monitoring::v3::UptimeCheckConfig_HttpCheck_RequestMethod value) {
  
  request_method_ = value;
}
inline void UptimeCheckConfig_HttpCheck::set_request_method(::google::monitoring::v3::UptimeCheckConfig_HttpCheck_RequestMethod value) {
  _internal_set_request_method(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.HttpCheck.request_method)
}

// bool use_ssl = 1;
inline void UptimeCheckConfig_HttpCheck::clear_use_ssl() {
  use_ssl_ = false;
}
inline bool UptimeCheckConfig_HttpCheck::_internal_use_ssl() const {
  return use_ssl_;
}
inline bool UptimeCheckConfig_HttpCheck::use_ssl() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.HttpCheck.use_ssl)
  return _internal_use_ssl();
}
inline void UptimeCheckConfig_HttpCheck::_internal_set_use_ssl(bool value) {
  
  use_ssl_ = value;
}
inline void UptimeCheckConfig_HttpCheck::set_use_ssl(bool value) {
  _internal_set_use_ssl(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.HttpCheck.use_ssl)
}

// string path = 2;
inline void UptimeCheckConfig_HttpCheck::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& UptimeCheckConfig_HttpCheck::path() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.HttpCheck.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UptimeCheckConfig_HttpCheck::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.HttpCheck.path)
}
inline std::string* UptimeCheckConfig_HttpCheck::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.HttpCheck.path)
  return _s;
}
inline const std::string& UptimeCheckConfig_HttpCheck::_internal_path() const {
  return path_.Get();
}
inline void UptimeCheckConfig_HttpCheck::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig_HttpCheck::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig_HttpCheck::release_path() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckConfig.HttpCheck.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UptimeCheckConfig_HttpCheck::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.UptimeCheckConfig.HttpCheck.path)
}

// int32 port = 3;
inline void UptimeCheckConfig_HttpCheck::clear_port() {
  port_ = 0;
}
inline int32_t UptimeCheckConfig_HttpCheck::_internal_port() const {
  return port_;
}
inline int32_t UptimeCheckConfig_HttpCheck::port() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.HttpCheck.port)
  return _internal_port();
}
inline void UptimeCheckConfig_HttpCheck::_internal_set_port(int32_t value) {
  
  port_ = value;
}
inline void UptimeCheckConfig_HttpCheck::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.HttpCheck.port)
}

// .google.monitoring.v3.UptimeCheckConfig.HttpCheck.BasicAuthentication auth_info = 4;
inline bool UptimeCheckConfig_HttpCheck::_internal_has_auth_info() const {
  return this != internal_default_instance() && auth_info_ != nullptr;
}
inline bool UptimeCheckConfig_HttpCheck::has_auth_info() const {
  return _internal_has_auth_info();
}
inline void UptimeCheckConfig_HttpCheck::clear_auth_info() {
  if (GetArenaForAllocation() == nullptr && auth_info_ != nullptr) {
    delete auth_info_;
  }
  auth_info_ = nullptr;
}
inline const ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication& UptimeCheckConfig_HttpCheck::_internal_auth_info() const {
  const ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* p = auth_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication&>(
      ::google::monitoring::v3::_UptimeCheckConfig_HttpCheck_BasicAuthentication_default_instance_);
}
inline const ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication& UptimeCheckConfig_HttpCheck::auth_info() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.HttpCheck.auth_info)
  return _internal_auth_info();
}
inline void UptimeCheckConfig_HttpCheck::unsafe_arena_set_allocated_auth_info(
    ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* auth_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auth_info_);
  }
  auth_info_ = auth_info;
  if (auth_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.UptimeCheckConfig.HttpCheck.auth_info)
}
inline ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* UptimeCheckConfig_HttpCheck::release_auth_info() {
  
  ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* temp = auth_info_;
  auth_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* UptimeCheckConfig_HttpCheck::unsafe_arena_release_auth_info() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckConfig.HttpCheck.auth_info)
  
  ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* temp = auth_info_;
  auth_info_ = nullptr;
  return temp;
}
inline ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* UptimeCheckConfig_HttpCheck::_internal_mutable_auth_info() {
  
  if (auth_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication>(GetArenaForAllocation());
    auth_info_ = p;
  }
  return auth_info_;
}
inline ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* UptimeCheckConfig_HttpCheck::mutable_auth_info() {
  ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* _msg = _internal_mutable_auth_info();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.HttpCheck.auth_info)
  return _msg;
}
inline void UptimeCheckConfig_HttpCheck::set_allocated_auth_info(::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication* auth_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete auth_info_;
  }
  if (auth_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::google::monitoring::v3::UptimeCheckConfig_HttpCheck_BasicAuthentication>::GetOwningArena(auth_info);
    if (message_arena != submessage_arena) {
      auth_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth_info, submessage_arena);
    }
    
  } else {
    
  }
  auth_info_ = auth_info;
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.UptimeCheckConfig.HttpCheck.auth_info)
}

// bool mask_headers = 5;
inline void UptimeCheckConfig_HttpCheck::clear_mask_headers() {
  mask_headers_ = false;
}
inline bool UptimeCheckConfig_HttpCheck::_internal_mask_headers() const {
  return mask_headers_;
}
inline bool UptimeCheckConfig_HttpCheck::mask_headers() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.HttpCheck.mask_headers)
  return _internal_mask_headers();
}
inline void UptimeCheckConfig_HttpCheck::_internal_set_mask_headers(bool value) {
  
  mask_headers_ = value;
}
inline void UptimeCheckConfig_HttpCheck::set_mask_headers(bool value) {
  _internal_set_mask_headers(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.HttpCheck.mask_headers)
}

// map<string, string> headers = 6;
inline int UptimeCheckConfig_HttpCheck::_internal_headers_size() const {
  return headers_.size();
}
inline int UptimeCheckConfig_HttpCheck::headers_size() const {
  return _internal_headers_size();
}
inline void UptimeCheckConfig_HttpCheck::clear_headers() {
  headers_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UptimeCheckConfig_HttpCheck::_internal_headers() const {
  return headers_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UptimeCheckConfig_HttpCheck::headers() const {
  // @@protoc_insertion_point(field_map:google.monitoring.v3.UptimeCheckConfig.HttpCheck.headers)
  return _internal_headers();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UptimeCheckConfig_HttpCheck::_internal_mutable_headers() {
  return headers_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UptimeCheckConfig_HttpCheck::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_map:google.monitoring.v3.UptimeCheckConfig.HttpCheck.headers)
  return _internal_mutable_headers();
}

// .google.monitoring.v3.UptimeCheckConfig.HttpCheck.ContentType content_type = 9;
inline void UptimeCheckConfig_HttpCheck::clear_content_type() {
  content_type_ = 0;
}
inline ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_ContentType UptimeCheckConfig_HttpCheck::_internal_content_type() const {
  return static_cast< ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_ContentType >(content_type_);
}
inline ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_ContentType UptimeCheckConfig_HttpCheck::content_type() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.HttpCheck.content_type)
  return _internal_content_type();
}
inline void UptimeCheckConfig_HttpCheck::_internal_set_content_type(::google::monitoring::v3::UptimeCheckConfig_HttpCheck_ContentType value) {
  
  content_type_ = value;
}
inline void UptimeCheckConfig_HttpCheck::set_content_type(::google::monitoring::v3::UptimeCheckConfig_HttpCheck_ContentType value) {
  _internal_set_content_type(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.HttpCheck.content_type)
}

// bool validate_ssl = 7;
inline void UptimeCheckConfig_HttpCheck::clear_validate_ssl() {
  validate_ssl_ = false;
}
inline bool UptimeCheckConfig_HttpCheck::_internal_validate_ssl() const {
  return validate_ssl_;
}
inline bool UptimeCheckConfig_HttpCheck::validate_ssl() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.HttpCheck.validate_ssl)
  return _internal_validate_ssl();
}
inline void UptimeCheckConfig_HttpCheck::_internal_set_validate_ssl(bool value) {
  
  validate_ssl_ = value;
}
inline void UptimeCheckConfig_HttpCheck::set_validate_ssl(bool value) {
  _internal_set_validate_ssl(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.HttpCheck.validate_ssl)
}

// bytes body = 10;
inline void UptimeCheckConfig_HttpCheck::clear_body() {
  body_.ClearToEmpty();
}
inline const std::string& UptimeCheckConfig_HttpCheck::body() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.HttpCheck.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UptimeCheckConfig_HttpCheck::set_body(ArgT0&& arg0, ArgT... args) {
 
 body_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.HttpCheck.body)
}
inline std::string* UptimeCheckConfig_HttpCheck::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.HttpCheck.body)
  return _s;
}
inline const std::string& UptimeCheckConfig_HttpCheck::_internal_body() const {
  return body_.Get();
}
inline void UptimeCheckConfig_HttpCheck::_internal_set_body(const std::string& value) {
  
  body_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig_HttpCheck::_internal_mutable_body() {
  
  return body_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig_HttpCheck::release_body() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckConfig.HttpCheck.body)
  return body_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UptimeCheckConfig_HttpCheck::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  body_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), body,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (body_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.UptimeCheckConfig.HttpCheck.body)
}

// -------------------------------------------------------------------

// UptimeCheckConfig_TcpCheck

// int32 port = 1;
inline void UptimeCheckConfig_TcpCheck::clear_port() {
  port_ = 0;
}
inline int32_t UptimeCheckConfig_TcpCheck::_internal_port() const {
  return port_;
}
inline int32_t UptimeCheckConfig_TcpCheck::port() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.TcpCheck.port)
  return _internal_port();
}
inline void UptimeCheckConfig_TcpCheck::_internal_set_port(int32_t value) {
  
  port_ = value;
}
inline void UptimeCheckConfig_TcpCheck::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.TcpCheck.port)
}

// -------------------------------------------------------------------

// UptimeCheckConfig_ContentMatcher

// string content = 1;
inline void UptimeCheckConfig_ContentMatcher::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& UptimeCheckConfig_ContentMatcher::content() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.ContentMatcher.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UptimeCheckConfig_ContentMatcher::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.ContentMatcher.content)
}
inline std::string* UptimeCheckConfig_ContentMatcher::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.ContentMatcher.content)
  return _s;
}
inline const std::string& UptimeCheckConfig_ContentMatcher::_internal_content() const {
  return content_.Get();
}
inline void UptimeCheckConfig_ContentMatcher::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig_ContentMatcher::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig_ContentMatcher::release_content() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckConfig.ContentMatcher.content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UptimeCheckConfig_ContentMatcher::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.UptimeCheckConfig.ContentMatcher.content)
}

// .google.monitoring.v3.UptimeCheckConfig.ContentMatcher.ContentMatcherOption matcher = 2;
inline void UptimeCheckConfig_ContentMatcher::clear_matcher() {
  matcher_ = 0;
}
inline ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher_ContentMatcherOption UptimeCheckConfig_ContentMatcher::_internal_matcher() const {
  return static_cast< ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher_ContentMatcherOption >(matcher_);
}
inline ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher_ContentMatcherOption UptimeCheckConfig_ContentMatcher::matcher() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.ContentMatcher.matcher)
  return _internal_matcher();
}
inline void UptimeCheckConfig_ContentMatcher::_internal_set_matcher(::google::monitoring::v3::UptimeCheckConfig_ContentMatcher_ContentMatcherOption value) {
  
  matcher_ = value;
}
inline void UptimeCheckConfig_ContentMatcher::set_matcher(::google::monitoring::v3::UptimeCheckConfig_ContentMatcher_ContentMatcherOption value) {
  _internal_set_matcher(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.ContentMatcher.matcher)
}

// -------------------------------------------------------------------

// UptimeCheckConfig

// string name = 1;
inline void UptimeCheckConfig::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& UptimeCheckConfig::name() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UptimeCheckConfig::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.name)
}
inline std::string* UptimeCheckConfig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.name)
  return _s;
}
inline const std::string& UptimeCheckConfig::_internal_name() const {
  return name_.Get();
}
inline void UptimeCheckConfig::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig::release_name() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckConfig.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UptimeCheckConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.UptimeCheckConfig.name)
}

// string display_name = 2;
inline void UptimeCheckConfig::clear_display_name() {
  display_name_.ClearToEmpty();
}
inline const std::string& UptimeCheckConfig::display_name() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UptimeCheckConfig::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.display_name)
}
inline std::string* UptimeCheckConfig::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.display_name)
  return _s;
}
inline const std::string& UptimeCheckConfig::_internal_display_name() const {
  return display_name_.Get();
}
inline void UptimeCheckConfig::_internal_set_display_name(const std::string& value) {
  
  display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig::_internal_mutable_display_name() {
  
  return display_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UptimeCheckConfig::release_display_name() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckConfig.display_name)
  return display_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UptimeCheckConfig::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  display_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), display_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (display_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    display_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.UptimeCheckConfig.display_name)
}

// .google.api.MonitoredResource monitored_resource = 3;
inline bool UptimeCheckConfig::_internal_has_monitored_resource() const {
  return resource_case() == kMonitoredResource;
}
inline bool UptimeCheckConfig::has_monitored_resource() const {
  return _internal_has_monitored_resource();
}
inline void UptimeCheckConfig::set_has_monitored_resource() {
  _oneof_case_[0] = kMonitoredResource;
}
inline ::google::api::MonitoredResource* UptimeCheckConfig::release_monitored_resource() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckConfig.monitored_resource)
  if (_internal_has_monitored_resource()) {
    clear_has_resource();
      ::google::api::MonitoredResource* temp = resource_.monitored_resource_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    resource_.monitored_resource_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::api::MonitoredResource& UptimeCheckConfig::_internal_monitored_resource() const {
  return _internal_has_monitored_resource()
      ? *resource_.monitored_resource_
      : reinterpret_cast< ::google::api::MonitoredResource&>(::google::api::_MonitoredResource_default_instance_);
}
inline const ::google::api::MonitoredResource& UptimeCheckConfig::monitored_resource() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.monitored_resource)
  return _internal_monitored_resource();
}
inline ::google::api::MonitoredResource* UptimeCheckConfig::unsafe_arena_release_monitored_resource() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.UptimeCheckConfig.monitored_resource)
  if (_internal_has_monitored_resource()) {
    clear_has_resource();
    ::google::api::MonitoredResource* temp = resource_.monitored_resource_;
    resource_.monitored_resource_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UptimeCheckConfig::unsafe_arena_set_allocated_monitored_resource(::google::api::MonitoredResource* monitored_resource) {
  clear_resource();
  if (monitored_resource) {
    set_has_monitored_resource();
    resource_.monitored_resource_ = monitored_resource;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.UptimeCheckConfig.monitored_resource)
}
inline ::google::api::MonitoredResource* UptimeCheckConfig::_internal_mutable_monitored_resource() {
  if (!_internal_has_monitored_resource()) {
    clear_resource();
    set_has_monitored_resource();
    resource_.monitored_resource_ = CreateMaybeMessage< ::google::api::MonitoredResource >(GetArenaForAllocation());
  }
  return resource_.monitored_resource_;
}
inline ::google::api::MonitoredResource* UptimeCheckConfig::mutable_monitored_resource() {
  ::google::api::MonitoredResource* _msg = _internal_mutable_monitored_resource();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.monitored_resource)
  return _msg;
}

// .google.monitoring.v3.UptimeCheckConfig.ResourceGroup resource_group = 4;
inline bool UptimeCheckConfig::_internal_has_resource_group() const {
  return resource_case() == kResourceGroup;
}
inline bool UptimeCheckConfig::has_resource_group() const {
  return _internal_has_resource_group();
}
inline void UptimeCheckConfig::set_has_resource_group() {
  _oneof_case_[0] = kResourceGroup;
}
inline void UptimeCheckConfig::clear_resource_group() {
  if (_internal_has_resource_group()) {
    if (GetArenaForAllocation() == nullptr) {
      delete resource_.resource_group_;
    }
    clear_has_resource();
  }
}
inline ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* UptimeCheckConfig::release_resource_group() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckConfig.resource_group)
  if (_internal_has_resource_group()) {
    clear_has_resource();
      ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* temp = resource_.resource_group_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    resource_.resource_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup& UptimeCheckConfig::_internal_resource_group() const {
  return _internal_has_resource_group()
      ? *resource_.resource_group_
      : reinterpret_cast< ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup&>(::google::monitoring::v3::_UptimeCheckConfig_ResourceGroup_default_instance_);
}
inline const ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup& UptimeCheckConfig::resource_group() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.resource_group)
  return _internal_resource_group();
}
inline ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* UptimeCheckConfig::unsafe_arena_release_resource_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.UptimeCheckConfig.resource_group)
  if (_internal_has_resource_group()) {
    clear_has_resource();
    ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* temp = resource_.resource_group_;
    resource_.resource_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UptimeCheckConfig::unsafe_arena_set_allocated_resource_group(::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* resource_group) {
  clear_resource();
  if (resource_group) {
    set_has_resource_group();
    resource_.resource_group_ = resource_group;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.UptimeCheckConfig.resource_group)
}
inline ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* UptimeCheckConfig::_internal_mutable_resource_group() {
  if (!_internal_has_resource_group()) {
    clear_resource();
    set_has_resource_group();
    resource_.resource_group_ = CreateMaybeMessage< ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup >(GetArenaForAllocation());
  }
  return resource_.resource_group_;
}
inline ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* UptimeCheckConfig::mutable_resource_group() {
  ::google::monitoring::v3::UptimeCheckConfig_ResourceGroup* _msg = _internal_mutable_resource_group();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.resource_group)
  return _msg;
}

// .google.monitoring.v3.UptimeCheckConfig.HttpCheck http_check = 5;
inline bool UptimeCheckConfig::_internal_has_http_check() const {
  return check_request_type_case() == kHttpCheck;
}
inline bool UptimeCheckConfig::has_http_check() const {
  return _internal_has_http_check();
}
inline void UptimeCheckConfig::set_has_http_check() {
  _oneof_case_[1] = kHttpCheck;
}
inline void UptimeCheckConfig::clear_http_check() {
  if (_internal_has_http_check()) {
    if (GetArenaForAllocation() == nullptr) {
      delete check_request_type_.http_check_;
    }
    clear_has_check_request_type();
  }
}
inline ::google::monitoring::v3::UptimeCheckConfig_HttpCheck* UptimeCheckConfig::release_http_check() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckConfig.http_check)
  if (_internal_has_http_check()) {
    clear_has_check_request_type();
      ::google::monitoring::v3::UptimeCheckConfig_HttpCheck* temp = check_request_type_.http_check_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    check_request_type_.http_check_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::UptimeCheckConfig_HttpCheck& UptimeCheckConfig::_internal_http_check() const {
  return _internal_has_http_check()
      ? *check_request_type_.http_check_
      : reinterpret_cast< ::google::monitoring::v3::UptimeCheckConfig_HttpCheck&>(::google::monitoring::v3::_UptimeCheckConfig_HttpCheck_default_instance_);
}
inline const ::google::monitoring::v3::UptimeCheckConfig_HttpCheck& UptimeCheckConfig::http_check() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.http_check)
  return _internal_http_check();
}
inline ::google::monitoring::v3::UptimeCheckConfig_HttpCheck* UptimeCheckConfig::unsafe_arena_release_http_check() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.UptimeCheckConfig.http_check)
  if (_internal_has_http_check()) {
    clear_has_check_request_type();
    ::google::monitoring::v3::UptimeCheckConfig_HttpCheck* temp = check_request_type_.http_check_;
    check_request_type_.http_check_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UptimeCheckConfig::unsafe_arena_set_allocated_http_check(::google::monitoring::v3::UptimeCheckConfig_HttpCheck* http_check) {
  clear_check_request_type();
  if (http_check) {
    set_has_http_check();
    check_request_type_.http_check_ = http_check;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.UptimeCheckConfig.http_check)
}
inline ::google::monitoring::v3::UptimeCheckConfig_HttpCheck* UptimeCheckConfig::_internal_mutable_http_check() {
  if (!_internal_has_http_check()) {
    clear_check_request_type();
    set_has_http_check();
    check_request_type_.http_check_ = CreateMaybeMessage< ::google::monitoring::v3::UptimeCheckConfig_HttpCheck >(GetArenaForAllocation());
  }
  return check_request_type_.http_check_;
}
inline ::google::monitoring::v3::UptimeCheckConfig_HttpCheck* UptimeCheckConfig::mutable_http_check() {
  ::google::monitoring::v3::UptimeCheckConfig_HttpCheck* _msg = _internal_mutable_http_check();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.http_check)
  return _msg;
}

// .google.monitoring.v3.UptimeCheckConfig.TcpCheck tcp_check = 6;
inline bool UptimeCheckConfig::_internal_has_tcp_check() const {
  return check_request_type_case() == kTcpCheck;
}
inline bool UptimeCheckConfig::has_tcp_check() const {
  return _internal_has_tcp_check();
}
inline void UptimeCheckConfig::set_has_tcp_check() {
  _oneof_case_[1] = kTcpCheck;
}
inline void UptimeCheckConfig::clear_tcp_check() {
  if (_internal_has_tcp_check()) {
    if (GetArenaForAllocation() == nullptr) {
      delete check_request_type_.tcp_check_;
    }
    clear_has_check_request_type();
  }
}
inline ::google::monitoring::v3::UptimeCheckConfig_TcpCheck* UptimeCheckConfig::release_tcp_check() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckConfig.tcp_check)
  if (_internal_has_tcp_check()) {
    clear_has_check_request_type();
      ::google::monitoring::v3::UptimeCheckConfig_TcpCheck* temp = check_request_type_.tcp_check_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    check_request_type_.tcp_check_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::monitoring::v3::UptimeCheckConfig_TcpCheck& UptimeCheckConfig::_internal_tcp_check() const {
  return _internal_has_tcp_check()
      ? *check_request_type_.tcp_check_
      : reinterpret_cast< ::google::monitoring::v3::UptimeCheckConfig_TcpCheck&>(::google::monitoring::v3::_UptimeCheckConfig_TcpCheck_default_instance_);
}
inline const ::google::monitoring::v3::UptimeCheckConfig_TcpCheck& UptimeCheckConfig::tcp_check() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.tcp_check)
  return _internal_tcp_check();
}
inline ::google::monitoring::v3::UptimeCheckConfig_TcpCheck* UptimeCheckConfig::unsafe_arena_release_tcp_check() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.monitoring.v3.UptimeCheckConfig.tcp_check)
  if (_internal_has_tcp_check()) {
    clear_has_check_request_type();
    ::google::monitoring::v3::UptimeCheckConfig_TcpCheck* temp = check_request_type_.tcp_check_;
    check_request_type_.tcp_check_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UptimeCheckConfig::unsafe_arena_set_allocated_tcp_check(::google::monitoring::v3::UptimeCheckConfig_TcpCheck* tcp_check) {
  clear_check_request_type();
  if (tcp_check) {
    set_has_tcp_check();
    check_request_type_.tcp_check_ = tcp_check;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.UptimeCheckConfig.tcp_check)
}
inline ::google::monitoring::v3::UptimeCheckConfig_TcpCheck* UptimeCheckConfig::_internal_mutable_tcp_check() {
  if (!_internal_has_tcp_check()) {
    clear_check_request_type();
    set_has_tcp_check();
    check_request_type_.tcp_check_ = CreateMaybeMessage< ::google::monitoring::v3::UptimeCheckConfig_TcpCheck >(GetArenaForAllocation());
  }
  return check_request_type_.tcp_check_;
}
inline ::google::monitoring::v3::UptimeCheckConfig_TcpCheck* UptimeCheckConfig::mutable_tcp_check() {
  ::google::monitoring::v3::UptimeCheckConfig_TcpCheck* _msg = _internal_mutable_tcp_check();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.tcp_check)
  return _msg;
}

// .google.protobuf.Duration period = 7;
inline bool UptimeCheckConfig::_internal_has_period() const {
  return this != internal_default_instance() && period_ != nullptr;
}
inline bool UptimeCheckConfig::has_period() const {
  return _internal_has_period();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& UptimeCheckConfig::_internal_period() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = period_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& UptimeCheckConfig::period() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.period)
  return _internal_period();
}
inline void UptimeCheckConfig::unsafe_arena_set_allocated_period(
    ::PROTOBUF_NAMESPACE_ID::Duration* period) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(period_);
  }
  period_ = period;
  if (period) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.UptimeCheckConfig.period)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UptimeCheckConfig::release_period() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = period_;
  period_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UptimeCheckConfig::unsafe_arena_release_period() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckConfig.period)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = period_;
  period_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UptimeCheckConfig::_internal_mutable_period() {
  
  if (period_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    period_ = p;
  }
  return period_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UptimeCheckConfig::mutable_period() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_period();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.period)
  return _msg;
}
inline void UptimeCheckConfig::set_allocated_period(::PROTOBUF_NAMESPACE_ID::Duration* period) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(period_);
  }
  if (period) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(period));
    if (message_arena != submessage_arena) {
      period = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, period, submessage_arena);
    }
    
  } else {
    
  }
  period_ = period;
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.UptimeCheckConfig.period)
}

// .google.protobuf.Duration timeout = 8;
inline bool UptimeCheckConfig::_internal_has_timeout() const {
  return this != internal_default_instance() && timeout_ != nullptr;
}
inline bool UptimeCheckConfig::has_timeout() const {
  return _internal_has_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& UptimeCheckConfig::_internal_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& UptimeCheckConfig::timeout() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.timeout)
  return _internal_timeout();
}
inline void UptimeCheckConfig::unsafe_arena_set_allocated_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout_);
  }
  timeout_ = timeout;
  if (timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.monitoring.v3.UptimeCheckConfig.timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UptimeCheckConfig::release_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = timeout_;
  timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UptimeCheckConfig::unsafe_arena_release_timeout() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckConfig.timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = timeout_;
  timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UptimeCheckConfig::_internal_mutable_timeout() {
  
  if (timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    timeout_ = p;
  }
  return timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UptimeCheckConfig::mutable_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_timeout();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.timeout)
  return _msg;
}
inline void UptimeCheckConfig::set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout_);
  }
  if (timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout));
    if (message_arena != submessage_arena) {
      timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timeout, submessage_arena);
    }
    
  } else {
    
  }
  timeout_ = timeout;
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.UptimeCheckConfig.timeout)
}

// repeated .google.monitoring.v3.UptimeCheckConfig.ContentMatcher content_matchers = 9;
inline int UptimeCheckConfig::_internal_content_matchers_size() const {
  return content_matchers_.size();
}
inline int UptimeCheckConfig::content_matchers_size() const {
  return _internal_content_matchers_size();
}
inline void UptimeCheckConfig::clear_content_matchers() {
  content_matchers_.Clear();
}
inline ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher* UptimeCheckConfig::mutable_content_matchers(int index) {
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.content_matchers)
  return content_matchers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher >*
UptimeCheckConfig::mutable_content_matchers() {
  // @@protoc_insertion_point(field_mutable_list:google.monitoring.v3.UptimeCheckConfig.content_matchers)
  return &content_matchers_;
}
inline const ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher& UptimeCheckConfig::_internal_content_matchers(int index) const {
  return content_matchers_.Get(index);
}
inline const ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher& UptimeCheckConfig::content_matchers(int index) const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.content_matchers)
  return _internal_content_matchers(index);
}
inline ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher* UptimeCheckConfig::_internal_add_content_matchers() {
  return content_matchers_.Add();
}
inline ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher* UptimeCheckConfig::add_content_matchers() {
  ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher* _add = _internal_add_content_matchers();
  // @@protoc_insertion_point(field_add:google.monitoring.v3.UptimeCheckConfig.content_matchers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher >&
UptimeCheckConfig::content_matchers() const {
  // @@protoc_insertion_point(field_list:google.monitoring.v3.UptimeCheckConfig.content_matchers)
  return content_matchers_;
}

// repeated .google.monitoring.v3.UptimeCheckRegion selected_regions = 10;
inline int UptimeCheckConfig::_internal_selected_regions_size() const {
  return selected_regions_.size();
}
inline int UptimeCheckConfig::selected_regions_size() const {
  return _internal_selected_regions_size();
}
inline void UptimeCheckConfig::clear_selected_regions() {
  selected_regions_.Clear();
}
inline ::google::monitoring::v3::UptimeCheckRegion UptimeCheckConfig::_internal_selected_regions(int index) const {
  return static_cast< ::google::monitoring::v3::UptimeCheckRegion >(selected_regions_.Get(index));
}
inline ::google::monitoring::v3::UptimeCheckRegion UptimeCheckConfig::selected_regions(int index) const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.selected_regions)
  return _internal_selected_regions(index);
}
inline void UptimeCheckConfig::set_selected_regions(int index, ::google::monitoring::v3::UptimeCheckRegion value) {
  selected_regions_.Set(index, value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.selected_regions)
}
inline void UptimeCheckConfig::_internal_add_selected_regions(::google::monitoring::v3::UptimeCheckRegion value) {
  selected_regions_.Add(value);
}
inline void UptimeCheckConfig::add_selected_regions(::google::monitoring::v3::UptimeCheckRegion value) {
  _internal_add_selected_regions(value);
  // @@protoc_insertion_point(field_add:google.monitoring.v3.UptimeCheckConfig.selected_regions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
UptimeCheckConfig::selected_regions() const {
  // @@protoc_insertion_point(field_list:google.monitoring.v3.UptimeCheckConfig.selected_regions)
  return selected_regions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UptimeCheckConfig::_internal_mutable_selected_regions() {
  return &selected_regions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UptimeCheckConfig::mutable_selected_regions() {
  // @@protoc_insertion_point(field_mutable_list:google.monitoring.v3.UptimeCheckConfig.selected_regions)
  return _internal_mutable_selected_regions();
}

// bool is_internal = 15 [deprecated = true];
inline void UptimeCheckConfig::clear_is_internal() {
  is_internal_ = false;
}
inline bool UptimeCheckConfig::_internal_is_internal() const {
  return is_internal_;
}
inline bool UptimeCheckConfig::is_internal() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.is_internal)
  return _internal_is_internal();
}
inline void UptimeCheckConfig::_internal_set_is_internal(bool value) {
  
  is_internal_ = value;
}
inline void UptimeCheckConfig::set_is_internal(bool value) {
  _internal_set_is_internal(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckConfig.is_internal)
}

// repeated .google.monitoring.v3.InternalChecker internal_checkers = 14 [deprecated = true];
inline int UptimeCheckConfig::_internal_internal_checkers_size() const {
  return internal_checkers_.size();
}
inline int UptimeCheckConfig::internal_checkers_size() const {
  return _internal_internal_checkers_size();
}
inline void UptimeCheckConfig::clear_internal_checkers() {
  internal_checkers_.Clear();
}
inline ::google::monitoring::v3::InternalChecker* UptimeCheckConfig::mutable_internal_checkers(int index) {
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckConfig.internal_checkers)
  return internal_checkers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::monitoring::v3::InternalChecker >*
UptimeCheckConfig::mutable_internal_checkers() {
  // @@protoc_insertion_point(field_mutable_list:google.monitoring.v3.UptimeCheckConfig.internal_checkers)
  return &internal_checkers_;
}
inline const ::google::monitoring::v3::InternalChecker& UptimeCheckConfig::_internal_internal_checkers(int index) const {
  return internal_checkers_.Get(index);
}
inline const ::google::monitoring::v3::InternalChecker& UptimeCheckConfig::internal_checkers(int index) const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckConfig.internal_checkers)
  return _internal_internal_checkers(index);
}
inline ::google::monitoring::v3::InternalChecker* UptimeCheckConfig::_internal_add_internal_checkers() {
  return internal_checkers_.Add();
}
inline ::google::monitoring::v3::InternalChecker* UptimeCheckConfig::add_internal_checkers() {
  ::google::monitoring::v3::InternalChecker* _add = _internal_add_internal_checkers();
  // @@protoc_insertion_point(field_add:google.monitoring.v3.UptimeCheckConfig.internal_checkers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::monitoring::v3::InternalChecker >&
UptimeCheckConfig::internal_checkers() const {
  // @@protoc_insertion_point(field_list:google.monitoring.v3.UptimeCheckConfig.internal_checkers)
  return internal_checkers_;
}

inline bool UptimeCheckConfig::has_resource() const {
  return resource_case() != RESOURCE_NOT_SET;
}
inline void UptimeCheckConfig::clear_has_resource() {
  _oneof_case_[0] = RESOURCE_NOT_SET;
}
inline bool UptimeCheckConfig::has_check_request_type() const {
  return check_request_type_case() != CHECK_REQUEST_TYPE_NOT_SET;
}
inline void UptimeCheckConfig::clear_has_check_request_type() {
  _oneof_case_[1] = CHECK_REQUEST_TYPE_NOT_SET;
}
inline UptimeCheckConfig::ResourceCase UptimeCheckConfig::resource_case() const {
  return UptimeCheckConfig::ResourceCase(_oneof_case_[0]);
}
inline UptimeCheckConfig::CheckRequestTypeCase UptimeCheckConfig::check_request_type_case() const {
  return UptimeCheckConfig::CheckRequestTypeCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// UptimeCheckIp

// .google.monitoring.v3.UptimeCheckRegion region = 1;
inline void UptimeCheckIp::clear_region() {
  region_ = 0;
}
inline ::google::monitoring::v3::UptimeCheckRegion UptimeCheckIp::_internal_region() const {
  return static_cast< ::google::monitoring::v3::UptimeCheckRegion >(region_);
}
inline ::google::monitoring::v3::UptimeCheckRegion UptimeCheckIp::region() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckIp.region)
  return _internal_region();
}
inline void UptimeCheckIp::_internal_set_region(::google::monitoring::v3::UptimeCheckRegion value) {
  
  region_ = value;
}
inline void UptimeCheckIp::set_region(::google::monitoring::v3::UptimeCheckRegion value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckIp.region)
}

// string location = 2;
inline void UptimeCheckIp::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& UptimeCheckIp::location() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckIp.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UptimeCheckIp::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckIp.location)
}
inline std::string* UptimeCheckIp::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckIp.location)
  return _s;
}
inline const std::string& UptimeCheckIp::_internal_location() const {
  return location_.Get();
}
inline void UptimeCheckIp::_internal_set_location(const std::string& value) {
  
  location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UptimeCheckIp::_internal_mutable_location() {
  
  return location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UptimeCheckIp::release_location() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckIp.location)
  return location_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UptimeCheckIp::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.UptimeCheckIp.location)
}

// string ip_address = 3;
inline void UptimeCheckIp::clear_ip_address() {
  ip_address_.ClearToEmpty();
}
inline const std::string& UptimeCheckIp::ip_address() const {
  // @@protoc_insertion_point(field_get:google.monitoring.v3.UptimeCheckIp.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UptimeCheckIp::set_ip_address(ArgT0&& arg0, ArgT... args) {
 
 ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.monitoring.v3.UptimeCheckIp.ip_address)
}
inline std::string* UptimeCheckIp::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:google.monitoring.v3.UptimeCheckIp.ip_address)
  return _s;
}
inline const std::string& UptimeCheckIp::_internal_ip_address() const {
  return ip_address_.Get();
}
inline void UptimeCheckIp::_internal_set_ip_address(const std::string& value) {
  
  ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UptimeCheckIp::_internal_mutable_ip_address() {
  
  return ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UptimeCheckIp::release_ip_address() {
  // @@protoc_insertion_point(field_release:google.monitoring.v3.UptimeCheckIp.ip_address)
  return ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UptimeCheckIp::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    
  } else {
    
  }
  ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.monitoring.v3.UptimeCheckIp.ip_address)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v3
}  // namespace monitoring
}  // namespace google

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::google::monitoring::v3::InternalChecker_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::monitoring::v3::InternalChecker_State>() {
  return ::google::monitoring::v3::InternalChecker_State_descriptor();
}
template <> struct is_proto_enum< ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_RequestMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_RequestMethod>() {
  return ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_RequestMethod_descriptor();
}
template <> struct is_proto_enum< ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_ContentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_ContentType>() {
  return ::google::monitoring::v3::UptimeCheckConfig_HttpCheck_ContentType_descriptor();
}
template <> struct is_proto_enum< ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher_ContentMatcherOption> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher_ContentMatcherOption>() {
  return ::google::monitoring::v3::UptimeCheckConfig_ContentMatcher_ContentMatcherOption_descriptor();
}
template <> struct is_proto_enum< ::google::monitoring::v3::UptimeCheckRegion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::monitoring::v3::UptimeCheckRegion>() {
  return ::google::monitoring::v3::UptimeCheckRegion_descriptor();
}
template <> struct is_proto_enum< ::google::monitoring::v3::GroupResourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::monitoring::v3::GroupResourceType>() {
  return ::google::monitoring::v3::GroupResourceType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_google_2fmonitoring_2fv3_2fuptime_2eproto
