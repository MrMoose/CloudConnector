// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/iam/admin/v1/iam.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_google_2fiam_2fadmin_2fv1_2fiam_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_google_2fiam_2fadmin_2fv1_2fiam_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/client.pb.h"
#include "google/api/field_behavior.pb.h"
#include "google/api/resource.pb.h"
#include "google/iam/v1/iam_policy.pb.h"
#include "google/iam/v1/policy.pb.h"
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/field_mask.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "google/type/expr.pb.h"
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_google_2fiam_2fadmin_2fv1_2fiam_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
namespace google {
namespace iam {
namespace admin {
namespace v1 {
class CreateRoleRequest;
struct CreateRoleRequestDefaultTypeInternal;
extern CreateRoleRequestDefaultTypeInternal _CreateRoleRequest_default_instance_;
class CreateServiceAccountKeyRequest;
struct CreateServiceAccountKeyRequestDefaultTypeInternal;
extern CreateServiceAccountKeyRequestDefaultTypeInternal _CreateServiceAccountKeyRequest_default_instance_;
class CreateServiceAccountRequest;
struct CreateServiceAccountRequestDefaultTypeInternal;
extern CreateServiceAccountRequestDefaultTypeInternal _CreateServiceAccountRequest_default_instance_;
class DeleteRoleRequest;
struct DeleteRoleRequestDefaultTypeInternal;
extern DeleteRoleRequestDefaultTypeInternal _DeleteRoleRequest_default_instance_;
class DeleteServiceAccountKeyRequest;
struct DeleteServiceAccountKeyRequestDefaultTypeInternal;
extern DeleteServiceAccountKeyRequestDefaultTypeInternal _DeleteServiceAccountKeyRequest_default_instance_;
class DeleteServiceAccountRequest;
struct DeleteServiceAccountRequestDefaultTypeInternal;
extern DeleteServiceAccountRequestDefaultTypeInternal _DeleteServiceAccountRequest_default_instance_;
class DisableServiceAccountRequest;
struct DisableServiceAccountRequestDefaultTypeInternal;
extern DisableServiceAccountRequestDefaultTypeInternal _DisableServiceAccountRequest_default_instance_;
class EnableServiceAccountRequest;
struct EnableServiceAccountRequestDefaultTypeInternal;
extern EnableServiceAccountRequestDefaultTypeInternal _EnableServiceAccountRequest_default_instance_;
class GetRoleRequest;
struct GetRoleRequestDefaultTypeInternal;
extern GetRoleRequestDefaultTypeInternal _GetRoleRequest_default_instance_;
class GetServiceAccountKeyRequest;
struct GetServiceAccountKeyRequestDefaultTypeInternal;
extern GetServiceAccountKeyRequestDefaultTypeInternal _GetServiceAccountKeyRequest_default_instance_;
class GetServiceAccountRequest;
struct GetServiceAccountRequestDefaultTypeInternal;
extern GetServiceAccountRequestDefaultTypeInternal _GetServiceAccountRequest_default_instance_;
class LintPolicyRequest;
struct LintPolicyRequestDefaultTypeInternal;
extern LintPolicyRequestDefaultTypeInternal _LintPolicyRequest_default_instance_;
class LintPolicyResponse;
struct LintPolicyResponseDefaultTypeInternal;
extern LintPolicyResponseDefaultTypeInternal _LintPolicyResponse_default_instance_;
class LintResult;
struct LintResultDefaultTypeInternal;
extern LintResultDefaultTypeInternal _LintResult_default_instance_;
class ListRolesRequest;
struct ListRolesRequestDefaultTypeInternal;
extern ListRolesRequestDefaultTypeInternal _ListRolesRequest_default_instance_;
class ListRolesResponse;
struct ListRolesResponseDefaultTypeInternal;
extern ListRolesResponseDefaultTypeInternal _ListRolesResponse_default_instance_;
class ListServiceAccountKeysRequest;
struct ListServiceAccountKeysRequestDefaultTypeInternal;
extern ListServiceAccountKeysRequestDefaultTypeInternal _ListServiceAccountKeysRequest_default_instance_;
class ListServiceAccountKeysResponse;
struct ListServiceAccountKeysResponseDefaultTypeInternal;
extern ListServiceAccountKeysResponseDefaultTypeInternal _ListServiceAccountKeysResponse_default_instance_;
class ListServiceAccountsRequest;
struct ListServiceAccountsRequestDefaultTypeInternal;
extern ListServiceAccountsRequestDefaultTypeInternal _ListServiceAccountsRequest_default_instance_;
class ListServiceAccountsResponse;
struct ListServiceAccountsResponseDefaultTypeInternal;
extern ListServiceAccountsResponseDefaultTypeInternal _ListServiceAccountsResponse_default_instance_;
class PatchServiceAccountRequest;
struct PatchServiceAccountRequestDefaultTypeInternal;
extern PatchServiceAccountRequestDefaultTypeInternal _PatchServiceAccountRequest_default_instance_;
class Permission;
struct PermissionDefaultTypeInternal;
extern PermissionDefaultTypeInternal _Permission_default_instance_;
class QueryAuditableServicesRequest;
struct QueryAuditableServicesRequestDefaultTypeInternal;
extern QueryAuditableServicesRequestDefaultTypeInternal _QueryAuditableServicesRequest_default_instance_;
class QueryAuditableServicesResponse;
struct QueryAuditableServicesResponseDefaultTypeInternal;
extern QueryAuditableServicesResponseDefaultTypeInternal _QueryAuditableServicesResponse_default_instance_;
class QueryAuditableServicesResponse_AuditableService;
struct QueryAuditableServicesResponse_AuditableServiceDefaultTypeInternal;
extern QueryAuditableServicesResponse_AuditableServiceDefaultTypeInternal _QueryAuditableServicesResponse_AuditableService_default_instance_;
class QueryGrantableRolesRequest;
struct QueryGrantableRolesRequestDefaultTypeInternal;
extern QueryGrantableRolesRequestDefaultTypeInternal _QueryGrantableRolesRequest_default_instance_;
class QueryGrantableRolesResponse;
struct QueryGrantableRolesResponseDefaultTypeInternal;
extern QueryGrantableRolesResponseDefaultTypeInternal _QueryGrantableRolesResponse_default_instance_;
class QueryTestablePermissionsRequest;
struct QueryTestablePermissionsRequestDefaultTypeInternal;
extern QueryTestablePermissionsRequestDefaultTypeInternal _QueryTestablePermissionsRequest_default_instance_;
class QueryTestablePermissionsResponse;
struct QueryTestablePermissionsResponseDefaultTypeInternal;
extern QueryTestablePermissionsResponseDefaultTypeInternal _QueryTestablePermissionsResponse_default_instance_;
class Role;
struct RoleDefaultTypeInternal;
extern RoleDefaultTypeInternal _Role_default_instance_;
class ServiceAccount;
struct ServiceAccountDefaultTypeInternal;
extern ServiceAccountDefaultTypeInternal _ServiceAccount_default_instance_;
class ServiceAccountKey;
struct ServiceAccountKeyDefaultTypeInternal;
extern ServiceAccountKeyDefaultTypeInternal _ServiceAccountKey_default_instance_;
class SignBlobRequest;
struct SignBlobRequestDefaultTypeInternal;
extern SignBlobRequestDefaultTypeInternal _SignBlobRequest_default_instance_;
class SignBlobResponse;
struct SignBlobResponseDefaultTypeInternal;
extern SignBlobResponseDefaultTypeInternal _SignBlobResponse_default_instance_;
class SignJwtRequest;
struct SignJwtRequestDefaultTypeInternal;
extern SignJwtRequestDefaultTypeInternal _SignJwtRequest_default_instance_;
class SignJwtResponse;
struct SignJwtResponseDefaultTypeInternal;
extern SignJwtResponseDefaultTypeInternal _SignJwtResponse_default_instance_;
class UndeleteRoleRequest;
struct UndeleteRoleRequestDefaultTypeInternal;
extern UndeleteRoleRequestDefaultTypeInternal _UndeleteRoleRequest_default_instance_;
class UndeleteServiceAccountRequest;
struct UndeleteServiceAccountRequestDefaultTypeInternal;
extern UndeleteServiceAccountRequestDefaultTypeInternal _UndeleteServiceAccountRequest_default_instance_;
class UndeleteServiceAccountResponse;
struct UndeleteServiceAccountResponseDefaultTypeInternal;
extern UndeleteServiceAccountResponseDefaultTypeInternal _UndeleteServiceAccountResponse_default_instance_;
class UpdateRoleRequest;
struct UpdateRoleRequestDefaultTypeInternal;
extern UpdateRoleRequestDefaultTypeInternal _UpdateRoleRequest_default_instance_;
class UploadServiceAccountKeyRequest;
struct UploadServiceAccountKeyRequestDefaultTypeInternal;
extern UploadServiceAccountKeyRequestDefaultTypeInternal _UploadServiceAccountKeyRequest_default_instance_;
}  // namespace v1
}  // namespace admin
}  // namespace iam
}  // namespace google
PROTOBUF_NAMESPACE_OPEN
template<> ::google::iam::admin::v1::CreateRoleRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::CreateRoleRequest>(Arena*);
template<> ::google::iam::admin::v1::CreateServiceAccountKeyRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::CreateServiceAccountKeyRequest>(Arena*);
template<> ::google::iam::admin::v1::CreateServiceAccountRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::CreateServiceAccountRequest>(Arena*);
template<> ::google::iam::admin::v1::DeleteRoleRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::DeleteRoleRequest>(Arena*);
template<> ::google::iam::admin::v1::DeleteServiceAccountKeyRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::DeleteServiceAccountKeyRequest>(Arena*);
template<> ::google::iam::admin::v1::DeleteServiceAccountRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::DeleteServiceAccountRequest>(Arena*);
template<> ::google::iam::admin::v1::DisableServiceAccountRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::DisableServiceAccountRequest>(Arena*);
template<> ::google::iam::admin::v1::EnableServiceAccountRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::EnableServiceAccountRequest>(Arena*);
template<> ::google::iam::admin::v1::GetRoleRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::GetRoleRequest>(Arena*);
template<> ::google::iam::admin::v1::GetServiceAccountKeyRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::GetServiceAccountKeyRequest>(Arena*);
template<> ::google::iam::admin::v1::GetServiceAccountRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::GetServiceAccountRequest>(Arena*);
template<> ::google::iam::admin::v1::LintPolicyRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::LintPolicyRequest>(Arena*);
template<> ::google::iam::admin::v1::LintPolicyResponse* Arena::CreateMaybeMessage<::google::iam::admin::v1::LintPolicyResponse>(Arena*);
template<> ::google::iam::admin::v1::LintResult* Arena::CreateMaybeMessage<::google::iam::admin::v1::LintResult>(Arena*);
template<> ::google::iam::admin::v1::ListRolesRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::ListRolesRequest>(Arena*);
template<> ::google::iam::admin::v1::ListRolesResponse* Arena::CreateMaybeMessage<::google::iam::admin::v1::ListRolesResponse>(Arena*);
template<> ::google::iam::admin::v1::ListServiceAccountKeysRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::ListServiceAccountKeysRequest>(Arena*);
template<> ::google::iam::admin::v1::ListServiceAccountKeysResponse* Arena::CreateMaybeMessage<::google::iam::admin::v1::ListServiceAccountKeysResponse>(Arena*);
template<> ::google::iam::admin::v1::ListServiceAccountsRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::ListServiceAccountsRequest>(Arena*);
template<> ::google::iam::admin::v1::ListServiceAccountsResponse* Arena::CreateMaybeMessage<::google::iam::admin::v1::ListServiceAccountsResponse>(Arena*);
template<> ::google::iam::admin::v1::PatchServiceAccountRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::PatchServiceAccountRequest>(Arena*);
template<> ::google::iam::admin::v1::Permission* Arena::CreateMaybeMessage<::google::iam::admin::v1::Permission>(Arena*);
template<> ::google::iam::admin::v1::QueryAuditableServicesRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::QueryAuditableServicesRequest>(Arena*);
template<> ::google::iam::admin::v1::QueryAuditableServicesResponse* Arena::CreateMaybeMessage<::google::iam::admin::v1::QueryAuditableServicesResponse>(Arena*);
template<> ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService* Arena::CreateMaybeMessage<::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService>(Arena*);
template<> ::google::iam::admin::v1::QueryGrantableRolesRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::QueryGrantableRolesRequest>(Arena*);
template<> ::google::iam::admin::v1::QueryGrantableRolesResponse* Arena::CreateMaybeMessage<::google::iam::admin::v1::QueryGrantableRolesResponse>(Arena*);
template<> ::google::iam::admin::v1::QueryTestablePermissionsRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::QueryTestablePermissionsRequest>(Arena*);
template<> ::google::iam::admin::v1::QueryTestablePermissionsResponse* Arena::CreateMaybeMessage<::google::iam::admin::v1::QueryTestablePermissionsResponse>(Arena*);
template<> ::google::iam::admin::v1::Role* Arena::CreateMaybeMessage<::google::iam::admin::v1::Role>(Arena*);
template<> ::google::iam::admin::v1::ServiceAccount* Arena::CreateMaybeMessage<::google::iam::admin::v1::ServiceAccount>(Arena*);
template<> ::google::iam::admin::v1::ServiceAccountKey* Arena::CreateMaybeMessage<::google::iam::admin::v1::ServiceAccountKey>(Arena*);
template<> ::google::iam::admin::v1::SignBlobRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::SignBlobRequest>(Arena*);
template<> ::google::iam::admin::v1::SignBlobResponse* Arena::CreateMaybeMessage<::google::iam::admin::v1::SignBlobResponse>(Arena*);
template<> ::google::iam::admin::v1::SignJwtRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::SignJwtRequest>(Arena*);
template<> ::google::iam::admin::v1::SignJwtResponse* Arena::CreateMaybeMessage<::google::iam::admin::v1::SignJwtResponse>(Arena*);
template<> ::google::iam::admin::v1::UndeleteRoleRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::UndeleteRoleRequest>(Arena*);
template<> ::google::iam::admin::v1::UndeleteServiceAccountRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::UndeleteServiceAccountRequest>(Arena*);
template<> ::google::iam::admin::v1::UndeleteServiceAccountResponse* Arena::CreateMaybeMessage<::google::iam::admin::v1::UndeleteServiceAccountResponse>(Arena*);
template<> ::google::iam::admin::v1::UpdateRoleRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::UpdateRoleRequest>(Arena*);
template<> ::google::iam::admin::v1::UploadServiceAccountKeyRequest* Arena::CreateMaybeMessage<::google::iam::admin::v1::UploadServiceAccountKeyRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace google {
namespace iam {
namespace admin {
namespace v1 {

enum ListServiceAccountKeysRequest_KeyType : int {
  ListServiceAccountKeysRequest_KeyType_KEY_TYPE_UNSPECIFIED = 0,
  ListServiceAccountKeysRequest_KeyType_USER_MANAGED = 1,
  ListServiceAccountKeysRequest_KeyType_SYSTEM_MANAGED = 2,
  ListServiceAccountKeysRequest_KeyType_ListServiceAccountKeysRequest_KeyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ListServiceAccountKeysRequest_KeyType_ListServiceAccountKeysRequest_KeyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ListServiceAccountKeysRequest_KeyType_IsValid(int value);
constexpr ListServiceAccountKeysRequest_KeyType ListServiceAccountKeysRequest_KeyType_KeyType_MIN = ListServiceAccountKeysRequest_KeyType_KEY_TYPE_UNSPECIFIED;
constexpr ListServiceAccountKeysRequest_KeyType ListServiceAccountKeysRequest_KeyType_KeyType_MAX = ListServiceAccountKeysRequest_KeyType_SYSTEM_MANAGED;
constexpr int ListServiceAccountKeysRequest_KeyType_KeyType_ARRAYSIZE = ListServiceAccountKeysRequest_KeyType_KeyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ListServiceAccountKeysRequest_KeyType_descriptor();
template<typename T>
inline const std::string& ListServiceAccountKeysRequest_KeyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ListServiceAccountKeysRequest_KeyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ListServiceAccountKeysRequest_KeyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ListServiceAccountKeysRequest_KeyType_descriptor(), enum_t_value);
}
inline bool ListServiceAccountKeysRequest_KeyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ListServiceAccountKeysRequest_KeyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ListServiceAccountKeysRequest_KeyType>(
    ListServiceAccountKeysRequest_KeyType_descriptor(), name, value);
}
enum Role_RoleLaunchStage : int {
  Role_RoleLaunchStage_ALPHA = 0,
  Role_RoleLaunchStage_BETA = 1,
  Role_RoleLaunchStage_GA = 2,
  Role_RoleLaunchStage_DEPRECATED = 4,
  Role_RoleLaunchStage_DISABLED = 5,
  Role_RoleLaunchStage_EAP = 6,
  Role_RoleLaunchStage_Role_RoleLaunchStage_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Role_RoleLaunchStage_Role_RoleLaunchStage_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Role_RoleLaunchStage_IsValid(int value);
constexpr Role_RoleLaunchStage Role_RoleLaunchStage_RoleLaunchStage_MIN = Role_RoleLaunchStage_ALPHA;
constexpr Role_RoleLaunchStage Role_RoleLaunchStage_RoleLaunchStage_MAX = Role_RoleLaunchStage_EAP;
constexpr int Role_RoleLaunchStage_RoleLaunchStage_ARRAYSIZE = Role_RoleLaunchStage_RoleLaunchStage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Role_RoleLaunchStage_descriptor();
template<typename T>
inline const std::string& Role_RoleLaunchStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Role_RoleLaunchStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Role_RoleLaunchStage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Role_RoleLaunchStage_descriptor(), enum_t_value);
}
inline bool Role_RoleLaunchStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Role_RoleLaunchStage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Role_RoleLaunchStage>(
    Role_RoleLaunchStage_descriptor(), name, value);
}
enum Permission_PermissionLaunchStage : int {
  Permission_PermissionLaunchStage_ALPHA = 0,
  Permission_PermissionLaunchStage_BETA = 1,
  Permission_PermissionLaunchStage_GA = 2,
  Permission_PermissionLaunchStage_DEPRECATED = 3,
  Permission_PermissionLaunchStage_Permission_PermissionLaunchStage_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Permission_PermissionLaunchStage_Permission_PermissionLaunchStage_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Permission_PermissionLaunchStage_IsValid(int value);
constexpr Permission_PermissionLaunchStage Permission_PermissionLaunchStage_PermissionLaunchStage_MIN = Permission_PermissionLaunchStage_ALPHA;
constexpr Permission_PermissionLaunchStage Permission_PermissionLaunchStage_PermissionLaunchStage_MAX = Permission_PermissionLaunchStage_DEPRECATED;
constexpr int Permission_PermissionLaunchStage_PermissionLaunchStage_ARRAYSIZE = Permission_PermissionLaunchStage_PermissionLaunchStage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Permission_PermissionLaunchStage_descriptor();
template<typename T>
inline const std::string& Permission_PermissionLaunchStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Permission_PermissionLaunchStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Permission_PermissionLaunchStage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Permission_PermissionLaunchStage_descriptor(), enum_t_value);
}
inline bool Permission_PermissionLaunchStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Permission_PermissionLaunchStage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Permission_PermissionLaunchStage>(
    Permission_PermissionLaunchStage_descriptor(), name, value);
}
enum Permission_CustomRolesSupportLevel : int {
  Permission_CustomRolesSupportLevel_SUPPORTED = 0,
  Permission_CustomRolesSupportLevel_TESTING = 1,
  Permission_CustomRolesSupportLevel_NOT_SUPPORTED = 2,
  Permission_CustomRolesSupportLevel_Permission_CustomRolesSupportLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Permission_CustomRolesSupportLevel_Permission_CustomRolesSupportLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Permission_CustomRolesSupportLevel_IsValid(int value);
constexpr Permission_CustomRolesSupportLevel Permission_CustomRolesSupportLevel_CustomRolesSupportLevel_MIN = Permission_CustomRolesSupportLevel_SUPPORTED;
constexpr Permission_CustomRolesSupportLevel Permission_CustomRolesSupportLevel_CustomRolesSupportLevel_MAX = Permission_CustomRolesSupportLevel_NOT_SUPPORTED;
constexpr int Permission_CustomRolesSupportLevel_CustomRolesSupportLevel_ARRAYSIZE = Permission_CustomRolesSupportLevel_CustomRolesSupportLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Permission_CustomRolesSupportLevel_descriptor();
template<typename T>
inline const std::string& Permission_CustomRolesSupportLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Permission_CustomRolesSupportLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Permission_CustomRolesSupportLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Permission_CustomRolesSupportLevel_descriptor(), enum_t_value);
}
inline bool Permission_CustomRolesSupportLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Permission_CustomRolesSupportLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Permission_CustomRolesSupportLevel>(
    Permission_CustomRolesSupportLevel_descriptor(), name, value);
}
enum LintResult_Level : int {
  LintResult_Level_LEVEL_UNSPECIFIED = 0,
  LintResult_Level_CONDITION = 3,
  LintResult_Level_LintResult_Level_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LintResult_Level_LintResult_Level_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LintResult_Level_IsValid(int value);
constexpr LintResult_Level LintResult_Level_Level_MIN = LintResult_Level_LEVEL_UNSPECIFIED;
constexpr LintResult_Level LintResult_Level_Level_MAX = LintResult_Level_CONDITION;
constexpr int LintResult_Level_Level_ARRAYSIZE = LintResult_Level_Level_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LintResult_Level_descriptor();
template<typename T>
inline const std::string& LintResult_Level_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LintResult_Level>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LintResult_Level_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LintResult_Level_descriptor(), enum_t_value);
}
inline bool LintResult_Level_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LintResult_Level* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LintResult_Level>(
    LintResult_Level_descriptor(), name, value);
}
enum LintResult_Severity : int {
  LintResult_Severity_SEVERITY_UNSPECIFIED = 0,
  LintResult_Severity_ERROR = 1,
  LintResult_Severity_WARNING = 2,
  LintResult_Severity_NOTICE = 3,
  LintResult_Severity_INFO = 4,
  LintResult_Severity_DEPRECATED = 5,
  LintResult_Severity_LintResult_Severity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LintResult_Severity_LintResult_Severity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LintResult_Severity_IsValid(int value);
constexpr LintResult_Severity LintResult_Severity_Severity_MIN = LintResult_Severity_SEVERITY_UNSPECIFIED;
constexpr LintResult_Severity LintResult_Severity_Severity_MAX = LintResult_Severity_DEPRECATED;
constexpr int LintResult_Severity_Severity_ARRAYSIZE = LintResult_Severity_Severity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LintResult_Severity_descriptor();
template<typename T>
inline const std::string& LintResult_Severity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LintResult_Severity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LintResult_Severity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LintResult_Severity_descriptor(), enum_t_value);
}
inline bool LintResult_Severity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LintResult_Severity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LintResult_Severity>(
    LintResult_Severity_descriptor(), name, value);
}
enum ServiceAccountKeyAlgorithm : int {
  KEY_ALG_UNSPECIFIED = 0,
  KEY_ALG_RSA_1024 = 1,
  KEY_ALG_RSA_2048 = 2,
  ServiceAccountKeyAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ServiceAccountKeyAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ServiceAccountKeyAlgorithm_IsValid(int value);
constexpr ServiceAccountKeyAlgorithm ServiceAccountKeyAlgorithm_MIN = KEY_ALG_UNSPECIFIED;
constexpr ServiceAccountKeyAlgorithm ServiceAccountKeyAlgorithm_MAX = KEY_ALG_RSA_2048;
constexpr int ServiceAccountKeyAlgorithm_ARRAYSIZE = ServiceAccountKeyAlgorithm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceAccountKeyAlgorithm_descriptor();
template<typename T>
inline const std::string& ServiceAccountKeyAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceAccountKeyAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceAccountKeyAlgorithm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServiceAccountKeyAlgorithm_descriptor(), enum_t_value);
}
inline bool ServiceAccountKeyAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceAccountKeyAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServiceAccountKeyAlgorithm>(
    ServiceAccountKeyAlgorithm_descriptor(), name, value);
}
enum ServiceAccountPrivateKeyType : int {
  TYPE_UNSPECIFIED = 0,
  TYPE_PKCS12_FILE = 1,
  TYPE_GOOGLE_CREDENTIALS_FILE = 2,
  ServiceAccountPrivateKeyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ServiceAccountPrivateKeyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ServiceAccountPrivateKeyType_IsValid(int value);
constexpr ServiceAccountPrivateKeyType ServiceAccountPrivateKeyType_MIN = TYPE_UNSPECIFIED;
constexpr ServiceAccountPrivateKeyType ServiceAccountPrivateKeyType_MAX = TYPE_GOOGLE_CREDENTIALS_FILE;
constexpr int ServiceAccountPrivateKeyType_ARRAYSIZE = ServiceAccountPrivateKeyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceAccountPrivateKeyType_descriptor();
template<typename T>
inline const std::string& ServiceAccountPrivateKeyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceAccountPrivateKeyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceAccountPrivateKeyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServiceAccountPrivateKeyType_descriptor(), enum_t_value);
}
inline bool ServiceAccountPrivateKeyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceAccountPrivateKeyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServiceAccountPrivateKeyType>(
    ServiceAccountPrivateKeyType_descriptor(), name, value);
}
enum ServiceAccountPublicKeyType : int {
  TYPE_NONE = 0,
  TYPE_X509_PEM_FILE = 1,
  TYPE_RAW_PUBLIC_KEY = 2,
  ServiceAccountPublicKeyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ServiceAccountPublicKeyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ServiceAccountPublicKeyType_IsValid(int value);
constexpr ServiceAccountPublicKeyType ServiceAccountPublicKeyType_MIN = TYPE_NONE;
constexpr ServiceAccountPublicKeyType ServiceAccountPublicKeyType_MAX = TYPE_RAW_PUBLIC_KEY;
constexpr int ServiceAccountPublicKeyType_ARRAYSIZE = ServiceAccountPublicKeyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceAccountPublicKeyType_descriptor();
template<typename T>
inline const std::string& ServiceAccountPublicKeyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceAccountPublicKeyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceAccountPublicKeyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServiceAccountPublicKeyType_descriptor(), enum_t_value);
}
inline bool ServiceAccountPublicKeyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceAccountPublicKeyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServiceAccountPublicKeyType>(
    ServiceAccountPublicKeyType_descriptor(), name, value);
}
enum ServiceAccountKeyOrigin : int {
  ORIGIN_UNSPECIFIED = 0,
  USER_PROVIDED = 1,
  GOOGLE_PROVIDED = 2,
  ServiceAccountKeyOrigin_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ServiceAccountKeyOrigin_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ServiceAccountKeyOrigin_IsValid(int value);
constexpr ServiceAccountKeyOrigin ServiceAccountKeyOrigin_MIN = ORIGIN_UNSPECIFIED;
constexpr ServiceAccountKeyOrigin ServiceAccountKeyOrigin_MAX = GOOGLE_PROVIDED;
constexpr int ServiceAccountKeyOrigin_ARRAYSIZE = ServiceAccountKeyOrigin_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceAccountKeyOrigin_descriptor();
template<typename T>
inline const std::string& ServiceAccountKeyOrigin_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceAccountKeyOrigin>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceAccountKeyOrigin_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServiceAccountKeyOrigin_descriptor(), enum_t_value);
}
inline bool ServiceAccountKeyOrigin_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceAccountKeyOrigin* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServiceAccountKeyOrigin>(
    ServiceAccountKeyOrigin_descriptor(), name, value);
}
enum RoleView : int {
  BASIC = 0,
  FULL = 1,
  RoleView_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RoleView_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RoleView_IsValid(int value);
constexpr RoleView RoleView_MIN = BASIC;
constexpr RoleView RoleView_MAX = FULL;
constexpr int RoleView_ARRAYSIZE = RoleView_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoleView_descriptor();
template<typename T>
inline const std::string& RoleView_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoleView>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoleView_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoleView_descriptor(), enum_t_value);
}
inline bool RoleView_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RoleView* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoleView>(
    RoleView_descriptor(), name, value);
}
// ===================================================================

class ServiceAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.ServiceAccount) */ {
 public:
  inline ServiceAccount() : ServiceAccount(nullptr) {}
  ~ServiceAccount() override;
  explicit PROTOBUF_CONSTEXPR ServiceAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceAccount(const ServiceAccount& from);
  ServiceAccount(ServiceAccount&& from) noexcept
    : ServiceAccount() {
    *this = ::std::move(from);
  }

  inline ServiceAccount& operator=(const ServiceAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceAccount& operator=(ServiceAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceAccount* internal_default_instance() {
    return reinterpret_cast<const ServiceAccount*>(
               &_ServiceAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ServiceAccount& a, ServiceAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceAccount& from) {
    ServiceAccount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.ServiceAccount";
  }
  protected:
  explicit ServiceAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kProjectIdFieldNumber = 2,
    kUniqueIdFieldNumber = 4,
    kEmailFieldNumber = 5,
    kDisplayNameFieldNumber = 6,
    kEtagFieldNumber = 7,
    kDescriptionFieldNumber = 8,
    kOauth2ClientIdFieldNumber = 9,
    kDisabledFieldNumber = 11,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string project_id = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_project_id();
  const std::string& project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project_id();
  PROTOBUF_NODISCARD std::string* release_project_id();
  void set_allocated_project_id(std::string* project_id);
  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(const std::string& value);
  std::string* _internal_mutable_project_id();
  public:

  // string unique_id = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_unique_id();
  const std::string& unique_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unique_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unique_id();
  PROTOBUF_NODISCARD std::string* release_unique_id();
  void set_allocated_unique_id(std::string* unique_id);
  private:
  const std::string& _internal_unique_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unique_id(const std::string& value);
  std::string* _internal_mutable_unique_id();
  public:

  // string email = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string display_name = 6 [(.google.api.field_behavior) = OPTIONAL];
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // bytes etag = 7 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_etag();
  PROTOBUF_DEPRECATED const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_etag(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_etag();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_etag();
  PROTOBUF_DEPRECATED void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // string description = 8 [(.google.api.field_behavior) = OPTIONAL];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string oauth2_client_id = 9 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_oauth2_client_id();
  const std::string& oauth2_client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_oauth2_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_oauth2_client_id();
  PROTOBUF_NODISCARD std::string* release_oauth2_client_id();
  void set_allocated_oauth2_client_id(std::string* oauth2_client_id);
  private:
  const std::string& _internal_oauth2_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oauth2_client_id(const std::string& value);
  std::string* _internal_mutable_oauth2_client_id();
  public:

  // bool disabled = 11 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_disabled();
  bool disabled() const;
  void set_disabled(bool value);
  private:
  bool _internal_disabled() const;
  void _internal_set_disabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.ServiceAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oauth2_client_id_;
    bool disabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class CreateServiceAccountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.CreateServiceAccountRequest) */ {
 public:
  inline CreateServiceAccountRequest() : CreateServiceAccountRequest(nullptr) {}
  ~CreateServiceAccountRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateServiceAccountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateServiceAccountRequest(const CreateServiceAccountRequest& from);
  CreateServiceAccountRequest(CreateServiceAccountRequest&& from) noexcept
    : CreateServiceAccountRequest() {
    *this = ::std::move(from);
  }

  inline CreateServiceAccountRequest& operator=(const CreateServiceAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateServiceAccountRequest& operator=(CreateServiceAccountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateServiceAccountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateServiceAccountRequest* internal_default_instance() {
    return reinterpret_cast<const CreateServiceAccountRequest*>(
               &_CreateServiceAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateServiceAccountRequest& a, CreateServiceAccountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateServiceAccountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateServiceAccountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateServiceAccountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateServiceAccountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateServiceAccountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateServiceAccountRequest& from) {
    CreateServiceAccountRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateServiceAccountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.CreateServiceAccountRequest";
  }
  protected:
  explicit CreateServiceAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAccountIdFieldNumber = 2,
    kServiceAccountFieldNumber = 3,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string account_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // .google.iam.admin.v1.ServiceAccount service_account = 3;
  bool has_service_account() const;
  private:
  bool _internal_has_service_account() const;
  public:
  void clear_service_account();
  const ::google::iam::admin::v1::ServiceAccount& service_account() const;
  PROTOBUF_NODISCARD ::google::iam::admin::v1::ServiceAccount* release_service_account();
  ::google::iam::admin::v1::ServiceAccount* mutable_service_account();
  void set_allocated_service_account(::google::iam::admin::v1::ServiceAccount* service_account);
  private:
  const ::google::iam::admin::v1::ServiceAccount& _internal_service_account() const;
  ::google::iam::admin::v1::ServiceAccount* _internal_mutable_service_account();
  public:
  void unsafe_arena_set_allocated_service_account(
      ::google::iam::admin::v1::ServiceAccount* service_account);
  ::google::iam::admin::v1::ServiceAccount* unsafe_arena_release_service_account();

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.CreateServiceAccountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    ::google::iam::admin::v1::ServiceAccount* service_account_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class ListServiceAccountsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.ListServiceAccountsRequest) */ {
 public:
  inline ListServiceAccountsRequest() : ListServiceAccountsRequest(nullptr) {}
  ~ListServiceAccountsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListServiceAccountsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServiceAccountsRequest(const ListServiceAccountsRequest& from);
  ListServiceAccountsRequest(ListServiceAccountsRequest&& from) noexcept
    : ListServiceAccountsRequest() {
    *this = ::std::move(from);
  }

  inline ListServiceAccountsRequest& operator=(const ListServiceAccountsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServiceAccountsRequest& operator=(ListServiceAccountsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServiceAccountsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServiceAccountsRequest* internal_default_instance() {
    return reinterpret_cast<const ListServiceAccountsRequest*>(
               &_ListServiceAccountsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ListServiceAccountsRequest& a, ListServiceAccountsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServiceAccountsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServiceAccountsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServiceAccountsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServiceAccountsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServiceAccountsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListServiceAccountsRequest& from) {
    ListServiceAccountsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServiceAccountsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.ListServiceAccountsRequest";
  }
  protected:
  explicit ListServiceAccountsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string page_token = 3;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.ListServiceAccountsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class ListServiceAccountsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.ListServiceAccountsResponse) */ {
 public:
  inline ListServiceAccountsResponse() : ListServiceAccountsResponse(nullptr) {}
  ~ListServiceAccountsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListServiceAccountsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServiceAccountsResponse(const ListServiceAccountsResponse& from);
  ListServiceAccountsResponse(ListServiceAccountsResponse&& from) noexcept
    : ListServiceAccountsResponse() {
    *this = ::std::move(from);
  }

  inline ListServiceAccountsResponse& operator=(const ListServiceAccountsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServiceAccountsResponse& operator=(ListServiceAccountsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServiceAccountsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServiceAccountsResponse* internal_default_instance() {
    return reinterpret_cast<const ListServiceAccountsResponse*>(
               &_ListServiceAccountsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ListServiceAccountsResponse& a, ListServiceAccountsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServiceAccountsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServiceAccountsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServiceAccountsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServiceAccountsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServiceAccountsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListServiceAccountsResponse& from) {
    ListServiceAccountsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServiceAccountsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.ListServiceAccountsResponse";
  }
  protected:
  explicit ListServiceAccountsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.iam.admin.v1.ServiceAccount accounts = 1;
  int accounts_size() const;
  private:
  int _internal_accounts_size() const;
  public:
  void clear_accounts();
  ::google::iam::admin::v1::ServiceAccount* mutable_accounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::ServiceAccount >*
      mutable_accounts();
  private:
  const ::google::iam::admin::v1::ServiceAccount& _internal_accounts(int index) const;
  ::google::iam::admin::v1::ServiceAccount* _internal_add_accounts();
  public:
  const ::google::iam::admin::v1::ServiceAccount& accounts(int index) const;
  ::google::iam::admin::v1::ServiceAccount* add_accounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::ServiceAccount >&
      accounts() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.ListServiceAccountsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::ServiceAccount > accounts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class GetServiceAccountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.GetServiceAccountRequest) */ {
 public:
  inline GetServiceAccountRequest() : GetServiceAccountRequest(nullptr) {}
  ~GetServiceAccountRequest() override;
  explicit PROTOBUF_CONSTEXPR GetServiceAccountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServiceAccountRequest(const GetServiceAccountRequest& from);
  GetServiceAccountRequest(GetServiceAccountRequest&& from) noexcept
    : GetServiceAccountRequest() {
    *this = ::std::move(from);
  }

  inline GetServiceAccountRequest& operator=(const GetServiceAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceAccountRequest& operator=(GetServiceAccountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceAccountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceAccountRequest* internal_default_instance() {
    return reinterpret_cast<const GetServiceAccountRequest*>(
               &_GetServiceAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetServiceAccountRequest& a, GetServiceAccountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceAccountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceAccountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceAccountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceAccountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServiceAccountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetServiceAccountRequest& from) {
    GetServiceAccountRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServiceAccountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.GetServiceAccountRequest";
  }
  protected:
  explicit GetServiceAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.GetServiceAccountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class DeleteServiceAccountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.DeleteServiceAccountRequest) */ {
 public:
  inline DeleteServiceAccountRequest() : DeleteServiceAccountRequest(nullptr) {}
  ~DeleteServiceAccountRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteServiceAccountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteServiceAccountRequest(const DeleteServiceAccountRequest& from);
  DeleteServiceAccountRequest(DeleteServiceAccountRequest&& from) noexcept
    : DeleteServiceAccountRequest() {
    *this = ::std::move(from);
  }

  inline DeleteServiceAccountRequest& operator=(const DeleteServiceAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteServiceAccountRequest& operator=(DeleteServiceAccountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteServiceAccountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteServiceAccountRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteServiceAccountRequest*>(
               &_DeleteServiceAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeleteServiceAccountRequest& a, DeleteServiceAccountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteServiceAccountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteServiceAccountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteServiceAccountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteServiceAccountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteServiceAccountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteServiceAccountRequest& from) {
    DeleteServiceAccountRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteServiceAccountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.DeleteServiceAccountRequest";
  }
  protected:
  explicit DeleteServiceAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.DeleteServiceAccountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class PatchServiceAccountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.PatchServiceAccountRequest) */ {
 public:
  inline PatchServiceAccountRequest() : PatchServiceAccountRequest(nullptr) {}
  ~PatchServiceAccountRequest() override;
  explicit PROTOBUF_CONSTEXPR PatchServiceAccountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PatchServiceAccountRequest(const PatchServiceAccountRequest& from);
  PatchServiceAccountRequest(PatchServiceAccountRequest&& from) noexcept
    : PatchServiceAccountRequest() {
    *this = ::std::move(from);
  }

  inline PatchServiceAccountRequest& operator=(const PatchServiceAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchServiceAccountRequest& operator=(PatchServiceAccountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchServiceAccountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchServiceAccountRequest* internal_default_instance() {
    return reinterpret_cast<const PatchServiceAccountRequest*>(
               &_PatchServiceAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PatchServiceAccountRequest& a, PatchServiceAccountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PatchServiceAccountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchServiceAccountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchServiceAccountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PatchServiceAccountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PatchServiceAccountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PatchServiceAccountRequest& from) {
    PatchServiceAccountRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PatchServiceAccountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.PatchServiceAccountRequest";
  }
  protected:
  explicit PatchServiceAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceAccountFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
  };
  // .google.iam.admin.v1.ServiceAccount service_account = 1;
  bool has_service_account() const;
  private:
  bool _internal_has_service_account() const;
  public:
  void clear_service_account();
  const ::google::iam::admin::v1::ServiceAccount& service_account() const;
  PROTOBUF_NODISCARD ::google::iam::admin::v1::ServiceAccount* release_service_account();
  ::google::iam::admin::v1::ServiceAccount* mutable_service_account();
  void set_allocated_service_account(::google::iam::admin::v1::ServiceAccount* service_account);
  private:
  const ::google::iam::admin::v1::ServiceAccount& _internal_service_account() const;
  ::google::iam::admin::v1::ServiceAccount* _internal_mutable_service_account();
  public:
  void unsafe_arena_set_allocated_service_account(
      ::google::iam::admin::v1::ServiceAccount* service_account);
  ::google::iam::admin::v1::ServiceAccount* unsafe_arena_release_service_account();

  // .google.protobuf.FieldMask update_mask = 2;
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.PatchServiceAccountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::iam::admin::v1::ServiceAccount* service_account_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class UndeleteServiceAccountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.UndeleteServiceAccountRequest) */ {
 public:
  inline UndeleteServiceAccountRequest() : UndeleteServiceAccountRequest(nullptr) {}
  ~UndeleteServiceAccountRequest() override;
  explicit PROTOBUF_CONSTEXPR UndeleteServiceAccountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UndeleteServiceAccountRequest(const UndeleteServiceAccountRequest& from);
  UndeleteServiceAccountRequest(UndeleteServiceAccountRequest&& from) noexcept
    : UndeleteServiceAccountRequest() {
    *this = ::std::move(from);
  }

  inline UndeleteServiceAccountRequest& operator=(const UndeleteServiceAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UndeleteServiceAccountRequest& operator=(UndeleteServiceAccountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UndeleteServiceAccountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UndeleteServiceAccountRequest* internal_default_instance() {
    return reinterpret_cast<const UndeleteServiceAccountRequest*>(
               &_UndeleteServiceAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UndeleteServiceAccountRequest& a, UndeleteServiceAccountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UndeleteServiceAccountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UndeleteServiceAccountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UndeleteServiceAccountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UndeleteServiceAccountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UndeleteServiceAccountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UndeleteServiceAccountRequest& from) {
    UndeleteServiceAccountRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UndeleteServiceAccountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.UndeleteServiceAccountRequest";
  }
  protected:
  explicit UndeleteServiceAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.UndeleteServiceAccountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class UndeleteServiceAccountResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.UndeleteServiceAccountResponse) */ {
 public:
  inline UndeleteServiceAccountResponse() : UndeleteServiceAccountResponse(nullptr) {}
  ~UndeleteServiceAccountResponse() override;
  explicit PROTOBUF_CONSTEXPR UndeleteServiceAccountResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UndeleteServiceAccountResponse(const UndeleteServiceAccountResponse& from);
  UndeleteServiceAccountResponse(UndeleteServiceAccountResponse&& from) noexcept
    : UndeleteServiceAccountResponse() {
    *this = ::std::move(from);
  }

  inline UndeleteServiceAccountResponse& operator=(const UndeleteServiceAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UndeleteServiceAccountResponse& operator=(UndeleteServiceAccountResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UndeleteServiceAccountResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UndeleteServiceAccountResponse* internal_default_instance() {
    return reinterpret_cast<const UndeleteServiceAccountResponse*>(
               &_UndeleteServiceAccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UndeleteServiceAccountResponse& a, UndeleteServiceAccountResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UndeleteServiceAccountResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UndeleteServiceAccountResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UndeleteServiceAccountResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UndeleteServiceAccountResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UndeleteServiceAccountResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UndeleteServiceAccountResponse& from) {
    UndeleteServiceAccountResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UndeleteServiceAccountResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.UndeleteServiceAccountResponse";
  }
  protected:
  explicit UndeleteServiceAccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRestoredAccountFieldNumber = 1,
  };
  // .google.iam.admin.v1.ServiceAccount restored_account = 1;
  bool has_restored_account() const;
  private:
  bool _internal_has_restored_account() const;
  public:
  void clear_restored_account();
  const ::google::iam::admin::v1::ServiceAccount& restored_account() const;
  PROTOBUF_NODISCARD ::google::iam::admin::v1::ServiceAccount* release_restored_account();
  ::google::iam::admin::v1::ServiceAccount* mutable_restored_account();
  void set_allocated_restored_account(::google::iam::admin::v1::ServiceAccount* restored_account);
  private:
  const ::google::iam::admin::v1::ServiceAccount& _internal_restored_account() const;
  ::google::iam::admin::v1::ServiceAccount* _internal_mutable_restored_account();
  public:
  void unsafe_arena_set_allocated_restored_account(
      ::google::iam::admin::v1::ServiceAccount* restored_account);
  ::google::iam::admin::v1::ServiceAccount* unsafe_arena_release_restored_account();

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.UndeleteServiceAccountResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::iam::admin::v1::ServiceAccount* restored_account_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class EnableServiceAccountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.EnableServiceAccountRequest) */ {
 public:
  inline EnableServiceAccountRequest() : EnableServiceAccountRequest(nullptr) {}
  ~EnableServiceAccountRequest() override;
  explicit PROTOBUF_CONSTEXPR EnableServiceAccountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnableServiceAccountRequest(const EnableServiceAccountRequest& from);
  EnableServiceAccountRequest(EnableServiceAccountRequest&& from) noexcept
    : EnableServiceAccountRequest() {
    *this = ::std::move(from);
  }

  inline EnableServiceAccountRequest& operator=(const EnableServiceAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableServiceAccountRequest& operator=(EnableServiceAccountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableServiceAccountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableServiceAccountRequest* internal_default_instance() {
    return reinterpret_cast<const EnableServiceAccountRequest*>(
               &_EnableServiceAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EnableServiceAccountRequest& a, EnableServiceAccountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EnableServiceAccountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableServiceAccountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnableServiceAccountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnableServiceAccountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnableServiceAccountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnableServiceAccountRequest& from) {
    EnableServiceAccountRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableServiceAccountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.EnableServiceAccountRequest";
  }
  protected:
  explicit EnableServiceAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.EnableServiceAccountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class DisableServiceAccountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.DisableServiceAccountRequest) */ {
 public:
  inline DisableServiceAccountRequest() : DisableServiceAccountRequest(nullptr) {}
  ~DisableServiceAccountRequest() override;
  explicit PROTOBUF_CONSTEXPR DisableServiceAccountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisableServiceAccountRequest(const DisableServiceAccountRequest& from);
  DisableServiceAccountRequest(DisableServiceAccountRequest&& from) noexcept
    : DisableServiceAccountRequest() {
    *this = ::std::move(from);
  }

  inline DisableServiceAccountRequest& operator=(const DisableServiceAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisableServiceAccountRequest& operator=(DisableServiceAccountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisableServiceAccountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisableServiceAccountRequest* internal_default_instance() {
    return reinterpret_cast<const DisableServiceAccountRequest*>(
               &_DisableServiceAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DisableServiceAccountRequest& a, DisableServiceAccountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DisableServiceAccountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisableServiceAccountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisableServiceAccountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisableServiceAccountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisableServiceAccountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DisableServiceAccountRequest& from) {
    DisableServiceAccountRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisableServiceAccountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.DisableServiceAccountRequest";
  }
  protected:
  explicit DisableServiceAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.DisableServiceAccountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class ListServiceAccountKeysRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.ListServiceAccountKeysRequest) */ {
 public:
  inline ListServiceAccountKeysRequest() : ListServiceAccountKeysRequest(nullptr) {}
  ~ListServiceAccountKeysRequest() override;
  explicit PROTOBUF_CONSTEXPR ListServiceAccountKeysRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServiceAccountKeysRequest(const ListServiceAccountKeysRequest& from);
  ListServiceAccountKeysRequest(ListServiceAccountKeysRequest&& from) noexcept
    : ListServiceAccountKeysRequest() {
    *this = ::std::move(from);
  }

  inline ListServiceAccountKeysRequest& operator=(const ListServiceAccountKeysRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServiceAccountKeysRequest& operator=(ListServiceAccountKeysRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServiceAccountKeysRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServiceAccountKeysRequest* internal_default_instance() {
    return reinterpret_cast<const ListServiceAccountKeysRequest*>(
               &_ListServiceAccountKeysRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ListServiceAccountKeysRequest& a, ListServiceAccountKeysRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServiceAccountKeysRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServiceAccountKeysRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServiceAccountKeysRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServiceAccountKeysRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServiceAccountKeysRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListServiceAccountKeysRequest& from) {
    ListServiceAccountKeysRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServiceAccountKeysRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.ListServiceAccountKeysRequest";
  }
  protected:
  explicit ListServiceAccountKeysRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ListServiceAccountKeysRequest_KeyType KeyType;
  static constexpr KeyType KEY_TYPE_UNSPECIFIED =
    ListServiceAccountKeysRequest_KeyType_KEY_TYPE_UNSPECIFIED;
  static constexpr KeyType USER_MANAGED =
    ListServiceAccountKeysRequest_KeyType_USER_MANAGED;
  static constexpr KeyType SYSTEM_MANAGED =
    ListServiceAccountKeysRequest_KeyType_SYSTEM_MANAGED;
  static inline bool KeyType_IsValid(int value) {
    return ListServiceAccountKeysRequest_KeyType_IsValid(value);
  }
  static constexpr KeyType KeyType_MIN =
    ListServiceAccountKeysRequest_KeyType_KeyType_MIN;
  static constexpr KeyType KeyType_MAX =
    ListServiceAccountKeysRequest_KeyType_KeyType_MAX;
  static constexpr int KeyType_ARRAYSIZE =
    ListServiceAccountKeysRequest_KeyType_KeyType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  KeyType_descriptor() {
    return ListServiceAccountKeysRequest_KeyType_descriptor();
  }
  template<typename T>
  static inline const std::string& KeyType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, KeyType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function KeyType_Name.");
    return ListServiceAccountKeysRequest_KeyType_Name(enum_t_value);
  }
  static inline bool KeyType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      KeyType* value) {
    return ListServiceAccountKeysRequest_KeyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKeyTypesFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .google.iam.admin.v1.ListServiceAccountKeysRequest.KeyType key_types = 2;
  int key_types_size() const;
  private:
  int _internal_key_types_size() const;
  public:
  void clear_key_types();
  private:
  ::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType _internal_key_types(int index) const;
  void _internal_add_key_types(::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_key_types();
  public:
  ::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType key_types(int index) const;
  void set_key_types(int index, ::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType value);
  void add_key_types(::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& key_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_key_types();

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.ListServiceAccountKeysRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> key_types_;
    mutable std::atomic<int> _key_types_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class ListServiceAccountKeysResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.ListServiceAccountKeysResponse) */ {
 public:
  inline ListServiceAccountKeysResponse() : ListServiceAccountKeysResponse(nullptr) {}
  ~ListServiceAccountKeysResponse() override;
  explicit PROTOBUF_CONSTEXPR ListServiceAccountKeysResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServiceAccountKeysResponse(const ListServiceAccountKeysResponse& from);
  ListServiceAccountKeysResponse(ListServiceAccountKeysResponse&& from) noexcept
    : ListServiceAccountKeysResponse() {
    *this = ::std::move(from);
  }

  inline ListServiceAccountKeysResponse& operator=(const ListServiceAccountKeysResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServiceAccountKeysResponse& operator=(ListServiceAccountKeysResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServiceAccountKeysResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServiceAccountKeysResponse* internal_default_instance() {
    return reinterpret_cast<const ListServiceAccountKeysResponse*>(
               &_ListServiceAccountKeysResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListServiceAccountKeysResponse& a, ListServiceAccountKeysResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServiceAccountKeysResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServiceAccountKeysResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServiceAccountKeysResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServiceAccountKeysResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServiceAccountKeysResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListServiceAccountKeysResponse& from) {
    ListServiceAccountKeysResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServiceAccountKeysResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.ListServiceAccountKeysResponse";
  }
  protected:
  explicit ListServiceAccountKeysResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
  };
  // repeated .google.iam.admin.v1.ServiceAccountKey keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  ::google::iam::admin::v1::ServiceAccountKey* mutable_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::ServiceAccountKey >*
      mutable_keys();
  private:
  const ::google::iam::admin::v1::ServiceAccountKey& _internal_keys(int index) const;
  ::google::iam::admin::v1::ServiceAccountKey* _internal_add_keys();
  public:
  const ::google::iam::admin::v1::ServiceAccountKey& keys(int index) const;
  ::google::iam::admin::v1::ServiceAccountKey* add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::ServiceAccountKey >&
      keys() const;

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.ListServiceAccountKeysResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::ServiceAccountKey > keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class GetServiceAccountKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.GetServiceAccountKeyRequest) */ {
 public:
  inline GetServiceAccountKeyRequest() : GetServiceAccountKeyRequest(nullptr) {}
  ~GetServiceAccountKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR GetServiceAccountKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServiceAccountKeyRequest(const GetServiceAccountKeyRequest& from);
  GetServiceAccountKeyRequest(GetServiceAccountKeyRequest&& from) noexcept
    : GetServiceAccountKeyRequest() {
    *this = ::std::move(from);
  }

  inline GetServiceAccountKeyRequest& operator=(const GetServiceAccountKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceAccountKeyRequest& operator=(GetServiceAccountKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceAccountKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceAccountKeyRequest* internal_default_instance() {
    return reinterpret_cast<const GetServiceAccountKeyRequest*>(
               &_GetServiceAccountKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetServiceAccountKeyRequest& a, GetServiceAccountKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceAccountKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceAccountKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceAccountKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceAccountKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServiceAccountKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetServiceAccountKeyRequest& from) {
    GetServiceAccountKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServiceAccountKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.GetServiceAccountKeyRequest";
  }
  protected:
  explicit GetServiceAccountKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPublicKeyTypeFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.iam.admin.v1.ServiceAccountPublicKeyType public_key_type = 2;
  void clear_public_key_type();
  ::google::iam::admin::v1::ServiceAccountPublicKeyType public_key_type() const;
  void set_public_key_type(::google::iam::admin::v1::ServiceAccountPublicKeyType value);
  private:
  ::google::iam::admin::v1::ServiceAccountPublicKeyType _internal_public_key_type() const;
  void _internal_set_public_key_type(::google::iam::admin::v1::ServiceAccountPublicKeyType value);
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.GetServiceAccountKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int public_key_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class ServiceAccountKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.ServiceAccountKey) */ {
 public:
  inline ServiceAccountKey() : ServiceAccountKey(nullptr) {}
  ~ServiceAccountKey() override;
  explicit PROTOBUF_CONSTEXPR ServiceAccountKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceAccountKey(const ServiceAccountKey& from);
  ServiceAccountKey(ServiceAccountKey&& from) noexcept
    : ServiceAccountKey() {
    *this = ::std::move(from);
  }

  inline ServiceAccountKey& operator=(const ServiceAccountKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceAccountKey& operator=(ServiceAccountKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceAccountKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceAccountKey* internal_default_instance() {
    return reinterpret_cast<const ServiceAccountKey*>(
               &_ServiceAccountKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ServiceAccountKey& a, ServiceAccountKey& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceAccountKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceAccountKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceAccountKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceAccountKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceAccountKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceAccountKey& from) {
    ServiceAccountKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceAccountKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.ServiceAccountKey";
  }
  protected:
  explicit ServiceAccountKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPrivateKeyDataFieldNumber = 3,
    kPublicKeyDataFieldNumber = 7,
    kValidAfterTimeFieldNumber = 4,
    kValidBeforeTimeFieldNumber = 5,
    kPrivateKeyTypeFieldNumber = 2,
    kKeyAlgorithmFieldNumber = 8,
    kKeyOriginFieldNumber = 9,
    kKeyTypeFieldNumber = 10,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes private_key_data = 3;
  void clear_private_key_data();
  const std::string& private_key_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_key_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_key_data();
  PROTOBUF_NODISCARD std::string* release_private_key_data();
  void set_allocated_private_key_data(std::string* private_key_data);
  private:
  const std::string& _internal_private_key_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_key_data(const std::string& value);
  std::string* _internal_mutable_private_key_data();
  public:

  // bytes public_key_data = 7;
  void clear_public_key_data();
  const std::string& public_key_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key_data();
  PROTOBUF_NODISCARD std::string* release_public_key_data();
  void set_allocated_public_key_data(std::string* public_key_data);
  private:
  const std::string& _internal_public_key_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key_data(const std::string& value);
  std::string* _internal_mutable_public_key_data();
  public:

  // .google.protobuf.Timestamp valid_after_time = 4;
  bool has_valid_after_time() const;
  private:
  bool _internal_has_valid_after_time() const;
  public:
  void clear_valid_after_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& valid_after_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_valid_after_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_valid_after_time();
  void set_allocated_valid_after_time(::PROTOBUF_NAMESPACE_ID::Timestamp* valid_after_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_valid_after_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_valid_after_time();
  public:
  void unsafe_arena_set_allocated_valid_after_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* valid_after_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_valid_after_time();

  // .google.protobuf.Timestamp valid_before_time = 5;
  bool has_valid_before_time() const;
  private:
  bool _internal_has_valid_before_time() const;
  public:
  void clear_valid_before_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& valid_before_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_valid_before_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_valid_before_time();
  void set_allocated_valid_before_time(::PROTOBUF_NAMESPACE_ID::Timestamp* valid_before_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_valid_before_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_valid_before_time();
  public:
  void unsafe_arena_set_allocated_valid_before_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* valid_before_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_valid_before_time();

  // .google.iam.admin.v1.ServiceAccountPrivateKeyType private_key_type = 2;
  void clear_private_key_type();
  ::google::iam::admin::v1::ServiceAccountPrivateKeyType private_key_type() const;
  void set_private_key_type(::google::iam::admin::v1::ServiceAccountPrivateKeyType value);
  private:
  ::google::iam::admin::v1::ServiceAccountPrivateKeyType _internal_private_key_type() const;
  void _internal_set_private_key_type(::google::iam::admin::v1::ServiceAccountPrivateKeyType value);
  public:

  // .google.iam.admin.v1.ServiceAccountKeyAlgorithm key_algorithm = 8;
  void clear_key_algorithm();
  ::google::iam::admin::v1::ServiceAccountKeyAlgorithm key_algorithm() const;
  void set_key_algorithm(::google::iam::admin::v1::ServiceAccountKeyAlgorithm value);
  private:
  ::google::iam::admin::v1::ServiceAccountKeyAlgorithm _internal_key_algorithm() const;
  void _internal_set_key_algorithm(::google::iam::admin::v1::ServiceAccountKeyAlgorithm value);
  public:

  // .google.iam.admin.v1.ServiceAccountKeyOrigin key_origin = 9;
  void clear_key_origin();
  ::google::iam::admin::v1::ServiceAccountKeyOrigin key_origin() const;
  void set_key_origin(::google::iam::admin::v1::ServiceAccountKeyOrigin value);
  private:
  ::google::iam::admin::v1::ServiceAccountKeyOrigin _internal_key_origin() const;
  void _internal_set_key_origin(::google::iam::admin::v1::ServiceAccountKeyOrigin value);
  public:

  // .google.iam.admin.v1.ListServiceAccountKeysRequest.KeyType key_type = 10;
  void clear_key_type();
  ::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType key_type() const;
  void set_key_type(::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType value);
  private:
  ::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType _internal_key_type() const;
  void _internal_set_key_type(::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType value);
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.ServiceAccountKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_key_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_data_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* valid_after_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* valid_before_time_;
    int private_key_type_;
    int key_algorithm_;
    int key_origin_;
    int key_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class CreateServiceAccountKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.CreateServiceAccountKeyRequest) */ {
 public:
  inline CreateServiceAccountKeyRequest() : CreateServiceAccountKeyRequest(nullptr) {}
  ~CreateServiceAccountKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateServiceAccountKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateServiceAccountKeyRequest(const CreateServiceAccountKeyRequest& from);
  CreateServiceAccountKeyRequest(CreateServiceAccountKeyRequest&& from) noexcept
    : CreateServiceAccountKeyRequest() {
    *this = ::std::move(from);
  }

  inline CreateServiceAccountKeyRequest& operator=(const CreateServiceAccountKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateServiceAccountKeyRequest& operator=(CreateServiceAccountKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateServiceAccountKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateServiceAccountKeyRequest* internal_default_instance() {
    return reinterpret_cast<const CreateServiceAccountKeyRequest*>(
               &_CreateServiceAccountKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CreateServiceAccountKeyRequest& a, CreateServiceAccountKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateServiceAccountKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateServiceAccountKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateServiceAccountKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateServiceAccountKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateServiceAccountKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateServiceAccountKeyRequest& from) {
    CreateServiceAccountKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateServiceAccountKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.CreateServiceAccountKeyRequest";
  }
  protected:
  explicit CreateServiceAccountKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPrivateKeyTypeFieldNumber = 2,
    kKeyAlgorithmFieldNumber = 3,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.iam.admin.v1.ServiceAccountPrivateKeyType private_key_type = 2;
  void clear_private_key_type();
  ::google::iam::admin::v1::ServiceAccountPrivateKeyType private_key_type() const;
  void set_private_key_type(::google::iam::admin::v1::ServiceAccountPrivateKeyType value);
  private:
  ::google::iam::admin::v1::ServiceAccountPrivateKeyType _internal_private_key_type() const;
  void _internal_set_private_key_type(::google::iam::admin::v1::ServiceAccountPrivateKeyType value);
  public:

  // .google.iam.admin.v1.ServiceAccountKeyAlgorithm key_algorithm = 3;
  void clear_key_algorithm();
  ::google::iam::admin::v1::ServiceAccountKeyAlgorithm key_algorithm() const;
  void set_key_algorithm(::google::iam::admin::v1::ServiceAccountKeyAlgorithm value);
  private:
  ::google::iam::admin::v1::ServiceAccountKeyAlgorithm _internal_key_algorithm() const;
  void _internal_set_key_algorithm(::google::iam::admin::v1::ServiceAccountKeyAlgorithm value);
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.CreateServiceAccountKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int private_key_type_;
    int key_algorithm_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class UploadServiceAccountKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.UploadServiceAccountKeyRequest) */ {
 public:
  inline UploadServiceAccountKeyRequest() : UploadServiceAccountKeyRequest(nullptr) {}
  ~UploadServiceAccountKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR UploadServiceAccountKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadServiceAccountKeyRequest(const UploadServiceAccountKeyRequest& from);
  UploadServiceAccountKeyRequest(UploadServiceAccountKeyRequest&& from) noexcept
    : UploadServiceAccountKeyRequest() {
    *this = ::std::move(from);
  }

  inline UploadServiceAccountKeyRequest& operator=(const UploadServiceAccountKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadServiceAccountKeyRequest& operator=(UploadServiceAccountKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadServiceAccountKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadServiceAccountKeyRequest* internal_default_instance() {
    return reinterpret_cast<const UploadServiceAccountKeyRequest*>(
               &_UploadServiceAccountKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UploadServiceAccountKeyRequest& a, UploadServiceAccountKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadServiceAccountKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadServiceAccountKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadServiceAccountKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadServiceAccountKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadServiceAccountKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadServiceAccountKeyRequest& from) {
    UploadServiceAccountKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadServiceAccountKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.UploadServiceAccountKeyRequest";
  }
  protected:
  explicit UploadServiceAccountKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPublicKeyDataFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes public_key_data = 2;
  void clear_public_key_data();
  const std::string& public_key_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key_data();
  PROTOBUF_NODISCARD std::string* release_public_key_data();
  void set_allocated_public_key_data(std::string* public_key_data);
  private:
  const std::string& _internal_public_key_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key_data(const std::string& value);
  std::string* _internal_mutable_public_key_data();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.UploadServiceAccountKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class DeleteServiceAccountKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.DeleteServiceAccountKeyRequest) */ {
 public:
  inline DeleteServiceAccountKeyRequest() : DeleteServiceAccountKeyRequest(nullptr) {}
  ~DeleteServiceAccountKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteServiceAccountKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteServiceAccountKeyRequest(const DeleteServiceAccountKeyRequest& from);
  DeleteServiceAccountKeyRequest(DeleteServiceAccountKeyRequest&& from) noexcept
    : DeleteServiceAccountKeyRequest() {
    *this = ::std::move(from);
  }

  inline DeleteServiceAccountKeyRequest& operator=(const DeleteServiceAccountKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteServiceAccountKeyRequest& operator=(DeleteServiceAccountKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteServiceAccountKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteServiceAccountKeyRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteServiceAccountKeyRequest*>(
               &_DeleteServiceAccountKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DeleteServiceAccountKeyRequest& a, DeleteServiceAccountKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteServiceAccountKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteServiceAccountKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteServiceAccountKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteServiceAccountKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteServiceAccountKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteServiceAccountKeyRequest& from) {
    DeleteServiceAccountKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteServiceAccountKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.DeleteServiceAccountKeyRequest";
  }
  protected:
  explicit DeleteServiceAccountKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.DeleteServiceAccountKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class SignBlobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.SignBlobRequest) */ {
 public:
  inline SignBlobRequest() : SignBlobRequest(nullptr) {}
  ~SignBlobRequest() override;
  explicit PROTOBUF_CONSTEXPR SignBlobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignBlobRequest(const SignBlobRequest& from);
  SignBlobRequest(SignBlobRequest&& from) noexcept
    : SignBlobRequest() {
    *this = ::std::move(from);
  }

  inline SignBlobRequest& operator=(const SignBlobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignBlobRequest& operator=(SignBlobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignBlobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignBlobRequest* internal_default_instance() {
    return reinterpret_cast<const SignBlobRequest*>(
               &_SignBlobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SignBlobRequest& a, SignBlobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignBlobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignBlobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignBlobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignBlobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignBlobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignBlobRequest& from) {
    SignBlobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignBlobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.SignBlobRequest";
  }
  protected:
  explicit SignBlobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kBytesToSignFieldNumber = 2,
  };
  // string name = 1 [deprecated = true, (.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  PROTOBUF_DEPRECATED void clear_name();
  PROTOBUF_DEPRECATED const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_name(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_name();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_name();
  PROTOBUF_DEPRECATED void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes bytes_to_sign = 2 [deprecated = true, (.google.api.field_behavior) = REQUIRED];
  PROTOBUF_DEPRECATED void clear_bytes_to_sign();
  PROTOBUF_DEPRECATED const std::string& bytes_to_sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_bytes_to_sign(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_bytes_to_sign();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_bytes_to_sign();
  PROTOBUF_DEPRECATED void set_allocated_bytes_to_sign(std::string* bytes_to_sign);
  private:
  const std::string& _internal_bytes_to_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bytes_to_sign(const std::string& value);
  std::string* _internal_mutable_bytes_to_sign();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.SignBlobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytes_to_sign_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class SignBlobResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.SignBlobResponse) */ {
 public:
  inline SignBlobResponse() : SignBlobResponse(nullptr) {}
  ~SignBlobResponse() override;
  explicit PROTOBUF_CONSTEXPR SignBlobResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignBlobResponse(const SignBlobResponse& from);
  SignBlobResponse(SignBlobResponse&& from) noexcept
    : SignBlobResponse() {
    *this = ::std::move(from);
  }

  inline SignBlobResponse& operator=(const SignBlobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignBlobResponse& operator=(SignBlobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignBlobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignBlobResponse* internal_default_instance() {
    return reinterpret_cast<const SignBlobResponse*>(
               &_SignBlobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SignBlobResponse& a, SignBlobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignBlobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignBlobResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignBlobResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignBlobResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignBlobResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignBlobResponse& from) {
    SignBlobResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignBlobResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.SignBlobResponse";
  }
  protected:
  explicit SignBlobResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyIdFieldNumber = 1,
    kSignatureFieldNumber = 2,
  };
  // string key_id = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_key_id();
  PROTOBUF_DEPRECATED const std::string& key_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_key_id(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_key_id();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_key_id();
  PROTOBUF_DEPRECATED void set_allocated_key_id(std::string* key_id);
  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(const std::string& value);
  std::string* _internal_mutable_key_id();
  public:

  // bytes signature = 2 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_signature();
  PROTOBUF_DEPRECATED const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_signature(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_signature();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_signature();
  PROTOBUF_DEPRECATED void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.SignBlobResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class SignJwtRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.SignJwtRequest) */ {
 public:
  inline SignJwtRequest() : SignJwtRequest(nullptr) {}
  ~SignJwtRequest() override;
  explicit PROTOBUF_CONSTEXPR SignJwtRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignJwtRequest(const SignJwtRequest& from);
  SignJwtRequest(SignJwtRequest&& from) noexcept
    : SignJwtRequest() {
    *this = ::std::move(from);
  }

  inline SignJwtRequest& operator=(const SignJwtRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignJwtRequest& operator=(SignJwtRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignJwtRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignJwtRequest* internal_default_instance() {
    return reinterpret_cast<const SignJwtRequest*>(
               &_SignJwtRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SignJwtRequest& a, SignJwtRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignJwtRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignJwtRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignJwtRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignJwtRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignJwtRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignJwtRequest& from) {
    SignJwtRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignJwtRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.SignJwtRequest";
  }
  protected:
  explicit SignJwtRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPayloadFieldNumber = 2,
  };
  // string name = 1 [deprecated = true, (.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  PROTOBUF_DEPRECATED void clear_name();
  PROTOBUF_DEPRECATED const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_name(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_name();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_name();
  PROTOBUF_DEPRECATED void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string payload = 2 [deprecated = true, (.google.api.field_behavior) = REQUIRED];
  PROTOBUF_DEPRECATED void clear_payload();
  PROTOBUF_DEPRECATED const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_payload(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_payload();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_payload();
  PROTOBUF_DEPRECATED void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.SignJwtRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class SignJwtResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.SignJwtResponse) */ {
 public:
  inline SignJwtResponse() : SignJwtResponse(nullptr) {}
  ~SignJwtResponse() override;
  explicit PROTOBUF_CONSTEXPR SignJwtResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignJwtResponse(const SignJwtResponse& from);
  SignJwtResponse(SignJwtResponse&& from) noexcept
    : SignJwtResponse() {
    *this = ::std::move(from);
  }

  inline SignJwtResponse& operator=(const SignJwtResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignJwtResponse& operator=(SignJwtResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignJwtResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignJwtResponse* internal_default_instance() {
    return reinterpret_cast<const SignJwtResponse*>(
               &_SignJwtResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SignJwtResponse& a, SignJwtResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignJwtResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignJwtResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignJwtResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignJwtResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignJwtResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignJwtResponse& from) {
    SignJwtResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignJwtResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.SignJwtResponse";
  }
  protected:
  explicit SignJwtResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyIdFieldNumber = 1,
    kSignedJwtFieldNumber = 2,
  };
  // string key_id = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_key_id();
  PROTOBUF_DEPRECATED const std::string& key_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_key_id(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_key_id();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_key_id();
  PROTOBUF_DEPRECATED void set_allocated_key_id(std::string* key_id);
  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(const std::string& value);
  std::string* _internal_mutable_key_id();
  public:

  // string signed_jwt = 2 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_signed_jwt();
  PROTOBUF_DEPRECATED const std::string& signed_jwt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_signed_jwt(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_signed_jwt();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_signed_jwt();
  PROTOBUF_DEPRECATED void set_allocated_signed_jwt(std::string* signed_jwt);
  private:
  const std::string& _internal_signed_jwt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signed_jwt(const std::string& value);
  std::string* _internal_mutable_signed_jwt();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.SignJwtResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signed_jwt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class Role final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.Role) */ {
 public:
  inline Role() : Role(nullptr) {}
  ~Role() override;
  explicit PROTOBUF_CONSTEXPR Role(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Role(const Role& from);
  Role(Role&& from) noexcept
    : Role() {
    *this = ::std::move(from);
  }

  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }
  inline Role& operator=(Role&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Role& default_instance() {
    return *internal_default_instance();
  }
  static inline const Role* internal_default_instance() {
    return reinterpret_cast<const Role*>(
               &_Role_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Role& a, Role& b) {
    a.Swap(&b);
  }
  inline void Swap(Role* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Role* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Role* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Role>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Role& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Role& from) {
    Role::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Role* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.Role";
  }
  protected:
  explicit Role(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Role_RoleLaunchStage RoleLaunchStage;
  static constexpr RoleLaunchStage ALPHA =
    Role_RoleLaunchStage_ALPHA;
  static constexpr RoleLaunchStage BETA =
    Role_RoleLaunchStage_BETA;
  static constexpr RoleLaunchStage GA =
    Role_RoleLaunchStage_GA;
  static constexpr RoleLaunchStage DEPRECATED =
    Role_RoleLaunchStage_DEPRECATED;
  static constexpr RoleLaunchStage DISABLED =
    Role_RoleLaunchStage_DISABLED;
  static constexpr RoleLaunchStage EAP =
    Role_RoleLaunchStage_EAP;
  static inline bool RoleLaunchStage_IsValid(int value) {
    return Role_RoleLaunchStage_IsValid(value);
  }
  static constexpr RoleLaunchStage RoleLaunchStage_MIN =
    Role_RoleLaunchStage_RoleLaunchStage_MIN;
  static constexpr RoleLaunchStage RoleLaunchStage_MAX =
    Role_RoleLaunchStage_RoleLaunchStage_MAX;
  static constexpr int RoleLaunchStage_ARRAYSIZE =
    Role_RoleLaunchStage_RoleLaunchStage_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RoleLaunchStage_descriptor() {
    return Role_RoleLaunchStage_descriptor();
  }
  template<typename T>
  static inline const std::string& RoleLaunchStage_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RoleLaunchStage>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RoleLaunchStage_Name.");
    return Role_RoleLaunchStage_Name(enum_t_value);
  }
  static inline bool RoleLaunchStage_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RoleLaunchStage* value) {
    return Role_RoleLaunchStage_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIncludedPermissionsFieldNumber = 7,
    kNameFieldNumber = 1,
    kTitleFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kEtagFieldNumber = 9,
    kStageFieldNumber = 8,
    kDeletedFieldNumber = 11,
  };
  // repeated string included_permissions = 7;
  int included_permissions_size() const;
  private:
  int _internal_included_permissions_size() const;
  public:
  void clear_included_permissions();
  const std::string& included_permissions(int index) const;
  std::string* mutable_included_permissions(int index);
  void set_included_permissions(int index, const std::string& value);
  void set_included_permissions(int index, std::string&& value);
  void set_included_permissions(int index, const char* value);
  void set_included_permissions(int index, const char* value, size_t size);
  std::string* add_included_permissions();
  void add_included_permissions(const std::string& value);
  void add_included_permissions(std::string&& value);
  void add_included_permissions(const char* value);
  void add_included_permissions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& included_permissions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_included_permissions();
  private:
  const std::string& _internal_included_permissions(int index) const;
  std::string* _internal_add_included_permissions();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // bytes etag = 9;
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // .google.iam.admin.v1.Role.RoleLaunchStage stage = 8;
  void clear_stage();
  ::google::iam::admin::v1::Role_RoleLaunchStage stage() const;
  void set_stage(::google::iam::admin::v1::Role_RoleLaunchStage value);
  private:
  ::google::iam::admin::v1::Role_RoleLaunchStage _internal_stage() const;
  void _internal_set_stage(::google::iam::admin::v1::Role_RoleLaunchStage value);
  public:

  // bool deleted = 11;
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.Role)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> included_permissions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
    int stage_;
    bool deleted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class QueryGrantableRolesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.QueryGrantableRolesRequest) */ {
 public:
  inline QueryGrantableRolesRequest() : QueryGrantableRolesRequest(nullptr) {}
  ~QueryGrantableRolesRequest() override;
  explicit PROTOBUF_CONSTEXPR QueryGrantableRolesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryGrantableRolesRequest(const QueryGrantableRolesRequest& from);
  QueryGrantableRolesRequest(QueryGrantableRolesRequest&& from) noexcept
    : QueryGrantableRolesRequest() {
    *this = ::std::move(from);
  }

  inline QueryGrantableRolesRequest& operator=(const QueryGrantableRolesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryGrantableRolesRequest& operator=(QueryGrantableRolesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryGrantableRolesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryGrantableRolesRequest* internal_default_instance() {
    return reinterpret_cast<const QueryGrantableRolesRequest*>(
               &_QueryGrantableRolesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(QueryGrantableRolesRequest& a, QueryGrantableRolesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryGrantableRolesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryGrantableRolesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryGrantableRolesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryGrantableRolesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryGrantableRolesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryGrantableRolesRequest& from) {
    QueryGrantableRolesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryGrantableRolesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.QueryGrantableRolesRequest";
  }
  protected:
  explicit QueryGrantableRolesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFullResourceNameFieldNumber = 1,
    kPageTokenFieldNumber = 4,
    kViewFieldNumber = 2,
    kPageSizeFieldNumber = 3,
  };
  // string full_resource_name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_full_resource_name();
  const std::string& full_resource_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_resource_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_resource_name();
  PROTOBUF_NODISCARD std::string* release_full_resource_name();
  void set_allocated_full_resource_name(std::string* full_resource_name);
  private:
  const std::string& _internal_full_resource_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_resource_name(const std::string& value);
  std::string* _internal_mutable_full_resource_name();
  public:

  // string page_token = 4;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // .google.iam.admin.v1.RoleView view = 2;
  void clear_view();
  ::google::iam::admin::v1::RoleView view() const;
  void set_view(::google::iam::admin::v1::RoleView value);
  private:
  ::google::iam::admin::v1::RoleView _internal_view() const;
  void _internal_set_view(::google::iam::admin::v1::RoleView value);
  public:

  // int32 page_size = 3;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.QueryGrantableRolesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_resource_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int view_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class QueryGrantableRolesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.QueryGrantableRolesResponse) */ {
 public:
  inline QueryGrantableRolesResponse() : QueryGrantableRolesResponse(nullptr) {}
  ~QueryGrantableRolesResponse() override;
  explicit PROTOBUF_CONSTEXPR QueryGrantableRolesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryGrantableRolesResponse(const QueryGrantableRolesResponse& from);
  QueryGrantableRolesResponse(QueryGrantableRolesResponse&& from) noexcept
    : QueryGrantableRolesResponse() {
    *this = ::std::move(from);
  }

  inline QueryGrantableRolesResponse& operator=(const QueryGrantableRolesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryGrantableRolesResponse& operator=(QueryGrantableRolesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryGrantableRolesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryGrantableRolesResponse* internal_default_instance() {
    return reinterpret_cast<const QueryGrantableRolesResponse*>(
               &_QueryGrantableRolesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(QueryGrantableRolesResponse& a, QueryGrantableRolesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryGrantableRolesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryGrantableRolesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryGrantableRolesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryGrantableRolesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryGrantableRolesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryGrantableRolesResponse& from) {
    QueryGrantableRolesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryGrantableRolesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.QueryGrantableRolesResponse";
  }
  protected:
  explicit QueryGrantableRolesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.iam.admin.v1.Role roles = 1;
  int roles_size() const;
  private:
  int _internal_roles_size() const;
  public:
  void clear_roles();
  ::google::iam::admin::v1::Role* mutable_roles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::Role >*
      mutable_roles();
  private:
  const ::google::iam::admin::v1::Role& _internal_roles(int index) const;
  ::google::iam::admin::v1::Role* _internal_add_roles();
  public:
  const ::google::iam::admin::v1::Role& roles(int index) const;
  ::google::iam::admin::v1::Role* add_roles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::Role >&
      roles() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.QueryGrantableRolesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::Role > roles_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class ListRolesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.ListRolesRequest) */ {
 public:
  inline ListRolesRequest() : ListRolesRequest(nullptr) {}
  ~ListRolesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListRolesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRolesRequest(const ListRolesRequest& from);
  ListRolesRequest(ListRolesRequest&& from) noexcept
    : ListRolesRequest() {
    *this = ::std::move(from);
  }

  inline ListRolesRequest& operator=(const ListRolesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRolesRequest& operator=(ListRolesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRolesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRolesRequest* internal_default_instance() {
    return reinterpret_cast<const ListRolesRequest*>(
               &_ListRolesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ListRolesRequest& a, ListRolesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRolesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRolesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRolesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRolesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRolesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListRolesRequest& from) {
    ListRolesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRolesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.ListRolesRequest";
  }
  protected:
  explicit ListRolesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
    kViewFieldNumber = 4,
    kShowDeletedFieldNumber = 6,
  };
  // string parent = 1 [(.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 3;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // .google.iam.admin.v1.RoleView view = 4;
  void clear_view();
  ::google::iam::admin::v1::RoleView view() const;
  void set_view(::google::iam::admin::v1::RoleView value);
  private:
  ::google::iam::admin::v1::RoleView _internal_view() const;
  void _internal_set_view(::google::iam::admin::v1::RoleView value);
  public:

  // bool show_deleted = 6;
  void clear_show_deleted();
  bool show_deleted() const;
  void set_show_deleted(bool value);
  private:
  bool _internal_show_deleted() const;
  void _internal_set_show_deleted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.ListRolesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    int view_;
    bool show_deleted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class ListRolesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.ListRolesResponse) */ {
 public:
  inline ListRolesResponse() : ListRolesResponse(nullptr) {}
  ~ListRolesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListRolesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRolesResponse(const ListRolesResponse& from);
  ListRolesResponse(ListRolesResponse&& from) noexcept
    : ListRolesResponse() {
    *this = ::std::move(from);
  }

  inline ListRolesResponse& operator=(const ListRolesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRolesResponse& operator=(ListRolesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRolesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRolesResponse* internal_default_instance() {
    return reinterpret_cast<const ListRolesResponse*>(
               &_ListRolesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ListRolesResponse& a, ListRolesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRolesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRolesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRolesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRolesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRolesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListRolesResponse& from) {
    ListRolesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRolesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.ListRolesResponse";
  }
  protected:
  explicit ListRolesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.iam.admin.v1.Role roles = 1;
  int roles_size() const;
  private:
  int _internal_roles_size() const;
  public:
  void clear_roles();
  ::google::iam::admin::v1::Role* mutable_roles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::Role >*
      mutable_roles();
  private:
  const ::google::iam::admin::v1::Role& _internal_roles(int index) const;
  ::google::iam::admin::v1::Role* _internal_add_roles();
  public:
  const ::google::iam::admin::v1::Role& roles(int index) const;
  ::google::iam::admin::v1::Role* add_roles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::Role >&
      roles() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.ListRolesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::Role > roles_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class GetRoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.GetRoleRequest) */ {
 public:
  inline GetRoleRequest() : GetRoleRequest(nullptr) {}
  ~GetRoleRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleRequest(const GetRoleRequest& from);
  GetRoleRequest(GetRoleRequest&& from) noexcept
    : GetRoleRequest() {
    *this = ::std::move(from);
  }

  inline GetRoleRequest& operator=(const GetRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleRequest& operator=(GetRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleRequest* internal_default_instance() {
    return reinterpret_cast<const GetRoleRequest*>(
               &_GetRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GetRoleRequest& a, GetRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleRequest& from) {
    GetRoleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.GetRoleRequest";
  }
  protected:
  explicit GetRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.GetRoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class CreateRoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.CreateRoleRequest) */ {
 public:
  inline CreateRoleRequest() : CreateRoleRequest(nullptr) {}
  ~CreateRoleRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRoleRequest(const CreateRoleRequest& from);
  CreateRoleRequest(CreateRoleRequest&& from) noexcept
    : CreateRoleRequest() {
    *this = ::std::move(from);
  }

  inline CreateRoleRequest& operator=(const CreateRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoleRequest& operator=(CreateRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoleRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRoleRequest*>(
               &_CreateRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CreateRoleRequest& a, CreateRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRoleRequest& from) {
    CreateRoleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.CreateRoleRequest";
  }
  protected:
  explicit CreateRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kRoleIdFieldNumber = 2,
    kRoleFieldNumber = 3,
  };
  // string parent = 1 [(.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string role_id = 2;
  void clear_role_id();
  const std::string& role_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_role_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_role_id();
  PROTOBUF_NODISCARD std::string* release_role_id();
  void set_allocated_role_id(std::string* role_id);
  private:
  const std::string& _internal_role_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role_id(const std::string& value);
  std::string* _internal_mutable_role_id();
  public:

  // .google.iam.admin.v1.Role role = 3;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::google::iam::admin::v1::Role& role() const;
  PROTOBUF_NODISCARD ::google::iam::admin::v1::Role* release_role();
  ::google::iam::admin::v1::Role* mutable_role();
  void set_allocated_role(::google::iam::admin::v1::Role* role);
  private:
  const ::google::iam::admin::v1::Role& _internal_role() const;
  ::google::iam::admin::v1::Role* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::google::iam::admin::v1::Role* role);
  ::google::iam::admin::v1::Role* unsafe_arena_release_role();

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.CreateRoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_id_;
    ::google::iam::admin::v1::Role* role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class UpdateRoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.UpdateRoleRequest) */ {
 public:
  inline UpdateRoleRequest() : UpdateRoleRequest(nullptr) {}
  ~UpdateRoleRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateRoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRoleRequest(const UpdateRoleRequest& from);
  UpdateRoleRequest(UpdateRoleRequest&& from) noexcept
    : UpdateRoleRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRoleRequest& operator=(const UpdateRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRoleRequest& operator=(UpdateRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRoleRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRoleRequest*>(
               &_UpdateRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(UpdateRoleRequest& a, UpdateRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateRoleRequest& from) {
    UpdateRoleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.UpdateRoleRequest";
  }
  protected:
  explicit UpdateRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRoleFieldNumber = 2,
    kUpdateMaskFieldNumber = 3,
  };
  // string name = 1 [(.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.iam.admin.v1.Role role = 2;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::google::iam::admin::v1::Role& role() const;
  PROTOBUF_NODISCARD ::google::iam::admin::v1::Role* release_role();
  ::google::iam::admin::v1::Role* mutable_role();
  void set_allocated_role(::google::iam::admin::v1::Role* role);
  private:
  const ::google::iam::admin::v1::Role& _internal_role() const;
  ::google::iam::admin::v1::Role* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::google::iam::admin::v1::Role* role);
  ::google::iam::admin::v1::Role* unsafe_arena_release_role();

  // .google.protobuf.FieldMask update_mask = 3;
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.UpdateRoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::google::iam::admin::v1::Role* role_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class DeleteRoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.DeleteRoleRequest) */ {
 public:
  inline DeleteRoleRequest() : DeleteRoleRequest(nullptr) {}
  ~DeleteRoleRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRoleRequest(const DeleteRoleRequest& from);
  DeleteRoleRequest(DeleteRoleRequest&& from) noexcept
    : DeleteRoleRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRoleRequest& operator=(const DeleteRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRoleRequest& operator=(DeleteRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRoleRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRoleRequest*>(
               &_DeleteRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(DeleteRoleRequest& a, DeleteRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRoleRequest& from) {
    DeleteRoleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.DeleteRoleRequest";
  }
  protected:
  explicit DeleteRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kEtagFieldNumber = 2,
  };
  // string name = 1 [(.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes etag = 2;
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.DeleteRoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class UndeleteRoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.UndeleteRoleRequest) */ {
 public:
  inline UndeleteRoleRequest() : UndeleteRoleRequest(nullptr) {}
  ~UndeleteRoleRequest() override;
  explicit PROTOBUF_CONSTEXPR UndeleteRoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UndeleteRoleRequest(const UndeleteRoleRequest& from);
  UndeleteRoleRequest(UndeleteRoleRequest&& from) noexcept
    : UndeleteRoleRequest() {
    *this = ::std::move(from);
  }

  inline UndeleteRoleRequest& operator=(const UndeleteRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UndeleteRoleRequest& operator=(UndeleteRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UndeleteRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UndeleteRoleRequest* internal_default_instance() {
    return reinterpret_cast<const UndeleteRoleRequest*>(
               &_UndeleteRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(UndeleteRoleRequest& a, UndeleteRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UndeleteRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UndeleteRoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UndeleteRoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UndeleteRoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UndeleteRoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UndeleteRoleRequest& from) {
    UndeleteRoleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UndeleteRoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.UndeleteRoleRequest";
  }
  protected:
  explicit UndeleteRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kEtagFieldNumber = 2,
  };
  // string name = 1 [(.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes etag = 2;
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.UndeleteRoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class Permission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.Permission) */ {
 public:
  inline Permission() : Permission(nullptr) {}
  ~Permission() override;
  explicit PROTOBUF_CONSTEXPR Permission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Permission(const Permission& from);
  Permission(Permission&& from) noexcept
    : Permission() {
    *this = ::std::move(from);
  }

  inline Permission& operator=(const Permission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Permission& operator=(Permission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Permission& default_instance() {
    return *internal_default_instance();
  }
  static inline const Permission* internal_default_instance() {
    return reinterpret_cast<const Permission*>(
               &_Permission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Permission& a, Permission& b) {
    a.Swap(&b);
  }
  inline void Swap(Permission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Permission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Permission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Permission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Permission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Permission& from) {
    Permission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Permission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.Permission";
  }
  protected:
  explicit Permission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Permission_PermissionLaunchStage PermissionLaunchStage;
  static constexpr PermissionLaunchStage ALPHA =
    Permission_PermissionLaunchStage_ALPHA;
  static constexpr PermissionLaunchStage BETA =
    Permission_PermissionLaunchStage_BETA;
  static constexpr PermissionLaunchStage GA =
    Permission_PermissionLaunchStage_GA;
  static constexpr PermissionLaunchStage DEPRECATED =
    Permission_PermissionLaunchStage_DEPRECATED;
  static inline bool PermissionLaunchStage_IsValid(int value) {
    return Permission_PermissionLaunchStage_IsValid(value);
  }
  static constexpr PermissionLaunchStage PermissionLaunchStage_MIN =
    Permission_PermissionLaunchStage_PermissionLaunchStage_MIN;
  static constexpr PermissionLaunchStage PermissionLaunchStage_MAX =
    Permission_PermissionLaunchStage_PermissionLaunchStage_MAX;
  static constexpr int PermissionLaunchStage_ARRAYSIZE =
    Permission_PermissionLaunchStage_PermissionLaunchStage_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PermissionLaunchStage_descriptor() {
    return Permission_PermissionLaunchStage_descriptor();
  }
  template<typename T>
  static inline const std::string& PermissionLaunchStage_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PermissionLaunchStage>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PermissionLaunchStage_Name.");
    return Permission_PermissionLaunchStage_Name(enum_t_value);
  }
  static inline bool PermissionLaunchStage_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PermissionLaunchStage* value) {
    return Permission_PermissionLaunchStage_Parse(name, value);
  }

  typedef Permission_CustomRolesSupportLevel CustomRolesSupportLevel;
  static constexpr CustomRolesSupportLevel SUPPORTED =
    Permission_CustomRolesSupportLevel_SUPPORTED;
  static constexpr CustomRolesSupportLevel TESTING =
    Permission_CustomRolesSupportLevel_TESTING;
  static constexpr CustomRolesSupportLevel NOT_SUPPORTED =
    Permission_CustomRolesSupportLevel_NOT_SUPPORTED;
  static inline bool CustomRolesSupportLevel_IsValid(int value) {
    return Permission_CustomRolesSupportLevel_IsValid(value);
  }
  static constexpr CustomRolesSupportLevel CustomRolesSupportLevel_MIN =
    Permission_CustomRolesSupportLevel_CustomRolesSupportLevel_MIN;
  static constexpr CustomRolesSupportLevel CustomRolesSupportLevel_MAX =
    Permission_CustomRolesSupportLevel_CustomRolesSupportLevel_MAX;
  static constexpr int CustomRolesSupportLevel_ARRAYSIZE =
    Permission_CustomRolesSupportLevel_CustomRolesSupportLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CustomRolesSupportLevel_descriptor() {
    return Permission_CustomRolesSupportLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& CustomRolesSupportLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CustomRolesSupportLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CustomRolesSupportLevel_Name.");
    return Permission_CustomRolesSupportLevel_Name(enum_t_value);
  }
  static inline bool CustomRolesSupportLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CustomRolesSupportLevel* value) {
    return Permission_CustomRolesSupportLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTitleFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kPrimaryPermissionFieldNumber = 8,
    kStageFieldNumber = 5,
    kOnlyInPredefinedRolesFieldNumber = 4,
    kApiDisabledFieldNumber = 7,
    kCustomRolesSupportLevelFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string primary_permission = 8;
  void clear_primary_permission();
  const std::string& primary_permission() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_primary_permission(ArgT0&& arg0, ArgT... args);
  std::string* mutable_primary_permission();
  PROTOBUF_NODISCARD std::string* release_primary_permission();
  void set_allocated_primary_permission(std::string* primary_permission);
  private:
  const std::string& _internal_primary_permission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_permission(const std::string& value);
  std::string* _internal_mutable_primary_permission();
  public:

  // .google.iam.admin.v1.Permission.PermissionLaunchStage stage = 5;
  void clear_stage();
  ::google::iam::admin::v1::Permission_PermissionLaunchStage stage() const;
  void set_stage(::google::iam::admin::v1::Permission_PermissionLaunchStage value);
  private:
  ::google::iam::admin::v1::Permission_PermissionLaunchStage _internal_stage() const;
  void _internal_set_stage(::google::iam::admin::v1::Permission_PermissionLaunchStage value);
  public:

  // bool only_in_predefined_roles = 4 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_only_in_predefined_roles();
  PROTOBUF_DEPRECATED bool only_in_predefined_roles() const;
  PROTOBUF_DEPRECATED void set_only_in_predefined_roles(bool value);
  private:
  bool _internal_only_in_predefined_roles() const;
  void _internal_set_only_in_predefined_roles(bool value);
  public:

  // bool api_disabled = 7;
  void clear_api_disabled();
  bool api_disabled() const;
  void set_api_disabled(bool value);
  private:
  bool _internal_api_disabled() const;
  void _internal_set_api_disabled(bool value);
  public:

  // .google.iam.admin.v1.Permission.CustomRolesSupportLevel custom_roles_support_level = 6;
  void clear_custom_roles_support_level();
  ::google::iam::admin::v1::Permission_CustomRolesSupportLevel custom_roles_support_level() const;
  void set_custom_roles_support_level(::google::iam::admin::v1::Permission_CustomRolesSupportLevel value);
  private:
  ::google::iam::admin::v1::Permission_CustomRolesSupportLevel _internal_custom_roles_support_level() const;
  void _internal_set_custom_roles_support_level(::google::iam::admin::v1::Permission_CustomRolesSupportLevel value);
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.Permission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr primary_permission_;
    int stage_;
    bool only_in_predefined_roles_;
    bool api_disabled_;
    int custom_roles_support_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class QueryTestablePermissionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.QueryTestablePermissionsRequest) */ {
 public:
  inline QueryTestablePermissionsRequest() : QueryTestablePermissionsRequest(nullptr) {}
  ~QueryTestablePermissionsRequest() override;
  explicit PROTOBUF_CONSTEXPR QueryTestablePermissionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTestablePermissionsRequest(const QueryTestablePermissionsRequest& from);
  QueryTestablePermissionsRequest(QueryTestablePermissionsRequest&& from) noexcept
    : QueryTestablePermissionsRequest() {
    *this = ::std::move(from);
  }

  inline QueryTestablePermissionsRequest& operator=(const QueryTestablePermissionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTestablePermissionsRequest& operator=(QueryTestablePermissionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTestablePermissionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTestablePermissionsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryTestablePermissionsRequest*>(
               &_QueryTestablePermissionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(QueryTestablePermissionsRequest& a, QueryTestablePermissionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTestablePermissionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTestablePermissionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTestablePermissionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTestablePermissionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTestablePermissionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryTestablePermissionsRequest& from) {
    QueryTestablePermissionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTestablePermissionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.QueryTestablePermissionsRequest";
  }
  protected:
  explicit QueryTestablePermissionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFullResourceNameFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string full_resource_name = 1;
  void clear_full_resource_name();
  const std::string& full_resource_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_resource_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_resource_name();
  PROTOBUF_NODISCARD std::string* release_full_resource_name();
  void set_allocated_full_resource_name(std::string* full_resource_name);
  private:
  const std::string& _internal_full_resource_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_resource_name(const std::string& value);
  std::string* _internal_mutable_full_resource_name();
  public:

  // string page_token = 3;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.QueryTestablePermissionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_resource_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class QueryTestablePermissionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.QueryTestablePermissionsResponse) */ {
 public:
  inline QueryTestablePermissionsResponse() : QueryTestablePermissionsResponse(nullptr) {}
  ~QueryTestablePermissionsResponse() override;
  explicit PROTOBUF_CONSTEXPR QueryTestablePermissionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTestablePermissionsResponse(const QueryTestablePermissionsResponse& from);
  QueryTestablePermissionsResponse(QueryTestablePermissionsResponse&& from) noexcept
    : QueryTestablePermissionsResponse() {
    *this = ::std::move(from);
  }

  inline QueryTestablePermissionsResponse& operator=(const QueryTestablePermissionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTestablePermissionsResponse& operator=(QueryTestablePermissionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTestablePermissionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTestablePermissionsResponse* internal_default_instance() {
    return reinterpret_cast<const QueryTestablePermissionsResponse*>(
               &_QueryTestablePermissionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(QueryTestablePermissionsResponse& a, QueryTestablePermissionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTestablePermissionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTestablePermissionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTestablePermissionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTestablePermissionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTestablePermissionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryTestablePermissionsResponse& from) {
    QueryTestablePermissionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTestablePermissionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.QueryTestablePermissionsResponse";
  }
  protected:
  explicit QueryTestablePermissionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.iam.admin.v1.Permission permissions = 1;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::google::iam::admin::v1::Permission* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::Permission >*
      mutable_permissions();
  private:
  const ::google::iam::admin::v1::Permission& _internal_permissions(int index) const;
  ::google::iam::admin::v1::Permission* _internal_add_permissions();
  public:
  const ::google::iam::admin::v1::Permission& permissions(int index) const;
  ::google::iam::admin::v1::Permission* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::Permission >&
      permissions() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.QueryTestablePermissionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::Permission > permissions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class QueryAuditableServicesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.QueryAuditableServicesRequest) */ {
 public:
  inline QueryAuditableServicesRequest() : QueryAuditableServicesRequest(nullptr) {}
  ~QueryAuditableServicesRequest() override;
  explicit PROTOBUF_CONSTEXPR QueryAuditableServicesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAuditableServicesRequest(const QueryAuditableServicesRequest& from);
  QueryAuditableServicesRequest(QueryAuditableServicesRequest&& from) noexcept
    : QueryAuditableServicesRequest() {
    *this = ::std::move(from);
  }

  inline QueryAuditableServicesRequest& operator=(const QueryAuditableServicesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAuditableServicesRequest& operator=(QueryAuditableServicesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAuditableServicesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAuditableServicesRequest* internal_default_instance() {
    return reinterpret_cast<const QueryAuditableServicesRequest*>(
               &_QueryAuditableServicesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(QueryAuditableServicesRequest& a, QueryAuditableServicesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAuditableServicesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAuditableServicesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAuditableServicesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAuditableServicesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAuditableServicesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAuditableServicesRequest& from) {
    QueryAuditableServicesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAuditableServicesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.QueryAuditableServicesRequest";
  }
  protected:
  explicit QueryAuditableServicesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFullResourceNameFieldNumber = 1,
  };
  // string full_resource_name = 1;
  void clear_full_resource_name();
  const std::string& full_resource_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_resource_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_resource_name();
  PROTOBUF_NODISCARD std::string* release_full_resource_name();
  void set_allocated_full_resource_name(std::string* full_resource_name);
  private:
  const std::string& _internal_full_resource_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_resource_name(const std::string& value);
  std::string* _internal_mutable_full_resource_name();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.QueryAuditableServicesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_resource_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class QueryAuditableServicesResponse_AuditableService final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.QueryAuditableServicesResponse.AuditableService) */ {
 public:
  inline QueryAuditableServicesResponse_AuditableService() : QueryAuditableServicesResponse_AuditableService(nullptr) {}
  ~QueryAuditableServicesResponse_AuditableService() override;
  explicit PROTOBUF_CONSTEXPR QueryAuditableServicesResponse_AuditableService(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAuditableServicesResponse_AuditableService(const QueryAuditableServicesResponse_AuditableService& from);
  QueryAuditableServicesResponse_AuditableService(QueryAuditableServicesResponse_AuditableService&& from) noexcept
    : QueryAuditableServicesResponse_AuditableService() {
    *this = ::std::move(from);
  }

  inline QueryAuditableServicesResponse_AuditableService& operator=(const QueryAuditableServicesResponse_AuditableService& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAuditableServicesResponse_AuditableService& operator=(QueryAuditableServicesResponse_AuditableService&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAuditableServicesResponse_AuditableService& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAuditableServicesResponse_AuditableService* internal_default_instance() {
    return reinterpret_cast<const QueryAuditableServicesResponse_AuditableService*>(
               &_QueryAuditableServicesResponse_AuditableService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(QueryAuditableServicesResponse_AuditableService& a, QueryAuditableServicesResponse_AuditableService& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAuditableServicesResponse_AuditableService* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAuditableServicesResponse_AuditableService* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAuditableServicesResponse_AuditableService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAuditableServicesResponse_AuditableService>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAuditableServicesResponse_AuditableService& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAuditableServicesResponse_AuditableService& from) {
    QueryAuditableServicesResponse_AuditableService::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAuditableServicesResponse_AuditableService* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.QueryAuditableServicesResponse.AuditableService";
  }
  protected:
  explicit QueryAuditableServicesResponse_AuditableService(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.QueryAuditableServicesResponse.AuditableService)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class QueryAuditableServicesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.QueryAuditableServicesResponse) */ {
 public:
  inline QueryAuditableServicesResponse() : QueryAuditableServicesResponse(nullptr) {}
  ~QueryAuditableServicesResponse() override;
  explicit PROTOBUF_CONSTEXPR QueryAuditableServicesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryAuditableServicesResponse(const QueryAuditableServicesResponse& from);
  QueryAuditableServicesResponse(QueryAuditableServicesResponse&& from) noexcept
    : QueryAuditableServicesResponse() {
    *this = ::std::move(from);
  }

  inline QueryAuditableServicesResponse& operator=(const QueryAuditableServicesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAuditableServicesResponse& operator=(QueryAuditableServicesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAuditableServicesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAuditableServicesResponse* internal_default_instance() {
    return reinterpret_cast<const QueryAuditableServicesResponse*>(
               &_QueryAuditableServicesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(QueryAuditableServicesResponse& a, QueryAuditableServicesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryAuditableServicesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAuditableServicesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAuditableServicesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryAuditableServicesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryAuditableServicesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryAuditableServicesResponse& from) {
    QueryAuditableServicesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryAuditableServicesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.QueryAuditableServicesResponse";
  }
  protected:
  explicit QueryAuditableServicesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef QueryAuditableServicesResponse_AuditableService AuditableService;

  // accessors -------------------------------------------------------

  enum : int {
    kServicesFieldNumber = 1,
  };
  // repeated .google.iam.admin.v1.QueryAuditableServicesResponse.AuditableService services = 1;
  int services_size() const;
  private:
  int _internal_services_size() const;
  public:
  void clear_services();
  ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService* mutable_services(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService >*
      mutable_services();
  private:
  const ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService& _internal_services(int index) const;
  ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService* _internal_add_services();
  public:
  const ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService& services(int index) const;
  ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService* add_services();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService >&
      services() const;

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.QueryAuditableServicesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService > services_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class LintPolicyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.LintPolicyRequest) */ {
 public:
  inline LintPolicyRequest() : LintPolicyRequest(nullptr) {}
  ~LintPolicyRequest() override;
  explicit PROTOBUF_CONSTEXPR LintPolicyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LintPolicyRequest(const LintPolicyRequest& from);
  LintPolicyRequest(LintPolicyRequest&& from) noexcept
    : LintPolicyRequest() {
    *this = ::std::move(from);
  }

  inline LintPolicyRequest& operator=(const LintPolicyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LintPolicyRequest& operator=(LintPolicyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LintPolicyRequest& default_instance() {
    return *internal_default_instance();
  }
  enum LintObjectCase {
    kCondition = 5,
    LINT_OBJECT_NOT_SET = 0,
  };

  static inline const LintPolicyRequest* internal_default_instance() {
    return reinterpret_cast<const LintPolicyRequest*>(
               &_LintPolicyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(LintPolicyRequest& a, LintPolicyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LintPolicyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LintPolicyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LintPolicyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LintPolicyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LintPolicyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LintPolicyRequest& from) {
    LintPolicyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LintPolicyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.LintPolicyRequest";
  }
  protected:
  explicit LintPolicyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFullResourceNameFieldNumber = 1,
    kConditionFieldNumber = 5,
  };
  // string full_resource_name = 1;
  void clear_full_resource_name();
  const std::string& full_resource_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_resource_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_resource_name();
  PROTOBUF_NODISCARD std::string* release_full_resource_name();
  void set_allocated_full_resource_name(std::string* full_resource_name);
  private:
  const std::string& _internal_full_resource_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_resource_name(const std::string& value);
  std::string* _internal_mutable_full_resource_name();
  public:

  // .google.type.Expr condition = 5;
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;
  public:
  void clear_condition();
  const ::google::type::Expr& condition() const;
  PROTOBUF_NODISCARD ::google::type::Expr* release_condition();
  ::google::type::Expr* mutable_condition();
  void set_allocated_condition(::google::type::Expr* condition);
  private:
  const ::google::type::Expr& _internal_condition() const;
  ::google::type::Expr* _internal_mutable_condition();
  public:
  void unsafe_arena_set_allocated_condition(
      ::google::type::Expr* condition);
  ::google::type::Expr* unsafe_arena_release_condition();

  void clear_lint_object();
  LintObjectCase lint_object_case() const;
  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.LintPolicyRequest)
 private:
  class _Internal;
  void set_has_condition();

  inline bool has_lint_object() const;
  inline void clear_has_lint_object();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_resource_name_;
    union LintObjectUnion {
      constexpr LintObjectUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::google::type::Expr* condition_;
    } lint_object_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class LintResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.LintResult) */ {
 public:
  inline LintResult() : LintResult(nullptr) {}
  ~LintResult() override;
  explicit PROTOBUF_CONSTEXPR LintResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LintResult(const LintResult& from);
  LintResult(LintResult&& from) noexcept
    : LintResult() {
    *this = ::std::move(from);
  }

  inline LintResult& operator=(const LintResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline LintResult& operator=(LintResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LintResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const LintResult* internal_default_instance() {
    return reinterpret_cast<const LintResult*>(
               &_LintResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(LintResult& a, LintResult& b) {
    a.Swap(&b);
  }
  inline void Swap(LintResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LintResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LintResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LintResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LintResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LintResult& from) {
    LintResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LintResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.LintResult";
  }
  protected:
  explicit LintResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LintResult_Level Level;
  static constexpr Level LEVEL_UNSPECIFIED =
    LintResult_Level_LEVEL_UNSPECIFIED;
  static constexpr Level CONDITION =
    LintResult_Level_CONDITION;
  static inline bool Level_IsValid(int value) {
    return LintResult_Level_IsValid(value);
  }
  static constexpr Level Level_MIN =
    LintResult_Level_Level_MIN;
  static constexpr Level Level_MAX =
    LintResult_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE =
    LintResult_Level_Level_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Level_descriptor() {
    return LintResult_Level_descriptor();
  }
  template<typename T>
  static inline const std::string& Level_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Level>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Level_Name.");
    return LintResult_Level_Name(enum_t_value);
  }
  static inline bool Level_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Level* value) {
    return LintResult_Level_Parse(name, value);
  }

  typedef LintResult_Severity Severity;
  static constexpr Severity SEVERITY_UNSPECIFIED =
    LintResult_Severity_SEVERITY_UNSPECIFIED;
  static constexpr Severity ERROR =
    LintResult_Severity_ERROR;
  static constexpr Severity WARNING =
    LintResult_Severity_WARNING;
  static constexpr Severity NOTICE =
    LintResult_Severity_NOTICE;
  static constexpr Severity INFO =
    LintResult_Severity_INFO;
  static constexpr Severity DEPRECATED =
    LintResult_Severity_DEPRECATED;
  static inline bool Severity_IsValid(int value) {
    return LintResult_Severity_IsValid(value);
  }
  static constexpr Severity Severity_MIN =
    LintResult_Severity_Severity_MIN;
  static constexpr Severity Severity_MAX =
    LintResult_Severity_Severity_MAX;
  static constexpr int Severity_ARRAYSIZE =
    LintResult_Severity_Severity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Severity_descriptor() {
    return LintResult_Severity_descriptor();
  }
  template<typename T>
  static inline const std::string& Severity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Severity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Severity_Name.");
    return LintResult_Severity_Name(enum_t_value);
  }
  static inline bool Severity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Severity* value) {
    return LintResult_Severity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValidationUnitNameFieldNumber = 2,
    kFieldNameFieldNumber = 5,
    kDebugMessageFieldNumber = 7,
    kLevelFieldNumber = 1,
    kSeverityFieldNumber = 3,
    kLocationOffsetFieldNumber = 6,
  };
  // string validation_unit_name = 2;
  void clear_validation_unit_name();
  const std::string& validation_unit_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_validation_unit_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_validation_unit_name();
  PROTOBUF_NODISCARD std::string* release_validation_unit_name();
  void set_allocated_validation_unit_name(std::string* validation_unit_name);
  private:
  const std::string& _internal_validation_unit_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validation_unit_name(const std::string& value);
  std::string* _internal_mutable_validation_unit_name();
  public:

  // string field_name = 5;
  void clear_field_name();
  const std::string& field_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field_name();
  PROTOBUF_NODISCARD std::string* release_field_name();
  void set_allocated_field_name(std::string* field_name);
  private:
  const std::string& _internal_field_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field_name(const std::string& value);
  std::string* _internal_mutable_field_name();
  public:

  // string debug_message = 7;
  void clear_debug_message();
  const std::string& debug_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_debug_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_debug_message();
  PROTOBUF_NODISCARD std::string* release_debug_message();
  void set_allocated_debug_message(std::string* debug_message);
  private:
  const std::string& _internal_debug_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debug_message(const std::string& value);
  std::string* _internal_mutable_debug_message();
  public:

  // .google.iam.admin.v1.LintResult.Level level = 1;
  void clear_level();
  ::google::iam::admin::v1::LintResult_Level level() const;
  void set_level(::google::iam::admin::v1::LintResult_Level value);
  private:
  ::google::iam::admin::v1::LintResult_Level _internal_level() const;
  void _internal_set_level(::google::iam::admin::v1::LintResult_Level value);
  public:

  // .google.iam.admin.v1.LintResult.Severity severity = 3;
  void clear_severity();
  ::google::iam::admin::v1::LintResult_Severity severity() const;
  void set_severity(::google::iam::admin::v1::LintResult_Severity value);
  private:
  ::google::iam::admin::v1::LintResult_Severity _internal_severity() const;
  void _internal_set_severity(::google::iam::admin::v1::LintResult_Severity value);
  public:

  // int32 location_offset = 6;
  void clear_location_offset();
  int32_t location_offset() const;
  void set_location_offset(int32_t value);
  private:
  int32_t _internal_location_offset() const;
  void _internal_set_location_offset(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.LintResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validation_unit_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr debug_message_;
    int level_;
    int severity_;
    int32_t location_offset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// -------------------------------------------------------------------

class LintPolicyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.admin.v1.LintPolicyResponse) */ {
 public:
  inline LintPolicyResponse() : LintPolicyResponse(nullptr) {}
  ~LintPolicyResponse() override;
  explicit PROTOBUF_CONSTEXPR LintPolicyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LintPolicyResponse(const LintPolicyResponse& from);
  LintPolicyResponse(LintPolicyResponse&& from) noexcept
    : LintPolicyResponse() {
    *this = ::std::move(from);
  }

  inline LintPolicyResponse& operator=(const LintPolicyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LintPolicyResponse& operator=(LintPolicyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LintPolicyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LintPolicyResponse* internal_default_instance() {
    return reinterpret_cast<const LintPolicyResponse*>(
               &_LintPolicyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(LintPolicyResponse& a, LintPolicyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LintPolicyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LintPolicyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LintPolicyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LintPolicyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LintPolicyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LintPolicyResponse& from) {
    LintPolicyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LintPolicyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.admin.v1.LintPolicyResponse";
  }
  protected:
  explicit LintPolicyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLintResultsFieldNumber = 1,
  };
  // repeated .google.iam.admin.v1.LintResult lint_results = 1;
  int lint_results_size() const;
  private:
  int _internal_lint_results_size() const;
  public:
  void clear_lint_results();
  ::google::iam::admin::v1::LintResult* mutable_lint_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::LintResult >*
      mutable_lint_results();
  private:
  const ::google::iam::admin::v1::LintResult& _internal_lint_results(int index) const;
  ::google::iam::admin::v1::LintResult* _internal_add_lint_results();
  public:
  const ::google::iam::admin::v1::LintResult& lint_results(int index) const;
  ::google::iam::admin::v1::LintResult* add_lint_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::LintResult >&
      lint_results() const;

  // @@protoc_insertion_point(class_scope:google.iam.admin.v1.LintPolicyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::LintResult > lint_results_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fadmin_2fv1_2fiam_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ServiceAccount

// string name = 1;
inline void ServiceAccount::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ServiceAccount::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccount.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceAccount::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccount.name)
}
inline std::string* ServiceAccount::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ServiceAccount.name)
  return _s;
}
inline const std::string& ServiceAccount::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ServiceAccount::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceAccount::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceAccount::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ServiceAccount.name)
  return _impl_.name_.Release();
}
inline void ServiceAccount::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ServiceAccount.name)
}

// string project_id = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void ServiceAccount::clear_project_id() {
  _impl_.project_id_.ClearToEmpty();
}
inline const std::string& ServiceAccount::project_id() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccount.project_id)
  return _internal_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceAccount::set_project_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.project_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccount.project_id)
}
inline std::string* ServiceAccount::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ServiceAccount.project_id)
  return _s;
}
inline const std::string& ServiceAccount::_internal_project_id() const {
  return _impl_.project_id_.Get();
}
inline void ServiceAccount::_internal_set_project_id(const std::string& value) {
  
  _impl_.project_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceAccount::_internal_mutable_project_id() {
  
  return _impl_.project_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceAccount::release_project_id() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ServiceAccount.project_id)
  return _impl_.project_id_.Release();
}
inline void ServiceAccount::set_allocated_project_id(std::string* project_id) {
  if (project_id != nullptr) {
    
  } else {
    
  }
  _impl_.project_id_.SetAllocated(project_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.project_id_.IsDefault()) {
    _impl_.project_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ServiceAccount.project_id)
}

// string unique_id = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void ServiceAccount::clear_unique_id() {
  _impl_.unique_id_.ClearToEmpty();
}
inline const std::string& ServiceAccount::unique_id() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccount.unique_id)
  return _internal_unique_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceAccount::set_unique_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.unique_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccount.unique_id)
}
inline std::string* ServiceAccount::mutable_unique_id() {
  std::string* _s = _internal_mutable_unique_id();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ServiceAccount.unique_id)
  return _s;
}
inline const std::string& ServiceAccount::_internal_unique_id() const {
  return _impl_.unique_id_.Get();
}
inline void ServiceAccount::_internal_set_unique_id(const std::string& value) {
  
  _impl_.unique_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceAccount::_internal_mutable_unique_id() {
  
  return _impl_.unique_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceAccount::release_unique_id() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ServiceAccount.unique_id)
  return _impl_.unique_id_.Release();
}
inline void ServiceAccount::set_allocated_unique_id(std::string* unique_id) {
  if (unique_id != nullptr) {
    
  } else {
    
  }
  _impl_.unique_id_.SetAllocated(unique_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unique_id_.IsDefault()) {
    _impl_.unique_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ServiceAccount.unique_id)
}

// string email = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void ServiceAccount::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& ServiceAccount::email() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccount.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceAccount::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccount.email)
}
inline std::string* ServiceAccount::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ServiceAccount.email)
  return _s;
}
inline const std::string& ServiceAccount::_internal_email() const {
  return _impl_.email_.Get();
}
inline void ServiceAccount::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceAccount::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceAccount::release_email() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ServiceAccount.email)
  return _impl_.email_.Release();
}
inline void ServiceAccount::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ServiceAccount.email)
}

// string display_name = 6 [(.google.api.field_behavior) = OPTIONAL];
inline void ServiceAccount::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& ServiceAccount::display_name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccount.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceAccount::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccount.display_name)
}
inline std::string* ServiceAccount::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ServiceAccount.display_name)
  return _s;
}
inline const std::string& ServiceAccount::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void ServiceAccount::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceAccount::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceAccount::release_display_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ServiceAccount.display_name)
  return _impl_.display_name_.Release();
}
inline void ServiceAccount::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ServiceAccount.display_name)
}

// bytes etag = 7 [deprecated = true];
inline void ServiceAccount::clear_etag() {
  _impl_.etag_.ClearToEmpty();
}
inline const std::string& ServiceAccount::etag() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccount.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceAccount::set_etag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.etag_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccount.etag)
}
inline std::string* ServiceAccount::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ServiceAccount.etag)
  return _s;
}
inline const std::string& ServiceAccount::_internal_etag() const {
  return _impl_.etag_.Get();
}
inline void ServiceAccount::_internal_set_etag(const std::string& value) {
  
  _impl_.etag_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceAccount::_internal_mutable_etag() {
  
  return _impl_.etag_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceAccount::release_etag() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ServiceAccount.etag)
  return _impl_.etag_.Release();
}
inline void ServiceAccount::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    
  } else {
    
  }
  _impl_.etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.etag_.IsDefault()) {
    _impl_.etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ServiceAccount.etag)
}

// string description = 8 [(.google.api.field_behavior) = OPTIONAL];
inline void ServiceAccount::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ServiceAccount::description() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccount.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceAccount::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccount.description)
}
inline std::string* ServiceAccount::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ServiceAccount.description)
  return _s;
}
inline const std::string& ServiceAccount::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ServiceAccount::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceAccount::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceAccount::release_description() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ServiceAccount.description)
  return _impl_.description_.Release();
}
inline void ServiceAccount::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ServiceAccount.description)
}

// string oauth2_client_id = 9 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void ServiceAccount::clear_oauth2_client_id() {
  _impl_.oauth2_client_id_.ClearToEmpty();
}
inline const std::string& ServiceAccount::oauth2_client_id() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccount.oauth2_client_id)
  return _internal_oauth2_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceAccount::set_oauth2_client_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.oauth2_client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccount.oauth2_client_id)
}
inline std::string* ServiceAccount::mutable_oauth2_client_id() {
  std::string* _s = _internal_mutable_oauth2_client_id();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ServiceAccount.oauth2_client_id)
  return _s;
}
inline const std::string& ServiceAccount::_internal_oauth2_client_id() const {
  return _impl_.oauth2_client_id_.Get();
}
inline void ServiceAccount::_internal_set_oauth2_client_id(const std::string& value) {
  
  _impl_.oauth2_client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceAccount::_internal_mutable_oauth2_client_id() {
  
  return _impl_.oauth2_client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceAccount::release_oauth2_client_id() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ServiceAccount.oauth2_client_id)
  return _impl_.oauth2_client_id_.Release();
}
inline void ServiceAccount::set_allocated_oauth2_client_id(std::string* oauth2_client_id) {
  if (oauth2_client_id != nullptr) {
    
  } else {
    
  }
  _impl_.oauth2_client_id_.SetAllocated(oauth2_client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.oauth2_client_id_.IsDefault()) {
    _impl_.oauth2_client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ServiceAccount.oauth2_client_id)
}

// bool disabled = 11 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void ServiceAccount::clear_disabled() {
  _impl_.disabled_ = false;
}
inline bool ServiceAccount::_internal_disabled() const {
  return _impl_.disabled_;
}
inline bool ServiceAccount::disabled() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccount.disabled)
  return _internal_disabled();
}
inline void ServiceAccount::_internal_set_disabled(bool value) {
  
  _impl_.disabled_ = value;
}
inline void ServiceAccount::set_disabled(bool value) {
  _internal_set_disabled(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccount.disabled)
}

// -------------------------------------------------------------------

// CreateServiceAccountRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CreateServiceAccountRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateServiceAccountRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.CreateServiceAccountRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateServiceAccountRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.CreateServiceAccountRequest.name)
}
inline std::string* CreateServiceAccountRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.CreateServiceAccountRequest.name)
  return _s;
}
inline const std::string& CreateServiceAccountRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateServiceAccountRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateServiceAccountRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateServiceAccountRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.CreateServiceAccountRequest.name)
  return _impl_.name_.Release();
}
inline void CreateServiceAccountRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.CreateServiceAccountRequest.name)
}

// string account_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void CreateServiceAccountRequest::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& CreateServiceAccountRequest::account_id() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.CreateServiceAccountRequest.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateServiceAccountRequest::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.CreateServiceAccountRequest.account_id)
}
inline std::string* CreateServiceAccountRequest::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.CreateServiceAccountRequest.account_id)
  return _s;
}
inline const std::string& CreateServiceAccountRequest::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void CreateServiceAccountRequest::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateServiceAccountRequest::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateServiceAccountRequest::release_account_id() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.CreateServiceAccountRequest.account_id)
  return _impl_.account_id_.Release();
}
inline void CreateServiceAccountRequest::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.CreateServiceAccountRequest.account_id)
}

// .google.iam.admin.v1.ServiceAccount service_account = 3;
inline bool CreateServiceAccountRequest::_internal_has_service_account() const {
  return this != internal_default_instance() && _impl_.service_account_ != nullptr;
}
inline bool CreateServiceAccountRequest::has_service_account() const {
  return _internal_has_service_account();
}
inline void CreateServiceAccountRequest::clear_service_account() {
  if (GetArenaForAllocation() == nullptr && _impl_.service_account_ != nullptr) {
    delete _impl_.service_account_;
  }
  _impl_.service_account_ = nullptr;
}
inline const ::google::iam::admin::v1::ServiceAccount& CreateServiceAccountRequest::_internal_service_account() const {
  const ::google::iam::admin::v1::ServiceAccount* p = _impl_.service_account_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::iam::admin::v1::ServiceAccount&>(
      ::google::iam::admin::v1::_ServiceAccount_default_instance_);
}
inline const ::google::iam::admin::v1::ServiceAccount& CreateServiceAccountRequest::service_account() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.CreateServiceAccountRequest.service_account)
  return _internal_service_account();
}
inline void CreateServiceAccountRequest::unsafe_arena_set_allocated_service_account(
    ::google::iam::admin::v1::ServiceAccount* service_account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_account_);
  }
  _impl_.service_account_ = service_account;
  if (service_account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.iam.admin.v1.CreateServiceAccountRequest.service_account)
}
inline ::google::iam::admin::v1::ServiceAccount* CreateServiceAccountRequest::release_service_account() {
  
  ::google::iam::admin::v1::ServiceAccount* temp = _impl_.service_account_;
  _impl_.service_account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::iam::admin::v1::ServiceAccount* CreateServiceAccountRequest::unsafe_arena_release_service_account() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.CreateServiceAccountRequest.service_account)
  
  ::google::iam::admin::v1::ServiceAccount* temp = _impl_.service_account_;
  _impl_.service_account_ = nullptr;
  return temp;
}
inline ::google::iam::admin::v1::ServiceAccount* CreateServiceAccountRequest::_internal_mutable_service_account() {
  
  if (_impl_.service_account_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::iam::admin::v1::ServiceAccount>(GetArenaForAllocation());
    _impl_.service_account_ = p;
  }
  return _impl_.service_account_;
}
inline ::google::iam::admin::v1::ServiceAccount* CreateServiceAccountRequest::mutable_service_account() {
  ::google::iam::admin::v1::ServiceAccount* _msg = _internal_mutable_service_account();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.CreateServiceAccountRequest.service_account)
  return _msg;
}
inline void CreateServiceAccountRequest::set_allocated_service_account(::google::iam::admin::v1::ServiceAccount* service_account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.service_account_;
  }
  if (service_account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(service_account);
    if (message_arena != submessage_arena) {
      service_account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_account, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.service_account_ = service_account;
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.CreateServiceAccountRequest.service_account)
}

// -------------------------------------------------------------------

// ListServiceAccountsRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListServiceAccountsRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ListServiceAccountsRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ListServiceAccountsRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServiceAccountsRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ListServiceAccountsRequest.name)
}
inline std::string* ListServiceAccountsRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ListServiceAccountsRequest.name)
  return _s;
}
inline const std::string& ListServiceAccountsRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ListServiceAccountsRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServiceAccountsRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServiceAccountsRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ListServiceAccountsRequest.name)
  return _impl_.name_.Release();
}
inline void ListServiceAccountsRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ListServiceAccountsRequest.name)
}

// int32 page_size = 2;
inline void ListServiceAccountsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListServiceAccountsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListServiceAccountsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ListServiceAccountsRequest.page_size)
  return _internal_page_size();
}
inline void ListServiceAccountsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListServiceAccountsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ListServiceAccountsRequest.page_size)
}

// string page_token = 3;
inline void ListServiceAccountsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListServiceAccountsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ListServiceAccountsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServiceAccountsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ListServiceAccountsRequest.page_token)
}
inline std::string* ListServiceAccountsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ListServiceAccountsRequest.page_token)
  return _s;
}
inline const std::string& ListServiceAccountsRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListServiceAccountsRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServiceAccountsRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServiceAccountsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ListServiceAccountsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListServiceAccountsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ListServiceAccountsRequest.page_token)
}

// -------------------------------------------------------------------

// ListServiceAccountsResponse

// repeated .google.iam.admin.v1.ServiceAccount accounts = 1;
inline int ListServiceAccountsResponse::_internal_accounts_size() const {
  return _impl_.accounts_.size();
}
inline int ListServiceAccountsResponse::accounts_size() const {
  return _internal_accounts_size();
}
inline void ListServiceAccountsResponse::clear_accounts() {
  _impl_.accounts_.Clear();
}
inline ::google::iam::admin::v1::ServiceAccount* ListServiceAccountsResponse::mutable_accounts(int index) {
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ListServiceAccountsResponse.accounts)
  return _impl_.accounts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::ServiceAccount >*
ListServiceAccountsResponse::mutable_accounts() {
  // @@protoc_insertion_point(field_mutable_list:google.iam.admin.v1.ListServiceAccountsResponse.accounts)
  return &_impl_.accounts_;
}
inline const ::google::iam::admin::v1::ServiceAccount& ListServiceAccountsResponse::_internal_accounts(int index) const {
  return _impl_.accounts_.Get(index);
}
inline const ::google::iam::admin::v1::ServiceAccount& ListServiceAccountsResponse::accounts(int index) const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ListServiceAccountsResponse.accounts)
  return _internal_accounts(index);
}
inline ::google::iam::admin::v1::ServiceAccount* ListServiceAccountsResponse::_internal_add_accounts() {
  return _impl_.accounts_.Add();
}
inline ::google::iam::admin::v1::ServiceAccount* ListServiceAccountsResponse::add_accounts() {
  ::google::iam::admin::v1::ServiceAccount* _add = _internal_add_accounts();
  // @@protoc_insertion_point(field_add:google.iam.admin.v1.ListServiceAccountsResponse.accounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::ServiceAccount >&
ListServiceAccountsResponse::accounts() const {
  // @@protoc_insertion_point(field_list:google.iam.admin.v1.ListServiceAccountsResponse.accounts)
  return _impl_.accounts_;
}

// string next_page_token = 2;
inline void ListServiceAccountsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListServiceAccountsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ListServiceAccountsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServiceAccountsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ListServiceAccountsResponse.next_page_token)
}
inline std::string* ListServiceAccountsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ListServiceAccountsResponse.next_page_token)
  return _s;
}
inline const std::string& ListServiceAccountsResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListServiceAccountsResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServiceAccountsResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServiceAccountsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ListServiceAccountsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListServiceAccountsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ListServiceAccountsResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetServiceAccountRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetServiceAccountRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetServiceAccountRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.GetServiceAccountRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServiceAccountRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.GetServiceAccountRequest.name)
}
inline std::string* GetServiceAccountRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.GetServiceAccountRequest.name)
  return _s;
}
inline const std::string& GetServiceAccountRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetServiceAccountRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetServiceAccountRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetServiceAccountRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.GetServiceAccountRequest.name)
  return _impl_.name_.Release();
}
inline void GetServiceAccountRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.GetServiceAccountRequest.name)
}

// -------------------------------------------------------------------

// DeleteServiceAccountRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteServiceAccountRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteServiceAccountRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.DeleteServiceAccountRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteServiceAccountRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.DeleteServiceAccountRequest.name)
}
inline std::string* DeleteServiceAccountRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.DeleteServiceAccountRequest.name)
  return _s;
}
inline const std::string& DeleteServiceAccountRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteServiceAccountRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteServiceAccountRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteServiceAccountRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.DeleteServiceAccountRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteServiceAccountRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.DeleteServiceAccountRequest.name)
}

// -------------------------------------------------------------------

// PatchServiceAccountRequest

// .google.iam.admin.v1.ServiceAccount service_account = 1;
inline bool PatchServiceAccountRequest::_internal_has_service_account() const {
  return this != internal_default_instance() && _impl_.service_account_ != nullptr;
}
inline bool PatchServiceAccountRequest::has_service_account() const {
  return _internal_has_service_account();
}
inline void PatchServiceAccountRequest::clear_service_account() {
  if (GetArenaForAllocation() == nullptr && _impl_.service_account_ != nullptr) {
    delete _impl_.service_account_;
  }
  _impl_.service_account_ = nullptr;
}
inline const ::google::iam::admin::v1::ServiceAccount& PatchServiceAccountRequest::_internal_service_account() const {
  const ::google::iam::admin::v1::ServiceAccount* p = _impl_.service_account_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::iam::admin::v1::ServiceAccount&>(
      ::google::iam::admin::v1::_ServiceAccount_default_instance_);
}
inline const ::google::iam::admin::v1::ServiceAccount& PatchServiceAccountRequest::service_account() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.PatchServiceAccountRequest.service_account)
  return _internal_service_account();
}
inline void PatchServiceAccountRequest::unsafe_arena_set_allocated_service_account(
    ::google::iam::admin::v1::ServiceAccount* service_account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.service_account_);
  }
  _impl_.service_account_ = service_account;
  if (service_account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.iam.admin.v1.PatchServiceAccountRequest.service_account)
}
inline ::google::iam::admin::v1::ServiceAccount* PatchServiceAccountRequest::release_service_account() {
  
  ::google::iam::admin::v1::ServiceAccount* temp = _impl_.service_account_;
  _impl_.service_account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::iam::admin::v1::ServiceAccount* PatchServiceAccountRequest::unsafe_arena_release_service_account() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.PatchServiceAccountRequest.service_account)
  
  ::google::iam::admin::v1::ServiceAccount* temp = _impl_.service_account_;
  _impl_.service_account_ = nullptr;
  return temp;
}
inline ::google::iam::admin::v1::ServiceAccount* PatchServiceAccountRequest::_internal_mutable_service_account() {
  
  if (_impl_.service_account_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::iam::admin::v1::ServiceAccount>(GetArenaForAllocation());
    _impl_.service_account_ = p;
  }
  return _impl_.service_account_;
}
inline ::google::iam::admin::v1::ServiceAccount* PatchServiceAccountRequest::mutable_service_account() {
  ::google::iam::admin::v1::ServiceAccount* _msg = _internal_mutable_service_account();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.PatchServiceAccountRequest.service_account)
  return _msg;
}
inline void PatchServiceAccountRequest::set_allocated_service_account(::google::iam::admin::v1::ServiceAccount* service_account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.service_account_;
  }
  if (service_account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(service_account);
    if (message_arena != submessage_arena) {
      service_account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_account, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.service_account_ = service_account;
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.PatchServiceAccountRequest.service_account)
}

// .google.protobuf.FieldMask update_mask = 2;
inline bool PatchServiceAccountRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool PatchServiceAccountRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& PatchServiceAccountRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& PatchServiceAccountRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.PatchServiceAccountRequest.update_mask)
  return _internal_update_mask();
}
inline void PatchServiceAccountRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.iam.admin.v1.PatchServiceAccountRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* PatchServiceAccountRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* PatchServiceAccountRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.PatchServiceAccountRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* PatchServiceAccountRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* PatchServiceAccountRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.PatchServiceAccountRequest.update_mask)
  return _msg;
}
inline void PatchServiceAccountRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.PatchServiceAccountRequest.update_mask)
}

// -------------------------------------------------------------------

// UndeleteServiceAccountRequest

// string name = 1;
inline void UndeleteServiceAccountRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UndeleteServiceAccountRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.UndeleteServiceAccountRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UndeleteServiceAccountRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.UndeleteServiceAccountRequest.name)
}
inline std::string* UndeleteServiceAccountRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.UndeleteServiceAccountRequest.name)
  return _s;
}
inline const std::string& UndeleteServiceAccountRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UndeleteServiceAccountRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UndeleteServiceAccountRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UndeleteServiceAccountRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.UndeleteServiceAccountRequest.name)
  return _impl_.name_.Release();
}
inline void UndeleteServiceAccountRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.UndeleteServiceAccountRequest.name)
}

// -------------------------------------------------------------------

// UndeleteServiceAccountResponse

// .google.iam.admin.v1.ServiceAccount restored_account = 1;
inline bool UndeleteServiceAccountResponse::_internal_has_restored_account() const {
  return this != internal_default_instance() && _impl_.restored_account_ != nullptr;
}
inline bool UndeleteServiceAccountResponse::has_restored_account() const {
  return _internal_has_restored_account();
}
inline void UndeleteServiceAccountResponse::clear_restored_account() {
  if (GetArenaForAllocation() == nullptr && _impl_.restored_account_ != nullptr) {
    delete _impl_.restored_account_;
  }
  _impl_.restored_account_ = nullptr;
}
inline const ::google::iam::admin::v1::ServiceAccount& UndeleteServiceAccountResponse::_internal_restored_account() const {
  const ::google::iam::admin::v1::ServiceAccount* p = _impl_.restored_account_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::iam::admin::v1::ServiceAccount&>(
      ::google::iam::admin::v1::_ServiceAccount_default_instance_);
}
inline const ::google::iam::admin::v1::ServiceAccount& UndeleteServiceAccountResponse::restored_account() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.UndeleteServiceAccountResponse.restored_account)
  return _internal_restored_account();
}
inline void UndeleteServiceAccountResponse::unsafe_arena_set_allocated_restored_account(
    ::google::iam::admin::v1::ServiceAccount* restored_account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.restored_account_);
  }
  _impl_.restored_account_ = restored_account;
  if (restored_account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.iam.admin.v1.UndeleteServiceAccountResponse.restored_account)
}
inline ::google::iam::admin::v1::ServiceAccount* UndeleteServiceAccountResponse::release_restored_account() {
  
  ::google::iam::admin::v1::ServiceAccount* temp = _impl_.restored_account_;
  _impl_.restored_account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::iam::admin::v1::ServiceAccount* UndeleteServiceAccountResponse::unsafe_arena_release_restored_account() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.UndeleteServiceAccountResponse.restored_account)
  
  ::google::iam::admin::v1::ServiceAccount* temp = _impl_.restored_account_;
  _impl_.restored_account_ = nullptr;
  return temp;
}
inline ::google::iam::admin::v1::ServiceAccount* UndeleteServiceAccountResponse::_internal_mutable_restored_account() {
  
  if (_impl_.restored_account_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::iam::admin::v1::ServiceAccount>(GetArenaForAllocation());
    _impl_.restored_account_ = p;
  }
  return _impl_.restored_account_;
}
inline ::google::iam::admin::v1::ServiceAccount* UndeleteServiceAccountResponse::mutable_restored_account() {
  ::google::iam::admin::v1::ServiceAccount* _msg = _internal_mutable_restored_account();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.UndeleteServiceAccountResponse.restored_account)
  return _msg;
}
inline void UndeleteServiceAccountResponse::set_allocated_restored_account(::google::iam::admin::v1::ServiceAccount* restored_account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.restored_account_;
  }
  if (restored_account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(restored_account);
    if (message_arena != submessage_arena) {
      restored_account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, restored_account, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.restored_account_ = restored_account;
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.UndeleteServiceAccountResponse.restored_account)
}

// -------------------------------------------------------------------

// EnableServiceAccountRequest

// string name = 1;
inline void EnableServiceAccountRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& EnableServiceAccountRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.EnableServiceAccountRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnableServiceAccountRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.EnableServiceAccountRequest.name)
}
inline std::string* EnableServiceAccountRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.EnableServiceAccountRequest.name)
  return _s;
}
inline const std::string& EnableServiceAccountRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void EnableServiceAccountRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* EnableServiceAccountRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* EnableServiceAccountRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.EnableServiceAccountRequest.name)
  return _impl_.name_.Release();
}
inline void EnableServiceAccountRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.EnableServiceAccountRequest.name)
}

// -------------------------------------------------------------------

// DisableServiceAccountRequest

// string name = 1;
inline void DisableServiceAccountRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DisableServiceAccountRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.DisableServiceAccountRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DisableServiceAccountRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.DisableServiceAccountRequest.name)
}
inline std::string* DisableServiceAccountRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.DisableServiceAccountRequest.name)
  return _s;
}
inline const std::string& DisableServiceAccountRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DisableServiceAccountRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DisableServiceAccountRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DisableServiceAccountRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.DisableServiceAccountRequest.name)
  return _impl_.name_.Release();
}
inline void DisableServiceAccountRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.DisableServiceAccountRequest.name)
}

// -------------------------------------------------------------------

// ListServiceAccountKeysRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListServiceAccountKeysRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ListServiceAccountKeysRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ListServiceAccountKeysRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListServiceAccountKeysRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ListServiceAccountKeysRequest.name)
}
inline std::string* ListServiceAccountKeysRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ListServiceAccountKeysRequest.name)
  return _s;
}
inline const std::string& ListServiceAccountKeysRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ListServiceAccountKeysRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ListServiceAccountKeysRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ListServiceAccountKeysRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ListServiceAccountKeysRequest.name)
  return _impl_.name_.Release();
}
inline void ListServiceAccountKeysRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ListServiceAccountKeysRequest.name)
}

// repeated .google.iam.admin.v1.ListServiceAccountKeysRequest.KeyType key_types = 2;
inline int ListServiceAccountKeysRequest::_internal_key_types_size() const {
  return _impl_.key_types_.size();
}
inline int ListServiceAccountKeysRequest::key_types_size() const {
  return _internal_key_types_size();
}
inline void ListServiceAccountKeysRequest::clear_key_types() {
  _impl_.key_types_.Clear();
}
inline ::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType ListServiceAccountKeysRequest::_internal_key_types(int index) const {
  return static_cast< ::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType >(_impl_.key_types_.Get(index));
}
inline ::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType ListServiceAccountKeysRequest::key_types(int index) const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ListServiceAccountKeysRequest.key_types)
  return _internal_key_types(index);
}
inline void ListServiceAccountKeysRequest::set_key_types(int index, ::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType value) {
  _impl_.key_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ListServiceAccountKeysRequest.key_types)
}
inline void ListServiceAccountKeysRequest::_internal_add_key_types(::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType value) {
  _impl_.key_types_.Add(value);
}
inline void ListServiceAccountKeysRequest::add_key_types(::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType value) {
  _internal_add_key_types(value);
  // @@protoc_insertion_point(field_add:google.iam.admin.v1.ListServiceAccountKeysRequest.key_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ListServiceAccountKeysRequest::key_types() const {
  // @@protoc_insertion_point(field_list:google.iam.admin.v1.ListServiceAccountKeysRequest.key_types)
  return _impl_.key_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListServiceAccountKeysRequest::_internal_mutable_key_types() {
  return &_impl_.key_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ListServiceAccountKeysRequest::mutable_key_types() {
  // @@protoc_insertion_point(field_mutable_list:google.iam.admin.v1.ListServiceAccountKeysRequest.key_types)
  return _internal_mutable_key_types();
}

// -------------------------------------------------------------------

// ListServiceAccountKeysResponse

// repeated .google.iam.admin.v1.ServiceAccountKey keys = 1;
inline int ListServiceAccountKeysResponse::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int ListServiceAccountKeysResponse::keys_size() const {
  return _internal_keys_size();
}
inline void ListServiceAccountKeysResponse::clear_keys() {
  _impl_.keys_.Clear();
}
inline ::google::iam::admin::v1::ServiceAccountKey* ListServiceAccountKeysResponse::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ListServiceAccountKeysResponse.keys)
  return _impl_.keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::ServiceAccountKey >*
ListServiceAccountKeysResponse::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:google.iam.admin.v1.ListServiceAccountKeysResponse.keys)
  return &_impl_.keys_;
}
inline const ::google::iam::admin::v1::ServiceAccountKey& ListServiceAccountKeysResponse::_internal_keys(int index) const {
  return _impl_.keys_.Get(index);
}
inline const ::google::iam::admin::v1::ServiceAccountKey& ListServiceAccountKeysResponse::keys(int index) const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ListServiceAccountKeysResponse.keys)
  return _internal_keys(index);
}
inline ::google::iam::admin::v1::ServiceAccountKey* ListServiceAccountKeysResponse::_internal_add_keys() {
  return _impl_.keys_.Add();
}
inline ::google::iam::admin::v1::ServiceAccountKey* ListServiceAccountKeysResponse::add_keys() {
  ::google::iam::admin::v1::ServiceAccountKey* _add = _internal_add_keys();
  // @@protoc_insertion_point(field_add:google.iam.admin.v1.ListServiceAccountKeysResponse.keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::ServiceAccountKey >&
ListServiceAccountKeysResponse::keys() const {
  // @@protoc_insertion_point(field_list:google.iam.admin.v1.ListServiceAccountKeysResponse.keys)
  return _impl_.keys_;
}

// -------------------------------------------------------------------

// GetServiceAccountKeyRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetServiceAccountKeyRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetServiceAccountKeyRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.GetServiceAccountKeyRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServiceAccountKeyRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.GetServiceAccountKeyRequest.name)
}
inline std::string* GetServiceAccountKeyRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.GetServiceAccountKeyRequest.name)
  return _s;
}
inline const std::string& GetServiceAccountKeyRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetServiceAccountKeyRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetServiceAccountKeyRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetServiceAccountKeyRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.GetServiceAccountKeyRequest.name)
  return _impl_.name_.Release();
}
inline void GetServiceAccountKeyRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.GetServiceAccountKeyRequest.name)
}

// .google.iam.admin.v1.ServiceAccountPublicKeyType public_key_type = 2;
inline void GetServiceAccountKeyRequest::clear_public_key_type() {
  _impl_.public_key_type_ = 0;
}
inline ::google::iam::admin::v1::ServiceAccountPublicKeyType GetServiceAccountKeyRequest::_internal_public_key_type() const {
  return static_cast< ::google::iam::admin::v1::ServiceAccountPublicKeyType >(_impl_.public_key_type_);
}
inline ::google::iam::admin::v1::ServiceAccountPublicKeyType GetServiceAccountKeyRequest::public_key_type() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.GetServiceAccountKeyRequest.public_key_type)
  return _internal_public_key_type();
}
inline void GetServiceAccountKeyRequest::_internal_set_public_key_type(::google::iam::admin::v1::ServiceAccountPublicKeyType value) {
  
  _impl_.public_key_type_ = value;
}
inline void GetServiceAccountKeyRequest::set_public_key_type(::google::iam::admin::v1::ServiceAccountPublicKeyType value) {
  _internal_set_public_key_type(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.GetServiceAccountKeyRequest.public_key_type)
}

// -------------------------------------------------------------------

// ServiceAccountKey

// string name = 1;
inline void ServiceAccountKey::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ServiceAccountKey::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccountKey.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceAccountKey::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccountKey.name)
}
inline std::string* ServiceAccountKey::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ServiceAccountKey.name)
  return _s;
}
inline const std::string& ServiceAccountKey::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ServiceAccountKey::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceAccountKey::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceAccountKey::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ServiceAccountKey.name)
  return _impl_.name_.Release();
}
inline void ServiceAccountKey::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ServiceAccountKey.name)
}

// .google.iam.admin.v1.ServiceAccountPrivateKeyType private_key_type = 2;
inline void ServiceAccountKey::clear_private_key_type() {
  _impl_.private_key_type_ = 0;
}
inline ::google::iam::admin::v1::ServiceAccountPrivateKeyType ServiceAccountKey::_internal_private_key_type() const {
  return static_cast< ::google::iam::admin::v1::ServiceAccountPrivateKeyType >(_impl_.private_key_type_);
}
inline ::google::iam::admin::v1::ServiceAccountPrivateKeyType ServiceAccountKey::private_key_type() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccountKey.private_key_type)
  return _internal_private_key_type();
}
inline void ServiceAccountKey::_internal_set_private_key_type(::google::iam::admin::v1::ServiceAccountPrivateKeyType value) {
  
  _impl_.private_key_type_ = value;
}
inline void ServiceAccountKey::set_private_key_type(::google::iam::admin::v1::ServiceAccountPrivateKeyType value) {
  _internal_set_private_key_type(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccountKey.private_key_type)
}

// .google.iam.admin.v1.ServiceAccountKeyAlgorithm key_algorithm = 8;
inline void ServiceAccountKey::clear_key_algorithm() {
  _impl_.key_algorithm_ = 0;
}
inline ::google::iam::admin::v1::ServiceAccountKeyAlgorithm ServiceAccountKey::_internal_key_algorithm() const {
  return static_cast< ::google::iam::admin::v1::ServiceAccountKeyAlgorithm >(_impl_.key_algorithm_);
}
inline ::google::iam::admin::v1::ServiceAccountKeyAlgorithm ServiceAccountKey::key_algorithm() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccountKey.key_algorithm)
  return _internal_key_algorithm();
}
inline void ServiceAccountKey::_internal_set_key_algorithm(::google::iam::admin::v1::ServiceAccountKeyAlgorithm value) {
  
  _impl_.key_algorithm_ = value;
}
inline void ServiceAccountKey::set_key_algorithm(::google::iam::admin::v1::ServiceAccountKeyAlgorithm value) {
  _internal_set_key_algorithm(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccountKey.key_algorithm)
}

// bytes private_key_data = 3;
inline void ServiceAccountKey::clear_private_key_data() {
  _impl_.private_key_data_.ClearToEmpty();
}
inline const std::string& ServiceAccountKey::private_key_data() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccountKey.private_key_data)
  return _internal_private_key_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceAccountKey::set_private_key_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.private_key_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccountKey.private_key_data)
}
inline std::string* ServiceAccountKey::mutable_private_key_data() {
  std::string* _s = _internal_mutable_private_key_data();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ServiceAccountKey.private_key_data)
  return _s;
}
inline const std::string& ServiceAccountKey::_internal_private_key_data() const {
  return _impl_.private_key_data_.Get();
}
inline void ServiceAccountKey::_internal_set_private_key_data(const std::string& value) {
  
  _impl_.private_key_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceAccountKey::_internal_mutable_private_key_data() {
  
  return _impl_.private_key_data_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceAccountKey::release_private_key_data() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ServiceAccountKey.private_key_data)
  return _impl_.private_key_data_.Release();
}
inline void ServiceAccountKey::set_allocated_private_key_data(std::string* private_key_data) {
  if (private_key_data != nullptr) {
    
  } else {
    
  }
  _impl_.private_key_data_.SetAllocated(private_key_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.private_key_data_.IsDefault()) {
    _impl_.private_key_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ServiceAccountKey.private_key_data)
}

// bytes public_key_data = 7;
inline void ServiceAccountKey::clear_public_key_data() {
  _impl_.public_key_data_.ClearToEmpty();
}
inline const std::string& ServiceAccountKey::public_key_data() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccountKey.public_key_data)
  return _internal_public_key_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceAccountKey::set_public_key_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccountKey.public_key_data)
}
inline std::string* ServiceAccountKey::mutable_public_key_data() {
  std::string* _s = _internal_mutable_public_key_data();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ServiceAccountKey.public_key_data)
  return _s;
}
inline const std::string& ServiceAccountKey::_internal_public_key_data() const {
  return _impl_.public_key_data_.Get();
}
inline void ServiceAccountKey::_internal_set_public_key_data(const std::string& value) {
  
  _impl_.public_key_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceAccountKey::_internal_mutable_public_key_data() {
  
  return _impl_.public_key_data_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceAccountKey::release_public_key_data() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ServiceAccountKey.public_key_data)
  return _impl_.public_key_data_.Release();
}
inline void ServiceAccountKey::set_allocated_public_key_data(std::string* public_key_data) {
  if (public_key_data != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_data_.SetAllocated(public_key_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_data_.IsDefault()) {
    _impl_.public_key_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ServiceAccountKey.public_key_data)
}

// .google.protobuf.Timestamp valid_after_time = 4;
inline bool ServiceAccountKey::_internal_has_valid_after_time() const {
  return this != internal_default_instance() && _impl_.valid_after_time_ != nullptr;
}
inline bool ServiceAccountKey::has_valid_after_time() const {
  return _internal_has_valid_after_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServiceAccountKey::_internal_valid_after_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.valid_after_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServiceAccountKey::valid_after_time() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccountKey.valid_after_time)
  return _internal_valid_after_time();
}
inline void ServiceAccountKey::unsafe_arena_set_allocated_valid_after_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* valid_after_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valid_after_time_);
  }
  _impl_.valid_after_time_ = valid_after_time;
  if (valid_after_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.iam.admin.v1.ServiceAccountKey.valid_after_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceAccountKey::release_valid_after_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.valid_after_time_;
  _impl_.valid_after_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceAccountKey::unsafe_arena_release_valid_after_time() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ServiceAccountKey.valid_after_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.valid_after_time_;
  _impl_.valid_after_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceAccountKey::_internal_mutable_valid_after_time() {
  
  if (_impl_.valid_after_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.valid_after_time_ = p;
  }
  return _impl_.valid_after_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceAccountKey::mutable_valid_after_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_valid_after_time();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ServiceAccountKey.valid_after_time)
  return _msg;
}
inline void ServiceAccountKey::set_allocated_valid_after_time(::PROTOBUF_NAMESPACE_ID::Timestamp* valid_after_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valid_after_time_);
  }
  if (valid_after_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(valid_after_time));
    if (message_arena != submessage_arena) {
      valid_after_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valid_after_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.valid_after_time_ = valid_after_time;
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ServiceAccountKey.valid_after_time)
}

// .google.protobuf.Timestamp valid_before_time = 5;
inline bool ServiceAccountKey::_internal_has_valid_before_time() const {
  return this != internal_default_instance() && _impl_.valid_before_time_ != nullptr;
}
inline bool ServiceAccountKey::has_valid_before_time() const {
  return _internal_has_valid_before_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServiceAccountKey::_internal_valid_before_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.valid_before_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServiceAccountKey::valid_before_time() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccountKey.valid_before_time)
  return _internal_valid_before_time();
}
inline void ServiceAccountKey::unsafe_arena_set_allocated_valid_before_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* valid_before_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valid_before_time_);
  }
  _impl_.valid_before_time_ = valid_before_time;
  if (valid_before_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.iam.admin.v1.ServiceAccountKey.valid_before_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceAccountKey::release_valid_before_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.valid_before_time_;
  _impl_.valid_before_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceAccountKey::unsafe_arena_release_valid_before_time() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ServiceAccountKey.valid_before_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.valid_before_time_;
  _impl_.valid_before_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceAccountKey::_internal_mutable_valid_before_time() {
  
  if (_impl_.valid_before_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.valid_before_time_ = p;
  }
  return _impl_.valid_before_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceAccountKey::mutable_valid_before_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_valid_before_time();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ServiceAccountKey.valid_before_time)
  return _msg;
}
inline void ServiceAccountKey::set_allocated_valid_before_time(::PROTOBUF_NAMESPACE_ID::Timestamp* valid_before_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valid_before_time_);
  }
  if (valid_before_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(valid_before_time));
    if (message_arena != submessage_arena) {
      valid_before_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valid_before_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.valid_before_time_ = valid_before_time;
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ServiceAccountKey.valid_before_time)
}

// .google.iam.admin.v1.ServiceAccountKeyOrigin key_origin = 9;
inline void ServiceAccountKey::clear_key_origin() {
  _impl_.key_origin_ = 0;
}
inline ::google::iam::admin::v1::ServiceAccountKeyOrigin ServiceAccountKey::_internal_key_origin() const {
  return static_cast< ::google::iam::admin::v1::ServiceAccountKeyOrigin >(_impl_.key_origin_);
}
inline ::google::iam::admin::v1::ServiceAccountKeyOrigin ServiceAccountKey::key_origin() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccountKey.key_origin)
  return _internal_key_origin();
}
inline void ServiceAccountKey::_internal_set_key_origin(::google::iam::admin::v1::ServiceAccountKeyOrigin value) {
  
  _impl_.key_origin_ = value;
}
inline void ServiceAccountKey::set_key_origin(::google::iam::admin::v1::ServiceAccountKeyOrigin value) {
  _internal_set_key_origin(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccountKey.key_origin)
}

// .google.iam.admin.v1.ListServiceAccountKeysRequest.KeyType key_type = 10;
inline void ServiceAccountKey::clear_key_type() {
  _impl_.key_type_ = 0;
}
inline ::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType ServiceAccountKey::_internal_key_type() const {
  return static_cast< ::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType >(_impl_.key_type_);
}
inline ::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType ServiceAccountKey::key_type() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ServiceAccountKey.key_type)
  return _internal_key_type();
}
inline void ServiceAccountKey::_internal_set_key_type(::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType value) {
  
  _impl_.key_type_ = value;
}
inline void ServiceAccountKey::set_key_type(::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType value) {
  _internal_set_key_type(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ServiceAccountKey.key_type)
}

// -------------------------------------------------------------------

// CreateServiceAccountKeyRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CreateServiceAccountKeyRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateServiceAccountKeyRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.CreateServiceAccountKeyRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateServiceAccountKeyRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.CreateServiceAccountKeyRequest.name)
}
inline std::string* CreateServiceAccountKeyRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.CreateServiceAccountKeyRequest.name)
  return _s;
}
inline const std::string& CreateServiceAccountKeyRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateServiceAccountKeyRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateServiceAccountKeyRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateServiceAccountKeyRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.CreateServiceAccountKeyRequest.name)
  return _impl_.name_.Release();
}
inline void CreateServiceAccountKeyRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.CreateServiceAccountKeyRequest.name)
}

// .google.iam.admin.v1.ServiceAccountPrivateKeyType private_key_type = 2;
inline void CreateServiceAccountKeyRequest::clear_private_key_type() {
  _impl_.private_key_type_ = 0;
}
inline ::google::iam::admin::v1::ServiceAccountPrivateKeyType CreateServiceAccountKeyRequest::_internal_private_key_type() const {
  return static_cast< ::google::iam::admin::v1::ServiceAccountPrivateKeyType >(_impl_.private_key_type_);
}
inline ::google::iam::admin::v1::ServiceAccountPrivateKeyType CreateServiceAccountKeyRequest::private_key_type() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.CreateServiceAccountKeyRequest.private_key_type)
  return _internal_private_key_type();
}
inline void CreateServiceAccountKeyRequest::_internal_set_private_key_type(::google::iam::admin::v1::ServiceAccountPrivateKeyType value) {
  
  _impl_.private_key_type_ = value;
}
inline void CreateServiceAccountKeyRequest::set_private_key_type(::google::iam::admin::v1::ServiceAccountPrivateKeyType value) {
  _internal_set_private_key_type(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.CreateServiceAccountKeyRequest.private_key_type)
}

// .google.iam.admin.v1.ServiceAccountKeyAlgorithm key_algorithm = 3;
inline void CreateServiceAccountKeyRequest::clear_key_algorithm() {
  _impl_.key_algorithm_ = 0;
}
inline ::google::iam::admin::v1::ServiceAccountKeyAlgorithm CreateServiceAccountKeyRequest::_internal_key_algorithm() const {
  return static_cast< ::google::iam::admin::v1::ServiceAccountKeyAlgorithm >(_impl_.key_algorithm_);
}
inline ::google::iam::admin::v1::ServiceAccountKeyAlgorithm CreateServiceAccountKeyRequest::key_algorithm() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.CreateServiceAccountKeyRequest.key_algorithm)
  return _internal_key_algorithm();
}
inline void CreateServiceAccountKeyRequest::_internal_set_key_algorithm(::google::iam::admin::v1::ServiceAccountKeyAlgorithm value) {
  
  _impl_.key_algorithm_ = value;
}
inline void CreateServiceAccountKeyRequest::set_key_algorithm(::google::iam::admin::v1::ServiceAccountKeyAlgorithm value) {
  _internal_set_key_algorithm(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.CreateServiceAccountKeyRequest.key_algorithm)
}

// -------------------------------------------------------------------

// UploadServiceAccountKeyRequest

// string name = 1;
inline void UploadServiceAccountKeyRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UploadServiceAccountKeyRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.UploadServiceAccountKeyRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadServiceAccountKeyRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.UploadServiceAccountKeyRequest.name)
}
inline std::string* UploadServiceAccountKeyRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.UploadServiceAccountKeyRequest.name)
  return _s;
}
inline const std::string& UploadServiceAccountKeyRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UploadServiceAccountKeyRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadServiceAccountKeyRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadServiceAccountKeyRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.UploadServiceAccountKeyRequest.name)
  return _impl_.name_.Release();
}
inline void UploadServiceAccountKeyRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.UploadServiceAccountKeyRequest.name)
}

// bytes public_key_data = 2;
inline void UploadServiceAccountKeyRequest::clear_public_key_data() {
  _impl_.public_key_data_.ClearToEmpty();
}
inline const std::string& UploadServiceAccountKeyRequest::public_key_data() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.UploadServiceAccountKeyRequest.public_key_data)
  return _internal_public_key_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadServiceAccountKeyRequest::set_public_key_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.UploadServiceAccountKeyRequest.public_key_data)
}
inline std::string* UploadServiceAccountKeyRequest::mutable_public_key_data() {
  std::string* _s = _internal_mutable_public_key_data();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.UploadServiceAccountKeyRequest.public_key_data)
  return _s;
}
inline const std::string& UploadServiceAccountKeyRequest::_internal_public_key_data() const {
  return _impl_.public_key_data_.Get();
}
inline void UploadServiceAccountKeyRequest::_internal_set_public_key_data(const std::string& value) {
  
  _impl_.public_key_data_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadServiceAccountKeyRequest::_internal_mutable_public_key_data() {
  
  return _impl_.public_key_data_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadServiceAccountKeyRequest::release_public_key_data() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.UploadServiceAccountKeyRequest.public_key_data)
  return _impl_.public_key_data_.Release();
}
inline void UploadServiceAccountKeyRequest::set_allocated_public_key_data(std::string* public_key_data) {
  if (public_key_data != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_data_.SetAllocated(public_key_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_data_.IsDefault()) {
    _impl_.public_key_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.UploadServiceAccountKeyRequest.public_key_data)
}

// -------------------------------------------------------------------

// DeleteServiceAccountKeyRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteServiceAccountKeyRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteServiceAccountKeyRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.DeleteServiceAccountKeyRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteServiceAccountKeyRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.DeleteServiceAccountKeyRequest.name)
}
inline std::string* DeleteServiceAccountKeyRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.DeleteServiceAccountKeyRequest.name)
  return _s;
}
inline const std::string& DeleteServiceAccountKeyRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteServiceAccountKeyRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteServiceAccountKeyRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteServiceAccountKeyRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.DeleteServiceAccountKeyRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteServiceAccountKeyRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.DeleteServiceAccountKeyRequest.name)
}

// -------------------------------------------------------------------

// SignBlobRequest

// string name = 1 [deprecated = true, (.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void SignBlobRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SignBlobRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.SignBlobRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignBlobRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.SignBlobRequest.name)
}
inline std::string* SignBlobRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.SignBlobRequest.name)
  return _s;
}
inline const std::string& SignBlobRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SignBlobRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SignBlobRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SignBlobRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.SignBlobRequest.name)
  return _impl_.name_.Release();
}
inline void SignBlobRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.SignBlobRequest.name)
}

// bytes bytes_to_sign = 2 [deprecated = true, (.google.api.field_behavior) = REQUIRED];
inline void SignBlobRequest::clear_bytes_to_sign() {
  _impl_.bytes_to_sign_.ClearToEmpty();
}
inline const std::string& SignBlobRequest::bytes_to_sign() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.SignBlobRequest.bytes_to_sign)
  return _internal_bytes_to_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignBlobRequest::set_bytes_to_sign(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bytes_to_sign_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.SignBlobRequest.bytes_to_sign)
}
inline std::string* SignBlobRequest::mutable_bytes_to_sign() {
  std::string* _s = _internal_mutable_bytes_to_sign();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.SignBlobRequest.bytes_to_sign)
  return _s;
}
inline const std::string& SignBlobRequest::_internal_bytes_to_sign() const {
  return _impl_.bytes_to_sign_.Get();
}
inline void SignBlobRequest::_internal_set_bytes_to_sign(const std::string& value) {
  
  _impl_.bytes_to_sign_.Set(value, GetArenaForAllocation());
}
inline std::string* SignBlobRequest::_internal_mutable_bytes_to_sign() {
  
  return _impl_.bytes_to_sign_.Mutable(GetArenaForAllocation());
}
inline std::string* SignBlobRequest::release_bytes_to_sign() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.SignBlobRequest.bytes_to_sign)
  return _impl_.bytes_to_sign_.Release();
}
inline void SignBlobRequest::set_allocated_bytes_to_sign(std::string* bytes_to_sign) {
  if (bytes_to_sign != nullptr) {
    
  } else {
    
  }
  _impl_.bytes_to_sign_.SetAllocated(bytes_to_sign, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bytes_to_sign_.IsDefault()) {
    _impl_.bytes_to_sign_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.SignBlobRequest.bytes_to_sign)
}

// -------------------------------------------------------------------

// SignBlobResponse

// string key_id = 1 [deprecated = true];
inline void SignBlobResponse::clear_key_id() {
  _impl_.key_id_.ClearToEmpty();
}
inline const std::string& SignBlobResponse::key_id() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.SignBlobResponse.key_id)
  return _internal_key_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignBlobResponse::set_key_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.SignBlobResponse.key_id)
}
inline std::string* SignBlobResponse::mutable_key_id() {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.SignBlobResponse.key_id)
  return _s;
}
inline const std::string& SignBlobResponse::_internal_key_id() const {
  return _impl_.key_id_.Get();
}
inline void SignBlobResponse::_internal_set_key_id(const std::string& value) {
  
  _impl_.key_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SignBlobResponse::_internal_mutable_key_id() {
  
  return _impl_.key_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SignBlobResponse::release_key_id() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.SignBlobResponse.key_id)
  return _impl_.key_id_.Release();
}
inline void SignBlobResponse::set_allocated_key_id(std::string* key_id) {
  if (key_id != nullptr) {
    
  } else {
    
  }
  _impl_.key_id_.SetAllocated(key_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_id_.IsDefault()) {
    _impl_.key_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.SignBlobResponse.key_id)
}

// bytes signature = 2 [deprecated = true];
inline void SignBlobResponse::clear_signature() {
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& SignBlobResponse::signature() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.SignBlobResponse.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignBlobResponse::set_signature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.SignBlobResponse.signature)
}
inline std::string* SignBlobResponse::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.SignBlobResponse.signature)
  return _s;
}
inline const std::string& SignBlobResponse::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void SignBlobResponse::_internal_set_signature(const std::string& value) {
  
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* SignBlobResponse::_internal_mutable_signature() {
  
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* SignBlobResponse::release_signature() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.SignBlobResponse.signature)
  return _impl_.signature_.Release();
}
inline void SignBlobResponse::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.SignBlobResponse.signature)
}

// -------------------------------------------------------------------

// SignJwtRequest

// string name = 1 [deprecated = true, (.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void SignJwtRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SignJwtRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.SignJwtRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignJwtRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.SignJwtRequest.name)
}
inline std::string* SignJwtRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.SignJwtRequest.name)
  return _s;
}
inline const std::string& SignJwtRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SignJwtRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SignJwtRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SignJwtRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.SignJwtRequest.name)
  return _impl_.name_.Release();
}
inline void SignJwtRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.SignJwtRequest.name)
}

// string payload = 2 [deprecated = true, (.google.api.field_behavior) = REQUIRED];
inline void SignJwtRequest::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& SignJwtRequest::payload() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.SignJwtRequest.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignJwtRequest::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.SignJwtRequest.payload)
}
inline std::string* SignJwtRequest::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.SignJwtRequest.payload)
  return _s;
}
inline const std::string& SignJwtRequest::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void SignJwtRequest::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* SignJwtRequest::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* SignJwtRequest::release_payload() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.SignJwtRequest.payload)
  return _impl_.payload_.Release();
}
inline void SignJwtRequest::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.SignJwtRequest.payload)
}

// -------------------------------------------------------------------

// SignJwtResponse

// string key_id = 1 [deprecated = true];
inline void SignJwtResponse::clear_key_id() {
  _impl_.key_id_.ClearToEmpty();
}
inline const std::string& SignJwtResponse::key_id() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.SignJwtResponse.key_id)
  return _internal_key_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignJwtResponse::set_key_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.SignJwtResponse.key_id)
}
inline std::string* SignJwtResponse::mutable_key_id() {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.SignJwtResponse.key_id)
  return _s;
}
inline const std::string& SignJwtResponse::_internal_key_id() const {
  return _impl_.key_id_.Get();
}
inline void SignJwtResponse::_internal_set_key_id(const std::string& value) {
  
  _impl_.key_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SignJwtResponse::_internal_mutable_key_id() {
  
  return _impl_.key_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SignJwtResponse::release_key_id() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.SignJwtResponse.key_id)
  return _impl_.key_id_.Release();
}
inline void SignJwtResponse::set_allocated_key_id(std::string* key_id) {
  if (key_id != nullptr) {
    
  } else {
    
  }
  _impl_.key_id_.SetAllocated(key_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_id_.IsDefault()) {
    _impl_.key_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.SignJwtResponse.key_id)
}

// string signed_jwt = 2 [deprecated = true];
inline void SignJwtResponse::clear_signed_jwt() {
  _impl_.signed_jwt_.ClearToEmpty();
}
inline const std::string& SignJwtResponse::signed_jwt() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.SignJwtResponse.signed_jwt)
  return _internal_signed_jwt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignJwtResponse::set_signed_jwt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signed_jwt_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.SignJwtResponse.signed_jwt)
}
inline std::string* SignJwtResponse::mutable_signed_jwt() {
  std::string* _s = _internal_mutable_signed_jwt();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.SignJwtResponse.signed_jwt)
  return _s;
}
inline const std::string& SignJwtResponse::_internal_signed_jwt() const {
  return _impl_.signed_jwt_.Get();
}
inline void SignJwtResponse::_internal_set_signed_jwt(const std::string& value) {
  
  _impl_.signed_jwt_.Set(value, GetArenaForAllocation());
}
inline std::string* SignJwtResponse::_internal_mutable_signed_jwt() {
  
  return _impl_.signed_jwt_.Mutable(GetArenaForAllocation());
}
inline std::string* SignJwtResponse::release_signed_jwt() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.SignJwtResponse.signed_jwt)
  return _impl_.signed_jwt_.Release();
}
inline void SignJwtResponse::set_allocated_signed_jwt(std::string* signed_jwt) {
  if (signed_jwt != nullptr) {
    
  } else {
    
  }
  _impl_.signed_jwt_.SetAllocated(signed_jwt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signed_jwt_.IsDefault()) {
    _impl_.signed_jwt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.SignJwtResponse.signed_jwt)
}

// -------------------------------------------------------------------

// Role

// string name = 1;
inline void Role::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Role::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.Role.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Role::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Role.name)
}
inline std::string* Role::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.Role.name)
  return _s;
}
inline const std::string& Role::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Role::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Role::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Role::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.Role.name)
  return _impl_.name_.Release();
}
inline void Role::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.Role.name)
}

// string title = 2;
inline void Role::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& Role::title() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.Role.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Role::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Role.title)
}
inline std::string* Role::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.Role.title)
  return _s;
}
inline const std::string& Role::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Role::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Role::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Role::release_title() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.Role.title)
  return _impl_.title_.Release();
}
inline void Role::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.Role.title)
}

// string description = 3;
inline void Role::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Role::description() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.Role.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Role::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Role.description)
}
inline std::string* Role::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.Role.description)
  return _s;
}
inline const std::string& Role::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Role::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Role::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Role::release_description() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.Role.description)
  return _impl_.description_.Release();
}
inline void Role::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.Role.description)
}

// repeated string included_permissions = 7;
inline int Role::_internal_included_permissions_size() const {
  return _impl_.included_permissions_.size();
}
inline int Role::included_permissions_size() const {
  return _internal_included_permissions_size();
}
inline void Role::clear_included_permissions() {
  _impl_.included_permissions_.Clear();
}
inline std::string* Role::add_included_permissions() {
  std::string* _s = _internal_add_included_permissions();
  // @@protoc_insertion_point(field_add_mutable:google.iam.admin.v1.Role.included_permissions)
  return _s;
}
inline const std::string& Role::_internal_included_permissions(int index) const {
  return _impl_.included_permissions_.Get(index);
}
inline const std::string& Role::included_permissions(int index) const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.Role.included_permissions)
  return _internal_included_permissions(index);
}
inline std::string* Role::mutable_included_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.Role.included_permissions)
  return _impl_.included_permissions_.Mutable(index);
}
inline void Role::set_included_permissions(int index, const std::string& value) {
  _impl_.included_permissions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Role.included_permissions)
}
inline void Role::set_included_permissions(int index, std::string&& value) {
  _impl_.included_permissions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Role.included_permissions)
}
inline void Role::set_included_permissions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.included_permissions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.iam.admin.v1.Role.included_permissions)
}
inline void Role::set_included_permissions(int index, const char* value, size_t size) {
  _impl_.included_permissions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.iam.admin.v1.Role.included_permissions)
}
inline std::string* Role::_internal_add_included_permissions() {
  return _impl_.included_permissions_.Add();
}
inline void Role::add_included_permissions(const std::string& value) {
  _impl_.included_permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.iam.admin.v1.Role.included_permissions)
}
inline void Role::add_included_permissions(std::string&& value) {
  _impl_.included_permissions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.iam.admin.v1.Role.included_permissions)
}
inline void Role::add_included_permissions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.included_permissions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.iam.admin.v1.Role.included_permissions)
}
inline void Role::add_included_permissions(const char* value, size_t size) {
  _impl_.included_permissions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.iam.admin.v1.Role.included_permissions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Role::included_permissions() const {
  // @@protoc_insertion_point(field_list:google.iam.admin.v1.Role.included_permissions)
  return _impl_.included_permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Role::mutable_included_permissions() {
  // @@protoc_insertion_point(field_mutable_list:google.iam.admin.v1.Role.included_permissions)
  return &_impl_.included_permissions_;
}

// .google.iam.admin.v1.Role.RoleLaunchStage stage = 8;
inline void Role::clear_stage() {
  _impl_.stage_ = 0;
}
inline ::google::iam::admin::v1::Role_RoleLaunchStage Role::_internal_stage() const {
  return static_cast< ::google::iam::admin::v1::Role_RoleLaunchStage >(_impl_.stage_);
}
inline ::google::iam::admin::v1::Role_RoleLaunchStage Role::stage() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.Role.stage)
  return _internal_stage();
}
inline void Role::_internal_set_stage(::google::iam::admin::v1::Role_RoleLaunchStage value) {
  
  _impl_.stage_ = value;
}
inline void Role::set_stage(::google::iam::admin::v1::Role_RoleLaunchStage value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Role.stage)
}

// bytes etag = 9;
inline void Role::clear_etag() {
  _impl_.etag_.ClearToEmpty();
}
inline const std::string& Role::etag() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.Role.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Role::set_etag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.etag_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Role.etag)
}
inline std::string* Role::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.Role.etag)
  return _s;
}
inline const std::string& Role::_internal_etag() const {
  return _impl_.etag_.Get();
}
inline void Role::_internal_set_etag(const std::string& value) {
  
  _impl_.etag_.Set(value, GetArenaForAllocation());
}
inline std::string* Role::_internal_mutable_etag() {
  
  return _impl_.etag_.Mutable(GetArenaForAllocation());
}
inline std::string* Role::release_etag() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.Role.etag)
  return _impl_.etag_.Release();
}
inline void Role::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    
  } else {
    
  }
  _impl_.etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.etag_.IsDefault()) {
    _impl_.etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.Role.etag)
}

// bool deleted = 11;
inline void Role::clear_deleted() {
  _impl_.deleted_ = false;
}
inline bool Role::_internal_deleted() const {
  return _impl_.deleted_;
}
inline bool Role::deleted() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.Role.deleted)
  return _internal_deleted();
}
inline void Role::_internal_set_deleted(bool value) {
  
  _impl_.deleted_ = value;
}
inline void Role::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Role.deleted)
}

// -------------------------------------------------------------------

// QueryGrantableRolesRequest

// string full_resource_name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void QueryGrantableRolesRequest::clear_full_resource_name() {
  _impl_.full_resource_name_.ClearToEmpty();
}
inline const std::string& QueryGrantableRolesRequest::full_resource_name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.QueryGrantableRolesRequest.full_resource_name)
  return _internal_full_resource_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryGrantableRolesRequest::set_full_resource_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.full_resource_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.QueryGrantableRolesRequest.full_resource_name)
}
inline std::string* QueryGrantableRolesRequest::mutable_full_resource_name() {
  std::string* _s = _internal_mutable_full_resource_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.QueryGrantableRolesRequest.full_resource_name)
  return _s;
}
inline const std::string& QueryGrantableRolesRequest::_internal_full_resource_name() const {
  return _impl_.full_resource_name_.Get();
}
inline void QueryGrantableRolesRequest::_internal_set_full_resource_name(const std::string& value) {
  
  _impl_.full_resource_name_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryGrantableRolesRequest::_internal_mutable_full_resource_name() {
  
  return _impl_.full_resource_name_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryGrantableRolesRequest::release_full_resource_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.QueryGrantableRolesRequest.full_resource_name)
  return _impl_.full_resource_name_.Release();
}
inline void QueryGrantableRolesRequest::set_allocated_full_resource_name(std::string* full_resource_name) {
  if (full_resource_name != nullptr) {
    
  } else {
    
  }
  _impl_.full_resource_name_.SetAllocated(full_resource_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.full_resource_name_.IsDefault()) {
    _impl_.full_resource_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.QueryGrantableRolesRequest.full_resource_name)
}

// .google.iam.admin.v1.RoleView view = 2;
inline void QueryGrantableRolesRequest::clear_view() {
  _impl_.view_ = 0;
}
inline ::google::iam::admin::v1::RoleView QueryGrantableRolesRequest::_internal_view() const {
  return static_cast< ::google::iam::admin::v1::RoleView >(_impl_.view_);
}
inline ::google::iam::admin::v1::RoleView QueryGrantableRolesRequest::view() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.QueryGrantableRolesRequest.view)
  return _internal_view();
}
inline void QueryGrantableRolesRequest::_internal_set_view(::google::iam::admin::v1::RoleView value) {
  
  _impl_.view_ = value;
}
inline void QueryGrantableRolesRequest::set_view(::google::iam::admin::v1::RoleView value) {
  _internal_set_view(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.QueryGrantableRolesRequest.view)
}

// int32 page_size = 3;
inline void QueryGrantableRolesRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t QueryGrantableRolesRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t QueryGrantableRolesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.QueryGrantableRolesRequest.page_size)
  return _internal_page_size();
}
inline void QueryGrantableRolesRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void QueryGrantableRolesRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.QueryGrantableRolesRequest.page_size)
}

// string page_token = 4;
inline void QueryGrantableRolesRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& QueryGrantableRolesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.QueryGrantableRolesRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryGrantableRolesRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.QueryGrantableRolesRequest.page_token)
}
inline std::string* QueryGrantableRolesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.QueryGrantableRolesRequest.page_token)
  return _s;
}
inline const std::string& QueryGrantableRolesRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void QueryGrantableRolesRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryGrantableRolesRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryGrantableRolesRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.QueryGrantableRolesRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void QueryGrantableRolesRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.QueryGrantableRolesRequest.page_token)
}

// -------------------------------------------------------------------

// QueryGrantableRolesResponse

// repeated .google.iam.admin.v1.Role roles = 1;
inline int QueryGrantableRolesResponse::_internal_roles_size() const {
  return _impl_.roles_.size();
}
inline int QueryGrantableRolesResponse::roles_size() const {
  return _internal_roles_size();
}
inline void QueryGrantableRolesResponse::clear_roles() {
  _impl_.roles_.Clear();
}
inline ::google::iam::admin::v1::Role* QueryGrantableRolesResponse::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.QueryGrantableRolesResponse.roles)
  return _impl_.roles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::Role >*
QueryGrantableRolesResponse::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:google.iam.admin.v1.QueryGrantableRolesResponse.roles)
  return &_impl_.roles_;
}
inline const ::google::iam::admin::v1::Role& QueryGrantableRolesResponse::_internal_roles(int index) const {
  return _impl_.roles_.Get(index);
}
inline const ::google::iam::admin::v1::Role& QueryGrantableRolesResponse::roles(int index) const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.QueryGrantableRolesResponse.roles)
  return _internal_roles(index);
}
inline ::google::iam::admin::v1::Role* QueryGrantableRolesResponse::_internal_add_roles() {
  return _impl_.roles_.Add();
}
inline ::google::iam::admin::v1::Role* QueryGrantableRolesResponse::add_roles() {
  ::google::iam::admin::v1::Role* _add = _internal_add_roles();
  // @@protoc_insertion_point(field_add:google.iam.admin.v1.QueryGrantableRolesResponse.roles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::Role >&
QueryGrantableRolesResponse::roles() const {
  // @@protoc_insertion_point(field_list:google.iam.admin.v1.QueryGrantableRolesResponse.roles)
  return _impl_.roles_;
}

// string next_page_token = 2;
inline void QueryGrantableRolesResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& QueryGrantableRolesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.QueryGrantableRolesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryGrantableRolesResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.QueryGrantableRolesResponse.next_page_token)
}
inline std::string* QueryGrantableRolesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.QueryGrantableRolesResponse.next_page_token)
  return _s;
}
inline const std::string& QueryGrantableRolesResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void QueryGrantableRolesResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryGrantableRolesResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryGrantableRolesResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.QueryGrantableRolesResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void QueryGrantableRolesResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.QueryGrantableRolesResponse.next_page_token)
}

// -------------------------------------------------------------------

// ListRolesRequest

// string parent = 1 [(.google.api.resource_reference) = {
inline void ListRolesRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListRolesRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ListRolesRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRolesRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ListRolesRequest.parent)
}
inline std::string* ListRolesRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ListRolesRequest.parent)
  return _s;
}
inline const std::string& ListRolesRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListRolesRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRolesRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListRolesRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ListRolesRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListRolesRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ListRolesRequest.parent)
}

// int32 page_size = 2;
inline void ListRolesRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListRolesRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListRolesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ListRolesRequest.page_size)
  return _internal_page_size();
}
inline void ListRolesRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListRolesRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ListRolesRequest.page_size)
}

// string page_token = 3;
inline void ListRolesRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListRolesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ListRolesRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRolesRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ListRolesRequest.page_token)
}
inline std::string* ListRolesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ListRolesRequest.page_token)
  return _s;
}
inline const std::string& ListRolesRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListRolesRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRolesRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListRolesRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ListRolesRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListRolesRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ListRolesRequest.page_token)
}

// .google.iam.admin.v1.RoleView view = 4;
inline void ListRolesRequest::clear_view() {
  _impl_.view_ = 0;
}
inline ::google::iam::admin::v1::RoleView ListRolesRequest::_internal_view() const {
  return static_cast< ::google::iam::admin::v1::RoleView >(_impl_.view_);
}
inline ::google::iam::admin::v1::RoleView ListRolesRequest::view() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ListRolesRequest.view)
  return _internal_view();
}
inline void ListRolesRequest::_internal_set_view(::google::iam::admin::v1::RoleView value) {
  
  _impl_.view_ = value;
}
inline void ListRolesRequest::set_view(::google::iam::admin::v1::RoleView value) {
  _internal_set_view(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ListRolesRequest.view)
}

// bool show_deleted = 6;
inline void ListRolesRequest::clear_show_deleted() {
  _impl_.show_deleted_ = false;
}
inline bool ListRolesRequest::_internal_show_deleted() const {
  return _impl_.show_deleted_;
}
inline bool ListRolesRequest::show_deleted() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ListRolesRequest.show_deleted)
  return _internal_show_deleted();
}
inline void ListRolesRequest::_internal_set_show_deleted(bool value) {
  
  _impl_.show_deleted_ = value;
}
inline void ListRolesRequest::set_show_deleted(bool value) {
  _internal_set_show_deleted(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ListRolesRequest.show_deleted)
}

// -------------------------------------------------------------------

// ListRolesResponse

// repeated .google.iam.admin.v1.Role roles = 1;
inline int ListRolesResponse::_internal_roles_size() const {
  return _impl_.roles_.size();
}
inline int ListRolesResponse::roles_size() const {
  return _internal_roles_size();
}
inline void ListRolesResponse::clear_roles() {
  _impl_.roles_.Clear();
}
inline ::google::iam::admin::v1::Role* ListRolesResponse::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ListRolesResponse.roles)
  return _impl_.roles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::Role >*
ListRolesResponse::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:google.iam.admin.v1.ListRolesResponse.roles)
  return &_impl_.roles_;
}
inline const ::google::iam::admin::v1::Role& ListRolesResponse::_internal_roles(int index) const {
  return _impl_.roles_.Get(index);
}
inline const ::google::iam::admin::v1::Role& ListRolesResponse::roles(int index) const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ListRolesResponse.roles)
  return _internal_roles(index);
}
inline ::google::iam::admin::v1::Role* ListRolesResponse::_internal_add_roles() {
  return _impl_.roles_.Add();
}
inline ::google::iam::admin::v1::Role* ListRolesResponse::add_roles() {
  ::google::iam::admin::v1::Role* _add = _internal_add_roles();
  // @@protoc_insertion_point(field_add:google.iam.admin.v1.ListRolesResponse.roles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::Role >&
ListRolesResponse::roles() const {
  // @@protoc_insertion_point(field_list:google.iam.admin.v1.ListRolesResponse.roles)
  return _impl_.roles_;
}

// string next_page_token = 2;
inline void ListRolesResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListRolesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.ListRolesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListRolesResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.ListRolesResponse.next_page_token)
}
inline std::string* ListRolesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.ListRolesResponse.next_page_token)
  return _s;
}
inline const std::string& ListRolesResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListRolesResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRolesResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListRolesResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.ListRolesResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListRolesResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.ListRolesResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetRoleRequest

// string name = 1 [(.google.api.resource_reference) = {
inline void GetRoleRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetRoleRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.GetRoleRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRoleRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.GetRoleRequest.name)
}
inline std::string* GetRoleRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.GetRoleRequest.name)
  return _s;
}
inline const std::string& GetRoleRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetRoleRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRoleRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRoleRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.GetRoleRequest.name)
  return _impl_.name_.Release();
}
inline void GetRoleRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.GetRoleRequest.name)
}

// -------------------------------------------------------------------

// CreateRoleRequest

// string parent = 1 [(.google.api.resource_reference) = {
inline void CreateRoleRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& CreateRoleRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.CreateRoleRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoleRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.CreateRoleRequest.parent)
}
inline std::string* CreateRoleRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.CreateRoleRequest.parent)
  return _s;
}
inline const std::string& CreateRoleRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void CreateRoleRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRoleRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRoleRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.CreateRoleRequest.parent)
  return _impl_.parent_.Release();
}
inline void CreateRoleRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.CreateRoleRequest.parent)
}

// string role_id = 2;
inline void CreateRoleRequest::clear_role_id() {
  _impl_.role_id_.ClearToEmpty();
}
inline const std::string& CreateRoleRequest::role_id() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.CreateRoleRequest.role_id)
  return _internal_role_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoleRequest::set_role_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.role_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.CreateRoleRequest.role_id)
}
inline std::string* CreateRoleRequest::mutable_role_id() {
  std::string* _s = _internal_mutable_role_id();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.CreateRoleRequest.role_id)
  return _s;
}
inline const std::string& CreateRoleRequest::_internal_role_id() const {
  return _impl_.role_id_.Get();
}
inline void CreateRoleRequest::_internal_set_role_id(const std::string& value) {
  
  _impl_.role_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRoleRequest::_internal_mutable_role_id() {
  
  return _impl_.role_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRoleRequest::release_role_id() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.CreateRoleRequest.role_id)
  return _impl_.role_id_.Release();
}
inline void CreateRoleRequest::set_allocated_role_id(std::string* role_id) {
  if (role_id != nullptr) {
    
  } else {
    
  }
  _impl_.role_id_.SetAllocated(role_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.role_id_.IsDefault()) {
    _impl_.role_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.CreateRoleRequest.role_id)
}

// .google.iam.admin.v1.Role role = 3;
inline bool CreateRoleRequest::_internal_has_role() const {
  return this != internal_default_instance() && _impl_.role_ != nullptr;
}
inline bool CreateRoleRequest::has_role() const {
  return _internal_has_role();
}
inline void CreateRoleRequest::clear_role() {
  if (GetArenaForAllocation() == nullptr && _impl_.role_ != nullptr) {
    delete _impl_.role_;
  }
  _impl_.role_ = nullptr;
}
inline const ::google::iam::admin::v1::Role& CreateRoleRequest::_internal_role() const {
  const ::google::iam::admin::v1::Role* p = _impl_.role_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::iam::admin::v1::Role&>(
      ::google::iam::admin::v1::_Role_default_instance_);
}
inline const ::google::iam::admin::v1::Role& CreateRoleRequest::role() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.CreateRoleRequest.role)
  return _internal_role();
}
inline void CreateRoleRequest::unsafe_arena_set_allocated_role(
    ::google::iam::admin::v1::Role* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.role_);
  }
  _impl_.role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.iam.admin.v1.CreateRoleRequest.role)
}
inline ::google::iam::admin::v1::Role* CreateRoleRequest::release_role() {
  
  ::google::iam::admin::v1::Role* temp = _impl_.role_;
  _impl_.role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::iam::admin::v1::Role* CreateRoleRequest::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.CreateRoleRequest.role)
  
  ::google::iam::admin::v1::Role* temp = _impl_.role_;
  _impl_.role_ = nullptr;
  return temp;
}
inline ::google::iam::admin::v1::Role* CreateRoleRequest::_internal_mutable_role() {
  
  if (_impl_.role_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::iam::admin::v1::Role>(GetArenaForAllocation());
    _impl_.role_ = p;
  }
  return _impl_.role_;
}
inline ::google::iam::admin::v1::Role* CreateRoleRequest::mutable_role() {
  ::google::iam::admin::v1::Role* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.CreateRoleRequest.role)
  return _msg;
}
inline void CreateRoleRequest::set_allocated_role(::google::iam::admin::v1::Role* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.role_ = role;
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.CreateRoleRequest.role)
}

// -------------------------------------------------------------------

// UpdateRoleRequest

// string name = 1 [(.google.api.resource_reference) = {
inline void UpdateRoleRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateRoleRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.UpdateRoleRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRoleRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.UpdateRoleRequest.name)
}
inline std::string* UpdateRoleRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.UpdateRoleRequest.name)
  return _s;
}
inline const std::string& UpdateRoleRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateRoleRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRoleRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRoleRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.UpdateRoleRequest.name)
  return _impl_.name_.Release();
}
inline void UpdateRoleRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.UpdateRoleRequest.name)
}

// .google.iam.admin.v1.Role role = 2;
inline bool UpdateRoleRequest::_internal_has_role() const {
  return this != internal_default_instance() && _impl_.role_ != nullptr;
}
inline bool UpdateRoleRequest::has_role() const {
  return _internal_has_role();
}
inline void UpdateRoleRequest::clear_role() {
  if (GetArenaForAllocation() == nullptr && _impl_.role_ != nullptr) {
    delete _impl_.role_;
  }
  _impl_.role_ = nullptr;
}
inline const ::google::iam::admin::v1::Role& UpdateRoleRequest::_internal_role() const {
  const ::google::iam::admin::v1::Role* p = _impl_.role_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::iam::admin::v1::Role&>(
      ::google::iam::admin::v1::_Role_default_instance_);
}
inline const ::google::iam::admin::v1::Role& UpdateRoleRequest::role() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.UpdateRoleRequest.role)
  return _internal_role();
}
inline void UpdateRoleRequest::unsafe_arena_set_allocated_role(
    ::google::iam::admin::v1::Role* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.role_);
  }
  _impl_.role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.iam.admin.v1.UpdateRoleRequest.role)
}
inline ::google::iam::admin::v1::Role* UpdateRoleRequest::release_role() {
  
  ::google::iam::admin::v1::Role* temp = _impl_.role_;
  _impl_.role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::iam::admin::v1::Role* UpdateRoleRequest::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.UpdateRoleRequest.role)
  
  ::google::iam::admin::v1::Role* temp = _impl_.role_;
  _impl_.role_ = nullptr;
  return temp;
}
inline ::google::iam::admin::v1::Role* UpdateRoleRequest::_internal_mutable_role() {
  
  if (_impl_.role_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::iam::admin::v1::Role>(GetArenaForAllocation());
    _impl_.role_ = p;
  }
  return _impl_.role_;
}
inline ::google::iam::admin::v1::Role* UpdateRoleRequest::mutable_role() {
  ::google::iam::admin::v1::Role* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.UpdateRoleRequest.role)
  return _msg;
}
inline void UpdateRoleRequest::set_allocated_role(::google::iam::admin::v1::Role* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.role_ = role;
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.UpdateRoleRequest.role)
}

// .google.protobuf.FieldMask update_mask = 3;
inline bool UpdateRoleRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateRoleRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateRoleRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateRoleRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.UpdateRoleRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateRoleRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.iam.admin.v1.UpdateRoleRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateRoleRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateRoleRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.UpdateRoleRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateRoleRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateRoleRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.UpdateRoleRequest.update_mask)
  return _msg;
}
inline void UpdateRoleRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.UpdateRoleRequest.update_mask)
}

// -------------------------------------------------------------------

// DeleteRoleRequest

// string name = 1 [(.google.api.resource_reference) = {
inline void DeleteRoleRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteRoleRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.DeleteRoleRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRoleRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.DeleteRoleRequest.name)
}
inline std::string* DeleteRoleRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.DeleteRoleRequest.name)
  return _s;
}
inline const std::string& DeleteRoleRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteRoleRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRoleRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRoleRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.DeleteRoleRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteRoleRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.DeleteRoleRequest.name)
}

// bytes etag = 2;
inline void DeleteRoleRequest::clear_etag() {
  _impl_.etag_.ClearToEmpty();
}
inline const std::string& DeleteRoleRequest::etag() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.DeleteRoleRequest.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRoleRequest::set_etag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.etag_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.DeleteRoleRequest.etag)
}
inline std::string* DeleteRoleRequest::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.DeleteRoleRequest.etag)
  return _s;
}
inline const std::string& DeleteRoleRequest::_internal_etag() const {
  return _impl_.etag_.Get();
}
inline void DeleteRoleRequest::_internal_set_etag(const std::string& value) {
  
  _impl_.etag_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRoleRequest::_internal_mutable_etag() {
  
  return _impl_.etag_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRoleRequest::release_etag() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.DeleteRoleRequest.etag)
  return _impl_.etag_.Release();
}
inline void DeleteRoleRequest::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    
  } else {
    
  }
  _impl_.etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.etag_.IsDefault()) {
    _impl_.etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.DeleteRoleRequest.etag)
}

// -------------------------------------------------------------------

// UndeleteRoleRequest

// string name = 1 [(.google.api.resource_reference) = {
inline void UndeleteRoleRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UndeleteRoleRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.UndeleteRoleRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UndeleteRoleRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.UndeleteRoleRequest.name)
}
inline std::string* UndeleteRoleRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.UndeleteRoleRequest.name)
  return _s;
}
inline const std::string& UndeleteRoleRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UndeleteRoleRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UndeleteRoleRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UndeleteRoleRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.UndeleteRoleRequest.name)
  return _impl_.name_.Release();
}
inline void UndeleteRoleRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.UndeleteRoleRequest.name)
}

// bytes etag = 2;
inline void UndeleteRoleRequest::clear_etag() {
  _impl_.etag_.ClearToEmpty();
}
inline const std::string& UndeleteRoleRequest::etag() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.UndeleteRoleRequest.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UndeleteRoleRequest::set_etag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.etag_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.UndeleteRoleRequest.etag)
}
inline std::string* UndeleteRoleRequest::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.UndeleteRoleRequest.etag)
  return _s;
}
inline const std::string& UndeleteRoleRequest::_internal_etag() const {
  return _impl_.etag_.Get();
}
inline void UndeleteRoleRequest::_internal_set_etag(const std::string& value) {
  
  _impl_.etag_.Set(value, GetArenaForAllocation());
}
inline std::string* UndeleteRoleRequest::_internal_mutable_etag() {
  
  return _impl_.etag_.Mutable(GetArenaForAllocation());
}
inline std::string* UndeleteRoleRequest::release_etag() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.UndeleteRoleRequest.etag)
  return _impl_.etag_.Release();
}
inline void UndeleteRoleRequest::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    
  } else {
    
  }
  _impl_.etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.etag_.IsDefault()) {
    _impl_.etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.UndeleteRoleRequest.etag)
}

// -------------------------------------------------------------------

// Permission

// string name = 1;
inline void Permission::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Permission::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.Permission.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Permission::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Permission.name)
}
inline std::string* Permission::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.Permission.name)
  return _s;
}
inline const std::string& Permission::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Permission::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Permission::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Permission::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.Permission.name)
  return _impl_.name_.Release();
}
inline void Permission::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.Permission.name)
}

// string title = 2;
inline void Permission::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& Permission::title() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.Permission.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Permission::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Permission.title)
}
inline std::string* Permission::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.Permission.title)
  return _s;
}
inline const std::string& Permission::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Permission::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Permission::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Permission::release_title() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.Permission.title)
  return _impl_.title_.Release();
}
inline void Permission::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.Permission.title)
}

// string description = 3;
inline void Permission::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Permission::description() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.Permission.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Permission::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Permission.description)
}
inline std::string* Permission::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.Permission.description)
  return _s;
}
inline const std::string& Permission::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Permission::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Permission::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Permission::release_description() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.Permission.description)
  return _impl_.description_.Release();
}
inline void Permission::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.Permission.description)
}

// bool only_in_predefined_roles = 4 [deprecated = true];
inline void Permission::clear_only_in_predefined_roles() {
  _impl_.only_in_predefined_roles_ = false;
}
inline bool Permission::_internal_only_in_predefined_roles() const {
  return _impl_.only_in_predefined_roles_;
}
inline bool Permission::only_in_predefined_roles() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.Permission.only_in_predefined_roles)
  return _internal_only_in_predefined_roles();
}
inline void Permission::_internal_set_only_in_predefined_roles(bool value) {
  
  _impl_.only_in_predefined_roles_ = value;
}
inline void Permission::set_only_in_predefined_roles(bool value) {
  _internal_set_only_in_predefined_roles(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Permission.only_in_predefined_roles)
}

// .google.iam.admin.v1.Permission.PermissionLaunchStage stage = 5;
inline void Permission::clear_stage() {
  _impl_.stage_ = 0;
}
inline ::google::iam::admin::v1::Permission_PermissionLaunchStage Permission::_internal_stage() const {
  return static_cast< ::google::iam::admin::v1::Permission_PermissionLaunchStage >(_impl_.stage_);
}
inline ::google::iam::admin::v1::Permission_PermissionLaunchStage Permission::stage() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.Permission.stage)
  return _internal_stage();
}
inline void Permission::_internal_set_stage(::google::iam::admin::v1::Permission_PermissionLaunchStage value) {
  
  _impl_.stage_ = value;
}
inline void Permission::set_stage(::google::iam::admin::v1::Permission_PermissionLaunchStage value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Permission.stage)
}

// .google.iam.admin.v1.Permission.CustomRolesSupportLevel custom_roles_support_level = 6;
inline void Permission::clear_custom_roles_support_level() {
  _impl_.custom_roles_support_level_ = 0;
}
inline ::google::iam::admin::v1::Permission_CustomRolesSupportLevel Permission::_internal_custom_roles_support_level() const {
  return static_cast< ::google::iam::admin::v1::Permission_CustomRolesSupportLevel >(_impl_.custom_roles_support_level_);
}
inline ::google::iam::admin::v1::Permission_CustomRolesSupportLevel Permission::custom_roles_support_level() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.Permission.custom_roles_support_level)
  return _internal_custom_roles_support_level();
}
inline void Permission::_internal_set_custom_roles_support_level(::google::iam::admin::v1::Permission_CustomRolesSupportLevel value) {
  
  _impl_.custom_roles_support_level_ = value;
}
inline void Permission::set_custom_roles_support_level(::google::iam::admin::v1::Permission_CustomRolesSupportLevel value) {
  _internal_set_custom_roles_support_level(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Permission.custom_roles_support_level)
}

// bool api_disabled = 7;
inline void Permission::clear_api_disabled() {
  _impl_.api_disabled_ = false;
}
inline bool Permission::_internal_api_disabled() const {
  return _impl_.api_disabled_;
}
inline bool Permission::api_disabled() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.Permission.api_disabled)
  return _internal_api_disabled();
}
inline void Permission::_internal_set_api_disabled(bool value) {
  
  _impl_.api_disabled_ = value;
}
inline void Permission::set_api_disabled(bool value) {
  _internal_set_api_disabled(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Permission.api_disabled)
}

// string primary_permission = 8;
inline void Permission::clear_primary_permission() {
  _impl_.primary_permission_.ClearToEmpty();
}
inline const std::string& Permission::primary_permission() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.Permission.primary_permission)
  return _internal_primary_permission();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Permission::set_primary_permission(ArgT0&& arg0, ArgT... args) {
 
 _impl_.primary_permission_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.Permission.primary_permission)
}
inline std::string* Permission::mutable_primary_permission() {
  std::string* _s = _internal_mutable_primary_permission();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.Permission.primary_permission)
  return _s;
}
inline const std::string& Permission::_internal_primary_permission() const {
  return _impl_.primary_permission_.Get();
}
inline void Permission::_internal_set_primary_permission(const std::string& value) {
  
  _impl_.primary_permission_.Set(value, GetArenaForAllocation());
}
inline std::string* Permission::_internal_mutable_primary_permission() {
  
  return _impl_.primary_permission_.Mutable(GetArenaForAllocation());
}
inline std::string* Permission::release_primary_permission() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.Permission.primary_permission)
  return _impl_.primary_permission_.Release();
}
inline void Permission::set_allocated_primary_permission(std::string* primary_permission) {
  if (primary_permission != nullptr) {
    
  } else {
    
  }
  _impl_.primary_permission_.SetAllocated(primary_permission, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.primary_permission_.IsDefault()) {
    _impl_.primary_permission_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.Permission.primary_permission)
}

// -------------------------------------------------------------------

// QueryTestablePermissionsRequest

// string full_resource_name = 1;
inline void QueryTestablePermissionsRequest::clear_full_resource_name() {
  _impl_.full_resource_name_.ClearToEmpty();
}
inline const std::string& QueryTestablePermissionsRequest::full_resource_name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.QueryTestablePermissionsRequest.full_resource_name)
  return _internal_full_resource_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryTestablePermissionsRequest::set_full_resource_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.full_resource_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.QueryTestablePermissionsRequest.full_resource_name)
}
inline std::string* QueryTestablePermissionsRequest::mutable_full_resource_name() {
  std::string* _s = _internal_mutable_full_resource_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.QueryTestablePermissionsRequest.full_resource_name)
  return _s;
}
inline const std::string& QueryTestablePermissionsRequest::_internal_full_resource_name() const {
  return _impl_.full_resource_name_.Get();
}
inline void QueryTestablePermissionsRequest::_internal_set_full_resource_name(const std::string& value) {
  
  _impl_.full_resource_name_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTestablePermissionsRequest::_internal_mutable_full_resource_name() {
  
  return _impl_.full_resource_name_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryTestablePermissionsRequest::release_full_resource_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.QueryTestablePermissionsRequest.full_resource_name)
  return _impl_.full_resource_name_.Release();
}
inline void QueryTestablePermissionsRequest::set_allocated_full_resource_name(std::string* full_resource_name) {
  if (full_resource_name != nullptr) {
    
  } else {
    
  }
  _impl_.full_resource_name_.SetAllocated(full_resource_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.full_resource_name_.IsDefault()) {
    _impl_.full_resource_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.QueryTestablePermissionsRequest.full_resource_name)
}

// int32 page_size = 2;
inline void QueryTestablePermissionsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t QueryTestablePermissionsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t QueryTestablePermissionsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.QueryTestablePermissionsRequest.page_size)
  return _internal_page_size();
}
inline void QueryTestablePermissionsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void QueryTestablePermissionsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.QueryTestablePermissionsRequest.page_size)
}

// string page_token = 3;
inline void QueryTestablePermissionsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& QueryTestablePermissionsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.QueryTestablePermissionsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryTestablePermissionsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.QueryTestablePermissionsRequest.page_token)
}
inline std::string* QueryTestablePermissionsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.QueryTestablePermissionsRequest.page_token)
  return _s;
}
inline const std::string& QueryTestablePermissionsRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void QueryTestablePermissionsRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTestablePermissionsRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryTestablePermissionsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.QueryTestablePermissionsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void QueryTestablePermissionsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.QueryTestablePermissionsRequest.page_token)
}

// -------------------------------------------------------------------

// QueryTestablePermissionsResponse

// repeated .google.iam.admin.v1.Permission permissions = 1;
inline int QueryTestablePermissionsResponse::_internal_permissions_size() const {
  return _impl_.permissions_.size();
}
inline int QueryTestablePermissionsResponse::permissions_size() const {
  return _internal_permissions_size();
}
inline void QueryTestablePermissionsResponse::clear_permissions() {
  _impl_.permissions_.Clear();
}
inline ::google::iam::admin::v1::Permission* QueryTestablePermissionsResponse::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.QueryTestablePermissionsResponse.permissions)
  return _impl_.permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::Permission >*
QueryTestablePermissionsResponse::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:google.iam.admin.v1.QueryTestablePermissionsResponse.permissions)
  return &_impl_.permissions_;
}
inline const ::google::iam::admin::v1::Permission& QueryTestablePermissionsResponse::_internal_permissions(int index) const {
  return _impl_.permissions_.Get(index);
}
inline const ::google::iam::admin::v1::Permission& QueryTestablePermissionsResponse::permissions(int index) const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.QueryTestablePermissionsResponse.permissions)
  return _internal_permissions(index);
}
inline ::google::iam::admin::v1::Permission* QueryTestablePermissionsResponse::_internal_add_permissions() {
  return _impl_.permissions_.Add();
}
inline ::google::iam::admin::v1::Permission* QueryTestablePermissionsResponse::add_permissions() {
  ::google::iam::admin::v1::Permission* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:google.iam.admin.v1.QueryTestablePermissionsResponse.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::Permission >&
QueryTestablePermissionsResponse::permissions() const {
  // @@protoc_insertion_point(field_list:google.iam.admin.v1.QueryTestablePermissionsResponse.permissions)
  return _impl_.permissions_;
}

// string next_page_token = 2;
inline void QueryTestablePermissionsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& QueryTestablePermissionsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.QueryTestablePermissionsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryTestablePermissionsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.QueryTestablePermissionsResponse.next_page_token)
}
inline std::string* QueryTestablePermissionsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.QueryTestablePermissionsResponse.next_page_token)
  return _s;
}
inline const std::string& QueryTestablePermissionsResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void QueryTestablePermissionsResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTestablePermissionsResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryTestablePermissionsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.QueryTestablePermissionsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void QueryTestablePermissionsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.QueryTestablePermissionsResponse.next_page_token)
}

// -------------------------------------------------------------------

// QueryAuditableServicesRequest

// string full_resource_name = 1;
inline void QueryAuditableServicesRequest::clear_full_resource_name() {
  _impl_.full_resource_name_.ClearToEmpty();
}
inline const std::string& QueryAuditableServicesRequest::full_resource_name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.QueryAuditableServicesRequest.full_resource_name)
  return _internal_full_resource_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryAuditableServicesRequest::set_full_resource_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.full_resource_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.QueryAuditableServicesRequest.full_resource_name)
}
inline std::string* QueryAuditableServicesRequest::mutable_full_resource_name() {
  std::string* _s = _internal_mutable_full_resource_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.QueryAuditableServicesRequest.full_resource_name)
  return _s;
}
inline const std::string& QueryAuditableServicesRequest::_internal_full_resource_name() const {
  return _impl_.full_resource_name_.Get();
}
inline void QueryAuditableServicesRequest::_internal_set_full_resource_name(const std::string& value) {
  
  _impl_.full_resource_name_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryAuditableServicesRequest::_internal_mutable_full_resource_name() {
  
  return _impl_.full_resource_name_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryAuditableServicesRequest::release_full_resource_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.QueryAuditableServicesRequest.full_resource_name)
  return _impl_.full_resource_name_.Release();
}
inline void QueryAuditableServicesRequest::set_allocated_full_resource_name(std::string* full_resource_name) {
  if (full_resource_name != nullptr) {
    
  } else {
    
  }
  _impl_.full_resource_name_.SetAllocated(full_resource_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.full_resource_name_.IsDefault()) {
    _impl_.full_resource_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.QueryAuditableServicesRequest.full_resource_name)
}

// -------------------------------------------------------------------

// QueryAuditableServicesResponse_AuditableService

// string name = 1;
inline void QueryAuditableServicesResponse_AuditableService::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& QueryAuditableServicesResponse_AuditableService::name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.QueryAuditableServicesResponse.AuditableService.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryAuditableServicesResponse_AuditableService::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.QueryAuditableServicesResponse.AuditableService.name)
}
inline std::string* QueryAuditableServicesResponse_AuditableService::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.QueryAuditableServicesResponse.AuditableService.name)
  return _s;
}
inline const std::string& QueryAuditableServicesResponse_AuditableService::_internal_name() const {
  return _impl_.name_.Get();
}
inline void QueryAuditableServicesResponse_AuditableService::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryAuditableServicesResponse_AuditableService::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryAuditableServicesResponse_AuditableService::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.QueryAuditableServicesResponse.AuditableService.name)
  return _impl_.name_.Release();
}
inline void QueryAuditableServicesResponse_AuditableService::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.QueryAuditableServicesResponse.AuditableService.name)
}

// -------------------------------------------------------------------

// QueryAuditableServicesResponse

// repeated .google.iam.admin.v1.QueryAuditableServicesResponse.AuditableService services = 1;
inline int QueryAuditableServicesResponse::_internal_services_size() const {
  return _impl_.services_.size();
}
inline int QueryAuditableServicesResponse::services_size() const {
  return _internal_services_size();
}
inline void QueryAuditableServicesResponse::clear_services() {
  _impl_.services_.Clear();
}
inline ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService* QueryAuditableServicesResponse::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.QueryAuditableServicesResponse.services)
  return _impl_.services_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService >*
QueryAuditableServicesResponse::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:google.iam.admin.v1.QueryAuditableServicesResponse.services)
  return &_impl_.services_;
}
inline const ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService& QueryAuditableServicesResponse::_internal_services(int index) const {
  return _impl_.services_.Get(index);
}
inline const ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService& QueryAuditableServicesResponse::services(int index) const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.QueryAuditableServicesResponse.services)
  return _internal_services(index);
}
inline ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService* QueryAuditableServicesResponse::_internal_add_services() {
  return _impl_.services_.Add();
}
inline ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService* QueryAuditableServicesResponse::add_services() {
  ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService* _add = _internal_add_services();
  // @@protoc_insertion_point(field_add:google.iam.admin.v1.QueryAuditableServicesResponse.services)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::QueryAuditableServicesResponse_AuditableService >&
QueryAuditableServicesResponse::services() const {
  // @@protoc_insertion_point(field_list:google.iam.admin.v1.QueryAuditableServicesResponse.services)
  return _impl_.services_;
}

// -------------------------------------------------------------------

// LintPolicyRequest

// string full_resource_name = 1;
inline void LintPolicyRequest::clear_full_resource_name() {
  _impl_.full_resource_name_.ClearToEmpty();
}
inline const std::string& LintPolicyRequest::full_resource_name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.LintPolicyRequest.full_resource_name)
  return _internal_full_resource_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LintPolicyRequest::set_full_resource_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.full_resource_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.LintPolicyRequest.full_resource_name)
}
inline std::string* LintPolicyRequest::mutable_full_resource_name() {
  std::string* _s = _internal_mutable_full_resource_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.LintPolicyRequest.full_resource_name)
  return _s;
}
inline const std::string& LintPolicyRequest::_internal_full_resource_name() const {
  return _impl_.full_resource_name_.Get();
}
inline void LintPolicyRequest::_internal_set_full_resource_name(const std::string& value) {
  
  _impl_.full_resource_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LintPolicyRequest::_internal_mutable_full_resource_name() {
  
  return _impl_.full_resource_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LintPolicyRequest::release_full_resource_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.LintPolicyRequest.full_resource_name)
  return _impl_.full_resource_name_.Release();
}
inline void LintPolicyRequest::set_allocated_full_resource_name(std::string* full_resource_name) {
  if (full_resource_name != nullptr) {
    
  } else {
    
  }
  _impl_.full_resource_name_.SetAllocated(full_resource_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.full_resource_name_.IsDefault()) {
    _impl_.full_resource_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.LintPolicyRequest.full_resource_name)
}

// .google.type.Expr condition = 5;
inline bool LintPolicyRequest::_internal_has_condition() const {
  return lint_object_case() == kCondition;
}
inline bool LintPolicyRequest::has_condition() const {
  return _internal_has_condition();
}
inline void LintPolicyRequest::set_has_condition() {
  _impl_._oneof_case_[0] = kCondition;
}
inline ::google::type::Expr* LintPolicyRequest::release_condition() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.LintPolicyRequest.condition)
  if (_internal_has_condition()) {
    clear_has_lint_object();
    ::google::type::Expr* temp = _impl_.lint_object_.condition_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.lint_object_.condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::type::Expr& LintPolicyRequest::_internal_condition() const {
  return _internal_has_condition()
      ? *_impl_.lint_object_.condition_
      : reinterpret_cast< ::google::type::Expr&>(::google::type::_Expr_default_instance_);
}
inline const ::google::type::Expr& LintPolicyRequest::condition() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.LintPolicyRequest.condition)
  return _internal_condition();
}
inline ::google::type::Expr* LintPolicyRequest::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.iam.admin.v1.LintPolicyRequest.condition)
  if (_internal_has_condition()) {
    clear_has_lint_object();
    ::google::type::Expr* temp = _impl_.lint_object_.condition_;
    _impl_.lint_object_.condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LintPolicyRequest::unsafe_arena_set_allocated_condition(::google::type::Expr* condition) {
  clear_lint_object();
  if (condition) {
    set_has_condition();
    _impl_.lint_object_.condition_ = condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.iam.admin.v1.LintPolicyRequest.condition)
}
inline ::google::type::Expr* LintPolicyRequest::_internal_mutable_condition() {
  if (!_internal_has_condition()) {
    clear_lint_object();
    set_has_condition();
    _impl_.lint_object_.condition_ = CreateMaybeMessage< ::google::type::Expr >(GetArenaForAllocation());
  }
  return _impl_.lint_object_.condition_;
}
inline ::google::type::Expr* LintPolicyRequest::mutable_condition() {
  ::google::type::Expr* _msg = _internal_mutable_condition();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.LintPolicyRequest.condition)
  return _msg;
}

inline bool LintPolicyRequest::has_lint_object() const {
  return lint_object_case() != LINT_OBJECT_NOT_SET;
}
inline void LintPolicyRequest::clear_has_lint_object() {
  _impl_._oneof_case_[0] = LINT_OBJECT_NOT_SET;
}
inline LintPolicyRequest::LintObjectCase LintPolicyRequest::lint_object_case() const {
  return LintPolicyRequest::LintObjectCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LintResult

// .google.iam.admin.v1.LintResult.Level level = 1;
inline void LintResult::clear_level() {
  _impl_.level_ = 0;
}
inline ::google::iam::admin::v1::LintResult_Level LintResult::_internal_level() const {
  return static_cast< ::google::iam::admin::v1::LintResult_Level >(_impl_.level_);
}
inline ::google::iam::admin::v1::LintResult_Level LintResult::level() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.LintResult.level)
  return _internal_level();
}
inline void LintResult::_internal_set_level(::google::iam::admin::v1::LintResult_Level value) {
  
  _impl_.level_ = value;
}
inline void LintResult::set_level(::google::iam::admin::v1::LintResult_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.LintResult.level)
}

// string validation_unit_name = 2;
inline void LintResult::clear_validation_unit_name() {
  _impl_.validation_unit_name_.ClearToEmpty();
}
inline const std::string& LintResult::validation_unit_name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.LintResult.validation_unit_name)
  return _internal_validation_unit_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LintResult::set_validation_unit_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.validation_unit_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.LintResult.validation_unit_name)
}
inline std::string* LintResult::mutable_validation_unit_name() {
  std::string* _s = _internal_mutable_validation_unit_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.LintResult.validation_unit_name)
  return _s;
}
inline const std::string& LintResult::_internal_validation_unit_name() const {
  return _impl_.validation_unit_name_.Get();
}
inline void LintResult::_internal_set_validation_unit_name(const std::string& value) {
  
  _impl_.validation_unit_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LintResult::_internal_mutable_validation_unit_name() {
  
  return _impl_.validation_unit_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LintResult::release_validation_unit_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.LintResult.validation_unit_name)
  return _impl_.validation_unit_name_.Release();
}
inline void LintResult::set_allocated_validation_unit_name(std::string* validation_unit_name) {
  if (validation_unit_name != nullptr) {
    
  } else {
    
  }
  _impl_.validation_unit_name_.SetAllocated(validation_unit_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.validation_unit_name_.IsDefault()) {
    _impl_.validation_unit_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.LintResult.validation_unit_name)
}

// .google.iam.admin.v1.LintResult.Severity severity = 3;
inline void LintResult::clear_severity() {
  _impl_.severity_ = 0;
}
inline ::google::iam::admin::v1::LintResult_Severity LintResult::_internal_severity() const {
  return static_cast< ::google::iam::admin::v1::LintResult_Severity >(_impl_.severity_);
}
inline ::google::iam::admin::v1::LintResult_Severity LintResult::severity() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.LintResult.severity)
  return _internal_severity();
}
inline void LintResult::_internal_set_severity(::google::iam::admin::v1::LintResult_Severity value) {
  
  _impl_.severity_ = value;
}
inline void LintResult::set_severity(::google::iam::admin::v1::LintResult_Severity value) {
  _internal_set_severity(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.LintResult.severity)
}

// string field_name = 5;
inline void LintResult::clear_field_name() {
  _impl_.field_name_.ClearToEmpty();
}
inline const std::string& LintResult::field_name() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.LintResult.field_name)
  return _internal_field_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LintResult::set_field_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.LintResult.field_name)
}
inline std::string* LintResult::mutable_field_name() {
  std::string* _s = _internal_mutable_field_name();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.LintResult.field_name)
  return _s;
}
inline const std::string& LintResult::_internal_field_name() const {
  return _impl_.field_name_.Get();
}
inline void LintResult::_internal_set_field_name(const std::string& value) {
  
  _impl_.field_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LintResult::_internal_mutable_field_name() {
  
  return _impl_.field_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LintResult::release_field_name() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.LintResult.field_name)
  return _impl_.field_name_.Release();
}
inline void LintResult::set_allocated_field_name(std::string* field_name) {
  if (field_name != nullptr) {
    
  } else {
    
  }
  _impl_.field_name_.SetAllocated(field_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_name_.IsDefault()) {
    _impl_.field_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.LintResult.field_name)
}

// int32 location_offset = 6;
inline void LintResult::clear_location_offset() {
  _impl_.location_offset_ = 0;
}
inline int32_t LintResult::_internal_location_offset() const {
  return _impl_.location_offset_;
}
inline int32_t LintResult::location_offset() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.LintResult.location_offset)
  return _internal_location_offset();
}
inline void LintResult::_internal_set_location_offset(int32_t value) {
  
  _impl_.location_offset_ = value;
}
inline void LintResult::set_location_offset(int32_t value) {
  _internal_set_location_offset(value);
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.LintResult.location_offset)
}

// string debug_message = 7;
inline void LintResult::clear_debug_message() {
  _impl_.debug_message_.ClearToEmpty();
}
inline const std::string& LintResult::debug_message() const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.LintResult.debug_message)
  return _internal_debug_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LintResult::set_debug_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.debug_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.admin.v1.LintResult.debug_message)
}
inline std::string* LintResult::mutable_debug_message() {
  std::string* _s = _internal_mutable_debug_message();
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.LintResult.debug_message)
  return _s;
}
inline const std::string& LintResult::_internal_debug_message() const {
  return _impl_.debug_message_.Get();
}
inline void LintResult::_internal_set_debug_message(const std::string& value) {
  
  _impl_.debug_message_.Set(value, GetArenaForAllocation());
}
inline std::string* LintResult::_internal_mutable_debug_message() {
  
  return _impl_.debug_message_.Mutable(GetArenaForAllocation());
}
inline std::string* LintResult::release_debug_message() {
  // @@protoc_insertion_point(field_release:google.iam.admin.v1.LintResult.debug_message)
  return _impl_.debug_message_.Release();
}
inline void LintResult::set_allocated_debug_message(std::string* debug_message) {
  if (debug_message != nullptr) {
    
  } else {
    
  }
  _impl_.debug_message_.SetAllocated(debug_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.debug_message_.IsDefault()) {
    _impl_.debug_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.admin.v1.LintResult.debug_message)
}

// -------------------------------------------------------------------

// LintPolicyResponse

// repeated .google.iam.admin.v1.LintResult lint_results = 1;
inline int LintPolicyResponse::_internal_lint_results_size() const {
  return _impl_.lint_results_.size();
}
inline int LintPolicyResponse::lint_results_size() const {
  return _internal_lint_results_size();
}
inline void LintPolicyResponse::clear_lint_results() {
  _impl_.lint_results_.Clear();
}
inline ::google::iam::admin::v1::LintResult* LintPolicyResponse::mutable_lint_results(int index) {
  // @@protoc_insertion_point(field_mutable:google.iam.admin.v1.LintPolicyResponse.lint_results)
  return _impl_.lint_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::LintResult >*
LintPolicyResponse::mutable_lint_results() {
  // @@protoc_insertion_point(field_mutable_list:google.iam.admin.v1.LintPolicyResponse.lint_results)
  return &_impl_.lint_results_;
}
inline const ::google::iam::admin::v1::LintResult& LintPolicyResponse::_internal_lint_results(int index) const {
  return _impl_.lint_results_.Get(index);
}
inline const ::google::iam::admin::v1::LintResult& LintPolicyResponse::lint_results(int index) const {
  // @@protoc_insertion_point(field_get:google.iam.admin.v1.LintPolicyResponse.lint_results)
  return _internal_lint_results(index);
}
inline ::google::iam::admin::v1::LintResult* LintPolicyResponse::_internal_add_lint_results() {
  return _impl_.lint_results_.Add();
}
inline ::google::iam::admin::v1::LintResult* LintPolicyResponse::add_lint_results() {
  ::google::iam::admin::v1::LintResult* _add = _internal_add_lint_results();
  // @@protoc_insertion_point(field_add:google.iam.admin.v1.LintPolicyResponse.lint_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::iam::admin::v1::LintResult >&
LintPolicyResponse::lint_results() const {
  // @@protoc_insertion_point(field_list:google.iam.admin.v1.LintPolicyResponse.lint_results)
  return _impl_.lint_results_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace admin
}  // namespace iam
}  // namespace google

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType>() {
  return ::google::iam::admin::v1::ListServiceAccountKeysRequest_KeyType_descriptor();
}
template <> struct is_proto_enum< ::google::iam::admin::v1::Role_RoleLaunchStage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::iam::admin::v1::Role_RoleLaunchStage>() {
  return ::google::iam::admin::v1::Role_RoleLaunchStage_descriptor();
}
template <> struct is_proto_enum< ::google::iam::admin::v1::Permission_PermissionLaunchStage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::iam::admin::v1::Permission_PermissionLaunchStage>() {
  return ::google::iam::admin::v1::Permission_PermissionLaunchStage_descriptor();
}
template <> struct is_proto_enum< ::google::iam::admin::v1::Permission_CustomRolesSupportLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::iam::admin::v1::Permission_CustomRolesSupportLevel>() {
  return ::google::iam::admin::v1::Permission_CustomRolesSupportLevel_descriptor();
}
template <> struct is_proto_enum< ::google::iam::admin::v1::LintResult_Level> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::iam::admin::v1::LintResult_Level>() {
  return ::google::iam::admin::v1::LintResult_Level_descriptor();
}
template <> struct is_proto_enum< ::google::iam::admin::v1::LintResult_Severity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::iam::admin::v1::LintResult_Severity>() {
  return ::google::iam::admin::v1::LintResult_Severity_descriptor();
}
template <> struct is_proto_enum< ::google::iam::admin::v1::ServiceAccountKeyAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::iam::admin::v1::ServiceAccountKeyAlgorithm>() {
  return ::google::iam::admin::v1::ServiceAccountKeyAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::google::iam::admin::v1::ServiceAccountPrivateKeyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::iam::admin::v1::ServiceAccountPrivateKeyType>() {
  return ::google::iam::admin::v1::ServiceAccountPrivateKeyType_descriptor();
}
template <> struct is_proto_enum< ::google::iam::admin::v1::ServiceAccountPublicKeyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::iam::admin::v1::ServiceAccountPublicKeyType>() {
  return ::google::iam::admin::v1::ServiceAccountPublicKeyType_descriptor();
}
template <> struct is_proto_enum< ::google::iam::admin::v1::ServiceAccountKeyOrigin> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::iam::admin::v1::ServiceAccountKeyOrigin>() {
  return ::google::iam::admin::v1::ServiceAccountKeyOrigin_descriptor();
}
template <> struct is_proto_enum< ::google::iam::admin::v1::RoleView> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::iam::admin::v1::RoleView>() {
  return ::google::iam::admin::v1::RoleView_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_google_2fiam_2fadmin_2fv1_2fiam_2eproto
