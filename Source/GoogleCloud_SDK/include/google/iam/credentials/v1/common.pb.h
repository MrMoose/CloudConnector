// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/iam/credentials/v1/common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_google_2fiam_2fcredentials_2fv1_2fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_google_2fiam_2fcredentials_2fv1_2fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "google/api/field_behavior.pb.h"
#include "google/api/resource.pb.h"
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_google_2fiam_2fcredentials_2fv1_2fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_google_2fiam_2fcredentials_2fv1_2fcommon_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_google_2fiam_2fcredentials_2fv1_2fcommon_2eproto;
namespace google {
namespace iam {
namespace credentials {
namespace v1 {
class GenerateAccessTokenRequest;
struct GenerateAccessTokenRequestDefaultTypeInternal;
extern GenerateAccessTokenRequestDefaultTypeInternal _GenerateAccessTokenRequest_default_instance_;
class GenerateAccessTokenResponse;
struct GenerateAccessTokenResponseDefaultTypeInternal;
extern GenerateAccessTokenResponseDefaultTypeInternal _GenerateAccessTokenResponse_default_instance_;
class GenerateIdTokenRequest;
struct GenerateIdTokenRequestDefaultTypeInternal;
extern GenerateIdTokenRequestDefaultTypeInternal _GenerateIdTokenRequest_default_instance_;
class GenerateIdTokenResponse;
struct GenerateIdTokenResponseDefaultTypeInternal;
extern GenerateIdTokenResponseDefaultTypeInternal _GenerateIdTokenResponse_default_instance_;
class SignBlobRequest;
struct SignBlobRequestDefaultTypeInternal;
extern SignBlobRequestDefaultTypeInternal _SignBlobRequest_default_instance_;
class SignBlobResponse;
struct SignBlobResponseDefaultTypeInternal;
extern SignBlobResponseDefaultTypeInternal _SignBlobResponse_default_instance_;
class SignJwtRequest;
struct SignJwtRequestDefaultTypeInternal;
extern SignJwtRequestDefaultTypeInternal _SignJwtRequest_default_instance_;
class SignJwtResponse;
struct SignJwtResponseDefaultTypeInternal;
extern SignJwtResponseDefaultTypeInternal _SignJwtResponse_default_instance_;
}  // namespace v1
}  // namespace credentials
}  // namespace iam
}  // namespace google
PROTOBUF_NAMESPACE_OPEN
template<> ::google::iam::credentials::v1::GenerateAccessTokenRequest* Arena::CreateMaybeMessage<::google::iam::credentials::v1::GenerateAccessTokenRequest>(Arena*);
template<> ::google::iam::credentials::v1::GenerateAccessTokenResponse* Arena::CreateMaybeMessage<::google::iam::credentials::v1::GenerateAccessTokenResponse>(Arena*);
template<> ::google::iam::credentials::v1::GenerateIdTokenRequest* Arena::CreateMaybeMessage<::google::iam::credentials::v1::GenerateIdTokenRequest>(Arena*);
template<> ::google::iam::credentials::v1::GenerateIdTokenResponse* Arena::CreateMaybeMessage<::google::iam::credentials::v1::GenerateIdTokenResponse>(Arena*);
template<> ::google::iam::credentials::v1::SignBlobRequest* Arena::CreateMaybeMessage<::google::iam::credentials::v1::SignBlobRequest>(Arena*);
template<> ::google::iam::credentials::v1::SignBlobResponse* Arena::CreateMaybeMessage<::google::iam::credentials::v1::SignBlobResponse>(Arena*);
template<> ::google::iam::credentials::v1::SignJwtRequest* Arena::CreateMaybeMessage<::google::iam::credentials::v1::SignJwtRequest>(Arena*);
template<> ::google::iam::credentials::v1::SignJwtResponse* Arena::CreateMaybeMessage<::google::iam::credentials::v1::SignJwtResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace google {
namespace iam {
namespace credentials {
namespace v1 {

// ===================================================================

class GenerateAccessTokenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.credentials.v1.GenerateAccessTokenRequest) */ {
 public:
  inline GenerateAccessTokenRequest() : GenerateAccessTokenRequest(nullptr) {}
  ~GenerateAccessTokenRequest() override;
  explicit PROTOBUF_CONSTEXPR GenerateAccessTokenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateAccessTokenRequest(const GenerateAccessTokenRequest& from);
  GenerateAccessTokenRequest(GenerateAccessTokenRequest&& from) noexcept
    : GenerateAccessTokenRequest() {
    *this = ::std::move(from);
  }

  inline GenerateAccessTokenRequest& operator=(const GenerateAccessTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateAccessTokenRequest& operator=(GenerateAccessTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateAccessTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateAccessTokenRequest* internal_default_instance() {
    return reinterpret_cast<const GenerateAccessTokenRequest*>(
               &_GenerateAccessTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GenerateAccessTokenRequest& a, GenerateAccessTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateAccessTokenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateAccessTokenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateAccessTokenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenerateAccessTokenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateAccessTokenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenerateAccessTokenRequest& from) {
    GenerateAccessTokenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateAccessTokenRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.credentials.v1.GenerateAccessTokenRequest";
  }
  protected:
  explicit GenerateAccessTokenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelegatesFieldNumber = 2,
    kScopeFieldNumber = 4,
    kNameFieldNumber = 1,
    kLifetimeFieldNumber = 7,
  };
  // repeated string delegates = 2;
  int delegates_size() const;
  private:
  int _internal_delegates_size() const;
  public:
  void clear_delegates();
  const std::string& delegates(int index) const;
  std::string* mutable_delegates(int index);
  void set_delegates(int index, const std::string& value);
  void set_delegates(int index, std::string&& value);
  void set_delegates(int index, const char* value);
  void set_delegates(int index, const char* value, size_t size);
  std::string* add_delegates();
  void add_delegates(const std::string& value);
  void add_delegates(std::string&& value);
  void add_delegates(const char* value);
  void add_delegates(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& delegates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_delegates();
  private:
  const std::string& _internal_delegates(int index) const;
  std::string* _internal_add_delegates();
  public:

  // repeated string scope = 4 [(.google.api.field_behavior) = REQUIRED];
  int scope_size() const;
  private:
  int _internal_scope_size() const;
  public:
  void clear_scope();
  const std::string& scope(int index) const;
  std::string* mutable_scope(int index);
  void set_scope(int index, const std::string& value);
  void set_scope(int index, std::string&& value);
  void set_scope(int index, const char* value);
  void set_scope(int index, const char* value, size_t size);
  std::string* add_scope();
  void add_scope(const std::string& value);
  void add_scope(std::string&& value);
  void add_scope(const char* value);
  void add_scope(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& scope() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_scope();
  private:
  const std::string& _internal_scope(int index) const;
  std::string* _internal_add_scope();
  public:

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Duration lifetime = 7;
  bool has_lifetime() const;
  private:
  bool _internal_has_lifetime() const;
  public:
  void clear_lifetime();
  const ::PROTOBUF_NAMESPACE_ID::Duration& lifetime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_lifetime();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_lifetime();
  void set_allocated_lifetime(::PROTOBUF_NAMESPACE_ID::Duration* lifetime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_lifetime() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_lifetime();
  public:
  void unsafe_arena_set_allocated_lifetime(
      ::PROTOBUF_NAMESPACE_ID::Duration* lifetime);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_lifetime();

  // @@protoc_insertion_point(class_scope:google.iam.credentials.v1.GenerateAccessTokenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> delegates_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> scope_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Duration* lifetime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fcredentials_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class GenerateAccessTokenResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.credentials.v1.GenerateAccessTokenResponse) */ {
 public:
  inline GenerateAccessTokenResponse() : GenerateAccessTokenResponse(nullptr) {}
  ~GenerateAccessTokenResponse() override;
  explicit PROTOBUF_CONSTEXPR GenerateAccessTokenResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateAccessTokenResponse(const GenerateAccessTokenResponse& from);
  GenerateAccessTokenResponse(GenerateAccessTokenResponse&& from) noexcept
    : GenerateAccessTokenResponse() {
    *this = ::std::move(from);
  }

  inline GenerateAccessTokenResponse& operator=(const GenerateAccessTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateAccessTokenResponse& operator=(GenerateAccessTokenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateAccessTokenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateAccessTokenResponse* internal_default_instance() {
    return reinterpret_cast<const GenerateAccessTokenResponse*>(
               &_GenerateAccessTokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GenerateAccessTokenResponse& a, GenerateAccessTokenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateAccessTokenResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateAccessTokenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateAccessTokenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenerateAccessTokenResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateAccessTokenResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenerateAccessTokenResponse& from) {
    GenerateAccessTokenResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateAccessTokenResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.credentials.v1.GenerateAccessTokenResponse";
  }
  protected:
  explicit GenerateAccessTokenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessTokenFieldNumber = 1,
    kExpireTimeFieldNumber = 3,
  };
  // string access_token = 1;
  void clear_access_token();
  const std::string& access_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_token();
  PROTOBUF_NODISCARD std::string* release_access_token();
  void set_allocated_access_token(std::string* access_token);
  private:
  const std::string& _internal_access_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_token(const std::string& value);
  std::string* _internal_mutable_access_token();
  public:

  // .google.protobuf.Timestamp expire_time = 3;
  bool has_expire_time() const;
  private:
  bool _internal_has_expire_time() const;
  public:
  void clear_expire_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& expire_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_expire_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_expire_time();
  void set_allocated_expire_time(::PROTOBUF_NAMESPACE_ID::Timestamp* expire_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_expire_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_expire_time();
  public:
  void unsafe_arena_set_allocated_expire_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* expire_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_expire_time();

  // @@protoc_insertion_point(class_scope:google.iam.credentials.v1.GenerateAccessTokenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_token_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expire_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fcredentials_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SignBlobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.credentials.v1.SignBlobRequest) */ {
 public:
  inline SignBlobRequest() : SignBlobRequest(nullptr) {}
  ~SignBlobRequest() override;
  explicit PROTOBUF_CONSTEXPR SignBlobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignBlobRequest(const SignBlobRequest& from);
  SignBlobRequest(SignBlobRequest&& from) noexcept
    : SignBlobRequest() {
    *this = ::std::move(from);
  }

  inline SignBlobRequest& operator=(const SignBlobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignBlobRequest& operator=(SignBlobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignBlobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignBlobRequest* internal_default_instance() {
    return reinterpret_cast<const SignBlobRequest*>(
               &_SignBlobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SignBlobRequest& a, SignBlobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignBlobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignBlobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignBlobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignBlobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignBlobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignBlobRequest& from) {
    SignBlobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignBlobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.credentials.v1.SignBlobRequest";
  }
  protected:
  explicit SignBlobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelegatesFieldNumber = 3,
    kNameFieldNumber = 1,
    kPayloadFieldNumber = 5,
  };
  // repeated string delegates = 3;
  int delegates_size() const;
  private:
  int _internal_delegates_size() const;
  public:
  void clear_delegates();
  const std::string& delegates(int index) const;
  std::string* mutable_delegates(int index);
  void set_delegates(int index, const std::string& value);
  void set_delegates(int index, std::string&& value);
  void set_delegates(int index, const char* value);
  void set_delegates(int index, const char* value, size_t size);
  std::string* add_delegates();
  void add_delegates(const std::string& value);
  void add_delegates(std::string&& value);
  void add_delegates(const char* value);
  void add_delegates(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& delegates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_delegates();
  private:
  const std::string& _internal_delegates(int index) const;
  std::string* _internal_add_delegates();
  public:

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes payload = 5 [(.google.api.field_behavior) = REQUIRED];
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.credentials.v1.SignBlobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> delegates_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fcredentials_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SignBlobResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.credentials.v1.SignBlobResponse) */ {
 public:
  inline SignBlobResponse() : SignBlobResponse(nullptr) {}
  ~SignBlobResponse() override;
  explicit PROTOBUF_CONSTEXPR SignBlobResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignBlobResponse(const SignBlobResponse& from);
  SignBlobResponse(SignBlobResponse&& from) noexcept
    : SignBlobResponse() {
    *this = ::std::move(from);
  }

  inline SignBlobResponse& operator=(const SignBlobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignBlobResponse& operator=(SignBlobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignBlobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignBlobResponse* internal_default_instance() {
    return reinterpret_cast<const SignBlobResponse*>(
               &_SignBlobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SignBlobResponse& a, SignBlobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignBlobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignBlobResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignBlobResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignBlobResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignBlobResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignBlobResponse& from) {
    SignBlobResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignBlobResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.credentials.v1.SignBlobResponse";
  }
  protected:
  explicit SignBlobResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyIdFieldNumber = 1,
    kSignedBlobFieldNumber = 4,
  };
  // string key_id = 1;
  void clear_key_id();
  const std::string& key_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_id();
  PROTOBUF_NODISCARD std::string* release_key_id();
  void set_allocated_key_id(std::string* key_id);
  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(const std::string& value);
  std::string* _internal_mutable_key_id();
  public:

  // bytes signed_blob = 4;
  void clear_signed_blob();
  const std::string& signed_blob() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signed_blob(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signed_blob();
  PROTOBUF_NODISCARD std::string* release_signed_blob();
  void set_allocated_signed_blob(std::string* signed_blob);
  private:
  const std::string& _internal_signed_blob() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signed_blob(const std::string& value);
  std::string* _internal_mutable_signed_blob();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.credentials.v1.SignBlobResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signed_blob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fcredentials_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SignJwtRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.credentials.v1.SignJwtRequest) */ {
 public:
  inline SignJwtRequest() : SignJwtRequest(nullptr) {}
  ~SignJwtRequest() override;
  explicit PROTOBUF_CONSTEXPR SignJwtRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignJwtRequest(const SignJwtRequest& from);
  SignJwtRequest(SignJwtRequest&& from) noexcept
    : SignJwtRequest() {
    *this = ::std::move(from);
  }

  inline SignJwtRequest& operator=(const SignJwtRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignJwtRequest& operator=(SignJwtRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignJwtRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignJwtRequest* internal_default_instance() {
    return reinterpret_cast<const SignJwtRequest*>(
               &_SignJwtRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SignJwtRequest& a, SignJwtRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignJwtRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignJwtRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignJwtRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignJwtRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignJwtRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignJwtRequest& from) {
    SignJwtRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignJwtRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.credentials.v1.SignJwtRequest";
  }
  protected:
  explicit SignJwtRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelegatesFieldNumber = 3,
    kNameFieldNumber = 1,
    kPayloadFieldNumber = 5,
  };
  // repeated string delegates = 3;
  int delegates_size() const;
  private:
  int _internal_delegates_size() const;
  public:
  void clear_delegates();
  const std::string& delegates(int index) const;
  std::string* mutable_delegates(int index);
  void set_delegates(int index, const std::string& value);
  void set_delegates(int index, std::string&& value);
  void set_delegates(int index, const char* value);
  void set_delegates(int index, const char* value, size_t size);
  std::string* add_delegates();
  void add_delegates(const std::string& value);
  void add_delegates(std::string&& value);
  void add_delegates(const char* value);
  void add_delegates(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& delegates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_delegates();
  private:
  const std::string& _internal_delegates(int index) const;
  std::string* _internal_add_delegates();
  public:

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string payload = 5 [(.google.api.field_behavior) = REQUIRED];
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.credentials.v1.SignJwtRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> delegates_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fcredentials_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SignJwtResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.credentials.v1.SignJwtResponse) */ {
 public:
  inline SignJwtResponse() : SignJwtResponse(nullptr) {}
  ~SignJwtResponse() override;
  explicit PROTOBUF_CONSTEXPR SignJwtResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignJwtResponse(const SignJwtResponse& from);
  SignJwtResponse(SignJwtResponse&& from) noexcept
    : SignJwtResponse() {
    *this = ::std::move(from);
  }

  inline SignJwtResponse& operator=(const SignJwtResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignJwtResponse& operator=(SignJwtResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignJwtResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignJwtResponse* internal_default_instance() {
    return reinterpret_cast<const SignJwtResponse*>(
               &_SignJwtResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SignJwtResponse& a, SignJwtResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignJwtResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignJwtResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignJwtResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignJwtResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignJwtResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignJwtResponse& from) {
    SignJwtResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignJwtResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.credentials.v1.SignJwtResponse";
  }
  protected:
  explicit SignJwtResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyIdFieldNumber = 1,
    kSignedJwtFieldNumber = 2,
  };
  // string key_id = 1;
  void clear_key_id();
  const std::string& key_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_id();
  PROTOBUF_NODISCARD std::string* release_key_id();
  void set_allocated_key_id(std::string* key_id);
  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(const std::string& value);
  std::string* _internal_mutable_key_id();
  public:

  // string signed_jwt = 2;
  void clear_signed_jwt();
  const std::string& signed_jwt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signed_jwt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signed_jwt();
  PROTOBUF_NODISCARD std::string* release_signed_jwt();
  void set_allocated_signed_jwt(std::string* signed_jwt);
  private:
  const std::string& _internal_signed_jwt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signed_jwt(const std::string& value);
  std::string* _internal_mutable_signed_jwt();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.credentials.v1.SignJwtResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signed_jwt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fcredentials_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class GenerateIdTokenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.credentials.v1.GenerateIdTokenRequest) */ {
 public:
  inline GenerateIdTokenRequest() : GenerateIdTokenRequest(nullptr) {}
  ~GenerateIdTokenRequest() override;
  explicit PROTOBUF_CONSTEXPR GenerateIdTokenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateIdTokenRequest(const GenerateIdTokenRequest& from);
  GenerateIdTokenRequest(GenerateIdTokenRequest&& from) noexcept
    : GenerateIdTokenRequest() {
    *this = ::std::move(from);
  }

  inline GenerateIdTokenRequest& operator=(const GenerateIdTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateIdTokenRequest& operator=(GenerateIdTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateIdTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateIdTokenRequest* internal_default_instance() {
    return reinterpret_cast<const GenerateIdTokenRequest*>(
               &_GenerateIdTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GenerateIdTokenRequest& a, GenerateIdTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateIdTokenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateIdTokenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateIdTokenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenerateIdTokenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateIdTokenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenerateIdTokenRequest& from) {
    GenerateIdTokenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateIdTokenRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.credentials.v1.GenerateIdTokenRequest";
  }
  protected:
  explicit GenerateIdTokenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelegatesFieldNumber = 2,
    kNameFieldNumber = 1,
    kAudienceFieldNumber = 3,
    kIncludeEmailFieldNumber = 4,
  };
  // repeated string delegates = 2;
  int delegates_size() const;
  private:
  int _internal_delegates_size() const;
  public:
  void clear_delegates();
  const std::string& delegates(int index) const;
  std::string* mutable_delegates(int index);
  void set_delegates(int index, const std::string& value);
  void set_delegates(int index, std::string&& value);
  void set_delegates(int index, const char* value);
  void set_delegates(int index, const char* value, size_t size);
  std::string* add_delegates();
  void add_delegates(const std::string& value);
  void add_delegates(std::string&& value);
  void add_delegates(const char* value);
  void add_delegates(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& delegates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_delegates();
  private:
  const std::string& _internal_delegates(int index) const;
  std::string* _internal_add_delegates();
  public:

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string audience = 3 [(.google.api.field_behavior) = REQUIRED];
  void clear_audience();
  const std::string& audience() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audience(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audience();
  PROTOBUF_NODISCARD std::string* release_audience();
  void set_allocated_audience(std::string* audience);
  private:
  const std::string& _internal_audience() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audience(const std::string& value);
  std::string* _internal_mutable_audience();
  public:

  // bool include_email = 4;
  void clear_include_email();
  bool include_email() const;
  void set_include_email(bool value);
  private:
  bool _internal_include_email() const;
  void _internal_set_include_email(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.iam.credentials.v1.GenerateIdTokenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> delegates_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audience_;
    bool include_email_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fcredentials_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class GenerateIdTokenResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.iam.credentials.v1.GenerateIdTokenResponse) */ {
 public:
  inline GenerateIdTokenResponse() : GenerateIdTokenResponse(nullptr) {}
  ~GenerateIdTokenResponse() override;
  explicit PROTOBUF_CONSTEXPR GenerateIdTokenResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateIdTokenResponse(const GenerateIdTokenResponse& from);
  GenerateIdTokenResponse(GenerateIdTokenResponse&& from) noexcept
    : GenerateIdTokenResponse() {
    *this = ::std::move(from);
  }

  inline GenerateIdTokenResponse& operator=(const GenerateIdTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateIdTokenResponse& operator=(GenerateIdTokenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateIdTokenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateIdTokenResponse* internal_default_instance() {
    return reinterpret_cast<const GenerateIdTokenResponse*>(
               &_GenerateIdTokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GenerateIdTokenResponse& a, GenerateIdTokenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateIdTokenResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateIdTokenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateIdTokenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenerateIdTokenResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateIdTokenResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenerateIdTokenResponse& from) {
    GenerateIdTokenResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateIdTokenResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.iam.credentials.v1.GenerateIdTokenResponse";
  }
  protected:
  explicit GenerateIdTokenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:google.iam.credentials.v1.GenerateIdTokenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fiam_2fcredentials_2fv1_2fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GenerateAccessTokenRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GenerateAccessTokenRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GenerateAccessTokenRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.GenerateAccessTokenRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateAccessTokenRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.GenerateAccessTokenRequest.name)
}
inline std::string* GenerateAccessTokenRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.GenerateAccessTokenRequest.name)
  return _s;
}
inline const std::string& GenerateAccessTokenRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GenerateAccessTokenRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GenerateAccessTokenRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GenerateAccessTokenRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.credentials.v1.GenerateAccessTokenRequest.name)
  return _impl_.name_.Release();
}
inline void GenerateAccessTokenRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.credentials.v1.GenerateAccessTokenRequest.name)
}

// repeated string delegates = 2;
inline int GenerateAccessTokenRequest::_internal_delegates_size() const {
  return _impl_.delegates_.size();
}
inline int GenerateAccessTokenRequest::delegates_size() const {
  return _internal_delegates_size();
}
inline void GenerateAccessTokenRequest::clear_delegates() {
  _impl_.delegates_.Clear();
}
inline std::string* GenerateAccessTokenRequest::add_delegates() {
  std::string* _s = _internal_add_delegates();
  // @@protoc_insertion_point(field_add_mutable:google.iam.credentials.v1.GenerateAccessTokenRequest.delegates)
  return _s;
}
inline const std::string& GenerateAccessTokenRequest::_internal_delegates(int index) const {
  return _impl_.delegates_.Get(index);
}
inline const std::string& GenerateAccessTokenRequest::delegates(int index) const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.GenerateAccessTokenRequest.delegates)
  return _internal_delegates(index);
}
inline std::string* GenerateAccessTokenRequest::mutable_delegates(int index) {
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.GenerateAccessTokenRequest.delegates)
  return _impl_.delegates_.Mutable(index);
}
inline void GenerateAccessTokenRequest::set_delegates(int index, const std::string& value) {
  _impl_.delegates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.GenerateAccessTokenRequest.delegates)
}
inline void GenerateAccessTokenRequest::set_delegates(int index, std::string&& value) {
  _impl_.delegates_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.GenerateAccessTokenRequest.delegates)
}
inline void GenerateAccessTokenRequest::set_delegates(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.delegates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.iam.credentials.v1.GenerateAccessTokenRequest.delegates)
}
inline void GenerateAccessTokenRequest::set_delegates(int index, const char* value, size_t size) {
  _impl_.delegates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.iam.credentials.v1.GenerateAccessTokenRequest.delegates)
}
inline std::string* GenerateAccessTokenRequest::_internal_add_delegates() {
  return _impl_.delegates_.Add();
}
inline void GenerateAccessTokenRequest::add_delegates(const std::string& value) {
  _impl_.delegates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.iam.credentials.v1.GenerateAccessTokenRequest.delegates)
}
inline void GenerateAccessTokenRequest::add_delegates(std::string&& value) {
  _impl_.delegates_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.iam.credentials.v1.GenerateAccessTokenRequest.delegates)
}
inline void GenerateAccessTokenRequest::add_delegates(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.delegates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.iam.credentials.v1.GenerateAccessTokenRequest.delegates)
}
inline void GenerateAccessTokenRequest::add_delegates(const char* value, size_t size) {
  _impl_.delegates_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.iam.credentials.v1.GenerateAccessTokenRequest.delegates)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GenerateAccessTokenRequest::delegates() const {
  // @@protoc_insertion_point(field_list:google.iam.credentials.v1.GenerateAccessTokenRequest.delegates)
  return _impl_.delegates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GenerateAccessTokenRequest::mutable_delegates() {
  // @@protoc_insertion_point(field_mutable_list:google.iam.credentials.v1.GenerateAccessTokenRequest.delegates)
  return &_impl_.delegates_;
}

// repeated string scope = 4 [(.google.api.field_behavior) = REQUIRED];
inline int GenerateAccessTokenRequest::_internal_scope_size() const {
  return _impl_.scope_.size();
}
inline int GenerateAccessTokenRequest::scope_size() const {
  return _internal_scope_size();
}
inline void GenerateAccessTokenRequest::clear_scope() {
  _impl_.scope_.Clear();
}
inline std::string* GenerateAccessTokenRequest::add_scope() {
  std::string* _s = _internal_add_scope();
  // @@protoc_insertion_point(field_add_mutable:google.iam.credentials.v1.GenerateAccessTokenRequest.scope)
  return _s;
}
inline const std::string& GenerateAccessTokenRequest::_internal_scope(int index) const {
  return _impl_.scope_.Get(index);
}
inline const std::string& GenerateAccessTokenRequest::scope(int index) const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.GenerateAccessTokenRequest.scope)
  return _internal_scope(index);
}
inline std::string* GenerateAccessTokenRequest::mutable_scope(int index) {
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.GenerateAccessTokenRequest.scope)
  return _impl_.scope_.Mutable(index);
}
inline void GenerateAccessTokenRequest::set_scope(int index, const std::string& value) {
  _impl_.scope_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.GenerateAccessTokenRequest.scope)
}
inline void GenerateAccessTokenRequest::set_scope(int index, std::string&& value) {
  _impl_.scope_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.GenerateAccessTokenRequest.scope)
}
inline void GenerateAccessTokenRequest::set_scope(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.scope_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.iam.credentials.v1.GenerateAccessTokenRequest.scope)
}
inline void GenerateAccessTokenRequest::set_scope(int index, const char* value, size_t size) {
  _impl_.scope_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.iam.credentials.v1.GenerateAccessTokenRequest.scope)
}
inline std::string* GenerateAccessTokenRequest::_internal_add_scope() {
  return _impl_.scope_.Add();
}
inline void GenerateAccessTokenRequest::add_scope(const std::string& value) {
  _impl_.scope_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.iam.credentials.v1.GenerateAccessTokenRequest.scope)
}
inline void GenerateAccessTokenRequest::add_scope(std::string&& value) {
  _impl_.scope_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.iam.credentials.v1.GenerateAccessTokenRequest.scope)
}
inline void GenerateAccessTokenRequest::add_scope(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.scope_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.iam.credentials.v1.GenerateAccessTokenRequest.scope)
}
inline void GenerateAccessTokenRequest::add_scope(const char* value, size_t size) {
  _impl_.scope_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.iam.credentials.v1.GenerateAccessTokenRequest.scope)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GenerateAccessTokenRequest::scope() const {
  // @@protoc_insertion_point(field_list:google.iam.credentials.v1.GenerateAccessTokenRequest.scope)
  return _impl_.scope_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GenerateAccessTokenRequest::mutable_scope() {
  // @@protoc_insertion_point(field_mutable_list:google.iam.credentials.v1.GenerateAccessTokenRequest.scope)
  return &_impl_.scope_;
}

// .google.protobuf.Duration lifetime = 7;
inline bool GenerateAccessTokenRequest::_internal_has_lifetime() const {
  return this != internal_default_instance() && _impl_.lifetime_ != nullptr;
}
inline bool GenerateAccessTokenRequest::has_lifetime() const {
  return _internal_has_lifetime();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& GenerateAccessTokenRequest::_internal_lifetime() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.lifetime_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& GenerateAccessTokenRequest::lifetime() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.GenerateAccessTokenRequest.lifetime)
  return _internal_lifetime();
}
inline void GenerateAccessTokenRequest::unsafe_arena_set_allocated_lifetime(
    ::PROTOBUF_NAMESPACE_ID::Duration* lifetime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lifetime_);
  }
  _impl_.lifetime_ = lifetime;
  if (lifetime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.iam.credentials.v1.GenerateAccessTokenRequest.lifetime)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* GenerateAccessTokenRequest::release_lifetime() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.lifetime_;
  _impl_.lifetime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* GenerateAccessTokenRequest::unsafe_arena_release_lifetime() {
  // @@protoc_insertion_point(field_release:google.iam.credentials.v1.GenerateAccessTokenRequest.lifetime)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.lifetime_;
  _impl_.lifetime_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* GenerateAccessTokenRequest::_internal_mutable_lifetime() {
  
  if (_impl_.lifetime_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.lifetime_ = p;
  }
  return _impl_.lifetime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* GenerateAccessTokenRequest::mutable_lifetime() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_lifetime();
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.GenerateAccessTokenRequest.lifetime)
  return _msg;
}
inline void GenerateAccessTokenRequest::set_allocated_lifetime(::PROTOBUF_NAMESPACE_ID::Duration* lifetime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lifetime_);
  }
  if (lifetime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lifetime));
    if (message_arena != submessage_arena) {
      lifetime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lifetime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lifetime_ = lifetime;
  // @@protoc_insertion_point(field_set_allocated:google.iam.credentials.v1.GenerateAccessTokenRequest.lifetime)
}

// -------------------------------------------------------------------

// GenerateAccessTokenResponse

// string access_token = 1;
inline void GenerateAccessTokenResponse::clear_access_token() {
  _impl_.access_token_.ClearToEmpty();
}
inline const std::string& GenerateAccessTokenResponse::access_token() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.GenerateAccessTokenResponse.access_token)
  return _internal_access_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateAccessTokenResponse::set_access_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.access_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.GenerateAccessTokenResponse.access_token)
}
inline std::string* GenerateAccessTokenResponse::mutable_access_token() {
  std::string* _s = _internal_mutable_access_token();
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.GenerateAccessTokenResponse.access_token)
  return _s;
}
inline const std::string& GenerateAccessTokenResponse::_internal_access_token() const {
  return _impl_.access_token_.Get();
}
inline void GenerateAccessTokenResponse::_internal_set_access_token(const std::string& value) {
  
  _impl_.access_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GenerateAccessTokenResponse::_internal_mutable_access_token() {
  
  return _impl_.access_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GenerateAccessTokenResponse::release_access_token() {
  // @@protoc_insertion_point(field_release:google.iam.credentials.v1.GenerateAccessTokenResponse.access_token)
  return _impl_.access_token_.Release();
}
inline void GenerateAccessTokenResponse::set_allocated_access_token(std::string* access_token) {
  if (access_token != nullptr) {
    
  } else {
    
  }
  _impl_.access_token_.SetAllocated(access_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.access_token_.IsDefault()) {
    _impl_.access_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.credentials.v1.GenerateAccessTokenResponse.access_token)
}

// .google.protobuf.Timestamp expire_time = 3;
inline bool GenerateAccessTokenResponse::_internal_has_expire_time() const {
  return this != internal_default_instance() && _impl_.expire_time_ != nullptr;
}
inline bool GenerateAccessTokenResponse::has_expire_time() const {
  return _internal_has_expire_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GenerateAccessTokenResponse::_internal_expire_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.expire_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GenerateAccessTokenResponse::expire_time() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.GenerateAccessTokenResponse.expire_time)
  return _internal_expire_time();
}
inline void GenerateAccessTokenResponse::unsafe_arena_set_allocated_expire_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expire_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expire_time_);
  }
  _impl_.expire_time_ = expire_time;
  if (expire_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.iam.credentials.v1.GenerateAccessTokenResponse.expire_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GenerateAccessTokenResponse::release_expire_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expire_time_;
  _impl_.expire_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GenerateAccessTokenResponse::unsafe_arena_release_expire_time() {
  // @@protoc_insertion_point(field_release:google.iam.credentials.v1.GenerateAccessTokenResponse.expire_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expire_time_;
  _impl_.expire_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GenerateAccessTokenResponse::_internal_mutable_expire_time() {
  
  if (_impl_.expire_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.expire_time_ = p;
  }
  return _impl_.expire_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GenerateAccessTokenResponse::mutable_expire_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_expire_time();
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.GenerateAccessTokenResponse.expire_time)
  return _msg;
}
inline void GenerateAccessTokenResponse::set_allocated_expire_time(::PROTOBUF_NAMESPACE_ID::Timestamp* expire_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expire_time_);
  }
  if (expire_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expire_time));
    if (message_arena != submessage_arena) {
      expire_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expire_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expire_time_ = expire_time;
  // @@protoc_insertion_point(field_set_allocated:google.iam.credentials.v1.GenerateAccessTokenResponse.expire_time)
}

// -------------------------------------------------------------------

// SignBlobRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void SignBlobRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SignBlobRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.SignBlobRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignBlobRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.SignBlobRequest.name)
}
inline std::string* SignBlobRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.SignBlobRequest.name)
  return _s;
}
inline const std::string& SignBlobRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SignBlobRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SignBlobRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SignBlobRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.credentials.v1.SignBlobRequest.name)
  return _impl_.name_.Release();
}
inline void SignBlobRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.credentials.v1.SignBlobRequest.name)
}

// repeated string delegates = 3;
inline int SignBlobRequest::_internal_delegates_size() const {
  return _impl_.delegates_.size();
}
inline int SignBlobRequest::delegates_size() const {
  return _internal_delegates_size();
}
inline void SignBlobRequest::clear_delegates() {
  _impl_.delegates_.Clear();
}
inline std::string* SignBlobRequest::add_delegates() {
  std::string* _s = _internal_add_delegates();
  // @@protoc_insertion_point(field_add_mutable:google.iam.credentials.v1.SignBlobRequest.delegates)
  return _s;
}
inline const std::string& SignBlobRequest::_internal_delegates(int index) const {
  return _impl_.delegates_.Get(index);
}
inline const std::string& SignBlobRequest::delegates(int index) const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.SignBlobRequest.delegates)
  return _internal_delegates(index);
}
inline std::string* SignBlobRequest::mutable_delegates(int index) {
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.SignBlobRequest.delegates)
  return _impl_.delegates_.Mutable(index);
}
inline void SignBlobRequest::set_delegates(int index, const std::string& value) {
  _impl_.delegates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.SignBlobRequest.delegates)
}
inline void SignBlobRequest::set_delegates(int index, std::string&& value) {
  _impl_.delegates_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.SignBlobRequest.delegates)
}
inline void SignBlobRequest::set_delegates(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.delegates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.iam.credentials.v1.SignBlobRequest.delegates)
}
inline void SignBlobRequest::set_delegates(int index, const char* value, size_t size) {
  _impl_.delegates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.iam.credentials.v1.SignBlobRequest.delegates)
}
inline std::string* SignBlobRequest::_internal_add_delegates() {
  return _impl_.delegates_.Add();
}
inline void SignBlobRequest::add_delegates(const std::string& value) {
  _impl_.delegates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.iam.credentials.v1.SignBlobRequest.delegates)
}
inline void SignBlobRequest::add_delegates(std::string&& value) {
  _impl_.delegates_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.iam.credentials.v1.SignBlobRequest.delegates)
}
inline void SignBlobRequest::add_delegates(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.delegates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.iam.credentials.v1.SignBlobRequest.delegates)
}
inline void SignBlobRequest::add_delegates(const char* value, size_t size) {
  _impl_.delegates_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.iam.credentials.v1.SignBlobRequest.delegates)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SignBlobRequest::delegates() const {
  // @@protoc_insertion_point(field_list:google.iam.credentials.v1.SignBlobRequest.delegates)
  return _impl_.delegates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SignBlobRequest::mutable_delegates() {
  // @@protoc_insertion_point(field_mutable_list:google.iam.credentials.v1.SignBlobRequest.delegates)
  return &_impl_.delegates_;
}

// bytes payload = 5 [(.google.api.field_behavior) = REQUIRED];
inline void SignBlobRequest::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& SignBlobRequest::payload() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.SignBlobRequest.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignBlobRequest::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.SignBlobRequest.payload)
}
inline std::string* SignBlobRequest::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.SignBlobRequest.payload)
  return _s;
}
inline const std::string& SignBlobRequest::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void SignBlobRequest::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* SignBlobRequest::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* SignBlobRequest::release_payload() {
  // @@protoc_insertion_point(field_release:google.iam.credentials.v1.SignBlobRequest.payload)
  return _impl_.payload_.Release();
}
inline void SignBlobRequest::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.credentials.v1.SignBlobRequest.payload)
}

// -------------------------------------------------------------------

// SignBlobResponse

// string key_id = 1;
inline void SignBlobResponse::clear_key_id() {
  _impl_.key_id_.ClearToEmpty();
}
inline const std::string& SignBlobResponse::key_id() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.SignBlobResponse.key_id)
  return _internal_key_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignBlobResponse::set_key_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.SignBlobResponse.key_id)
}
inline std::string* SignBlobResponse::mutable_key_id() {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.SignBlobResponse.key_id)
  return _s;
}
inline const std::string& SignBlobResponse::_internal_key_id() const {
  return _impl_.key_id_.Get();
}
inline void SignBlobResponse::_internal_set_key_id(const std::string& value) {
  
  _impl_.key_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SignBlobResponse::_internal_mutable_key_id() {
  
  return _impl_.key_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SignBlobResponse::release_key_id() {
  // @@protoc_insertion_point(field_release:google.iam.credentials.v1.SignBlobResponse.key_id)
  return _impl_.key_id_.Release();
}
inline void SignBlobResponse::set_allocated_key_id(std::string* key_id) {
  if (key_id != nullptr) {
    
  } else {
    
  }
  _impl_.key_id_.SetAllocated(key_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_id_.IsDefault()) {
    _impl_.key_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.credentials.v1.SignBlobResponse.key_id)
}

// bytes signed_blob = 4;
inline void SignBlobResponse::clear_signed_blob() {
  _impl_.signed_blob_.ClearToEmpty();
}
inline const std::string& SignBlobResponse::signed_blob() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.SignBlobResponse.signed_blob)
  return _internal_signed_blob();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignBlobResponse::set_signed_blob(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signed_blob_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.SignBlobResponse.signed_blob)
}
inline std::string* SignBlobResponse::mutable_signed_blob() {
  std::string* _s = _internal_mutable_signed_blob();
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.SignBlobResponse.signed_blob)
  return _s;
}
inline const std::string& SignBlobResponse::_internal_signed_blob() const {
  return _impl_.signed_blob_.Get();
}
inline void SignBlobResponse::_internal_set_signed_blob(const std::string& value) {
  
  _impl_.signed_blob_.Set(value, GetArenaForAllocation());
}
inline std::string* SignBlobResponse::_internal_mutable_signed_blob() {
  
  return _impl_.signed_blob_.Mutable(GetArenaForAllocation());
}
inline std::string* SignBlobResponse::release_signed_blob() {
  // @@protoc_insertion_point(field_release:google.iam.credentials.v1.SignBlobResponse.signed_blob)
  return _impl_.signed_blob_.Release();
}
inline void SignBlobResponse::set_allocated_signed_blob(std::string* signed_blob) {
  if (signed_blob != nullptr) {
    
  } else {
    
  }
  _impl_.signed_blob_.SetAllocated(signed_blob, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signed_blob_.IsDefault()) {
    _impl_.signed_blob_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.credentials.v1.SignBlobResponse.signed_blob)
}

// -------------------------------------------------------------------

// SignJwtRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void SignJwtRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SignJwtRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.SignJwtRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignJwtRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.SignJwtRequest.name)
}
inline std::string* SignJwtRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.SignJwtRequest.name)
  return _s;
}
inline const std::string& SignJwtRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SignJwtRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SignJwtRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SignJwtRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.credentials.v1.SignJwtRequest.name)
  return _impl_.name_.Release();
}
inline void SignJwtRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.credentials.v1.SignJwtRequest.name)
}

// repeated string delegates = 3;
inline int SignJwtRequest::_internal_delegates_size() const {
  return _impl_.delegates_.size();
}
inline int SignJwtRequest::delegates_size() const {
  return _internal_delegates_size();
}
inline void SignJwtRequest::clear_delegates() {
  _impl_.delegates_.Clear();
}
inline std::string* SignJwtRequest::add_delegates() {
  std::string* _s = _internal_add_delegates();
  // @@protoc_insertion_point(field_add_mutable:google.iam.credentials.v1.SignJwtRequest.delegates)
  return _s;
}
inline const std::string& SignJwtRequest::_internal_delegates(int index) const {
  return _impl_.delegates_.Get(index);
}
inline const std::string& SignJwtRequest::delegates(int index) const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.SignJwtRequest.delegates)
  return _internal_delegates(index);
}
inline std::string* SignJwtRequest::mutable_delegates(int index) {
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.SignJwtRequest.delegates)
  return _impl_.delegates_.Mutable(index);
}
inline void SignJwtRequest::set_delegates(int index, const std::string& value) {
  _impl_.delegates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.SignJwtRequest.delegates)
}
inline void SignJwtRequest::set_delegates(int index, std::string&& value) {
  _impl_.delegates_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.SignJwtRequest.delegates)
}
inline void SignJwtRequest::set_delegates(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.delegates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.iam.credentials.v1.SignJwtRequest.delegates)
}
inline void SignJwtRequest::set_delegates(int index, const char* value, size_t size) {
  _impl_.delegates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.iam.credentials.v1.SignJwtRequest.delegates)
}
inline std::string* SignJwtRequest::_internal_add_delegates() {
  return _impl_.delegates_.Add();
}
inline void SignJwtRequest::add_delegates(const std::string& value) {
  _impl_.delegates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.iam.credentials.v1.SignJwtRequest.delegates)
}
inline void SignJwtRequest::add_delegates(std::string&& value) {
  _impl_.delegates_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.iam.credentials.v1.SignJwtRequest.delegates)
}
inline void SignJwtRequest::add_delegates(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.delegates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.iam.credentials.v1.SignJwtRequest.delegates)
}
inline void SignJwtRequest::add_delegates(const char* value, size_t size) {
  _impl_.delegates_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.iam.credentials.v1.SignJwtRequest.delegates)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SignJwtRequest::delegates() const {
  // @@protoc_insertion_point(field_list:google.iam.credentials.v1.SignJwtRequest.delegates)
  return _impl_.delegates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SignJwtRequest::mutable_delegates() {
  // @@protoc_insertion_point(field_mutable_list:google.iam.credentials.v1.SignJwtRequest.delegates)
  return &_impl_.delegates_;
}

// string payload = 5 [(.google.api.field_behavior) = REQUIRED];
inline void SignJwtRequest::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& SignJwtRequest::payload() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.SignJwtRequest.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignJwtRequest::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.SignJwtRequest.payload)
}
inline std::string* SignJwtRequest::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.SignJwtRequest.payload)
  return _s;
}
inline const std::string& SignJwtRequest::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void SignJwtRequest::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* SignJwtRequest::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* SignJwtRequest::release_payload() {
  // @@protoc_insertion_point(field_release:google.iam.credentials.v1.SignJwtRequest.payload)
  return _impl_.payload_.Release();
}
inline void SignJwtRequest::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.credentials.v1.SignJwtRequest.payload)
}

// -------------------------------------------------------------------

// SignJwtResponse

// string key_id = 1;
inline void SignJwtResponse::clear_key_id() {
  _impl_.key_id_.ClearToEmpty();
}
inline const std::string& SignJwtResponse::key_id() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.SignJwtResponse.key_id)
  return _internal_key_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignJwtResponse::set_key_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.SignJwtResponse.key_id)
}
inline std::string* SignJwtResponse::mutable_key_id() {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.SignJwtResponse.key_id)
  return _s;
}
inline const std::string& SignJwtResponse::_internal_key_id() const {
  return _impl_.key_id_.Get();
}
inline void SignJwtResponse::_internal_set_key_id(const std::string& value) {
  
  _impl_.key_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SignJwtResponse::_internal_mutable_key_id() {
  
  return _impl_.key_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SignJwtResponse::release_key_id() {
  // @@protoc_insertion_point(field_release:google.iam.credentials.v1.SignJwtResponse.key_id)
  return _impl_.key_id_.Release();
}
inline void SignJwtResponse::set_allocated_key_id(std::string* key_id) {
  if (key_id != nullptr) {
    
  } else {
    
  }
  _impl_.key_id_.SetAllocated(key_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_id_.IsDefault()) {
    _impl_.key_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.credentials.v1.SignJwtResponse.key_id)
}

// string signed_jwt = 2;
inline void SignJwtResponse::clear_signed_jwt() {
  _impl_.signed_jwt_.ClearToEmpty();
}
inline const std::string& SignJwtResponse::signed_jwt() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.SignJwtResponse.signed_jwt)
  return _internal_signed_jwt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignJwtResponse::set_signed_jwt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signed_jwt_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.SignJwtResponse.signed_jwt)
}
inline std::string* SignJwtResponse::mutable_signed_jwt() {
  std::string* _s = _internal_mutable_signed_jwt();
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.SignJwtResponse.signed_jwt)
  return _s;
}
inline const std::string& SignJwtResponse::_internal_signed_jwt() const {
  return _impl_.signed_jwt_.Get();
}
inline void SignJwtResponse::_internal_set_signed_jwt(const std::string& value) {
  
  _impl_.signed_jwt_.Set(value, GetArenaForAllocation());
}
inline std::string* SignJwtResponse::_internal_mutable_signed_jwt() {
  
  return _impl_.signed_jwt_.Mutable(GetArenaForAllocation());
}
inline std::string* SignJwtResponse::release_signed_jwt() {
  // @@protoc_insertion_point(field_release:google.iam.credentials.v1.SignJwtResponse.signed_jwt)
  return _impl_.signed_jwt_.Release();
}
inline void SignJwtResponse::set_allocated_signed_jwt(std::string* signed_jwt) {
  if (signed_jwt != nullptr) {
    
  } else {
    
  }
  _impl_.signed_jwt_.SetAllocated(signed_jwt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signed_jwt_.IsDefault()) {
    _impl_.signed_jwt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.credentials.v1.SignJwtResponse.signed_jwt)
}

// -------------------------------------------------------------------

// GenerateIdTokenRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GenerateIdTokenRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GenerateIdTokenRequest::name() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.GenerateIdTokenRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateIdTokenRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.GenerateIdTokenRequest.name)
}
inline std::string* GenerateIdTokenRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.GenerateIdTokenRequest.name)
  return _s;
}
inline const std::string& GenerateIdTokenRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GenerateIdTokenRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GenerateIdTokenRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GenerateIdTokenRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.iam.credentials.v1.GenerateIdTokenRequest.name)
  return _impl_.name_.Release();
}
inline void GenerateIdTokenRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.credentials.v1.GenerateIdTokenRequest.name)
}

// repeated string delegates = 2;
inline int GenerateIdTokenRequest::_internal_delegates_size() const {
  return _impl_.delegates_.size();
}
inline int GenerateIdTokenRequest::delegates_size() const {
  return _internal_delegates_size();
}
inline void GenerateIdTokenRequest::clear_delegates() {
  _impl_.delegates_.Clear();
}
inline std::string* GenerateIdTokenRequest::add_delegates() {
  std::string* _s = _internal_add_delegates();
  // @@protoc_insertion_point(field_add_mutable:google.iam.credentials.v1.GenerateIdTokenRequest.delegates)
  return _s;
}
inline const std::string& GenerateIdTokenRequest::_internal_delegates(int index) const {
  return _impl_.delegates_.Get(index);
}
inline const std::string& GenerateIdTokenRequest::delegates(int index) const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.GenerateIdTokenRequest.delegates)
  return _internal_delegates(index);
}
inline std::string* GenerateIdTokenRequest::mutable_delegates(int index) {
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.GenerateIdTokenRequest.delegates)
  return _impl_.delegates_.Mutable(index);
}
inline void GenerateIdTokenRequest::set_delegates(int index, const std::string& value) {
  _impl_.delegates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.GenerateIdTokenRequest.delegates)
}
inline void GenerateIdTokenRequest::set_delegates(int index, std::string&& value) {
  _impl_.delegates_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.GenerateIdTokenRequest.delegates)
}
inline void GenerateIdTokenRequest::set_delegates(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.delegates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.iam.credentials.v1.GenerateIdTokenRequest.delegates)
}
inline void GenerateIdTokenRequest::set_delegates(int index, const char* value, size_t size) {
  _impl_.delegates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.iam.credentials.v1.GenerateIdTokenRequest.delegates)
}
inline std::string* GenerateIdTokenRequest::_internal_add_delegates() {
  return _impl_.delegates_.Add();
}
inline void GenerateIdTokenRequest::add_delegates(const std::string& value) {
  _impl_.delegates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.iam.credentials.v1.GenerateIdTokenRequest.delegates)
}
inline void GenerateIdTokenRequest::add_delegates(std::string&& value) {
  _impl_.delegates_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.iam.credentials.v1.GenerateIdTokenRequest.delegates)
}
inline void GenerateIdTokenRequest::add_delegates(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.delegates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.iam.credentials.v1.GenerateIdTokenRequest.delegates)
}
inline void GenerateIdTokenRequest::add_delegates(const char* value, size_t size) {
  _impl_.delegates_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.iam.credentials.v1.GenerateIdTokenRequest.delegates)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GenerateIdTokenRequest::delegates() const {
  // @@protoc_insertion_point(field_list:google.iam.credentials.v1.GenerateIdTokenRequest.delegates)
  return _impl_.delegates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GenerateIdTokenRequest::mutable_delegates() {
  // @@protoc_insertion_point(field_mutable_list:google.iam.credentials.v1.GenerateIdTokenRequest.delegates)
  return &_impl_.delegates_;
}

// string audience = 3 [(.google.api.field_behavior) = REQUIRED];
inline void GenerateIdTokenRequest::clear_audience() {
  _impl_.audience_.ClearToEmpty();
}
inline const std::string& GenerateIdTokenRequest::audience() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.GenerateIdTokenRequest.audience)
  return _internal_audience();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateIdTokenRequest::set_audience(ArgT0&& arg0, ArgT... args) {
 
 _impl_.audience_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.GenerateIdTokenRequest.audience)
}
inline std::string* GenerateIdTokenRequest::mutable_audience() {
  std::string* _s = _internal_mutable_audience();
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.GenerateIdTokenRequest.audience)
  return _s;
}
inline const std::string& GenerateIdTokenRequest::_internal_audience() const {
  return _impl_.audience_.Get();
}
inline void GenerateIdTokenRequest::_internal_set_audience(const std::string& value) {
  
  _impl_.audience_.Set(value, GetArenaForAllocation());
}
inline std::string* GenerateIdTokenRequest::_internal_mutable_audience() {
  
  return _impl_.audience_.Mutable(GetArenaForAllocation());
}
inline std::string* GenerateIdTokenRequest::release_audience() {
  // @@protoc_insertion_point(field_release:google.iam.credentials.v1.GenerateIdTokenRequest.audience)
  return _impl_.audience_.Release();
}
inline void GenerateIdTokenRequest::set_allocated_audience(std::string* audience) {
  if (audience != nullptr) {
    
  } else {
    
  }
  _impl_.audience_.SetAllocated(audience, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audience_.IsDefault()) {
    _impl_.audience_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.credentials.v1.GenerateIdTokenRequest.audience)
}

// bool include_email = 4;
inline void GenerateIdTokenRequest::clear_include_email() {
  _impl_.include_email_ = false;
}
inline bool GenerateIdTokenRequest::_internal_include_email() const {
  return _impl_.include_email_;
}
inline bool GenerateIdTokenRequest::include_email() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.GenerateIdTokenRequest.include_email)
  return _internal_include_email();
}
inline void GenerateIdTokenRequest::_internal_set_include_email(bool value) {
  
  _impl_.include_email_ = value;
}
inline void GenerateIdTokenRequest::set_include_email(bool value) {
  _internal_set_include_email(value);
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.GenerateIdTokenRequest.include_email)
}

// -------------------------------------------------------------------

// GenerateIdTokenResponse

// string token = 1;
inline void GenerateIdTokenResponse::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& GenerateIdTokenResponse::token() const {
  // @@protoc_insertion_point(field_get:google.iam.credentials.v1.GenerateIdTokenResponse.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateIdTokenResponse::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.iam.credentials.v1.GenerateIdTokenResponse.token)
}
inline std::string* GenerateIdTokenResponse::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:google.iam.credentials.v1.GenerateIdTokenResponse.token)
  return _s;
}
inline const std::string& GenerateIdTokenResponse::_internal_token() const {
  return _impl_.token_.Get();
}
inline void GenerateIdTokenResponse::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* GenerateIdTokenResponse::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* GenerateIdTokenResponse::release_token() {
  // @@protoc_insertion_point(field_release:google.iam.credentials.v1.GenerateIdTokenResponse.token)
  return _impl_.token_.Release();
}
inline void GenerateIdTokenResponse::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.iam.credentials.v1.GenerateIdTokenResponse.token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace credentials
}  // namespace iam
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_google_2fiam_2fcredentials_2fv1_2fcommon_2eproto
