// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/spanner/v1/spanner.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_google_2fspanner_2fv1_2fspanner_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_google_2fspanner_2fv1_2fspanner_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/api/client.pb.h"
#include "google/api/field_behavior.pb.h"
#include "google/api/resource.pb.h"
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "google/rpc/status.pb.h"
#include "google/spanner/v1/commit_response.pb.h"
#include "google/spanner/v1/keys.pb.h"
#include "google/spanner/v1/mutation.pb.h"
#include "google/spanner/v1/result_set.pb.h"
#include "google/spanner/v1/transaction.pb.h"
#include "google/spanner/v1/type.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_google_2fspanner_2fv1_2fspanner_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_google_2fspanner_2fv1_2fspanner_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_google_2fspanner_2fv1_2fspanner_2eproto;
namespace google {
namespace spanner {
namespace v1 {
class BatchCreateSessionsRequest;
struct BatchCreateSessionsRequestDefaultTypeInternal;
extern BatchCreateSessionsRequestDefaultTypeInternal _BatchCreateSessionsRequest_default_instance_;
class BatchCreateSessionsResponse;
struct BatchCreateSessionsResponseDefaultTypeInternal;
extern BatchCreateSessionsResponseDefaultTypeInternal _BatchCreateSessionsResponse_default_instance_;
class BeginTransactionRequest;
struct BeginTransactionRequestDefaultTypeInternal;
extern BeginTransactionRequestDefaultTypeInternal _BeginTransactionRequest_default_instance_;
class CommitRequest;
struct CommitRequestDefaultTypeInternal;
extern CommitRequestDefaultTypeInternal _CommitRequest_default_instance_;
class CreateSessionRequest;
struct CreateSessionRequestDefaultTypeInternal;
extern CreateSessionRequestDefaultTypeInternal _CreateSessionRequest_default_instance_;
class DeleteSessionRequest;
struct DeleteSessionRequestDefaultTypeInternal;
extern DeleteSessionRequestDefaultTypeInternal _DeleteSessionRequest_default_instance_;
class ExecuteBatchDmlRequest;
struct ExecuteBatchDmlRequestDefaultTypeInternal;
extern ExecuteBatchDmlRequestDefaultTypeInternal _ExecuteBatchDmlRequest_default_instance_;
class ExecuteBatchDmlRequest_Statement;
struct ExecuteBatchDmlRequest_StatementDefaultTypeInternal;
extern ExecuteBatchDmlRequest_StatementDefaultTypeInternal _ExecuteBatchDmlRequest_Statement_default_instance_;
class ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUse;
struct ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUseDefaultTypeInternal;
extern ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUseDefaultTypeInternal _ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUse_default_instance_;
class ExecuteBatchDmlResponse;
struct ExecuteBatchDmlResponseDefaultTypeInternal;
extern ExecuteBatchDmlResponseDefaultTypeInternal _ExecuteBatchDmlResponse_default_instance_;
class ExecuteSqlRequest;
struct ExecuteSqlRequestDefaultTypeInternal;
extern ExecuteSqlRequestDefaultTypeInternal _ExecuteSqlRequest_default_instance_;
class ExecuteSqlRequest_ParamTypesEntry_DoNotUse;
struct ExecuteSqlRequest_ParamTypesEntry_DoNotUseDefaultTypeInternal;
extern ExecuteSqlRequest_ParamTypesEntry_DoNotUseDefaultTypeInternal _ExecuteSqlRequest_ParamTypesEntry_DoNotUse_default_instance_;
class ExecuteSqlRequest_QueryOptions;
struct ExecuteSqlRequest_QueryOptionsDefaultTypeInternal;
extern ExecuteSqlRequest_QueryOptionsDefaultTypeInternal _ExecuteSqlRequest_QueryOptions_default_instance_;
class GetSessionRequest;
struct GetSessionRequestDefaultTypeInternal;
extern GetSessionRequestDefaultTypeInternal _GetSessionRequest_default_instance_;
class ListSessionsRequest;
struct ListSessionsRequestDefaultTypeInternal;
extern ListSessionsRequestDefaultTypeInternal _ListSessionsRequest_default_instance_;
class ListSessionsResponse;
struct ListSessionsResponseDefaultTypeInternal;
extern ListSessionsResponseDefaultTypeInternal _ListSessionsResponse_default_instance_;
class Partition;
struct PartitionDefaultTypeInternal;
extern PartitionDefaultTypeInternal _Partition_default_instance_;
class PartitionOptions;
struct PartitionOptionsDefaultTypeInternal;
extern PartitionOptionsDefaultTypeInternal _PartitionOptions_default_instance_;
class PartitionQueryRequest;
struct PartitionQueryRequestDefaultTypeInternal;
extern PartitionQueryRequestDefaultTypeInternal _PartitionQueryRequest_default_instance_;
class PartitionQueryRequest_ParamTypesEntry_DoNotUse;
struct PartitionQueryRequest_ParamTypesEntry_DoNotUseDefaultTypeInternal;
extern PartitionQueryRequest_ParamTypesEntry_DoNotUseDefaultTypeInternal _PartitionQueryRequest_ParamTypesEntry_DoNotUse_default_instance_;
class PartitionReadRequest;
struct PartitionReadRequestDefaultTypeInternal;
extern PartitionReadRequestDefaultTypeInternal _PartitionReadRequest_default_instance_;
class PartitionResponse;
struct PartitionResponseDefaultTypeInternal;
extern PartitionResponseDefaultTypeInternal _PartitionResponse_default_instance_;
class ReadRequest;
struct ReadRequestDefaultTypeInternal;
extern ReadRequestDefaultTypeInternal _ReadRequest_default_instance_;
class RequestOptions;
struct RequestOptionsDefaultTypeInternal;
extern RequestOptionsDefaultTypeInternal _RequestOptions_default_instance_;
class RollbackRequest;
struct RollbackRequestDefaultTypeInternal;
extern RollbackRequestDefaultTypeInternal _RollbackRequest_default_instance_;
class Session;
struct SessionDefaultTypeInternal;
extern SessionDefaultTypeInternal _Session_default_instance_;
class Session_LabelsEntry_DoNotUse;
struct Session_LabelsEntry_DoNotUseDefaultTypeInternal;
extern Session_LabelsEntry_DoNotUseDefaultTypeInternal _Session_LabelsEntry_DoNotUse_default_instance_;
}  // namespace v1
}  // namespace spanner
}  // namespace google
PROTOBUF_NAMESPACE_OPEN
template<> ::google::spanner::v1::BatchCreateSessionsRequest* Arena::CreateMaybeMessage<::google::spanner::v1::BatchCreateSessionsRequest>(Arena*);
template<> ::google::spanner::v1::BatchCreateSessionsResponse* Arena::CreateMaybeMessage<::google::spanner::v1::BatchCreateSessionsResponse>(Arena*);
template<> ::google::spanner::v1::BeginTransactionRequest* Arena::CreateMaybeMessage<::google::spanner::v1::BeginTransactionRequest>(Arena*);
template<> ::google::spanner::v1::CommitRequest* Arena::CreateMaybeMessage<::google::spanner::v1::CommitRequest>(Arena*);
template<> ::google::spanner::v1::CreateSessionRequest* Arena::CreateMaybeMessage<::google::spanner::v1::CreateSessionRequest>(Arena*);
template<> ::google::spanner::v1::DeleteSessionRequest* Arena::CreateMaybeMessage<::google::spanner::v1::DeleteSessionRequest>(Arena*);
template<> ::google::spanner::v1::ExecuteBatchDmlRequest* Arena::CreateMaybeMessage<::google::spanner::v1::ExecuteBatchDmlRequest>(Arena*);
template<> ::google::spanner::v1::ExecuteBatchDmlRequest_Statement* Arena::CreateMaybeMessage<::google::spanner::v1::ExecuteBatchDmlRequest_Statement>(Arena*);
template<> ::google::spanner::v1::ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUse* Arena::CreateMaybeMessage<::google::spanner::v1::ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUse>(Arena*);
template<> ::google::spanner::v1::ExecuteBatchDmlResponse* Arena::CreateMaybeMessage<::google::spanner::v1::ExecuteBatchDmlResponse>(Arena*);
template<> ::google::spanner::v1::ExecuteSqlRequest* Arena::CreateMaybeMessage<::google::spanner::v1::ExecuteSqlRequest>(Arena*);
template<> ::google::spanner::v1::ExecuteSqlRequest_ParamTypesEntry_DoNotUse* Arena::CreateMaybeMessage<::google::spanner::v1::ExecuteSqlRequest_ParamTypesEntry_DoNotUse>(Arena*);
template<> ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* Arena::CreateMaybeMessage<::google::spanner::v1::ExecuteSqlRequest_QueryOptions>(Arena*);
template<> ::google::spanner::v1::GetSessionRequest* Arena::CreateMaybeMessage<::google::spanner::v1::GetSessionRequest>(Arena*);
template<> ::google::spanner::v1::ListSessionsRequest* Arena::CreateMaybeMessage<::google::spanner::v1::ListSessionsRequest>(Arena*);
template<> ::google::spanner::v1::ListSessionsResponse* Arena::CreateMaybeMessage<::google::spanner::v1::ListSessionsResponse>(Arena*);
template<> ::google::spanner::v1::Partition* Arena::CreateMaybeMessage<::google::spanner::v1::Partition>(Arena*);
template<> ::google::spanner::v1::PartitionOptions* Arena::CreateMaybeMessage<::google::spanner::v1::PartitionOptions>(Arena*);
template<> ::google::spanner::v1::PartitionQueryRequest* Arena::CreateMaybeMessage<::google::spanner::v1::PartitionQueryRequest>(Arena*);
template<> ::google::spanner::v1::PartitionQueryRequest_ParamTypesEntry_DoNotUse* Arena::CreateMaybeMessage<::google::spanner::v1::PartitionQueryRequest_ParamTypesEntry_DoNotUse>(Arena*);
template<> ::google::spanner::v1::PartitionReadRequest* Arena::CreateMaybeMessage<::google::spanner::v1::PartitionReadRequest>(Arena*);
template<> ::google::spanner::v1::PartitionResponse* Arena::CreateMaybeMessage<::google::spanner::v1::PartitionResponse>(Arena*);
template<> ::google::spanner::v1::ReadRequest* Arena::CreateMaybeMessage<::google::spanner::v1::ReadRequest>(Arena*);
template<> ::google::spanner::v1::RequestOptions* Arena::CreateMaybeMessage<::google::spanner::v1::RequestOptions>(Arena*);
template<> ::google::spanner::v1::RollbackRequest* Arena::CreateMaybeMessage<::google::spanner::v1::RollbackRequest>(Arena*);
template<> ::google::spanner::v1::Session* Arena::CreateMaybeMessage<::google::spanner::v1::Session>(Arena*);
template<> ::google::spanner::v1::Session_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::google::spanner::v1::Session_LabelsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace google {
namespace spanner {
namespace v1 {

enum RequestOptions_Priority : int {
  RequestOptions_Priority_PRIORITY_UNSPECIFIED = 0,
  RequestOptions_Priority_PRIORITY_LOW = 1,
  RequestOptions_Priority_PRIORITY_MEDIUM = 2,
  RequestOptions_Priority_PRIORITY_HIGH = 3,
  RequestOptions_Priority_RequestOptions_Priority_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RequestOptions_Priority_RequestOptions_Priority_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RequestOptions_Priority_IsValid(int value);
constexpr RequestOptions_Priority RequestOptions_Priority_Priority_MIN = RequestOptions_Priority_PRIORITY_UNSPECIFIED;
constexpr RequestOptions_Priority RequestOptions_Priority_Priority_MAX = RequestOptions_Priority_PRIORITY_HIGH;
constexpr int RequestOptions_Priority_Priority_ARRAYSIZE = RequestOptions_Priority_Priority_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestOptions_Priority_descriptor();
template<typename T>
inline const std::string& RequestOptions_Priority_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestOptions_Priority>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestOptions_Priority_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestOptions_Priority_descriptor(), enum_t_value);
}
inline bool RequestOptions_Priority_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestOptions_Priority* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestOptions_Priority>(
    RequestOptions_Priority_descriptor(), name, value);
}
enum ExecuteSqlRequest_QueryMode : int {
  ExecuteSqlRequest_QueryMode_NORMAL = 0,
  ExecuteSqlRequest_QueryMode_PLAN = 1,
  ExecuteSqlRequest_QueryMode_PROFILE = 2,
  ExecuteSqlRequest_QueryMode_ExecuteSqlRequest_QueryMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ExecuteSqlRequest_QueryMode_ExecuteSqlRequest_QueryMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ExecuteSqlRequest_QueryMode_IsValid(int value);
constexpr ExecuteSqlRequest_QueryMode ExecuteSqlRequest_QueryMode_QueryMode_MIN = ExecuteSqlRequest_QueryMode_NORMAL;
constexpr ExecuteSqlRequest_QueryMode ExecuteSqlRequest_QueryMode_QueryMode_MAX = ExecuteSqlRequest_QueryMode_PROFILE;
constexpr int ExecuteSqlRequest_QueryMode_QueryMode_ARRAYSIZE = ExecuteSqlRequest_QueryMode_QueryMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExecuteSqlRequest_QueryMode_descriptor();
template<typename T>
inline const std::string& ExecuteSqlRequest_QueryMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExecuteSqlRequest_QueryMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExecuteSqlRequest_QueryMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExecuteSqlRequest_QueryMode_descriptor(), enum_t_value);
}
inline bool ExecuteSqlRequest_QueryMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExecuteSqlRequest_QueryMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExecuteSqlRequest_QueryMode>(
    ExecuteSqlRequest_QueryMode_descriptor(), name, value);
}
// ===================================================================

class CreateSessionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.CreateSessionRequest) */ {
 public:
  inline CreateSessionRequest() : CreateSessionRequest(nullptr) {}
  ~CreateSessionRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateSessionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSessionRequest(const CreateSessionRequest& from);
  CreateSessionRequest(CreateSessionRequest&& from) noexcept
    : CreateSessionRequest() {
    *this = ::std::move(from);
  }

  inline CreateSessionRequest& operator=(const CreateSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSessionRequest& operator=(CreateSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSessionRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSessionRequest*>(
               &_CreateSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateSessionRequest& a, CreateSessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSessionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSessionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSessionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSessionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateSessionRequest& from) {
    CreateSessionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSessionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.CreateSessionRequest";
  }
  protected:
  explicit CreateSessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseFieldNumber = 1,
    kSessionFieldNumber = 2,
  };
  // string database = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // .google.spanner.v1.Session session = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_session() const;
  private:
  bool _internal_has_session() const;
  public:
  void clear_session();
  const ::google::spanner::v1::Session& session() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::Session* release_session();
  ::google::spanner::v1::Session* mutable_session();
  void set_allocated_session(::google::spanner::v1::Session* session);
  private:
  const ::google::spanner::v1::Session& _internal_session() const;
  ::google::spanner::v1::Session* _internal_mutable_session();
  public:
  void unsafe_arena_set_allocated_session(
      ::google::spanner::v1::Session* session);
  ::google::spanner::v1::Session* unsafe_arena_release_session();

  // @@protoc_insertion_point(class_scope:google.spanner.v1.CreateSessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
    ::google::spanner::v1::Session* session_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class BatchCreateSessionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.BatchCreateSessionsRequest) */ {
 public:
  inline BatchCreateSessionsRequest() : BatchCreateSessionsRequest(nullptr) {}
  ~BatchCreateSessionsRequest() override;
  explicit PROTOBUF_CONSTEXPR BatchCreateSessionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchCreateSessionsRequest(const BatchCreateSessionsRequest& from);
  BatchCreateSessionsRequest(BatchCreateSessionsRequest&& from) noexcept
    : BatchCreateSessionsRequest() {
    *this = ::std::move(from);
  }

  inline BatchCreateSessionsRequest& operator=(const BatchCreateSessionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchCreateSessionsRequest& operator=(BatchCreateSessionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchCreateSessionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchCreateSessionsRequest* internal_default_instance() {
    return reinterpret_cast<const BatchCreateSessionsRequest*>(
               &_BatchCreateSessionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BatchCreateSessionsRequest& a, BatchCreateSessionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchCreateSessionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchCreateSessionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchCreateSessionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchCreateSessionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchCreateSessionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchCreateSessionsRequest& from) {
    BatchCreateSessionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchCreateSessionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.BatchCreateSessionsRequest";
  }
  protected:
  explicit BatchCreateSessionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseFieldNumber = 1,
    kSessionTemplateFieldNumber = 2,
    kSessionCountFieldNumber = 3,
  };
  // string database = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // .google.spanner.v1.Session session_template = 2;
  bool has_session_template() const;
  private:
  bool _internal_has_session_template() const;
  public:
  void clear_session_template();
  const ::google::spanner::v1::Session& session_template() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::Session* release_session_template();
  ::google::spanner::v1::Session* mutable_session_template();
  void set_allocated_session_template(::google::spanner::v1::Session* session_template);
  private:
  const ::google::spanner::v1::Session& _internal_session_template() const;
  ::google::spanner::v1::Session* _internal_mutable_session_template();
  public:
  void unsafe_arena_set_allocated_session_template(
      ::google::spanner::v1::Session* session_template);
  ::google::spanner::v1::Session* unsafe_arena_release_session_template();

  // int32 session_count = 3 [(.google.api.field_behavior) = REQUIRED];
  void clear_session_count();
  int32_t session_count() const;
  void set_session_count(int32_t value);
  private:
  int32_t _internal_session_count() const;
  void _internal_set_session_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.v1.BatchCreateSessionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
    ::google::spanner::v1::Session* session_template_;
    int32_t session_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class BatchCreateSessionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.BatchCreateSessionsResponse) */ {
 public:
  inline BatchCreateSessionsResponse() : BatchCreateSessionsResponse(nullptr) {}
  ~BatchCreateSessionsResponse() override;
  explicit PROTOBUF_CONSTEXPR BatchCreateSessionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchCreateSessionsResponse(const BatchCreateSessionsResponse& from);
  BatchCreateSessionsResponse(BatchCreateSessionsResponse&& from) noexcept
    : BatchCreateSessionsResponse() {
    *this = ::std::move(from);
  }

  inline BatchCreateSessionsResponse& operator=(const BatchCreateSessionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchCreateSessionsResponse& operator=(BatchCreateSessionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchCreateSessionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchCreateSessionsResponse* internal_default_instance() {
    return reinterpret_cast<const BatchCreateSessionsResponse*>(
               &_BatchCreateSessionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BatchCreateSessionsResponse& a, BatchCreateSessionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchCreateSessionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchCreateSessionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchCreateSessionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchCreateSessionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchCreateSessionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchCreateSessionsResponse& from) {
    BatchCreateSessionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchCreateSessionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.BatchCreateSessionsResponse";
  }
  protected:
  explicit BatchCreateSessionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 1,
  };
  // repeated .google.spanner.v1.Session session = 1;
  int session_size() const;
  private:
  int _internal_session_size() const;
  public:
  void clear_session();
  ::google::spanner::v1::Session* mutable_session(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Session >*
      mutable_session();
  private:
  const ::google::spanner::v1::Session& _internal_session(int index) const;
  ::google::spanner::v1::Session* _internal_add_session();
  public:
  const ::google::spanner::v1::Session& session(int index) const;
  ::google::spanner::v1::Session* add_session();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Session >&
      session() const;

  // @@protoc_insertion_point(class_scope:google.spanner.v1.BatchCreateSessionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Session > session_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class Session_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Session_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Session_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Session_LabelsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Session_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Session_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Session_LabelsEntry_DoNotUse& other);
  static const Session_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Session_LabelsEntry_DoNotUse*>(&_Session_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.spanner.v1.Session.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.spanner.v1.Session.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};

// -------------------------------------------------------------------

class Session final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.Session) */ {
 public:
  inline Session() : Session(nullptr) {}
  ~Session() override;
  explicit PROTOBUF_CONSTEXPR Session(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Session(const Session& from);
  Session(Session&& from) noexcept
    : Session() {
    *this = ::std::move(from);
  }

  inline Session& operator=(const Session& from) {
    CopyFrom(from);
    return *this;
  }
  inline Session& operator=(Session&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Session& default_instance() {
    return *internal_default_instance();
  }
  static inline const Session* internal_default_instance() {
    return reinterpret_cast<const Session*>(
               &_Session_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Session& a, Session& b) {
    a.Swap(&b);
  }
  inline void Swap(Session* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Session* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Session* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Session>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Session& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Session& from) {
    Session::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Session* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.Session";
  }
  protected:
  explicit Session(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 2,
    kNameFieldNumber = 1,
    kCreatorRoleFieldNumber = 5,
    kCreateTimeFieldNumber = 3,
    kApproximateLastUseTimeFieldNumber = 4,
  };
  // map<string, string> labels = 2;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string creator_role = 5;
  void clear_creator_role();
  const std::string& creator_role() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator_role(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator_role();
  PROTOBUF_NODISCARD std::string* release_creator_role();
  void set_allocated_creator_role(std::string* creator_role);
  private:
  const std::string& _internal_creator_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator_role(const std::string& value);
  std::string* _internal_mutable_creator_role();
  public:

  // .google.protobuf.Timestamp create_time = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_time();
  void set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_time();
  public:
  void unsafe_arena_set_allocated_create_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_time();

  // .google.protobuf.Timestamp approximate_last_use_time = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_approximate_last_use_time() const;
  private:
  bool _internal_has_approximate_last_use_time() const;
  public:
  void clear_approximate_last_use_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& approximate_last_use_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_approximate_last_use_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_approximate_last_use_time();
  void set_allocated_approximate_last_use_time(::PROTOBUF_NAMESPACE_ID::Timestamp* approximate_last_use_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_approximate_last_use_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_approximate_last_use_time();
  public:
  void unsafe_arena_set_allocated_approximate_last_use_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* approximate_last_use_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_approximate_last_use_time();

  // @@protoc_insertion_point(class_scope:google.spanner.v1.Session)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Session_LabelsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_role_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* approximate_last_use_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class GetSessionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.GetSessionRequest) */ {
 public:
  inline GetSessionRequest() : GetSessionRequest(nullptr) {}
  ~GetSessionRequest() override;
  explicit PROTOBUF_CONSTEXPR GetSessionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSessionRequest(const GetSessionRequest& from);
  GetSessionRequest(GetSessionRequest&& from) noexcept
    : GetSessionRequest() {
    *this = ::std::move(from);
  }

  inline GetSessionRequest& operator=(const GetSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSessionRequest& operator=(GetSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSessionRequest* internal_default_instance() {
    return reinterpret_cast<const GetSessionRequest*>(
               &_GetSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetSessionRequest& a, GetSessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSessionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSessionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSessionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSessionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSessionRequest& from) {
    GetSessionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSessionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.GetSessionRequest";
  }
  protected:
  explicit GetSessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.v1.GetSessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class ListSessionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.ListSessionsRequest) */ {
 public:
  inline ListSessionsRequest() : ListSessionsRequest(nullptr) {}
  ~ListSessionsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListSessionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListSessionsRequest(const ListSessionsRequest& from);
  ListSessionsRequest(ListSessionsRequest&& from) noexcept
    : ListSessionsRequest() {
    *this = ::std::move(from);
  }

  inline ListSessionsRequest& operator=(const ListSessionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSessionsRequest& operator=(ListSessionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSessionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSessionsRequest* internal_default_instance() {
    return reinterpret_cast<const ListSessionsRequest*>(
               &_ListSessionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListSessionsRequest& a, ListSessionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSessionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSessionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSessionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListSessionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListSessionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListSessionsRequest& from) {
    ListSessionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListSessionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.ListSessionsRequest";
  }
  protected:
  explicit ListSessionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kFilterFieldNumber = 4,
    kPageSizeFieldNumber = 2,
  };
  // string database = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // string page_token = 3;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // string filter = 4;
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // int32 page_size = 2;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.v1.ListSessionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class ListSessionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.ListSessionsResponse) */ {
 public:
  inline ListSessionsResponse() : ListSessionsResponse(nullptr) {}
  ~ListSessionsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListSessionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListSessionsResponse(const ListSessionsResponse& from);
  ListSessionsResponse(ListSessionsResponse&& from) noexcept
    : ListSessionsResponse() {
    *this = ::std::move(from);
  }

  inline ListSessionsResponse& operator=(const ListSessionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSessionsResponse& operator=(ListSessionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSessionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSessionsResponse* internal_default_instance() {
    return reinterpret_cast<const ListSessionsResponse*>(
               &_ListSessionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListSessionsResponse& a, ListSessionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSessionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSessionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSessionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListSessionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListSessionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListSessionsResponse& from) {
    ListSessionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListSessionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.ListSessionsResponse";
  }
  protected:
  explicit ListSessionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.spanner.v1.Session sessions = 1;
  int sessions_size() const;
  private:
  int _internal_sessions_size() const;
  public:
  void clear_sessions();
  ::google::spanner::v1::Session* mutable_sessions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Session >*
      mutable_sessions();
  private:
  const ::google::spanner::v1::Session& _internal_sessions(int index) const;
  ::google::spanner::v1::Session* _internal_add_sessions();
  public:
  const ::google::spanner::v1::Session& sessions(int index) const;
  ::google::spanner::v1::Session* add_sessions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Session >&
      sessions() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.v1.ListSessionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Session > sessions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class DeleteSessionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.DeleteSessionRequest) */ {
 public:
  inline DeleteSessionRequest() : DeleteSessionRequest(nullptr) {}
  ~DeleteSessionRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteSessionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSessionRequest(const DeleteSessionRequest& from);
  DeleteSessionRequest(DeleteSessionRequest&& from) noexcept
    : DeleteSessionRequest() {
    *this = ::std::move(from);
  }

  inline DeleteSessionRequest& operator=(const DeleteSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSessionRequest& operator=(DeleteSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSessionRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteSessionRequest*>(
               &_DeleteSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeleteSessionRequest& a, DeleteSessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSessionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSessionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSessionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteSessionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteSessionRequest& from) {
    DeleteSessionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSessionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.DeleteSessionRequest";
  }
  protected:
  explicit DeleteSessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.v1.DeleteSessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class RequestOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.RequestOptions) */ {
 public:
  inline RequestOptions() : RequestOptions(nullptr) {}
  ~RequestOptions() override;
  explicit PROTOBUF_CONSTEXPR RequestOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestOptions(const RequestOptions& from);
  RequestOptions(RequestOptions&& from) noexcept
    : RequestOptions() {
    *this = ::std::move(from);
  }

  inline RequestOptions& operator=(const RequestOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestOptions& operator=(RequestOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestOptions* internal_default_instance() {
    return reinterpret_cast<const RequestOptions*>(
               &_RequestOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RequestOptions& a, RequestOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestOptions& from) {
    RequestOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.RequestOptions";
  }
  protected:
  explicit RequestOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RequestOptions_Priority Priority;
  static constexpr Priority PRIORITY_UNSPECIFIED =
    RequestOptions_Priority_PRIORITY_UNSPECIFIED;
  static constexpr Priority PRIORITY_LOW =
    RequestOptions_Priority_PRIORITY_LOW;
  static constexpr Priority PRIORITY_MEDIUM =
    RequestOptions_Priority_PRIORITY_MEDIUM;
  static constexpr Priority PRIORITY_HIGH =
    RequestOptions_Priority_PRIORITY_HIGH;
  static inline bool Priority_IsValid(int value) {
    return RequestOptions_Priority_IsValid(value);
  }
  static constexpr Priority Priority_MIN =
    RequestOptions_Priority_Priority_MIN;
  static constexpr Priority Priority_MAX =
    RequestOptions_Priority_Priority_MAX;
  static constexpr int Priority_ARRAYSIZE =
    RequestOptions_Priority_Priority_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Priority_descriptor() {
    return RequestOptions_Priority_descriptor();
  }
  template<typename T>
  static inline const std::string& Priority_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Priority>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Priority_Name.");
    return RequestOptions_Priority_Name(enum_t_value);
  }
  static inline bool Priority_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Priority* value) {
    return RequestOptions_Priority_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRequestTagFieldNumber = 2,
    kTransactionTagFieldNumber = 3,
    kPriorityFieldNumber = 1,
  };
  // string request_tag = 2;
  void clear_request_tag();
  const std::string& request_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_tag();
  PROTOBUF_NODISCARD std::string* release_request_tag();
  void set_allocated_request_tag(std::string* request_tag);
  private:
  const std::string& _internal_request_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_tag(const std::string& value);
  std::string* _internal_mutable_request_tag();
  public:

  // string transaction_tag = 3;
  void clear_transaction_tag();
  const std::string& transaction_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transaction_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transaction_tag();
  PROTOBUF_NODISCARD std::string* release_transaction_tag();
  void set_allocated_transaction_tag(std::string* transaction_tag);
  private:
  const std::string& _internal_transaction_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_tag(const std::string& value);
  std::string* _internal_mutable_transaction_tag();
  public:

  // .google.spanner.v1.RequestOptions.Priority priority = 1;
  void clear_priority();
  ::google::spanner::v1::RequestOptions_Priority priority() const;
  void set_priority(::google::spanner::v1::RequestOptions_Priority value);
  private:
  ::google::spanner::v1::RequestOptions_Priority _internal_priority() const;
  void _internal_set_priority(::google::spanner::v1::RequestOptions_Priority value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.v1.RequestOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_tag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_tag_;
    int priority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class ExecuteSqlRequest_QueryOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.ExecuteSqlRequest.QueryOptions) */ {
 public:
  inline ExecuteSqlRequest_QueryOptions() : ExecuteSqlRequest_QueryOptions(nullptr) {}
  ~ExecuteSqlRequest_QueryOptions() override;
  explicit PROTOBUF_CONSTEXPR ExecuteSqlRequest_QueryOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteSqlRequest_QueryOptions(const ExecuteSqlRequest_QueryOptions& from);
  ExecuteSqlRequest_QueryOptions(ExecuteSqlRequest_QueryOptions&& from) noexcept
    : ExecuteSqlRequest_QueryOptions() {
    *this = ::std::move(from);
  }

  inline ExecuteSqlRequest_QueryOptions& operator=(const ExecuteSqlRequest_QueryOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteSqlRequest_QueryOptions& operator=(ExecuteSqlRequest_QueryOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteSqlRequest_QueryOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteSqlRequest_QueryOptions* internal_default_instance() {
    return reinterpret_cast<const ExecuteSqlRequest_QueryOptions*>(
               &_ExecuteSqlRequest_QueryOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ExecuteSqlRequest_QueryOptions& a, ExecuteSqlRequest_QueryOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteSqlRequest_QueryOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteSqlRequest_QueryOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteSqlRequest_QueryOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteSqlRequest_QueryOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteSqlRequest_QueryOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteSqlRequest_QueryOptions& from) {
    ExecuteSqlRequest_QueryOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteSqlRequest_QueryOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.ExecuteSqlRequest.QueryOptions";
  }
  protected:
  explicit ExecuteSqlRequest_QueryOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptimizerVersionFieldNumber = 1,
    kOptimizerStatisticsPackageFieldNumber = 2,
  };
  // string optimizer_version = 1;
  void clear_optimizer_version();
  const std::string& optimizer_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_optimizer_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_optimizer_version();
  PROTOBUF_NODISCARD std::string* release_optimizer_version();
  void set_allocated_optimizer_version(std::string* optimizer_version);
  private:
  const std::string& _internal_optimizer_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_optimizer_version(const std::string& value);
  std::string* _internal_mutable_optimizer_version();
  public:

  // string optimizer_statistics_package = 2;
  void clear_optimizer_statistics_package();
  const std::string& optimizer_statistics_package() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_optimizer_statistics_package(ArgT0&& arg0, ArgT... args);
  std::string* mutable_optimizer_statistics_package();
  PROTOBUF_NODISCARD std::string* release_optimizer_statistics_package();
  void set_allocated_optimizer_statistics_package(std::string* optimizer_statistics_package);
  private:
  const std::string& _internal_optimizer_statistics_package() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_optimizer_statistics_package(const std::string& value);
  std::string* _internal_mutable_optimizer_statistics_package();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.v1.ExecuteSqlRequest.QueryOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr optimizer_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr optimizer_statistics_package_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class ExecuteSqlRequest_ParamTypesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ExecuteSqlRequest_ParamTypesEntry_DoNotUse, 
    std::string, ::google::spanner::v1::Type,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ExecuteSqlRequest_ParamTypesEntry_DoNotUse, 
    std::string, ::google::spanner::v1::Type,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ExecuteSqlRequest_ParamTypesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ExecuteSqlRequest_ParamTypesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ExecuteSqlRequest_ParamTypesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ExecuteSqlRequest_ParamTypesEntry_DoNotUse& other);
  static const ExecuteSqlRequest_ParamTypesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ExecuteSqlRequest_ParamTypesEntry_DoNotUse*>(&_ExecuteSqlRequest_ParamTypesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.spanner.v1.ExecuteSqlRequest.ParamTypesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};

// -------------------------------------------------------------------

class ExecuteSqlRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.ExecuteSqlRequest) */ {
 public:
  inline ExecuteSqlRequest() : ExecuteSqlRequest(nullptr) {}
  ~ExecuteSqlRequest() override;
  explicit PROTOBUF_CONSTEXPR ExecuteSqlRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteSqlRequest(const ExecuteSqlRequest& from);
  ExecuteSqlRequest(ExecuteSqlRequest&& from) noexcept
    : ExecuteSqlRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteSqlRequest& operator=(const ExecuteSqlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteSqlRequest& operator=(ExecuteSqlRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteSqlRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteSqlRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteSqlRequest*>(
               &_ExecuteSqlRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ExecuteSqlRequest& a, ExecuteSqlRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteSqlRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteSqlRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteSqlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteSqlRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteSqlRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteSqlRequest& from) {
    ExecuteSqlRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteSqlRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.ExecuteSqlRequest";
  }
  protected:
  explicit ExecuteSqlRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ExecuteSqlRequest_QueryOptions QueryOptions;

  typedef ExecuteSqlRequest_QueryMode QueryMode;
  static constexpr QueryMode NORMAL =
    ExecuteSqlRequest_QueryMode_NORMAL;
  static constexpr QueryMode PLAN =
    ExecuteSqlRequest_QueryMode_PLAN;
  static constexpr QueryMode PROFILE =
    ExecuteSqlRequest_QueryMode_PROFILE;
  static inline bool QueryMode_IsValid(int value) {
    return ExecuteSqlRequest_QueryMode_IsValid(value);
  }
  static constexpr QueryMode QueryMode_MIN =
    ExecuteSqlRequest_QueryMode_QueryMode_MIN;
  static constexpr QueryMode QueryMode_MAX =
    ExecuteSqlRequest_QueryMode_QueryMode_MAX;
  static constexpr int QueryMode_ARRAYSIZE =
    ExecuteSqlRequest_QueryMode_QueryMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  QueryMode_descriptor() {
    return ExecuteSqlRequest_QueryMode_descriptor();
  }
  template<typename T>
  static inline const std::string& QueryMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, QueryMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function QueryMode_Name.");
    return ExecuteSqlRequest_QueryMode_Name(enum_t_value);
  }
  static inline bool QueryMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      QueryMode* value) {
    return ExecuteSqlRequest_QueryMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParamTypesFieldNumber = 5,
    kSessionFieldNumber = 1,
    kSqlFieldNumber = 3,
    kResumeTokenFieldNumber = 6,
    kPartitionTokenFieldNumber = 8,
    kTransactionFieldNumber = 2,
    kParamsFieldNumber = 4,
    kQueryOptionsFieldNumber = 10,
    kRequestOptionsFieldNumber = 11,
    kSeqnoFieldNumber = 9,
    kQueryModeFieldNumber = 7,
  };
  // map<string, .google.spanner.v1.Type> param_types = 5;
  int param_types_size() const;
  private:
  int _internal_param_types_size() const;
  public:
  void clear_param_types();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >&
      _internal_param_types() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >*
      _internal_mutable_param_types();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >&
      param_types() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >*
      mutable_param_types();

  // string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_session();
  const std::string& session() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session();
  PROTOBUF_NODISCARD std::string* release_session();
  void set_allocated_session(std::string* session);
  private:
  const std::string& _internal_session() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session(const std::string& value);
  std::string* _internal_mutable_session();
  public:

  // string sql = 3 [(.google.api.field_behavior) = REQUIRED];
  void clear_sql();
  const std::string& sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sql();
  PROTOBUF_NODISCARD std::string* release_sql();
  void set_allocated_sql(std::string* sql);
  private:
  const std::string& _internal_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql(const std::string& value);
  std::string* _internal_mutable_sql();
  public:

  // bytes resume_token = 6;
  void clear_resume_token();
  const std::string& resume_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resume_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resume_token();
  PROTOBUF_NODISCARD std::string* release_resume_token();
  void set_allocated_resume_token(std::string* resume_token);
  private:
  const std::string& _internal_resume_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resume_token(const std::string& value);
  std::string* _internal_mutable_resume_token();
  public:

  // bytes partition_token = 8;
  void clear_partition_token();
  const std::string& partition_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition_token();
  PROTOBUF_NODISCARD std::string* release_partition_token();
  void set_allocated_partition_token(std::string* partition_token);
  private:
  const std::string& _internal_partition_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_token(const std::string& value);
  std::string* _internal_mutable_partition_token();
  public:

  // .google.spanner.v1.TransactionSelector transaction = 2;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::google::spanner::v1::TransactionSelector& transaction() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::TransactionSelector* release_transaction();
  ::google::spanner::v1::TransactionSelector* mutable_transaction();
  void set_allocated_transaction(::google::spanner::v1::TransactionSelector* transaction);
  private:
  const ::google::spanner::v1::TransactionSelector& _internal_transaction() const;
  ::google::spanner::v1::TransactionSelector* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::google::spanner::v1::TransactionSelector* transaction);
  ::google::spanner::v1::TransactionSelector* unsafe_arena_release_transaction();

  // .google.protobuf.Struct params = 4;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::PROTOBUF_NAMESPACE_ID::Struct& params() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_params();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_params();
  void set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_params() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::PROTOBUF_NAMESPACE_ID::Struct* params);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_params();

  // .google.spanner.v1.ExecuteSqlRequest.QueryOptions query_options = 10;
  bool has_query_options() const;
  private:
  bool _internal_has_query_options() const;
  public:
  void clear_query_options();
  const ::google::spanner::v1::ExecuteSqlRequest_QueryOptions& query_options() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* release_query_options();
  ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* mutable_query_options();
  void set_allocated_query_options(::google::spanner::v1::ExecuteSqlRequest_QueryOptions* query_options);
  private:
  const ::google::spanner::v1::ExecuteSqlRequest_QueryOptions& _internal_query_options() const;
  ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* _internal_mutable_query_options();
  public:
  void unsafe_arena_set_allocated_query_options(
      ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* query_options);
  ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* unsafe_arena_release_query_options();

  // .google.spanner.v1.RequestOptions request_options = 11;
  bool has_request_options() const;
  private:
  bool _internal_has_request_options() const;
  public:
  void clear_request_options();
  const ::google::spanner::v1::RequestOptions& request_options() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::RequestOptions* release_request_options();
  ::google::spanner::v1::RequestOptions* mutable_request_options();
  void set_allocated_request_options(::google::spanner::v1::RequestOptions* request_options);
  private:
  const ::google::spanner::v1::RequestOptions& _internal_request_options() const;
  ::google::spanner::v1::RequestOptions* _internal_mutable_request_options();
  public:
  void unsafe_arena_set_allocated_request_options(
      ::google::spanner::v1::RequestOptions* request_options);
  ::google::spanner::v1::RequestOptions* unsafe_arena_release_request_options();

  // int64 seqno = 9;
  void clear_seqno();
  int64_t seqno() const;
  void set_seqno(int64_t value);
  private:
  int64_t _internal_seqno() const;
  void _internal_set_seqno(int64_t value);
  public:

  // .google.spanner.v1.ExecuteSqlRequest.QueryMode query_mode = 7;
  void clear_query_mode();
  ::google::spanner::v1::ExecuteSqlRequest_QueryMode query_mode() const;
  void set_query_mode(::google::spanner::v1::ExecuteSqlRequest_QueryMode value);
  private:
  ::google::spanner::v1::ExecuteSqlRequest_QueryMode _internal_query_mode() const;
  void _internal_set_query_mode(::google::spanner::v1::ExecuteSqlRequest_QueryMode value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.v1.ExecuteSqlRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ExecuteSqlRequest_ParamTypesEntry_DoNotUse,
        std::string, ::google::spanner::v1::Type,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> param_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sql_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resume_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_token_;
    ::google::spanner::v1::TransactionSelector* transaction_;
    ::PROTOBUF_NAMESPACE_ID::Struct* params_;
    ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* query_options_;
    ::google::spanner::v1::RequestOptions* request_options_;
    int64_t seqno_;
    int query_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUse, 
    std::string, ::google::spanner::v1::Type,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUse, 
    std::string, ::google::spanner::v1::Type,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUse& other);
  static const ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUse*>(&_ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.spanner.v1.ExecuteBatchDmlRequest.Statement.ParamTypesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};

// -------------------------------------------------------------------

class ExecuteBatchDmlRequest_Statement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.ExecuteBatchDmlRequest.Statement) */ {
 public:
  inline ExecuteBatchDmlRequest_Statement() : ExecuteBatchDmlRequest_Statement(nullptr) {}
  ~ExecuteBatchDmlRequest_Statement() override;
  explicit PROTOBUF_CONSTEXPR ExecuteBatchDmlRequest_Statement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteBatchDmlRequest_Statement(const ExecuteBatchDmlRequest_Statement& from);
  ExecuteBatchDmlRequest_Statement(ExecuteBatchDmlRequest_Statement&& from) noexcept
    : ExecuteBatchDmlRequest_Statement() {
    *this = ::std::move(from);
  }

  inline ExecuteBatchDmlRequest_Statement& operator=(const ExecuteBatchDmlRequest_Statement& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteBatchDmlRequest_Statement& operator=(ExecuteBatchDmlRequest_Statement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteBatchDmlRequest_Statement& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteBatchDmlRequest_Statement* internal_default_instance() {
    return reinterpret_cast<const ExecuteBatchDmlRequest_Statement*>(
               &_ExecuteBatchDmlRequest_Statement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ExecuteBatchDmlRequest_Statement& a, ExecuteBatchDmlRequest_Statement& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteBatchDmlRequest_Statement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteBatchDmlRequest_Statement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteBatchDmlRequest_Statement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteBatchDmlRequest_Statement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteBatchDmlRequest_Statement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteBatchDmlRequest_Statement& from) {
    ExecuteBatchDmlRequest_Statement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteBatchDmlRequest_Statement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.ExecuteBatchDmlRequest.Statement";
  }
  protected:
  explicit ExecuteBatchDmlRequest_Statement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParamTypesFieldNumber = 3,
    kSqlFieldNumber = 1,
    kParamsFieldNumber = 2,
  };
  // map<string, .google.spanner.v1.Type> param_types = 3;
  int param_types_size() const;
  private:
  int _internal_param_types_size() const;
  public:
  void clear_param_types();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >&
      _internal_param_types() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >*
      _internal_mutable_param_types();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >&
      param_types() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >*
      mutable_param_types();

  // string sql = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_sql();
  const std::string& sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sql();
  PROTOBUF_NODISCARD std::string* release_sql();
  void set_allocated_sql(std::string* sql);
  private:
  const std::string& _internal_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql(const std::string& value);
  std::string* _internal_mutable_sql();
  public:

  // .google.protobuf.Struct params = 2;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::PROTOBUF_NAMESPACE_ID::Struct& params() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_params();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_params();
  void set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_params() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::PROTOBUF_NAMESPACE_ID::Struct* params);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:google.spanner.v1.ExecuteBatchDmlRequest.Statement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ExecuteBatchDmlRequest_Statement_ParamTypesEntry_DoNotUse,
        std::string, ::google::spanner::v1::Type,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> param_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sql_;
    ::PROTOBUF_NAMESPACE_ID::Struct* params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class ExecuteBatchDmlRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.ExecuteBatchDmlRequest) */ {
 public:
  inline ExecuteBatchDmlRequest() : ExecuteBatchDmlRequest(nullptr) {}
  ~ExecuteBatchDmlRequest() override;
  explicit PROTOBUF_CONSTEXPR ExecuteBatchDmlRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteBatchDmlRequest(const ExecuteBatchDmlRequest& from);
  ExecuteBatchDmlRequest(ExecuteBatchDmlRequest&& from) noexcept
    : ExecuteBatchDmlRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteBatchDmlRequest& operator=(const ExecuteBatchDmlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteBatchDmlRequest& operator=(ExecuteBatchDmlRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteBatchDmlRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteBatchDmlRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteBatchDmlRequest*>(
               &_ExecuteBatchDmlRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ExecuteBatchDmlRequest& a, ExecuteBatchDmlRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteBatchDmlRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteBatchDmlRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteBatchDmlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteBatchDmlRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteBatchDmlRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteBatchDmlRequest& from) {
    ExecuteBatchDmlRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteBatchDmlRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.ExecuteBatchDmlRequest";
  }
  protected:
  explicit ExecuteBatchDmlRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ExecuteBatchDmlRequest_Statement Statement;

  // accessors -------------------------------------------------------

  enum : int {
    kStatementsFieldNumber = 3,
    kSessionFieldNumber = 1,
    kTransactionFieldNumber = 2,
    kRequestOptionsFieldNumber = 5,
    kSeqnoFieldNumber = 4,
  };
  // repeated .google.spanner.v1.ExecuteBatchDmlRequest.Statement statements = 3 [(.google.api.field_behavior) = REQUIRED];
  int statements_size() const;
  private:
  int _internal_statements_size() const;
  public:
  void clear_statements();
  ::google::spanner::v1::ExecuteBatchDmlRequest_Statement* mutable_statements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::ExecuteBatchDmlRequest_Statement >*
      mutable_statements();
  private:
  const ::google::spanner::v1::ExecuteBatchDmlRequest_Statement& _internal_statements(int index) const;
  ::google::spanner::v1::ExecuteBatchDmlRequest_Statement* _internal_add_statements();
  public:
  const ::google::spanner::v1::ExecuteBatchDmlRequest_Statement& statements(int index) const;
  ::google::spanner::v1::ExecuteBatchDmlRequest_Statement* add_statements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::ExecuteBatchDmlRequest_Statement >&
      statements() const;

  // string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_session();
  const std::string& session() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session();
  PROTOBUF_NODISCARD std::string* release_session();
  void set_allocated_session(std::string* session);
  private:
  const std::string& _internal_session() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session(const std::string& value);
  std::string* _internal_mutable_session();
  public:

  // .google.spanner.v1.TransactionSelector transaction = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::google::spanner::v1::TransactionSelector& transaction() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::TransactionSelector* release_transaction();
  ::google::spanner::v1::TransactionSelector* mutable_transaction();
  void set_allocated_transaction(::google::spanner::v1::TransactionSelector* transaction);
  private:
  const ::google::spanner::v1::TransactionSelector& _internal_transaction() const;
  ::google::spanner::v1::TransactionSelector* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::google::spanner::v1::TransactionSelector* transaction);
  ::google::spanner::v1::TransactionSelector* unsafe_arena_release_transaction();

  // .google.spanner.v1.RequestOptions request_options = 5;
  bool has_request_options() const;
  private:
  bool _internal_has_request_options() const;
  public:
  void clear_request_options();
  const ::google::spanner::v1::RequestOptions& request_options() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::RequestOptions* release_request_options();
  ::google::spanner::v1::RequestOptions* mutable_request_options();
  void set_allocated_request_options(::google::spanner::v1::RequestOptions* request_options);
  private:
  const ::google::spanner::v1::RequestOptions& _internal_request_options() const;
  ::google::spanner::v1::RequestOptions* _internal_mutable_request_options();
  public:
  void unsafe_arena_set_allocated_request_options(
      ::google::spanner::v1::RequestOptions* request_options);
  ::google::spanner::v1::RequestOptions* unsafe_arena_release_request_options();

  // int64 seqno = 4 [(.google.api.field_behavior) = REQUIRED];
  void clear_seqno();
  int64_t seqno() const;
  void set_seqno(int64_t value);
  private:
  int64_t _internal_seqno() const;
  void _internal_set_seqno(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.v1.ExecuteBatchDmlRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::ExecuteBatchDmlRequest_Statement > statements_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_;
    ::google::spanner::v1::TransactionSelector* transaction_;
    ::google::spanner::v1::RequestOptions* request_options_;
    int64_t seqno_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class ExecuteBatchDmlResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.ExecuteBatchDmlResponse) */ {
 public:
  inline ExecuteBatchDmlResponse() : ExecuteBatchDmlResponse(nullptr) {}
  ~ExecuteBatchDmlResponse() override;
  explicit PROTOBUF_CONSTEXPR ExecuteBatchDmlResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteBatchDmlResponse(const ExecuteBatchDmlResponse& from);
  ExecuteBatchDmlResponse(ExecuteBatchDmlResponse&& from) noexcept
    : ExecuteBatchDmlResponse() {
    *this = ::std::move(from);
  }

  inline ExecuteBatchDmlResponse& operator=(const ExecuteBatchDmlResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteBatchDmlResponse& operator=(ExecuteBatchDmlResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteBatchDmlResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteBatchDmlResponse* internal_default_instance() {
    return reinterpret_cast<const ExecuteBatchDmlResponse*>(
               &_ExecuteBatchDmlResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ExecuteBatchDmlResponse& a, ExecuteBatchDmlResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteBatchDmlResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteBatchDmlResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteBatchDmlResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteBatchDmlResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteBatchDmlResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteBatchDmlResponse& from) {
    ExecuteBatchDmlResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteBatchDmlResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.ExecuteBatchDmlResponse";
  }
  protected:
  explicit ExecuteBatchDmlResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultSetsFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated .google.spanner.v1.ResultSet result_sets = 1;
  int result_sets_size() const;
  private:
  int _internal_result_sets_size() const;
  public:
  void clear_result_sets();
  ::google::spanner::v1::ResultSet* mutable_result_sets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::ResultSet >*
      mutable_result_sets();
  private:
  const ::google::spanner::v1::ResultSet& _internal_result_sets(int index) const;
  ::google::spanner::v1::ResultSet* _internal_add_result_sets();
  public:
  const ::google::spanner::v1::ResultSet& result_sets(int index) const;
  ::google::spanner::v1::ResultSet* add_result_sets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::ResultSet >&
      result_sets() const;

  // .google.rpc.Status status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::google::rpc::Status& status() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_status();
  ::google::rpc::Status* mutable_status();
  void set_allocated_status(::google::rpc::Status* status);
  private:
  const ::google::rpc::Status& _internal_status() const;
  ::google::rpc::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::google::rpc::Status* status);
  ::google::rpc::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:google.spanner.v1.ExecuteBatchDmlResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::ResultSet > result_sets_;
    ::google::rpc::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class PartitionOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.PartitionOptions) */ {
 public:
  inline PartitionOptions() : PartitionOptions(nullptr) {}
  ~PartitionOptions() override;
  explicit PROTOBUF_CONSTEXPR PartitionOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionOptions(const PartitionOptions& from);
  PartitionOptions(PartitionOptions&& from) noexcept
    : PartitionOptions() {
    *this = ::std::move(from);
  }

  inline PartitionOptions& operator=(const PartitionOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionOptions& operator=(PartitionOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionOptions* internal_default_instance() {
    return reinterpret_cast<const PartitionOptions*>(
               &_PartitionOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PartitionOptions& a, PartitionOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitionOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartitionOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PartitionOptions& from) {
    PartitionOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.PartitionOptions";
  }
  protected:
  explicit PartitionOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionSizeBytesFieldNumber = 1,
    kMaxPartitionsFieldNumber = 2,
  };
  // int64 partition_size_bytes = 1;
  void clear_partition_size_bytes();
  int64_t partition_size_bytes() const;
  void set_partition_size_bytes(int64_t value);
  private:
  int64_t _internal_partition_size_bytes() const;
  void _internal_set_partition_size_bytes(int64_t value);
  public:

  // int64 max_partitions = 2;
  void clear_max_partitions();
  int64_t max_partitions() const;
  void set_max_partitions(int64_t value);
  private:
  int64_t _internal_max_partitions() const;
  void _internal_set_max_partitions(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.v1.PartitionOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t partition_size_bytes_;
    int64_t max_partitions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class PartitionQueryRequest_ParamTypesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PartitionQueryRequest_ParamTypesEntry_DoNotUse, 
    std::string, ::google::spanner::v1::Type,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PartitionQueryRequest_ParamTypesEntry_DoNotUse, 
    std::string, ::google::spanner::v1::Type,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PartitionQueryRequest_ParamTypesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR PartitionQueryRequest_ParamTypesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PartitionQueryRequest_ParamTypesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PartitionQueryRequest_ParamTypesEntry_DoNotUse& other);
  static const PartitionQueryRequest_ParamTypesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PartitionQueryRequest_ParamTypesEntry_DoNotUse*>(&_PartitionQueryRequest_ParamTypesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.spanner.v1.PartitionQueryRequest.ParamTypesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};

// -------------------------------------------------------------------

class PartitionQueryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.PartitionQueryRequest) */ {
 public:
  inline PartitionQueryRequest() : PartitionQueryRequest(nullptr) {}
  ~PartitionQueryRequest() override;
  explicit PROTOBUF_CONSTEXPR PartitionQueryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionQueryRequest(const PartitionQueryRequest& from);
  PartitionQueryRequest(PartitionQueryRequest&& from) noexcept
    : PartitionQueryRequest() {
    *this = ::std::move(from);
  }

  inline PartitionQueryRequest& operator=(const PartitionQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionQueryRequest& operator=(PartitionQueryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionQueryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionQueryRequest* internal_default_instance() {
    return reinterpret_cast<const PartitionQueryRequest*>(
               &_PartitionQueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PartitionQueryRequest& a, PartitionQueryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionQueryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionQueryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitionQueryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartitionQueryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionQueryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PartitionQueryRequest& from) {
    PartitionQueryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionQueryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.PartitionQueryRequest";
  }
  protected:
  explicit PartitionQueryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParamTypesFieldNumber = 5,
    kSessionFieldNumber = 1,
    kSqlFieldNumber = 3,
    kTransactionFieldNumber = 2,
    kParamsFieldNumber = 4,
    kPartitionOptionsFieldNumber = 6,
  };
  // map<string, .google.spanner.v1.Type> param_types = 5;
  int param_types_size() const;
  private:
  int _internal_param_types_size() const;
  public:
  void clear_param_types();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >&
      _internal_param_types() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >*
      _internal_mutable_param_types();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >&
      param_types() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >*
      mutable_param_types();

  // string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_session();
  const std::string& session() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session();
  PROTOBUF_NODISCARD std::string* release_session();
  void set_allocated_session(std::string* session);
  private:
  const std::string& _internal_session() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session(const std::string& value);
  std::string* _internal_mutable_session();
  public:

  // string sql = 3 [(.google.api.field_behavior) = REQUIRED];
  void clear_sql();
  const std::string& sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sql();
  PROTOBUF_NODISCARD std::string* release_sql();
  void set_allocated_sql(std::string* sql);
  private:
  const std::string& _internal_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql(const std::string& value);
  std::string* _internal_mutable_sql();
  public:

  // .google.spanner.v1.TransactionSelector transaction = 2;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::google::spanner::v1::TransactionSelector& transaction() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::TransactionSelector* release_transaction();
  ::google::spanner::v1::TransactionSelector* mutable_transaction();
  void set_allocated_transaction(::google::spanner::v1::TransactionSelector* transaction);
  private:
  const ::google::spanner::v1::TransactionSelector& _internal_transaction() const;
  ::google::spanner::v1::TransactionSelector* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::google::spanner::v1::TransactionSelector* transaction);
  ::google::spanner::v1::TransactionSelector* unsafe_arena_release_transaction();

  // .google.protobuf.Struct params = 4;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::PROTOBUF_NAMESPACE_ID::Struct& params() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_params();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_params();
  void set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_params() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::PROTOBUF_NAMESPACE_ID::Struct* params);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_params();

  // .google.spanner.v1.PartitionOptions partition_options = 6;
  bool has_partition_options() const;
  private:
  bool _internal_has_partition_options() const;
  public:
  void clear_partition_options();
  const ::google::spanner::v1::PartitionOptions& partition_options() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::PartitionOptions* release_partition_options();
  ::google::spanner::v1::PartitionOptions* mutable_partition_options();
  void set_allocated_partition_options(::google::spanner::v1::PartitionOptions* partition_options);
  private:
  const ::google::spanner::v1::PartitionOptions& _internal_partition_options() const;
  ::google::spanner::v1::PartitionOptions* _internal_mutable_partition_options();
  public:
  void unsafe_arena_set_allocated_partition_options(
      ::google::spanner::v1::PartitionOptions* partition_options);
  ::google::spanner::v1::PartitionOptions* unsafe_arena_release_partition_options();

  // @@protoc_insertion_point(class_scope:google.spanner.v1.PartitionQueryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        PartitionQueryRequest_ParamTypesEntry_DoNotUse,
        std::string, ::google::spanner::v1::Type,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> param_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sql_;
    ::google::spanner::v1::TransactionSelector* transaction_;
    ::PROTOBUF_NAMESPACE_ID::Struct* params_;
    ::google::spanner::v1::PartitionOptions* partition_options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class PartitionReadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.PartitionReadRequest) */ {
 public:
  inline PartitionReadRequest() : PartitionReadRequest(nullptr) {}
  ~PartitionReadRequest() override;
  explicit PROTOBUF_CONSTEXPR PartitionReadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionReadRequest(const PartitionReadRequest& from);
  PartitionReadRequest(PartitionReadRequest&& from) noexcept
    : PartitionReadRequest() {
    *this = ::std::move(from);
  }

  inline PartitionReadRequest& operator=(const PartitionReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionReadRequest& operator=(PartitionReadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionReadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionReadRequest* internal_default_instance() {
    return reinterpret_cast<const PartitionReadRequest*>(
               &_PartitionReadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PartitionReadRequest& a, PartitionReadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionReadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionReadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitionReadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartitionReadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionReadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PartitionReadRequest& from) {
    PartitionReadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionReadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.PartitionReadRequest";
  }
  protected:
  explicit PartitionReadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 5,
    kSessionFieldNumber = 1,
    kTableFieldNumber = 3,
    kIndexFieldNumber = 4,
    kTransactionFieldNumber = 2,
    kKeySetFieldNumber = 6,
    kPartitionOptionsFieldNumber = 9,
  };
  // repeated string columns = 5;
  int columns_size() const;
  private:
  int _internal_columns_size() const;
  public:
  void clear_columns();
  const std::string& columns(int index) const;
  std::string* mutable_columns(int index);
  void set_columns(int index, const std::string& value);
  void set_columns(int index, std::string&& value);
  void set_columns(int index, const char* value);
  void set_columns(int index, const char* value, size_t size);
  std::string* add_columns();
  void add_columns(const std::string& value);
  void add_columns(std::string&& value);
  void add_columns(const char* value);
  void add_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns();
  private:
  const std::string& _internal_columns(int index) const;
  std::string* _internal_add_columns();
  public:

  // string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_session();
  const std::string& session() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session();
  PROTOBUF_NODISCARD std::string* release_session();
  void set_allocated_session(std::string* session);
  private:
  const std::string& _internal_session() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session(const std::string& value);
  std::string* _internal_mutable_session();
  public:

  // string table = 3 [(.google.api.field_behavior) = REQUIRED];
  void clear_table();
  const std::string& table() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table();
  PROTOBUF_NODISCARD std::string* release_table();
  void set_allocated_table(std::string* table);
  private:
  const std::string& _internal_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table(const std::string& value);
  std::string* _internal_mutable_table();
  public:

  // string index = 4;
  void clear_index();
  const std::string& index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index();
  PROTOBUF_NODISCARD std::string* release_index();
  void set_allocated_index(std::string* index);
  private:
  const std::string& _internal_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index(const std::string& value);
  std::string* _internal_mutable_index();
  public:

  // .google.spanner.v1.TransactionSelector transaction = 2;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::google::spanner::v1::TransactionSelector& transaction() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::TransactionSelector* release_transaction();
  ::google::spanner::v1::TransactionSelector* mutable_transaction();
  void set_allocated_transaction(::google::spanner::v1::TransactionSelector* transaction);
  private:
  const ::google::spanner::v1::TransactionSelector& _internal_transaction() const;
  ::google::spanner::v1::TransactionSelector* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::google::spanner::v1::TransactionSelector* transaction);
  ::google::spanner::v1::TransactionSelector* unsafe_arena_release_transaction();

  // .google.spanner.v1.KeySet key_set = 6 [(.google.api.field_behavior) = REQUIRED];
  bool has_key_set() const;
  private:
  bool _internal_has_key_set() const;
  public:
  void clear_key_set();
  const ::google::spanner::v1::KeySet& key_set() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::KeySet* release_key_set();
  ::google::spanner::v1::KeySet* mutable_key_set();
  void set_allocated_key_set(::google::spanner::v1::KeySet* key_set);
  private:
  const ::google::spanner::v1::KeySet& _internal_key_set() const;
  ::google::spanner::v1::KeySet* _internal_mutable_key_set();
  public:
  void unsafe_arena_set_allocated_key_set(
      ::google::spanner::v1::KeySet* key_set);
  ::google::spanner::v1::KeySet* unsafe_arena_release_key_set();

  // .google.spanner.v1.PartitionOptions partition_options = 9;
  bool has_partition_options() const;
  private:
  bool _internal_has_partition_options() const;
  public:
  void clear_partition_options();
  const ::google::spanner::v1::PartitionOptions& partition_options() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::PartitionOptions* release_partition_options();
  ::google::spanner::v1::PartitionOptions* mutable_partition_options();
  void set_allocated_partition_options(::google::spanner::v1::PartitionOptions* partition_options);
  private:
  const ::google::spanner::v1::PartitionOptions& _internal_partition_options() const;
  ::google::spanner::v1::PartitionOptions* _internal_mutable_partition_options();
  public:
  void unsafe_arena_set_allocated_partition_options(
      ::google::spanner::v1::PartitionOptions* partition_options);
  ::google::spanner::v1::PartitionOptions* unsafe_arena_release_partition_options();

  // @@protoc_insertion_point(class_scope:google.spanner.v1.PartitionReadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_;
    ::google::spanner::v1::TransactionSelector* transaction_;
    ::google::spanner::v1::KeySet* key_set_;
    ::google::spanner::v1::PartitionOptions* partition_options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class Partition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.Partition) */ {
 public:
  inline Partition() : Partition(nullptr) {}
  ~Partition() override;
  explicit PROTOBUF_CONSTEXPR Partition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Partition(const Partition& from);
  Partition(Partition&& from) noexcept
    : Partition() {
    *this = ::std::move(from);
  }

  inline Partition& operator=(const Partition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Partition& operator=(Partition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Partition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Partition* internal_default_instance() {
    return reinterpret_cast<const Partition*>(
               &_Partition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Partition& a, Partition& b) {
    a.Swap(&b);
  }
  inline void Swap(Partition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Partition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Partition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Partition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Partition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Partition& from) {
    Partition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Partition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.Partition";
  }
  protected:
  explicit Partition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionTokenFieldNumber = 1,
  };
  // bytes partition_token = 1;
  void clear_partition_token();
  const std::string& partition_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition_token();
  PROTOBUF_NODISCARD std::string* release_partition_token();
  void set_allocated_partition_token(std::string* partition_token);
  private:
  const std::string& _internal_partition_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_token(const std::string& value);
  std::string* _internal_mutable_partition_token();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.v1.Partition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class PartitionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.PartitionResponse) */ {
 public:
  inline PartitionResponse() : PartitionResponse(nullptr) {}
  ~PartitionResponse() override;
  explicit PROTOBUF_CONSTEXPR PartitionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionResponse(const PartitionResponse& from);
  PartitionResponse(PartitionResponse&& from) noexcept
    : PartitionResponse() {
    *this = ::std::move(from);
  }

  inline PartitionResponse& operator=(const PartitionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionResponse& operator=(PartitionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionResponse* internal_default_instance() {
    return reinterpret_cast<const PartitionResponse*>(
               &_PartitionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PartitionResponse& a, PartitionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartitionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PartitionResponse& from) {
    PartitionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.PartitionResponse";
  }
  protected:
  explicit PartitionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionsFieldNumber = 1,
    kTransactionFieldNumber = 2,
  };
  // repeated .google.spanner.v1.Partition partitions = 1;
  int partitions_size() const;
  private:
  int _internal_partitions_size() const;
  public:
  void clear_partitions();
  ::google::spanner::v1::Partition* mutable_partitions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Partition >*
      mutable_partitions();
  private:
  const ::google::spanner::v1::Partition& _internal_partitions(int index) const;
  ::google::spanner::v1::Partition* _internal_add_partitions();
  public:
  const ::google::spanner::v1::Partition& partitions(int index) const;
  ::google::spanner::v1::Partition* add_partitions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Partition >&
      partitions() const;

  // .google.spanner.v1.Transaction transaction = 2;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::google::spanner::v1::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::Transaction* release_transaction();
  ::google::spanner::v1::Transaction* mutable_transaction();
  void set_allocated_transaction(::google::spanner::v1::Transaction* transaction);
  private:
  const ::google::spanner::v1::Transaction& _internal_transaction() const;
  ::google::spanner::v1::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::google::spanner::v1::Transaction* transaction);
  ::google::spanner::v1::Transaction* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:google.spanner.v1.PartitionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Partition > partitions_;
    ::google::spanner::v1::Transaction* transaction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class ReadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.ReadRequest) */ {
 public:
  inline ReadRequest() : ReadRequest(nullptr) {}
  ~ReadRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadRequest(const ReadRequest& from);
  ReadRequest(ReadRequest&& from) noexcept
    : ReadRequest() {
    *this = ::std::move(from);
  }

  inline ReadRequest& operator=(const ReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRequest& operator=(ReadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadRequest* internal_default_instance() {
    return reinterpret_cast<const ReadRequest*>(
               &_ReadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ReadRequest& a, ReadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadRequest& from) {
    ReadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.ReadRequest";
  }
  protected:
  explicit ReadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 5,
    kSessionFieldNumber = 1,
    kTableFieldNumber = 3,
    kIndexFieldNumber = 4,
    kResumeTokenFieldNumber = 9,
    kPartitionTokenFieldNumber = 10,
    kTransactionFieldNumber = 2,
    kKeySetFieldNumber = 6,
    kRequestOptionsFieldNumber = 11,
    kLimitFieldNumber = 8,
  };
  // repeated string columns = 5 [(.google.api.field_behavior) = REQUIRED];
  int columns_size() const;
  private:
  int _internal_columns_size() const;
  public:
  void clear_columns();
  const std::string& columns(int index) const;
  std::string* mutable_columns(int index);
  void set_columns(int index, const std::string& value);
  void set_columns(int index, std::string&& value);
  void set_columns(int index, const char* value);
  void set_columns(int index, const char* value, size_t size);
  std::string* add_columns();
  void add_columns(const std::string& value);
  void add_columns(std::string&& value);
  void add_columns(const char* value);
  void add_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns();
  private:
  const std::string& _internal_columns(int index) const;
  std::string* _internal_add_columns();
  public:

  // string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_session();
  const std::string& session() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session();
  PROTOBUF_NODISCARD std::string* release_session();
  void set_allocated_session(std::string* session);
  private:
  const std::string& _internal_session() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session(const std::string& value);
  std::string* _internal_mutable_session();
  public:

  // string table = 3 [(.google.api.field_behavior) = REQUIRED];
  void clear_table();
  const std::string& table() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table();
  PROTOBUF_NODISCARD std::string* release_table();
  void set_allocated_table(std::string* table);
  private:
  const std::string& _internal_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table(const std::string& value);
  std::string* _internal_mutable_table();
  public:

  // string index = 4;
  void clear_index();
  const std::string& index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index();
  PROTOBUF_NODISCARD std::string* release_index();
  void set_allocated_index(std::string* index);
  private:
  const std::string& _internal_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index(const std::string& value);
  std::string* _internal_mutable_index();
  public:

  // bytes resume_token = 9;
  void clear_resume_token();
  const std::string& resume_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resume_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resume_token();
  PROTOBUF_NODISCARD std::string* release_resume_token();
  void set_allocated_resume_token(std::string* resume_token);
  private:
  const std::string& _internal_resume_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resume_token(const std::string& value);
  std::string* _internal_mutable_resume_token();
  public:

  // bytes partition_token = 10;
  void clear_partition_token();
  const std::string& partition_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition_token();
  PROTOBUF_NODISCARD std::string* release_partition_token();
  void set_allocated_partition_token(std::string* partition_token);
  private:
  const std::string& _internal_partition_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_token(const std::string& value);
  std::string* _internal_mutable_partition_token();
  public:

  // .google.spanner.v1.TransactionSelector transaction = 2;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::google::spanner::v1::TransactionSelector& transaction() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::TransactionSelector* release_transaction();
  ::google::spanner::v1::TransactionSelector* mutable_transaction();
  void set_allocated_transaction(::google::spanner::v1::TransactionSelector* transaction);
  private:
  const ::google::spanner::v1::TransactionSelector& _internal_transaction() const;
  ::google::spanner::v1::TransactionSelector* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::google::spanner::v1::TransactionSelector* transaction);
  ::google::spanner::v1::TransactionSelector* unsafe_arena_release_transaction();

  // .google.spanner.v1.KeySet key_set = 6 [(.google.api.field_behavior) = REQUIRED];
  bool has_key_set() const;
  private:
  bool _internal_has_key_set() const;
  public:
  void clear_key_set();
  const ::google::spanner::v1::KeySet& key_set() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::KeySet* release_key_set();
  ::google::spanner::v1::KeySet* mutable_key_set();
  void set_allocated_key_set(::google::spanner::v1::KeySet* key_set);
  private:
  const ::google::spanner::v1::KeySet& _internal_key_set() const;
  ::google::spanner::v1::KeySet* _internal_mutable_key_set();
  public:
  void unsafe_arena_set_allocated_key_set(
      ::google::spanner::v1::KeySet* key_set);
  ::google::spanner::v1::KeySet* unsafe_arena_release_key_set();

  // .google.spanner.v1.RequestOptions request_options = 11;
  bool has_request_options() const;
  private:
  bool _internal_has_request_options() const;
  public:
  void clear_request_options();
  const ::google::spanner::v1::RequestOptions& request_options() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::RequestOptions* release_request_options();
  ::google::spanner::v1::RequestOptions* mutable_request_options();
  void set_allocated_request_options(::google::spanner::v1::RequestOptions* request_options);
  private:
  const ::google::spanner::v1::RequestOptions& _internal_request_options() const;
  ::google::spanner::v1::RequestOptions* _internal_mutable_request_options();
  public:
  void unsafe_arena_set_allocated_request_options(
      ::google::spanner::v1::RequestOptions* request_options);
  ::google::spanner::v1::RequestOptions* unsafe_arena_release_request_options();

  // int64 limit = 8;
  void clear_limit();
  int64_t limit() const;
  void set_limit(int64_t value);
  private:
  int64_t _internal_limit() const;
  void _internal_set_limit(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.v1.ReadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resume_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_token_;
    ::google::spanner::v1::TransactionSelector* transaction_;
    ::google::spanner::v1::KeySet* key_set_;
    ::google::spanner::v1::RequestOptions* request_options_;
    int64_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class BeginTransactionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.BeginTransactionRequest) */ {
 public:
  inline BeginTransactionRequest() : BeginTransactionRequest(nullptr) {}
  ~BeginTransactionRequest() override;
  explicit PROTOBUF_CONSTEXPR BeginTransactionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeginTransactionRequest(const BeginTransactionRequest& from);
  BeginTransactionRequest(BeginTransactionRequest&& from) noexcept
    : BeginTransactionRequest() {
    *this = ::std::move(from);
  }

  inline BeginTransactionRequest& operator=(const BeginTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeginTransactionRequest& operator=(BeginTransactionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeginTransactionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeginTransactionRequest* internal_default_instance() {
    return reinterpret_cast<const BeginTransactionRequest*>(
               &_BeginTransactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(BeginTransactionRequest& a, BeginTransactionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BeginTransactionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeginTransactionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeginTransactionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeginTransactionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeginTransactionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeginTransactionRequest& from) {
    BeginTransactionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeginTransactionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.BeginTransactionRequest";
  }
  protected:
  explicit BeginTransactionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 1,
    kOptionsFieldNumber = 2,
    kRequestOptionsFieldNumber = 3,
  };
  // string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_session();
  const std::string& session() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session();
  PROTOBUF_NODISCARD std::string* release_session();
  void set_allocated_session(std::string* session);
  private:
  const std::string& _internal_session() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session(const std::string& value);
  std::string* _internal_mutable_session();
  public:

  // .google.spanner.v1.TransactionOptions options = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::google::spanner::v1::TransactionOptions& options() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::TransactionOptions* release_options();
  ::google::spanner::v1::TransactionOptions* mutable_options();
  void set_allocated_options(::google::spanner::v1::TransactionOptions* options);
  private:
  const ::google::spanner::v1::TransactionOptions& _internal_options() const;
  ::google::spanner::v1::TransactionOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::google::spanner::v1::TransactionOptions* options);
  ::google::spanner::v1::TransactionOptions* unsafe_arena_release_options();

  // .google.spanner.v1.RequestOptions request_options = 3;
  bool has_request_options() const;
  private:
  bool _internal_has_request_options() const;
  public:
  void clear_request_options();
  const ::google::spanner::v1::RequestOptions& request_options() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::RequestOptions* release_request_options();
  ::google::spanner::v1::RequestOptions* mutable_request_options();
  void set_allocated_request_options(::google::spanner::v1::RequestOptions* request_options);
  private:
  const ::google::spanner::v1::RequestOptions& _internal_request_options() const;
  ::google::spanner::v1::RequestOptions* _internal_mutable_request_options();
  public:
  void unsafe_arena_set_allocated_request_options(
      ::google::spanner::v1::RequestOptions* request_options);
  ::google::spanner::v1::RequestOptions* unsafe_arena_release_request_options();

  // @@protoc_insertion_point(class_scope:google.spanner.v1.BeginTransactionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_;
    ::google::spanner::v1::TransactionOptions* options_;
    ::google::spanner::v1::RequestOptions* request_options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class CommitRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.CommitRequest) */ {
 public:
  inline CommitRequest() : CommitRequest(nullptr) {}
  ~CommitRequest() override;
  explicit PROTOBUF_CONSTEXPR CommitRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommitRequest(const CommitRequest& from);
  CommitRequest(CommitRequest&& from) noexcept
    : CommitRequest() {
    *this = ::std::move(from);
  }

  inline CommitRequest& operator=(const CommitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitRequest& operator=(CommitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommitRequest& default_instance() {
    return *internal_default_instance();
  }
  enum TransactionCase {
    kTransactionId = 2,
    kSingleUseTransaction = 3,
    TRANSACTION_NOT_SET = 0,
  };

  static inline const CommitRequest* internal_default_instance() {
    return reinterpret_cast<const CommitRequest*>(
               &_CommitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CommitRequest& a, CommitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CommitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommitRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommitRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommitRequest& from) {
    CommitRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommitRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.CommitRequest";
  }
  protected:
  explicit CommitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMutationsFieldNumber = 4,
    kSessionFieldNumber = 1,
    kRequestOptionsFieldNumber = 6,
    kReturnCommitStatsFieldNumber = 5,
    kTransactionIdFieldNumber = 2,
    kSingleUseTransactionFieldNumber = 3,
  };
  // repeated .google.spanner.v1.Mutation mutations = 4;
  int mutations_size() const;
  private:
  int _internal_mutations_size() const;
  public:
  void clear_mutations();
  ::google::spanner::v1::Mutation* mutable_mutations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Mutation >*
      mutable_mutations();
  private:
  const ::google::spanner::v1::Mutation& _internal_mutations(int index) const;
  ::google::spanner::v1::Mutation* _internal_add_mutations();
  public:
  const ::google::spanner::v1::Mutation& mutations(int index) const;
  ::google::spanner::v1::Mutation* add_mutations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Mutation >&
      mutations() const;

  // string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_session();
  const std::string& session() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session();
  PROTOBUF_NODISCARD std::string* release_session();
  void set_allocated_session(std::string* session);
  private:
  const std::string& _internal_session() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session(const std::string& value);
  std::string* _internal_mutable_session();
  public:

  // .google.spanner.v1.RequestOptions request_options = 6;
  bool has_request_options() const;
  private:
  bool _internal_has_request_options() const;
  public:
  void clear_request_options();
  const ::google::spanner::v1::RequestOptions& request_options() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::RequestOptions* release_request_options();
  ::google::spanner::v1::RequestOptions* mutable_request_options();
  void set_allocated_request_options(::google::spanner::v1::RequestOptions* request_options);
  private:
  const ::google::spanner::v1::RequestOptions& _internal_request_options() const;
  ::google::spanner::v1::RequestOptions* _internal_mutable_request_options();
  public:
  void unsafe_arena_set_allocated_request_options(
      ::google::spanner::v1::RequestOptions* request_options);
  ::google::spanner::v1::RequestOptions* unsafe_arena_release_request_options();

  // bool return_commit_stats = 5;
  void clear_return_commit_stats();
  bool return_commit_stats() const;
  void set_return_commit_stats(bool value);
  private:
  bool _internal_return_commit_stats() const;
  void _internal_set_return_commit_stats(bool value);
  public:

  // bytes transaction_id = 2;
  bool has_transaction_id() const;
  private:
  bool _internal_has_transaction_id() const;
  public:
  void clear_transaction_id();
  const std::string& transaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transaction_id();
  PROTOBUF_NODISCARD std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* transaction_id);
  private:
  const std::string& _internal_transaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();
  public:

  // .google.spanner.v1.TransactionOptions single_use_transaction = 3;
  bool has_single_use_transaction() const;
  private:
  bool _internal_has_single_use_transaction() const;
  public:
  void clear_single_use_transaction();
  const ::google::spanner::v1::TransactionOptions& single_use_transaction() const;
  PROTOBUF_NODISCARD ::google::spanner::v1::TransactionOptions* release_single_use_transaction();
  ::google::spanner::v1::TransactionOptions* mutable_single_use_transaction();
  void set_allocated_single_use_transaction(::google::spanner::v1::TransactionOptions* single_use_transaction);
  private:
  const ::google::spanner::v1::TransactionOptions& _internal_single_use_transaction() const;
  ::google::spanner::v1::TransactionOptions* _internal_mutable_single_use_transaction();
  public:
  void unsafe_arena_set_allocated_single_use_transaction(
      ::google::spanner::v1::TransactionOptions* single_use_transaction);
  ::google::spanner::v1::TransactionOptions* unsafe_arena_release_single_use_transaction();

  void clear_transaction();
  TransactionCase transaction_case() const;
  // @@protoc_insertion_point(class_scope:google.spanner.v1.CommitRequest)
 private:
  class _Internal;
  void set_has_transaction_id();
  void set_has_single_use_transaction();

  inline bool has_transaction() const;
  inline void clear_has_transaction();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Mutation > mutations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_;
    ::google::spanner::v1::RequestOptions* request_options_;
    bool return_commit_stats_;
    union TransactionUnion {
      constexpr TransactionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_id_;
      ::google::spanner::v1::TransactionOptions* single_use_transaction_;
    } transaction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// -------------------------------------------------------------------

class RollbackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.RollbackRequest) */ {
 public:
  inline RollbackRequest() : RollbackRequest(nullptr) {}
  ~RollbackRequest() override;
  explicit PROTOBUF_CONSTEXPR RollbackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RollbackRequest(const RollbackRequest& from);
  RollbackRequest(RollbackRequest&& from) noexcept
    : RollbackRequest() {
    *this = ::std::move(from);
  }

  inline RollbackRequest& operator=(const RollbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RollbackRequest& operator=(RollbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RollbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RollbackRequest* internal_default_instance() {
    return reinterpret_cast<const RollbackRequest*>(
               &_RollbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(RollbackRequest& a, RollbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RollbackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RollbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RollbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RollbackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RollbackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RollbackRequest& from) {
    RollbackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RollbackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.v1.RollbackRequest";
  }
  protected:
  explicit RollbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 1,
    kTransactionIdFieldNumber = 2,
  };
  // string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_session();
  const std::string& session() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session();
  PROTOBUF_NODISCARD std::string* release_session();
  void set_allocated_session(std::string* session);
  private:
  const std::string& _internal_session() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session(const std::string& value);
  std::string* _internal_mutable_session();
  public:

  // bytes transaction_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_transaction_id();
  const std::string& transaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transaction_id();
  PROTOBUF_NODISCARD std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* transaction_id);
  private:
  const std::string& _internal_transaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.v1.RollbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fv1_2fspanner_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateSessionRequest

// string database = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CreateSessionRequest::clear_database() {
  _impl_.database_.ClearToEmpty();
}
inline const std::string& CreateSessionRequest::database() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.CreateSessionRequest.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSessionRequest::set_database(ArgT0&& arg0, ArgT... args) {
 
 _impl_.database_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.CreateSessionRequest.database)
}
inline std::string* CreateSessionRequest::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.CreateSessionRequest.database)
  return _s;
}
inline const std::string& CreateSessionRequest::_internal_database() const {
  return _impl_.database_.Get();
}
inline void CreateSessionRequest::_internal_set_database(const std::string& value) {
  
  _impl_.database_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSessionRequest::_internal_mutable_database() {
  
  return _impl_.database_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSessionRequest::release_database() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.CreateSessionRequest.database)
  return _impl_.database_.Release();
}
inline void CreateSessionRequest::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    
  } else {
    
  }
  _impl_.database_.SetAllocated(database, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.database_.IsDefault()) {
    _impl_.database_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.CreateSessionRequest.database)
}

// .google.spanner.v1.Session session = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateSessionRequest::_internal_has_session() const {
  return this != internal_default_instance() && _impl_.session_ != nullptr;
}
inline bool CreateSessionRequest::has_session() const {
  return _internal_has_session();
}
inline void CreateSessionRequest::clear_session() {
  if (GetArenaForAllocation() == nullptr && _impl_.session_ != nullptr) {
    delete _impl_.session_;
  }
  _impl_.session_ = nullptr;
}
inline const ::google::spanner::v1::Session& CreateSessionRequest::_internal_session() const {
  const ::google::spanner::v1::Session* p = _impl_.session_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::Session&>(
      ::google::spanner::v1::_Session_default_instance_);
}
inline const ::google::spanner::v1::Session& CreateSessionRequest::session() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.CreateSessionRequest.session)
  return _internal_session();
}
inline void CreateSessionRequest::unsafe_arena_set_allocated_session(
    ::google::spanner::v1::Session* session) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_);
  }
  _impl_.session_ = session;
  if (session) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.CreateSessionRequest.session)
}
inline ::google::spanner::v1::Session* CreateSessionRequest::release_session() {
  
  ::google::spanner::v1::Session* temp = _impl_.session_;
  _impl_.session_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::Session* CreateSessionRequest::unsafe_arena_release_session() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.CreateSessionRequest.session)
  
  ::google::spanner::v1::Session* temp = _impl_.session_;
  _impl_.session_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::Session* CreateSessionRequest::_internal_mutable_session() {
  
  if (_impl_.session_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::Session>(GetArenaForAllocation());
    _impl_.session_ = p;
  }
  return _impl_.session_;
}
inline ::google::spanner::v1::Session* CreateSessionRequest::mutable_session() {
  ::google::spanner::v1::Session* _msg = _internal_mutable_session();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.CreateSessionRequest.session)
  return _msg;
}
inline void CreateSessionRequest::set_allocated_session(::google::spanner::v1::Session* session) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.session_;
  }
  if (session) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session);
    if (message_arena != submessage_arena) {
      session = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.session_ = session;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.CreateSessionRequest.session)
}

// -------------------------------------------------------------------

// BatchCreateSessionsRequest

// string database = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void BatchCreateSessionsRequest::clear_database() {
  _impl_.database_.ClearToEmpty();
}
inline const std::string& BatchCreateSessionsRequest::database() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.BatchCreateSessionsRequest.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatchCreateSessionsRequest::set_database(ArgT0&& arg0, ArgT... args) {
 
 _impl_.database_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.BatchCreateSessionsRequest.database)
}
inline std::string* BatchCreateSessionsRequest::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.BatchCreateSessionsRequest.database)
  return _s;
}
inline const std::string& BatchCreateSessionsRequest::_internal_database() const {
  return _impl_.database_.Get();
}
inline void BatchCreateSessionsRequest::_internal_set_database(const std::string& value) {
  
  _impl_.database_.Set(value, GetArenaForAllocation());
}
inline std::string* BatchCreateSessionsRequest::_internal_mutable_database() {
  
  return _impl_.database_.Mutable(GetArenaForAllocation());
}
inline std::string* BatchCreateSessionsRequest::release_database() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.BatchCreateSessionsRequest.database)
  return _impl_.database_.Release();
}
inline void BatchCreateSessionsRequest::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    
  } else {
    
  }
  _impl_.database_.SetAllocated(database, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.database_.IsDefault()) {
    _impl_.database_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.BatchCreateSessionsRequest.database)
}

// .google.spanner.v1.Session session_template = 2;
inline bool BatchCreateSessionsRequest::_internal_has_session_template() const {
  return this != internal_default_instance() && _impl_.session_template_ != nullptr;
}
inline bool BatchCreateSessionsRequest::has_session_template() const {
  return _internal_has_session_template();
}
inline void BatchCreateSessionsRequest::clear_session_template() {
  if (GetArenaForAllocation() == nullptr && _impl_.session_template_ != nullptr) {
    delete _impl_.session_template_;
  }
  _impl_.session_template_ = nullptr;
}
inline const ::google::spanner::v1::Session& BatchCreateSessionsRequest::_internal_session_template() const {
  const ::google::spanner::v1::Session* p = _impl_.session_template_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::Session&>(
      ::google::spanner::v1::_Session_default_instance_);
}
inline const ::google::spanner::v1::Session& BatchCreateSessionsRequest::session_template() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.BatchCreateSessionsRequest.session_template)
  return _internal_session_template();
}
inline void BatchCreateSessionsRequest::unsafe_arena_set_allocated_session_template(
    ::google::spanner::v1::Session* session_template) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_template_);
  }
  _impl_.session_template_ = session_template;
  if (session_template) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.BatchCreateSessionsRequest.session_template)
}
inline ::google::spanner::v1::Session* BatchCreateSessionsRequest::release_session_template() {
  
  ::google::spanner::v1::Session* temp = _impl_.session_template_;
  _impl_.session_template_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::Session* BatchCreateSessionsRequest::unsafe_arena_release_session_template() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.BatchCreateSessionsRequest.session_template)
  
  ::google::spanner::v1::Session* temp = _impl_.session_template_;
  _impl_.session_template_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::Session* BatchCreateSessionsRequest::_internal_mutable_session_template() {
  
  if (_impl_.session_template_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::Session>(GetArenaForAllocation());
    _impl_.session_template_ = p;
  }
  return _impl_.session_template_;
}
inline ::google::spanner::v1::Session* BatchCreateSessionsRequest::mutable_session_template() {
  ::google::spanner::v1::Session* _msg = _internal_mutable_session_template();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.BatchCreateSessionsRequest.session_template)
  return _msg;
}
inline void BatchCreateSessionsRequest::set_allocated_session_template(::google::spanner::v1::Session* session_template) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.session_template_;
  }
  if (session_template) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session_template);
    if (message_arena != submessage_arena) {
      session_template = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_template, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.session_template_ = session_template;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.BatchCreateSessionsRequest.session_template)
}

// int32 session_count = 3 [(.google.api.field_behavior) = REQUIRED];
inline void BatchCreateSessionsRequest::clear_session_count() {
  _impl_.session_count_ = 0;
}
inline int32_t BatchCreateSessionsRequest::_internal_session_count() const {
  return _impl_.session_count_;
}
inline int32_t BatchCreateSessionsRequest::session_count() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.BatchCreateSessionsRequest.session_count)
  return _internal_session_count();
}
inline void BatchCreateSessionsRequest::_internal_set_session_count(int32_t value) {
  
  _impl_.session_count_ = value;
}
inline void BatchCreateSessionsRequest::set_session_count(int32_t value) {
  _internal_set_session_count(value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.BatchCreateSessionsRequest.session_count)
}

// -------------------------------------------------------------------

// BatchCreateSessionsResponse

// repeated .google.spanner.v1.Session session = 1;
inline int BatchCreateSessionsResponse::_internal_session_size() const {
  return _impl_.session_.size();
}
inline int BatchCreateSessionsResponse::session_size() const {
  return _internal_session_size();
}
inline void BatchCreateSessionsResponse::clear_session() {
  _impl_.session_.Clear();
}
inline ::google::spanner::v1::Session* BatchCreateSessionsResponse::mutable_session(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.BatchCreateSessionsResponse.session)
  return _impl_.session_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Session >*
BatchCreateSessionsResponse::mutable_session() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.v1.BatchCreateSessionsResponse.session)
  return &_impl_.session_;
}
inline const ::google::spanner::v1::Session& BatchCreateSessionsResponse::_internal_session(int index) const {
  return _impl_.session_.Get(index);
}
inline const ::google::spanner::v1::Session& BatchCreateSessionsResponse::session(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.BatchCreateSessionsResponse.session)
  return _internal_session(index);
}
inline ::google::spanner::v1::Session* BatchCreateSessionsResponse::_internal_add_session() {
  return _impl_.session_.Add();
}
inline ::google::spanner::v1::Session* BatchCreateSessionsResponse::add_session() {
  ::google::spanner::v1::Session* _add = _internal_add_session();
  // @@protoc_insertion_point(field_add:google.spanner.v1.BatchCreateSessionsResponse.session)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Session >&
BatchCreateSessionsResponse::session() const {
  // @@protoc_insertion_point(field_list:google.spanner.v1.BatchCreateSessionsResponse.session)
  return _impl_.session_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Session

// string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Session::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Session::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.Session.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Session::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.Session.name)
}
inline std::string* Session::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.Session.name)
  return _s;
}
inline const std::string& Session::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Session::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.Session.name)
  return _impl_.name_.Release();
}
inline void Session::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.Session.name)
}

// map<string, string> labels = 2;
inline int Session::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int Session::labels_size() const {
  return _internal_labels_size();
}
inline void Session::clear_labels() {
  _impl_.labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Session::_internal_labels() const {
  return _impl_.labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Session::labels() const {
  // @@protoc_insertion_point(field_map:google.spanner.v1.Session.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Session::_internal_mutable_labels() {
  return _impl_.labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Session::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:google.spanner.v1.Session.labels)
  return _internal_mutable_labels();
}

// .google.protobuf.Timestamp create_time = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Session::_internal_has_create_time() const {
  return this != internal_default_instance() && _impl_.create_time_ != nullptr;
}
inline bool Session::has_create_time() const {
  return _internal_has_create_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Session::_internal_create_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.create_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Session::create_time() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.Session.create_time)
  return _internal_create_time();
}
inline void Session::unsafe_arena_set_allocated_create_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  _impl_.create_time_ = create_time;
  if (create_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.Session.create_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::release_create_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::unsafe_arena_release_create_time() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.Session.create_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::_internal_mutable_create_time() {
  
  if (_impl_.create_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.create_time_ = p;
  }
  return _impl_.create_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::mutable_create_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.Session.create_time)
  return _msg;
}
inline void Session::set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  if (create_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time));
    if (message_arena != submessage_arena) {
      create_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.Session.create_time)
}

// .google.protobuf.Timestamp approximate_last_use_time = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Session::_internal_has_approximate_last_use_time() const {
  return this != internal_default_instance() && _impl_.approximate_last_use_time_ != nullptr;
}
inline bool Session::has_approximate_last_use_time() const {
  return _internal_has_approximate_last_use_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Session::_internal_approximate_last_use_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.approximate_last_use_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Session::approximate_last_use_time() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.Session.approximate_last_use_time)
  return _internal_approximate_last_use_time();
}
inline void Session::unsafe_arena_set_allocated_approximate_last_use_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* approximate_last_use_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.approximate_last_use_time_);
  }
  _impl_.approximate_last_use_time_ = approximate_last_use_time;
  if (approximate_last_use_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.Session.approximate_last_use_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::release_approximate_last_use_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.approximate_last_use_time_;
  _impl_.approximate_last_use_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::unsafe_arena_release_approximate_last_use_time() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.Session.approximate_last_use_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.approximate_last_use_time_;
  _impl_.approximate_last_use_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::_internal_mutable_approximate_last_use_time() {
  
  if (_impl_.approximate_last_use_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.approximate_last_use_time_ = p;
  }
  return _impl_.approximate_last_use_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::mutable_approximate_last_use_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_approximate_last_use_time();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.Session.approximate_last_use_time)
  return _msg;
}
inline void Session::set_allocated_approximate_last_use_time(::PROTOBUF_NAMESPACE_ID::Timestamp* approximate_last_use_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.approximate_last_use_time_);
  }
  if (approximate_last_use_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(approximate_last_use_time));
    if (message_arena != submessage_arena) {
      approximate_last_use_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, approximate_last_use_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.approximate_last_use_time_ = approximate_last_use_time;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.Session.approximate_last_use_time)
}

// string creator_role = 5;
inline void Session::clear_creator_role() {
  _impl_.creator_role_.ClearToEmpty();
}
inline const std::string& Session::creator_role() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.Session.creator_role)
  return _internal_creator_role();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Session::set_creator_role(ArgT0&& arg0, ArgT... args) {
 
 _impl_.creator_role_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.Session.creator_role)
}
inline std::string* Session::mutable_creator_role() {
  std::string* _s = _internal_mutable_creator_role();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.Session.creator_role)
  return _s;
}
inline const std::string& Session::_internal_creator_role() const {
  return _impl_.creator_role_.Get();
}
inline void Session::_internal_set_creator_role(const std::string& value) {
  
  _impl_.creator_role_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_creator_role() {
  
  return _impl_.creator_role_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_creator_role() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.Session.creator_role)
  return _impl_.creator_role_.Release();
}
inline void Session::set_allocated_creator_role(std::string* creator_role) {
  if (creator_role != nullptr) {
    
  } else {
    
  }
  _impl_.creator_role_.SetAllocated(creator_role, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creator_role_.IsDefault()) {
    _impl_.creator_role_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.Session.creator_role)
}

// -------------------------------------------------------------------

// GetSessionRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetSessionRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetSessionRequest::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.GetSessionRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSessionRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.GetSessionRequest.name)
}
inline std::string* GetSessionRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.GetSessionRequest.name)
  return _s;
}
inline const std::string& GetSessionRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetSessionRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSessionRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSessionRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.GetSessionRequest.name)
  return _impl_.name_.Release();
}
inline void GetSessionRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.GetSessionRequest.name)
}

// -------------------------------------------------------------------

// ListSessionsRequest

// string database = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListSessionsRequest::clear_database() {
  _impl_.database_.ClearToEmpty();
}
inline const std::string& ListSessionsRequest::database() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ListSessionsRequest.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListSessionsRequest::set_database(ArgT0&& arg0, ArgT... args) {
 
 _impl_.database_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ListSessionsRequest.database)
}
inline std::string* ListSessionsRequest::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ListSessionsRequest.database)
  return _s;
}
inline const std::string& ListSessionsRequest::_internal_database() const {
  return _impl_.database_.Get();
}
inline void ListSessionsRequest::_internal_set_database(const std::string& value) {
  
  _impl_.database_.Set(value, GetArenaForAllocation());
}
inline std::string* ListSessionsRequest::_internal_mutable_database() {
  
  return _impl_.database_.Mutable(GetArenaForAllocation());
}
inline std::string* ListSessionsRequest::release_database() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ListSessionsRequest.database)
  return _impl_.database_.Release();
}
inline void ListSessionsRequest::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    
  } else {
    
  }
  _impl_.database_.SetAllocated(database, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.database_.IsDefault()) {
    _impl_.database_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ListSessionsRequest.database)
}

// int32 page_size = 2;
inline void ListSessionsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListSessionsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListSessionsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ListSessionsRequest.page_size)
  return _internal_page_size();
}
inline void ListSessionsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListSessionsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.ListSessionsRequest.page_size)
}

// string page_token = 3;
inline void ListSessionsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListSessionsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ListSessionsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListSessionsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ListSessionsRequest.page_token)
}
inline std::string* ListSessionsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ListSessionsRequest.page_token)
  return _s;
}
inline const std::string& ListSessionsRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListSessionsRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListSessionsRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListSessionsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ListSessionsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListSessionsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ListSessionsRequest.page_token)
}

// string filter = 4;
inline void ListSessionsRequest::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& ListSessionsRequest::filter() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ListSessionsRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListSessionsRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ListSessionsRequest.filter)
}
inline std::string* ListSessionsRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ListSessionsRequest.filter)
  return _s;
}
inline const std::string& ListSessionsRequest::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void ListSessionsRequest::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* ListSessionsRequest::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* ListSessionsRequest::release_filter() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ListSessionsRequest.filter)
  return _impl_.filter_.Release();
}
inline void ListSessionsRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ListSessionsRequest.filter)
}

// -------------------------------------------------------------------

// ListSessionsResponse

// repeated .google.spanner.v1.Session sessions = 1;
inline int ListSessionsResponse::_internal_sessions_size() const {
  return _impl_.sessions_.size();
}
inline int ListSessionsResponse::sessions_size() const {
  return _internal_sessions_size();
}
inline void ListSessionsResponse::clear_sessions() {
  _impl_.sessions_.Clear();
}
inline ::google::spanner::v1::Session* ListSessionsResponse::mutable_sessions(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ListSessionsResponse.sessions)
  return _impl_.sessions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Session >*
ListSessionsResponse::mutable_sessions() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.v1.ListSessionsResponse.sessions)
  return &_impl_.sessions_;
}
inline const ::google::spanner::v1::Session& ListSessionsResponse::_internal_sessions(int index) const {
  return _impl_.sessions_.Get(index);
}
inline const ::google::spanner::v1::Session& ListSessionsResponse::sessions(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ListSessionsResponse.sessions)
  return _internal_sessions(index);
}
inline ::google::spanner::v1::Session* ListSessionsResponse::_internal_add_sessions() {
  return _impl_.sessions_.Add();
}
inline ::google::spanner::v1::Session* ListSessionsResponse::add_sessions() {
  ::google::spanner::v1::Session* _add = _internal_add_sessions();
  // @@protoc_insertion_point(field_add:google.spanner.v1.ListSessionsResponse.sessions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Session >&
ListSessionsResponse::sessions() const {
  // @@protoc_insertion_point(field_list:google.spanner.v1.ListSessionsResponse.sessions)
  return _impl_.sessions_;
}

// string next_page_token = 2;
inline void ListSessionsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListSessionsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ListSessionsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListSessionsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ListSessionsResponse.next_page_token)
}
inline std::string* ListSessionsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ListSessionsResponse.next_page_token)
  return _s;
}
inline const std::string& ListSessionsResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListSessionsResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListSessionsResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListSessionsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ListSessionsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListSessionsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ListSessionsResponse.next_page_token)
}

// -------------------------------------------------------------------

// DeleteSessionRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteSessionRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteSessionRequest::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.DeleteSessionRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteSessionRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.DeleteSessionRequest.name)
}
inline std::string* DeleteSessionRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.DeleteSessionRequest.name)
  return _s;
}
inline const std::string& DeleteSessionRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteSessionRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteSessionRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteSessionRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.DeleteSessionRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteSessionRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.DeleteSessionRequest.name)
}

// -------------------------------------------------------------------

// RequestOptions

// .google.spanner.v1.RequestOptions.Priority priority = 1;
inline void RequestOptions::clear_priority() {
  _impl_.priority_ = 0;
}
inline ::google::spanner::v1::RequestOptions_Priority RequestOptions::_internal_priority() const {
  return static_cast< ::google::spanner::v1::RequestOptions_Priority >(_impl_.priority_);
}
inline ::google::spanner::v1::RequestOptions_Priority RequestOptions::priority() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.RequestOptions.priority)
  return _internal_priority();
}
inline void RequestOptions::_internal_set_priority(::google::spanner::v1::RequestOptions_Priority value) {
  
  _impl_.priority_ = value;
}
inline void RequestOptions::set_priority(::google::spanner::v1::RequestOptions_Priority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.RequestOptions.priority)
}

// string request_tag = 2;
inline void RequestOptions::clear_request_tag() {
  _impl_.request_tag_.ClearToEmpty();
}
inline const std::string& RequestOptions::request_tag() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.RequestOptions.request_tag)
  return _internal_request_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestOptions::set_request_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.RequestOptions.request_tag)
}
inline std::string* RequestOptions::mutable_request_tag() {
  std::string* _s = _internal_mutable_request_tag();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.RequestOptions.request_tag)
  return _s;
}
inline const std::string& RequestOptions::_internal_request_tag() const {
  return _impl_.request_tag_.Get();
}
inline void RequestOptions::_internal_set_request_tag(const std::string& value) {
  
  _impl_.request_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestOptions::_internal_mutable_request_tag() {
  
  return _impl_.request_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestOptions::release_request_tag() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.RequestOptions.request_tag)
  return _impl_.request_tag_.Release();
}
inline void RequestOptions::set_allocated_request_tag(std::string* request_tag) {
  if (request_tag != nullptr) {
    
  } else {
    
  }
  _impl_.request_tag_.SetAllocated(request_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_tag_.IsDefault()) {
    _impl_.request_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.RequestOptions.request_tag)
}

// string transaction_tag = 3;
inline void RequestOptions::clear_transaction_tag() {
  _impl_.transaction_tag_.ClearToEmpty();
}
inline const std::string& RequestOptions::transaction_tag() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.RequestOptions.transaction_tag)
  return _internal_transaction_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestOptions::set_transaction_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.transaction_tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.RequestOptions.transaction_tag)
}
inline std::string* RequestOptions::mutable_transaction_tag() {
  std::string* _s = _internal_mutable_transaction_tag();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.RequestOptions.transaction_tag)
  return _s;
}
inline const std::string& RequestOptions::_internal_transaction_tag() const {
  return _impl_.transaction_tag_.Get();
}
inline void RequestOptions::_internal_set_transaction_tag(const std::string& value) {
  
  _impl_.transaction_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestOptions::_internal_mutable_transaction_tag() {
  
  return _impl_.transaction_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestOptions::release_transaction_tag() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.RequestOptions.transaction_tag)
  return _impl_.transaction_tag_.Release();
}
inline void RequestOptions::set_allocated_transaction_tag(std::string* transaction_tag) {
  if (transaction_tag != nullptr) {
    
  } else {
    
  }
  _impl_.transaction_tag_.SetAllocated(transaction_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transaction_tag_.IsDefault()) {
    _impl_.transaction_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.RequestOptions.transaction_tag)
}

// -------------------------------------------------------------------

// ExecuteSqlRequest_QueryOptions

// string optimizer_version = 1;
inline void ExecuteSqlRequest_QueryOptions::clear_optimizer_version() {
  _impl_.optimizer_version_.ClearToEmpty();
}
inline const std::string& ExecuteSqlRequest_QueryOptions::optimizer_version() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.QueryOptions.optimizer_version)
  return _internal_optimizer_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteSqlRequest_QueryOptions::set_optimizer_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.optimizer_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ExecuteSqlRequest.QueryOptions.optimizer_version)
}
inline std::string* ExecuteSqlRequest_QueryOptions::mutable_optimizer_version() {
  std::string* _s = _internal_mutable_optimizer_version();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteSqlRequest.QueryOptions.optimizer_version)
  return _s;
}
inline const std::string& ExecuteSqlRequest_QueryOptions::_internal_optimizer_version() const {
  return _impl_.optimizer_version_.Get();
}
inline void ExecuteSqlRequest_QueryOptions::_internal_set_optimizer_version(const std::string& value) {
  
  _impl_.optimizer_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteSqlRequest_QueryOptions::_internal_mutable_optimizer_version() {
  
  return _impl_.optimizer_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteSqlRequest_QueryOptions::release_optimizer_version() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteSqlRequest.QueryOptions.optimizer_version)
  return _impl_.optimizer_version_.Release();
}
inline void ExecuteSqlRequest_QueryOptions::set_allocated_optimizer_version(std::string* optimizer_version) {
  if (optimizer_version != nullptr) {
    
  } else {
    
  }
  _impl_.optimizer_version_.SetAllocated(optimizer_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.optimizer_version_.IsDefault()) {
    _impl_.optimizer_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteSqlRequest.QueryOptions.optimizer_version)
}

// string optimizer_statistics_package = 2;
inline void ExecuteSqlRequest_QueryOptions::clear_optimizer_statistics_package() {
  _impl_.optimizer_statistics_package_.ClearToEmpty();
}
inline const std::string& ExecuteSqlRequest_QueryOptions::optimizer_statistics_package() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.QueryOptions.optimizer_statistics_package)
  return _internal_optimizer_statistics_package();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteSqlRequest_QueryOptions::set_optimizer_statistics_package(ArgT0&& arg0, ArgT... args) {
 
 _impl_.optimizer_statistics_package_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ExecuteSqlRequest.QueryOptions.optimizer_statistics_package)
}
inline std::string* ExecuteSqlRequest_QueryOptions::mutable_optimizer_statistics_package() {
  std::string* _s = _internal_mutable_optimizer_statistics_package();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteSqlRequest.QueryOptions.optimizer_statistics_package)
  return _s;
}
inline const std::string& ExecuteSqlRequest_QueryOptions::_internal_optimizer_statistics_package() const {
  return _impl_.optimizer_statistics_package_.Get();
}
inline void ExecuteSqlRequest_QueryOptions::_internal_set_optimizer_statistics_package(const std::string& value) {
  
  _impl_.optimizer_statistics_package_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteSqlRequest_QueryOptions::_internal_mutable_optimizer_statistics_package() {
  
  return _impl_.optimizer_statistics_package_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteSqlRequest_QueryOptions::release_optimizer_statistics_package() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteSqlRequest.QueryOptions.optimizer_statistics_package)
  return _impl_.optimizer_statistics_package_.Release();
}
inline void ExecuteSqlRequest_QueryOptions::set_allocated_optimizer_statistics_package(std::string* optimizer_statistics_package) {
  if (optimizer_statistics_package != nullptr) {
    
  } else {
    
  }
  _impl_.optimizer_statistics_package_.SetAllocated(optimizer_statistics_package, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.optimizer_statistics_package_.IsDefault()) {
    _impl_.optimizer_statistics_package_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteSqlRequest.QueryOptions.optimizer_statistics_package)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ExecuteSqlRequest

// string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ExecuteSqlRequest::clear_session() {
  _impl_.session_.ClearToEmpty();
}
inline const std::string& ExecuteSqlRequest::session() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.session)
  return _internal_session();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteSqlRequest::set_session(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ExecuteSqlRequest.session)
}
inline std::string* ExecuteSqlRequest::mutable_session() {
  std::string* _s = _internal_mutable_session();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteSqlRequest.session)
  return _s;
}
inline const std::string& ExecuteSqlRequest::_internal_session() const {
  return _impl_.session_.Get();
}
inline void ExecuteSqlRequest::_internal_set_session(const std::string& value) {
  
  _impl_.session_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteSqlRequest::_internal_mutable_session() {
  
  return _impl_.session_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteSqlRequest::release_session() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteSqlRequest.session)
  return _impl_.session_.Release();
}
inline void ExecuteSqlRequest::set_allocated_session(std::string* session) {
  if (session != nullptr) {
    
  } else {
    
  }
  _impl_.session_.SetAllocated(session, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_.IsDefault()) {
    _impl_.session_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteSqlRequest.session)
}

// .google.spanner.v1.TransactionSelector transaction = 2;
inline bool ExecuteSqlRequest::_internal_has_transaction() const {
  return this != internal_default_instance() && _impl_.transaction_ != nullptr;
}
inline bool ExecuteSqlRequest::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::google::spanner::v1::TransactionSelector& ExecuteSqlRequest::_internal_transaction() const {
  const ::google::spanner::v1::TransactionSelector* p = _impl_.transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::TransactionSelector&>(
      ::google::spanner::v1::_TransactionSelector_default_instance_);
}
inline const ::google::spanner::v1::TransactionSelector& ExecuteSqlRequest::transaction() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.transaction)
  return _internal_transaction();
}
inline void ExecuteSqlRequest::unsafe_arena_set_allocated_transaction(
    ::google::spanner::v1::TransactionSelector* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_);
  }
  _impl_.transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.ExecuteSqlRequest.transaction)
}
inline ::google::spanner::v1::TransactionSelector* ExecuteSqlRequest::release_transaction() {
  
  ::google::spanner::v1::TransactionSelector* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::TransactionSelector* ExecuteSqlRequest::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteSqlRequest.transaction)
  
  ::google::spanner::v1::TransactionSelector* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::TransactionSelector* ExecuteSqlRequest::_internal_mutable_transaction() {
  
  if (_impl_.transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::TransactionSelector>(GetArenaForAllocation());
    _impl_.transaction_ = p;
  }
  return _impl_.transaction_;
}
inline ::google::spanner::v1::TransactionSelector* ExecuteSqlRequest::mutable_transaction() {
  ::google::spanner::v1::TransactionSelector* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteSqlRequest.transaction)
  return _msg;
}
inline void ExecuteSqlRequest::set_allocated_transaction(::google::spanner::v1::TransactionSelector* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteSqlRequest.transaction)
}

// string sql = 3 [(.google.api.field_behavior) = REQUIRED];
inline void ExecuteSqlRequest::clear_sql() {
  _impl_.sql_.ClearToEmpty();
}
inline const std::string& ExecuteSqlRequest::sql() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.sql)
  return _internal_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteSqlRequest::set_sql(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sql_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ExecuteSqlRequest.sql)
}
inline std::string* ExecuteSqlRequest::mutable_sql() {
  std::string* _s = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteSqlRequest.sql)
  return _s;
}
inline const std::string& ExecuteSqlRequest::_internal_sql() const {
  return _impl_.sql_.Get();
}
inline void ExecuteSqlRequest::_internal_set_sql(const std::string& value) {
  
  _impl_.sql_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteSqlRequest::_internal_mutable_sql() {
  
  return _impl_.sql_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteSqlRequest::release_sql() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteSqlRequest.sql)
  return _impl_.sql_.Release();
}
inline void ExecuteSqlRequest::set_allocated_sql(std::string* sql) {
  if (sql != nullptr) {
    
  } else {
    
  }
  _impl_.sql_.SetAllocated(sql, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sql_.IsDefault()) {
    _impl_.sql_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteSqlRequest.sql)
}

// .google.protobuf.Struct params = 4;
inline bool ExecuteSqlRequest::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool ExecuteSqlRequest::has_params() const {
  return _internal_has_params();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ExecuteSqlRequest::_internal_params() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ExecuteSqlRequest::params() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.params)
  return _internal_params();
}
inline void ExecuteSqlRequest::unsafe_arena_set_allocated_params(
    ::PROTOBUF_NAMESPACE_ID::Struct* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.ExecuteSqlRequest.params)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteSqlRequest::release_params() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteSqlRequest::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteSqlRequest.params)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteSqlRequest::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteSqlRequest::mutable_params() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteSqlRequest.params)
  return _msg;
}
inline void ExecuteSqlRequest::set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteSqlRequest.params)
}

// map<string, .google.spanner.v1.Type> param_types = 5;
inline int ExecuteSqlRequest::_internal_param_types_size() const {
  return _impl_.param_types_.size();
}
inline int ExecuteSqlRequest::param_types_size() const {
  return _internal_param_types_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >&
ExecuteSqlRequest::_internal_param_types() const {
  return _impl_.param_types_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >&
ExecuteSqlRequest::param_types() const {
  // @@protoc_insertion_point(field_map:google.spanner.v1.ExecuteSqlRequest.param_types)
  return _internal_param_types();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >*
ExecuteSqlRequest::_internal_mutable_param_types() {
  return _impl_.param_types_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >*
ExecuteSqlRequest::mutable_param_types() {
  // @@protoc_insertion_point(field_mutable_map:google.spanner.v1.ExecuteSqlRequest.param_types)
  return _internal_mutable_param_types();
}

// bytes resume_token = 6;
inline void ExecuteSqlRequest::clear_resume_token() {
  _impl_.resume_token_.ClearToEmpty();
}
inline const std::string& ExecuteSqlRequest::resume_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.resume_token)
  return _internal_resume_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteSqlRequest::set_resume_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resume_token_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ExecuteSqlRequest.resume_token)
}
inline std::string* ExecuteSqlRequest::mutable_resume_token() {
  std::string* _s = _internal_mutable_resume_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteSqlRequest.resume_token)
  return _s;
}
inline const std::string& ExecuteSqlRequest::_internal_resume_token() const {
  return _impl_.resume_token_.Get();
}
inline void ExecuteSqlRequest::_internal_set_resume_token(const std::string& value) {
  
  _impl_.resume_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteSqlRequest::_internal_mutable_resume_token() {
  
  return _impl_.resume_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteSqlRequest::release_resume_token() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteSqlRequest.resume_token)
  return _impl_.resume_token_.Release();
}
inline void ExecuteSqlRequest::set_allocated_resume_token(std::string* resume_token) {
  if (resume_token != nullptr) {
    
  } else {
    
  }
  _impl_.resume_token_.SetAllocated(resume_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resume_token_.IsDefault()) {
    _impl_.resume_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteSqlRequest.resume_token)
}

// .google.spanner.v1.ExecuteSqlRequest.QueryMode query_mode = 7;
inline void ExecuteSqlRequest::clear_query_mode() {
  _impl_.query_mode_ = 0;
}
inline ::google::spanner::v1::ExecuteSqlRequest_QueryMode ExecuteSqlRequest::_internal_query_mode() const {
  return static_cast< ::google::spanner::v1::ExecuteSqlRequest_QueryMode >(_impl_.query_mode_);
}
inline ::google::spanner::v1::ExecuteSqlRequest_QueryMode ExecuteSqlRequest::query_mode() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.query_mode)
  return _internal_query_mode();
}
inline void ExecuteSqlRequest::_internal_set_query_mode(::google::spanner::v1::ExecuteSqlRequest_QueryMode value) {
  
  _impl_.query_mode_ = value;
}
inline void ExecuteSqlRequest::set_query_mode(::google::spanner::v1::ExecuteSqlRequest_QueryMode value) {
  _internal_set_query_mode(value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.ExecuteSqlRequest.query_mode)
}

// bytes partition_token = 8;
inline void ExecuteSqlRequest::clear_partition_token() {
  _impl_.partition_token_.ClearToEmpty();
}
inline const std::string& ExecuteSqlRequest::partition_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.partition_token)
  return _internal_partition_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteSqlRequest::set_partition_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.partition_token_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ExecuteSqlRequest.partition_token)
}
inline std::string* ExecuteSqlRequest::mutable_partition_token() {
  std::string* _s = _internal_mutable_partition_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteSqlRequest.partition_token)
  return _s;
}
inline const std::string& ExecuteSqlRequest::_internal_partition_token() const {
  return _impl_.partition_token_.Get();
}
inline void ExecuteSqlRequest::_internal_set_partition_token(const std::string& value) {
  
  _impl_.partition_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteSqlRequest::_internal_mutable_partition_token() {
  
  return _impl_.partition_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteSqlRequest::release_partition_token() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteSqlRequest.partition_token)
  return _impl_.partition_token_.Release();
}
inline void ExecuteSqlRequest::set_allocated_partition_token(std::string* partition_token) {
  if (partition_token != nullptr) {
    
  } else {
    
  }
  _impl_.partition_token_.SetAllocated(partition_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.partition_token_.IsDefault()) {
    _impl_.partition_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteSqlRequest.partition_token)
}

// int64 seqno = 9;
inline void ExecuteSqlRequest::clear_seqno() {
  _impl_.seqno_ = int64_t{0};
}
inline int64_t ExecuteSqlRequest::_internal_seqno() const {
  return _impl_.seqno_;
}
inline int64_t ExecuteSqlRequest::seqno() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.seqno)
  return _internal_seqno();
}
inline void ExecuteSqlRequest::_internal_set_seqno(int64_t value) {
  
  _impl_.seqno_ = value;
}
inline void ExecuteSqlRequest::set_seqno(int64_t value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.ExecuteSqlRequest.seqno)
}

// .google.spanner.v1.ExecuteSqlRequest.QueryOptions query_options = 10;
inline bool ExecuteSqlRequest::_internal_has_query_options() const {
  return this != internal_default_instance() && _impl_.query_options_ != nullptr;
}
inline bool ExecuteSqlRequest::has_query_options() const {
  return _internal_has_query_options();
}
inline void ExecuteSqlRequest::clear_query_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_options_ != nullptr) {
    delete _impl_.query_options_;
  }
  _impl_.query_options_ = nullptr;
}
inline const ::google::spanner::v1::ExecuteSqlRequest_QueryOptions& ExecuteSqlRequest::_internal_query_options() const {
  const ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* p = _impl_.query_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::ExecuteSqlRequest_QueryOptions&>(
      ::google::spanner::v1::_ExecuteSqlRequest_QueryOptions_default_instance_);
}
inline const ::google::spanner::v1::ExecuteSqlRequest_QueryOptions& ExecuteSqlRequest::query_options() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.query_options)
  return _internal_query_options();
}
inline void ExecuteSqlRequest::unsafe_arena_set_allocated_query_options(
    ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* query_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_options_);
  }
  _impl_.query_options_ = query_options;
  if (query_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.ExecuteSqlRequest.query_options)
}
inline ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* ExecuteSqlRequest::release_query_options() {
  
  ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* temp = _impl_.query_options_;
  _impl_.query_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* ExecuteSqlRequest::unsafe_arena_release_query_options() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteSqlRequest.query_options)
  
  ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* temp = _impl_.query_options_;
  _impl_.query_options_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* ExecuteSqlRequest::_internal_mutable_query_options() {
  
  if (_impl_.query_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::ExecuteSqlRequest_QueryOptions>(GetArenaForAllocation());
    _impl_.query_options_ = p;
  }
  return _impl_.query_options_;
}
inline ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* ExecuteSqlRequest::mutable_query_options() {
  ::google::spanner::v1::ExecuteSqlRequest_QueryOptions* _msg = _internal_mutable_query_options();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteSqlRequest.query_options)
  return _msg;
}
inline void ExecuteSqlRequest::set_allocated_query_options(::google::spanner::v1::ExecuteSqlRequest_QueryOptions* query_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_options_;
  }
  if (query_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query_options);
    if (message_arena != submessage_arena) {
      query_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_options_ = query_options;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteSqlRequest.query_options)
}

// .google.spanner.v1.RequestOptions request_options = 11;
inline bool ExecuteSqlRequest::_internal_has_request_options() const {
  return this != internal_default_instance() && _impl_.request_options_ != nullptr;
}
inline bool ExecuteSqlRequest::has_request_options() const {
  return _internal_has_request_options();
}
inline void ExecuteSqlRequest::clear_request_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_options_ != nullptr) {
    delete _impl_.request_options_;
  }
  _impl_.request_options_ = nullptr;
}
inline const ::google::spanner::v1::RequestOptions& ExecuteSqlRequest::_internal_request_options() const {
  const ::google::spanner::v1::RequestOptions* p = _impl_.request_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::RequestOptions&>(
      ::google::spanner::v1::_RequestOptions_default_instance_);
}
inline const ::google::spanner::v1::RequestOptions& ExecuteSqlRequest::request_options() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.request_options)
  return _internal_request_options();
}
inline void ExecuteSqlRequest::unsafe_arena_set_allocated_request_options(
    ::google::spanner::v1::RequestOptions* request_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_options_);
  }
  _impl_.request_options_ = request_options;
  if (request_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.ExecuteSqlRequest.request_options)
}
inline ::google::spanner::v1::RequestOptions* ExecuteSqlRequest::release_request_options() {
  
  ::google::spanner::v1::RequestOptions* temp = _impl_.request_options_;
  _impl_.request_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::RequestOptions* ExecuteSqlRequest::unsafe_arena_release_request_options() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteSqlRequest.request_options)
  
  ::google::spanner::v1::RequestOptions* temp = _impl_.request_options_;
  _impl_.request_options_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::RequestOptions* ExecuteSqlRequest::_internal_mutable_request_options() {
  
  if (_impl_.request_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::RequestOptions>(GetArenaForAllocation());
    _impl_.request_options_ = p;
  }
  return _impl_.request_options_;
}
inline ::google::spanner::v1::RequestOptions* ExecuteSqlRequest::mutable_request_options() {
  ::google::spanner::v1::RequestOptions* _msg = _internal_mutable_request_options();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteSqlRequest.request_options)
  return _msg;
}
inline void ExecuteSqlRequest::set_allocated_request_options(::google::spanner::v1::RequestOptions* request_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_options_;
  }
  if (request_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_options);
    if (message_arena != submessage_arena) {
      request_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_options_ = request_options;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteSqlRequest.request_options)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ExecuteBatchDmlRequest_Statement

// string sql = 1 [(.google.api.field_behavior) = REQUIRED];
inline void ExecuteBatchDmlRequest_Statement::clear_sql() {
  _impl_.sql_.ClearToEmpty();
}
inline const std::string& ExecuteBatchDmlRequest_Statement::sql() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteBatchDmlRequest.Statement.sql)
  return _internal_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteBatchDmlRequest_Statement::set_sql(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sql_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ExecuteBatchDmlRequest.Statement.sql)
}
inline std::string* ExecuteBatchDmlRequest_Statement::mutable_sql() {
  std::string* _s = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteBatchDmlRequest.Statement.sql)
  return _s;
}
inline const std::string& ExecuteBatchDmlRequest_Statement::_internal_sql() const {
  return _impl_.sql_.Get();
}
inline void ExecuteBatchDmlRequest_Statement::_internal_set_sql(const std::string& value) {
  
  _impl_.sql_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteBatchDmlRequest_Statement::_internal_mutable_sql() {
  
  return _impl_.sql_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteBatchDmlRequest_Statement::release_sql() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteBatchDmlRequest.Statement.sql)
  return _impl_.sql_.Release();
}
inline void ExecuteBatchDmlRequest_Statement::set_allocated_sql(std::string* sql) {
  if (sql != nullptr) {
    
  } else {
    
  }
  _impl_.sql_.SetAllocated(sql, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sql_.IsDefault()) {
    _impl_.sql_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteBatchDmlRequest.Statement.sql)
}

// .google.protobuf.Struct params = 2;
inline bool ExecuteBatchDmlRequest_Statement::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool ExecuteBatchDmlRequest_Statement::has_params() const {
  return _internal_has_params();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ExecuteBatchDmlRequest_Statement::_internal_params() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ExecuteBatchDmlRequest_Statement::params() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteBatchDmlRequest.Statement.params)
  return _internal_params();
}
inline void ExecuteBatchDmlRequest_Statement::unsafe_arena_set_allocated_params(
    ::PROTOBUF_NAMESPACE_ID::Struct* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.ExecuteBatchDmlRequest.Statement.params)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteBatchDmlRequest_Statement::release_params() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteBatchDmlRequest_Statement::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteBatchDmlRequest.Statement.params)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteBatchDmlRequest_Statement::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteBatchDmlRequest_Statement::mutable_params() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteBatchDmlRequest.Statement.params)
  return _msg;
}
inline void ExecuteBatchDmlRequest_Statement::set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteBatchDmlRequest.Statement.params)
}

// map<string, .google.spanner.v1.Type> param_types = 3;
inline int ExecuteBatchDmlRequest_Statement::_internal_param_types_size() const {
  return _impl_.param_types_.size();
}
inline int ExecuteBatchDmlRequest_Statement::param_types_size() const {
  return _internal_param_types_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >&
ExecuteBatchDmlRequest_Statement::_internal_param_types() const {
  return _impl_.param_types_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >&
ExecuteBatchDmlRequest_Statement::param_types() const {
  // @@protoc_insertion_point(field_map:google.spanner.v1.ExecuteBatchDmlRequest.Statement.param_types)
  return _internal_param_types();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >*
ExecuteBatchDmlRequest_Statement::_internal_mutable_param_types() {
  return _impl_.param_types_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >*
ExecuteBatchDmlRequest_Statement::mutable_param_types() {
  // @@protoc_insertion_point(field_mutable_map:google.spanner.v1.ExecuteBatchDmlRequest.Statement.param_types)
  return _internal_mutable_param_types();
}

// -------------------------------------------------------------------

// ExecuteBatchDmlRequest

// string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ExecuteBatchDmlRequest::clear_session() {
  _impl_.session_.ClearToEmpty();
}
inline const std::string& ExecuteBatchDmlRequest::session() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteBatchDmlRequest.session)
  return _internal_session();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteBatchDmlRequest::set_session(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ExecuteBatchDmlRequest.session)
}
inline std::string* ExecuteBatchDmlRequest::mutable_session() {
  std::string* _s = _internal_mutable_session();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteBatchDmlRequest.session)
  return _s;
}
inline const std::string& ExecuteBatchDmlRequest::_internal_session() const {
  return _impl_.session_.Get();
}
inline void ExecuteBatchDmlRequest::_internal_set_session(const std::string& value) {
  
  _impl_.session_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteBatchDmlRequest::_internal_mutable_session() {
  
  return _impl_.session_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteBatchDmlRequest::release_session() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteBatchDmlRequest.session)
  return _impl_.session_.Release();
}
inline void ExecuteBatchDmlRequest::set_allocated_session(std::string* session) {
  if (session != nullptr) {
    
  } else {
    
  }
  _impl_.session_.SetAllocated(session, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_.IsDefault()) {
    _impl_.session_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteBatchDmlRequest.session)
}

// .google.spanner.v1.TransactionSelector transaction = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool ExecuteBatchDmlRequest::_internal_has_transaction() const {
  return this != internal_default_instance() && _impl_.transaction_ != nullptr;
}
inline bool ExecuteBatchDmlRequest::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::google::spanner::v1::TransactionSelector& ExecuteBatchDmlRequest::_internal_transaction() const {
  const ::google::spanner::v1::TransactionSelector* p = _impl_.transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::TransactionSelector&>(
      ::google::spanner::v1::_TransactionSelector_default_instance_);
}
inline const ::google::spanner::v1::TransactionSelector& ExecuteBatchDmlRequest::transaction() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteBatchDmlRequest.transaction)
  return _internal_transaction();
}
inline void ExecuteBatchDmlRequest::unsafe_arena_set_allocated_transaction(
    ::google::spanner::v1::TransactionSelector* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_);
  }
  _impl_.transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.ExecuteBatchDmlRequest.transaction)
}
inline ::google::spanner::v1::TransactionSelector* ExecuteBatchDmlRequest::release_transaction() {
  
  ::google::spanner::v1::TransactionSelector* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::TransactionSelector* ExecuteBatchDmlRequest::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteBatchDmlRequest.transaction)
  
  ::google::spanner::v1::TransactionSelector* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::TransactionSelector* ExecuteBatchDmlRequest::_internal_mutable_transaction() {
  
  if (_impl_.transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::TransactionSelector>(GetArenaForAllocation());
    _impl_.transaction_ = p;
  }
  return _impl_.transaction_;
}
inline ::google::spanner::v1::TransactionSelector* ExecuteBatchDmlRequest::mutable_transaction() {
  ::google::spanner::v1::TransactionSelector* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteBatchDmlRequest.transaction)
  return _msg;
}
inline void ExecuteBatchDmlRequest::set_allocated_transaction(::google::spanner::v1::TransactionSelector* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteBatchDmlRequest.transaction)
}

// repeated .google.spanner.v1.ExecuteBatchDmlRequest.Statement statements = 3 [(.google.api.field_behavior) = REQUIRED];
inline int ExecuteBatchDmlRequest::_internal_statements_size() const {
  return _impl_.statements_.size();
}
inline int ExecuteBatchDmlRequest::statements_size() const {
  return _internal_statements_size();
}
inline void ExecuteBatchDmlRequest::clear_statements() {
  _impl_.statements_.Clear();
}
inline ::google::spanner::v1::ExecuteBatchDmlRequest_Statement* ExecuteBatchDmlRequest::mutable_statements(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteBatchDmlRequest.statements)
  return _impl_.statements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::ExecuteBatchDmlRequest_Statement >*
ExecuteBatchDmlRequest::mutable_statements() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.v1.ExecuteBatchDmlRequest.statements)
  return &_impl_.statements_;
}
inline const ::google::spanner::v1::ExecuteBatchDmlRequest_Statement& ExecuteBatchDmlRequest::_internal_statements(int index) const {
  return _impl_.statements_.Get(index);
}
inline const ::google::spanner::v1::ExecuteBatchDmlRequest_Statement& ExecuteBatchDmlRequest::statements(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteBatchDmlRequest.statements)
  return _internal_statements(index);
}
inline ::google::spanner::v1::ExecuteBatchDmlRequest_Statement* ExecuteBatchDmlRequest::_internal_add_statements() {
  return _impl_.statements_.Add();
}
inline ::google::spanner::v1::ExecuteBatchDmlRequest_Statement* ExecuteBatchDmlRequest::add_statements() {
  ::google::spanner::v1::ExecuteBatchDmlRequest_Statement* _add = _internal_add_statements();
  // @@protoc_insertion_point(field_add:google.spanner.v1.ExecuteBatchDmlRequest.statements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::ExecuteBatchDmlRequest_Statement >&
ExecuteBatchDmlRequest::statements() const {
  // @@protoc_insertion_point(field_list:google.spanner.v1.ExecuteBatchDmlRequest.statements)
  return _impl_.statements_;
}

// int64 seqno = 4 [(.google.api.field_behavior) = REQUIRED];
inline void ExecuteBatchDmlRequest::clear_seqno() {
  _impl_.seqno_ = int64_t{0};
}
inline int64_t ExecuteBatchDmlRequest::_internal_seqno() const {
  return _impl_.seqno_;
}
inline int64_t ExecuteBatchDmlRequest::seqno() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteBatchDmlRequest.seqno)
  return _internal_seqno();
}
inline void ExecuteBatchDmlRequest::_internal_set_seqno(int64_t value) {
  
  _impl_.seqno_ = value;
}
inline void ExecuteBatchDmlRequest::set_seqno(int64_t value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.ExecuteBatchDmlRequest.seqno)
}

// .google.spanner.v1.RequestOptions request_options = 5;
inline bool ExecuteBatchDmlRequest::_internal_has_request_options() const {
  return this != internal_default_instance() && _impl_.request_options_ != nullptr;
}
inline bool ExecuteBatchDmlRequest::has_request_options() const {
  return _internal_has_request_options();
}
inline void ExecuteBatchDmlRequest::clear_request_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_options_ != nullptr) {
    delete _impl_.request_options_;
  }
  _impl_.request_options_ = nullptr;
}
inline const ::google::spanner::v1::RequestOptions& ExecuteBatchDmlRequest::_internal_request_options() const {
  const ::google::spanner::v1::RequestOptions* p = _impl_.request_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::RequestOptions&>(
      ::google::spanner::v1::_RequestOptions_default_instance_);
}
inline const ::google::spanner::v1::RequestOptions& ExecuteBatchDmlRequest::request_options() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteBatchDmlRequest.request_options)
  return _internal_request_options();
}
inline void ExecuteBatchDmlRequest::unsafe_arena_set_allocated_request_options(
    ::google::spanner::v1::RequestOptions* request_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_options_);
  }
  _impl_.request_options_ = request_options;
  if (request_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.ExecuteBatchDmlRequest.request_options)
}
inline ::google::spanner::v1::RequestOptions* ExecuteBatchDmlRequest::release_request_options() {
  
  ::google::spanner::v1::RequestOptions* temp = _impl_.request_options_;
  _impl_.request_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::RequestOptions* ExecuteBatchDmlRequest::unsafe_arena_release_request_options() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteBatchDmlRequest.request_options)
  
  ::google::spanner::v1::RequestOptions* temp = _impl_.request_options_;
  _impl_.request_options_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::RequestOptions* ExecuteBatchDmlRequest::_internal_mutable_request_options() {
  
  if (_impl_.request_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::RequestOptions>(GetArenaForAllocation());
    _impl_.request_options_ = p;
  }
  return _impl_.request_options_;
}
inline ::google::spanner::v1::RequestOptions* ExecuteBatchDmlRequest::mutable_request_options() {
  ::google::spanner::v1::RequestOptions* _msg = _internal_mutable_request_options();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteBatchDmlRequest.request_options)
  return _msg;
}
inline void ExecuteBatchDmlRequest::set_allocated_request_options(::google::spanner::v1::RequestOptions* request_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_options_;
  }
  if (request_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_options);
    if (message_arena != submessage_arena) {
      request_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_options_ = request_options;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteBatchDmlRequest.request_options)
}

// -------------------------------------------------------------------

// ExecuteBatchDmlResponse

// repeated .google.spanner.v1.ResultSet result_sets = 1;
inline int ExecuteBatchDmlResponse::_internal_result_sets_size() const {
  return _impl_.result_sets_.size();
}
inline int ExecuteBatchDmlResponse::result_sets_size() const {
  return _internal_result_sets_size();
}
inline ::google::spanner::v1::ResultSet* ExecuteBatchDmlResponse::mutable_result_sets(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteBatchDmlResponse.result_sets)
  return _impl_.result_sets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::ResultSet >*
ExecuteBatchDmlResponse::mutable_result_sets() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.v1.ExecuteBatchDmlResponse.result_sets)
  return &_impl_.result_sets_;
}
inline const ::google::spanner::v1::ResultSet& ExecuteBatchDmlResponse::_internal_result_sets(int index) const {
  return _impl_.result_sets_.Get(index);
}
inline const ::google::spanner::v1::ResultSet& ExecuteBatchDmlResponse::result_sets(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteBatchDmlResponse.result_sets)
  return _internal_result_sets(index);
}
inline ::google::spanner::v1::ResultSet* ExecuteBatchDmlResponse::_internal_add_result_sets() {
  return _impl_.result_sets_.Add();
}
inline ::google::spanner::v1::ResultSet* ExecuteBatchDmlResponse::add_result_sets() {
  ::google::spanner::v1::ResultSet* _add = _internal_add_result_sets();
  // @@protoc_insertion_point(field_add:google.spanner.v1.ExecuteBatchDmlResponse.result_sets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::ResultSet >&
ExecuteBatchDmlResponse::result_sets() const {
  // @@protoc_insertion_point(field_list:google.spanner.v1.ExecuteBatchDmlResponse.result_sets)
  return _impl_.result_sets_;
}

// .google.rpc.Status status = 2;
inline bool ExecuteBatchDmlResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool ExecuteBatchDmlResponse::has_status() const {
  return _internal_has_status();
}
inline const ::google::rpc::Status& ExecuteBatchDmlResponse::_internal_status() const {
  const ::google::rpc::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::rpc::Status&>(
      ::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& ExecuteBatchDmlResponse::status() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteBatchDmlResponse.status)
  return _internal_status();
}
inline void ExecuteBatchDmlResponse::unsafe_arena_set_allocated_status(
    ::google::rpc::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.ExecuteBatchDmlResponse.status)
}
inline ::google::rpc::Status* ExecuteBatchDmlResponse::release_status() {
  
  ::google::rpc::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::rpc::Status* ExecuteBatchDmlResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteBatchDmlResponse.status)
  
  ::google::rpc::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::google::rpc::Status* ExecuteBatchDmlResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::rpc::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::google::rpc::Status* ExecuteBatchDmlResponse::mutable_status() {
  ::google::rpc::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteBatchDmlResponse.status)
  return _msg;
}
inline void ExecuteBatchDmlResponse::set_allocated_status(::google::rpc::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteBatchDmlResponse.status)
}

// -------------------------------------------------------------------

// PartitionOptions

// int64 partition_size_bytes = 1;
inline void PartitionOptions::clear_partition_size_bytes() {
  _impl_.partition_size_bytes_ = int64_t{0};
}
inline int64_t PartitionOptions::_internal_partition_size_bytes() const {
  return _impl_.partition_size_bytes_;
}
inline int64_t PartitionOptions::partition_size_bytes() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionOptions.partition_size_bytes)
  return _internal_partition_size_bytes();
}
inline void PartitionOptions::_internal_set_partition_size_bytes(int64_t value) {
  
  _impl_.partition_size_bytes_ = value;
}
inline void PartitionOptions::set_partition_size_bytes(int64_t value) {
  _internal_set_partition_size_bytes(value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.PartitionOptions.partition_size_bytes)
}

// int64 max_partitions = 2;
inline void PartitionOptions::clear_max_partitions() {
  _impl_.max_partitions_ = int64_t{0};
}
inline int64_t PartitionOptions::_internal_max_partitions() const {
  return _impl_.max_partitions_;
}
inline int64_t PartitionOptions::max_partitions() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionOptions.max_partitions)
  return _internal_max_partitions();
}
inline void PartitionOptions::_internal_set_max_partitions(int64_t value) {
  
  _impl_.max_partitions_ = value;
}
inline void PartitionOptions::set_max_partitions(int64_t value) {
  _internal_set_max_partitions(value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.PartitionOptions.max_partitions)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PartitionQueryRequest

// string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void PartitionQueryRequest::clear_session() {
  _impl_.session_.ClearToEmpty();
}
inline const std::string& PartitionQueryRequest::session() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionQueryRequest.session)
  return _internal_session();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionQueryRequest::set_session(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.PartitionQueryRequest.session)
}
inline std::string* PartitionQueryRequest::mutable_session() {
  std::string* _s = _internal_mutable_session();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.PartitionQueryRequest.session)
  return _s;
}
inline const std::string& PartitionQueryRequest::_internal_session() const {
  return _impl_.session_.Get();
}
inline void PartitionQueryRequest::_internal_set_session(const std::string& value) {
  
  _impl_.session_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionQueryRequest::_internal_mutable_session() {
  
  return _impl_.session_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionQueryRequest::release_session() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.PartitionQueryRequest.session)
  return _impl_.session_.Release();
}
inline void PartitionQueryRequest::set_allocated_session(std::string* session) {
  if (session != nullptr) {
    
  } else {
    
  }
  _impl_.session_.SetAllocated(session, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_.IsDefault()) {
    _impl_.session_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.PartitionQueryRequest.session)
}

// .google.spanner.v1.TransactionSelector transaction = 2;
inline bool PartitionQueryRequest::_internal_has_transaction() const {
  return this != internal_default_instance() && _impl_.transaction_ != nullptr;
}
inline bool PartitionQueryRequest::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::google::spanner::v1::TransactionSelector& PartitionQueryRequest::_internal_transaction() const {
  const ::google::spanner::v1::TransactionSelector* p = _impl_.transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::TransactionSelector&>(
      ::google::spanner::v1::_TransactionSelector_default_instance_);
}
inline const ::google::spanner::v1::TransactionSelector& PartitionQueryRequest::transaction() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionQueryRequest.transaction)
  return _internal_transaction();
}
inline void PartitionQueryRequest::unsafe_arena_set_allocated_transaction(
    ::google::spanner::v1::TransactionSelector* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_);
  }
  _impl_.transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.PartitionQueryRequest.transaction)
}
inline ::google::spanner::v1::TransactionSelector* PartitionQueryRequest::release_transaction() {
  
  ::google::spanner::v1::TransactionSelector* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::TransactionSelector* PartitionQueryRequest::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.PartitionQueryRequest.transaction)
  
  ::google::spanner::v1::TransactionSelector* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::TransactionSelector* PartitionQueryRequest::_internal_mutable_transaction() {
  
  if (_impl_.transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::TransactionSelector>(GetArenaForAllocation());
    _impl_.transaction_ = p;
  }
  return _impl_.transaction_;
}
inline ::google::spanner::v1::TransactionSelector* PartitionQueryRequest::mutable_transaction() {
  ::google::spanner::v1::TransactionSelector* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.PartitionQueryRequest.transaction)
  return _msg;
}
inline void PartitionQueryRequest::set_allocated_transaction(::google::spanner::v1::TransactionSelector* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.PartitionQueryRequest.transaction)
}

// string sql = 3 [(.google.api.field_behavior) = REQUIRED];
inline void PartitionQueryRequest::clear_sql() {
  _impl_.sql_.ClearToEmpty();
}
inline const std::string& PartitionQueryRequest::sql() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionQueryRequest.sql)
  return _internal_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionQueryRequest::set_sql(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sql_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.PartitionQueryRequest.sql)
}
inline std::string* PartitionQueryRequest::mutable_sql() {
  std::string* _s = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.PartitionQueryRequest.sql)
  return _s;
}
inline const std::string& PartitionQueryRequest::_internal_sql() const {
  return _impl_.sql_.Get();
}
inline void PartitionQueryRequest::_internal_set_sql(const std::string& value) {
  
  _impl_.sql_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionQueryRequest::_internal_mutable_sql() {
  
  return _impl_.sql_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionQueryRequest::release_sql() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.PartitionQueryRequest.sql)
  return _impl_.sql_.Release();
}
inline void PartitionQueryRequest::set_allocated_sql(std::string* sql) {
  if (sql != nullptr) {
    
  } else {
    
  }
  _impl_.sql_.SetAllocated(sql, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sql_.IsDefault()) {
    _impl_.sql_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.PartitionQueryRequest.sql)
}

// .google.protobuf.Struct params = 4;
inline bool PartitionQueryRequest::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool PartitionQueryRequest::has_params() const {
  return _internal_has_params();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& PartitionQueryRequest::_internal_params() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& PartitionQueryRequest::params() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionQueryRequest.params)
  return _internal_params();
}
inline void PartitionQueryRequest::unsafe_arena_set_allocated_params(
    ::PROTOBUF_NAMESPACE_ID::Struct* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.PartitionQueryRequest.params)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PartitionQueryRequest::release_params() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PartitionQueryRequest::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.PartitionQueryRequest.params)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PartitionQueryRequest::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PartitionQueryRequest::mutable_params() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.PartitionQueryRequest.params)
  return _msg;
}
inline void PartitionQueryRequest::set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.PartitionQueryRequest.params)
}

// map<string, .google.spanner.v1.Type> param_types = 5;
inline int PartitionQueryRequest::_internal_param_types_size() const {
  return _impl_.param_types_.size();
}
inline int PartitionQueryRequest::param_types_size() const {
  return _internal_param_types_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >&
PartitionQueryRequest::_internal_param_types() const {
  return _impl_.param_types_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >&
PartitionQueryRequest::param_types() const {
  // @@protoc_insertion_point(field_map:google.spanner.v1.PartitionQueryRequest.param_types)
  return _internal_param_types();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >*
PartitionQueryRequest::_internal_mutable_param_types() {
  return _impl_.param_types_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::spanner::v1::Type >*
PartitionQueryRequest::mutable_param_types() {
  // @@protoc_insertion_point(field_mutable_map:google.spanner.v1.PartitionQueryRequest.param_types)
  return _internal_mutable_param_types();
}

// .google.spanner.v1.PartitionOptions partition_options = 6;
inline bool PartitionQueryRequest::_internal_has_partition_options() const {
  return this != internal_default_instance() && _impl_.partition_options_ != nullptr;
}
inline bool PartitionQueryRequest::has_partition_options() const {
  return _internal_has_partition_options();
}
inline void PartitionQueryRequest::clear_partition_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.partition_options_ != nullptr) {
    delete _impl_.partition_options_;
  }
  _impl_.partition_options_ = nullptr;
}
inline const ::google::spanner::v1::PartitionOptions& PartitionQueryRequest::_internal_partition_options() const {
  const ::google::spanner::v1::PartitionOptions* p = _impl_.partition_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::PartitionOptions&>(
      ::google::spanner::v1::_PartitionOptions_default_instance_);
}
inline const ::google::spanner::v1::PartitionOptions& PartitionQueryRequest::partition_options() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionQueryRequest.partition_options)
  return _internal_partition_options();
}
inline void PartitionQueryRequest::unsafe_arena_set_allocated_partition_options(
    ::google::spanner::v1::PartitionOptions* partition_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partition_options_);
  }
  _impl_.partition_options_ = partition_options;
  if (partition_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.PartitionQueryRequest.partition_options)
}
inline ::google::spanner::v1::PartitionOptions* PartitionQueryRequest::release_partition_options() {
  
  ::google::spanner::v1::PartitionOptions* temp = _impl_.partition_options_;
  _impl_.partition_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::PartitionOptions* PartitionQueryRequest::unsafe_arena_release_partition_options() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.PartitionQueryRequest.partition_options)
  
  ::google::spanner::v1::PartitionOptions* temp = _impl_.partition_options_;
  _impl_.partition_options_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::PartitionOptions* PartitionQueryRequest::_internal_mutable_partition_options() {
  
  if (_impl_.partition_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::PartitionOptions>(GetArenaForAllocation());
    _impl_.partition_options_ = p;
  }
  return _impl_.partition_options_;
}
inline ::google::spanner::v1::PartitionOptions* PartitionQueryRequest::mutable_partition_options() {
  ::google::spanner::v1::PartitionOptions* _msg = _internal_mutable_partition_options();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.PartitionQueryRequest.partition_options)
  return _msg;
}
inline void PartitionQueryRequest::set_allocated_partition_options(::google::spanner::v1::PartitionOptions* partition_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.partition_options_;
  }
  if (partition_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(partition_options);
    if (message_arena != submessage_arena) {
      partition_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition_options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partition_options_ = partition_options;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.PartitionQueryRequest.partition_options)
}

// -------------------------------------------------------------------

// PartitionReadRequest

// string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void PartitionReadRequest::clear_session() {
  _impl_.session_.ClearToEmpty();
}
inline const std::string& PartitionReadRequest::session() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionReadRequest.session)
  return _internal_session();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionReadRequest::set_session(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.PartitionReadRequest.session)
}
inline std::string* PartitionReadRequest::mutable_session() {
  std::string* _s = _internal_mutable_session();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.PartitionReadRequest.session)
  return _s;
}
inline const std::string& PartitionReadRequest::_internal_session() const {
  return _impl_.session_.Get();
}
inline void PartitionReadRequest::_internal_set_session(const std::string& value) {
  
  _impl_.session_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionReadRequest::_internal_mutable_session() {
  
  return _impl_.session_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionReadRequest::release_session() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.PartitionReadRequest.session)
  return _impl_.session_.Release();
}
inline void PartitionReadRequest::set_allocated_session(std::string* session) {
  if (session != nullptr) {
    
  } else {
    
  }
  _impl_.session_.SetAllocated(session, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_.IsDefault()) {
    _impl_.session_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.PartitionReadRequest.session)
}

// .google.spanner.v1.TransactionSelector transaction = 2;
inline bool PartitionReadRequest::_internal_has_transaction() const {
  return this != internal_default_instance() && _impl_.transaction_ != nullptr;
}
inline bool PartitionReadRequest::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::google::spanner::v1::TransactionSelector& PartitionReadRequest::_internal_transaction() const {
  const ::google::spanner::v1::TransactionSelector* p = _impl_.transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::TransactionSelector&>(
      ::google::spanner::v1::_TransactionSelector_default_instance_);
}
inline const ::google::spanner::v1::TransactionSelector& PartitionReadRequest::transaction() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionReadRequest.transaction)
  return _internal_transaction();
}
inline void PartitionReadRequest::unsafe_arena_set_allocated_transaction(
    ::google::spanner::v1::TransactionSelector* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_);
  }
  _impl_.transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.PartitionReadRequest.transaction)
}
inline ::google::spanner::v1::TransactionSelector* PartitionReadRequest::release_transaction() {
  
  ::google::spanner::v1::TransactionSelector* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::TransactionSelector* PartitionReadRequest::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.PartitionReadRequest.transaction)
  
  ::google::spanner::v1::TransactionSelector* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::TransactionSelector* PartitionReadRequest::_internal_mutable_transaction() {
  
  if (_impl_.transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::TransactionSelector>(GetArenaForAllocation());
    _impl_.transaction_ = p;
  }
  return _impl_.transaction_;
}
inline ::google::spanner::v1::TransactionSelector* PartitionReadRequest::mutable_transaction() {
  ::google::spanner::v1::TransactionSelector* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.PartitionReadRequest.transaction)
  return _msg;
}
inline void PartitionReadRequest::set_allocated_transaction(::google::spanner::v1::TransactionSelector* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.PartitionReadRequest.transaction)
}

// string table = 3 [(.google.api.field_behavior) = REQUIRED];
inline void PartitionReadRequest::clear_table() {
  _impl_.table_.ClearToEmpty();
}
inline const std::string& PartitionReadRequest::table() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionReadRequest.table)
  return _internal_table();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionReadRequest::set_table(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.PartitionReadRequest.table)
}
inline std::string* PartitionReadRequest::mutable_table() {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.PartitionReadRequest.table)
  return _s;
}
inline const std::string& PartitionReadRequest::_internal_table() const {
  return _impl_.table_.Get();
}
inline void PartitionReadRequest::_internal_set_table(const std::string& value) {
  
  _impl_.table_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionReadRequest::_internal_mutable_table() {
  
  return _impl_.table_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionReadRequest::release_table() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.PartitionReadRequest.table)
  return _impl_.table_.Release();
}
inline void PartitionReadRequest::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  _impl_.table_.SetAllocated(table, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_.IsDefault()) {
    _impl_.table_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.PartitionReadRequest.table)
}

// string index = 4;
inline void PartitionReadRequest::clear_index() {
  _impl_.index_.ClearToEmpty();
}
inline const std::string& PartitionReadRequest::index() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionReadRequest.index)
  return _internal_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionReadRequest::set_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.PartitionReadRequest.index)
}
inline std::string* PartitionReadRequest::mutable_index() {
  std::string* _s = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.PartitionReadRequest.index)
  return _s;
}
inline const std::string& PartitionReadRequest::_internal_index() const {
  return _impl_.index_.Get();
}
inline void PartitionReadRequest::_internal_set_index(const std::string& value) {
  
  _impl_.index_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionReadRequest::_internal_mutable_index() {
  
  return _impl_.index_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionReadRequest::release_index() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.PartitionReadRequest.index)
  return _impl_.index_.Release();
}
inline void PartitionReadRequest::set_allocated_index(std::string* index) {
  if (index != nullptr) {
    
  } else {
    
  }
  _impl_.index_.SetAllocated(index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_.IsDefault()) {
    _impl_.index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.PartitionReadRequest.index)
}

// repeated string columns = 5;
inline int PartitionReadRequest::_internal_columns_size() const {
  return _impl_.columns_.size();
}
inline int PartitionReadRequest::columns_size() const {
  return _internal_columns_size();
}
inline void PartitionReadRequest::clear_columns() {
  _impl_.columns_.Clear();
}
inline std::string* PartitionReadRequest::add_columns() {
  std::string* _s = _internal_add_columns();
  // @@protoc_insertion_point(field_add_mutable:google.spanner.v1.PartitionReadRequest.columns)
  return _s;
}
inline const std::string& PartitionReadRequest::_internal_columns(int index) const {
  return _impl_.columns_.Get(index);
}
inline const std::string& PartitionReadRequest::columns(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionReadRequest.columns)
  return _internal_columns(index);
}
inline std::string* PartitionReadRequest::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.PartitionReadRequest.columns)
  return _impl_.columns_.Mutable(index);
}
inline void PartitionReadRequest::set_columns(int index, const std::string& value) {
  _impl_.columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.PartitionReadRequest.columns)
}
inline void PartitionReadRequest::set_columns(int index, std::string&& value) {
  _impl_.columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.spanner.v1.PartitionReadRequest.columns)
}
inline void PartitionReadRequest::set_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.PartitionReadRequest.columns)
}
inline void PartitionReadRequest::set_columns(int index, const char* value, size_t size) {
  _impl_.columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.PartitionReadRequest.columns)
}
inline std::string* PartitionReadRequest::_internal_add_columns() {
  return _impl_.columns_.Add();
}
inline void PartitionReadRequest::add_columns(const std::string& value) {
  _impl_.columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.spanner.v1.PartitionReadRequest.columns)
}
inline void PartitionReadRequest::add_columns(std::string&& value) {
  _impl_.columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.spanner.v1.PartitionReadRequest.columns)
}
inline void PartitionReadRequest::add_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.spanner.v1.PartitionReadRequest.columns)
}
inline void PartitionReadRequest::add_columns(const char* value, size_t size) {
  _impl_.columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.spanner.v1.PartitionReadRequest.columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PartitionReadRequest::columns() const {
  // @@protoc_insertion_point(field_list:google.spanner.v1.PartitionReadRequest.columns)
  return _impl_.columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PartitionReadRequest::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.v1.PartitionReadRequest.columns)
  return &_impl_.columns_;
}

// .google.spanner.v1.KeySet key_set = 6 [(.google.api.field_behavior) = REQUIRED];
inline bool PartitionReadRequest::_internal_has_key_set() const {
  return this != internal_default_instance() && _impl_.key_set_ != nullptr;
}
inline bool PartitionReadRequest::has_key_set() const {
  return _internal_has_key_set();
}
inline const ::google::spanner::v1::KeySet& PartitionReadRequest::_internal_key_set() const {
  const ::google::spanner::v1::KeySet* p = _impl_.key_set_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::KeySet&>(
      ::google::spanner::v1::_KeySet_default_instance_);
}
inline const ::google::spanner::v1::KeySet& PartitionReadRequest::key_set() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionReadRequest.key_set)
  return _internal_key_set();
}
inline void PartitionReadRequest::unsafe_arena_set_allocated_key_set(
    ::google::spanner::v1::KeySet* key_set) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_set_);
  }
  _impl_.key_set_ = key_set;
  if (key_set) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.PartitionReadRequest.key_set)
}
inline ::google::spanner::v1::KeySet* PartitionReadRequest::release_key_set() {
  
  ::google::spanner::v1::KeySet* temp = _impl_.key_set_;
  _impl_.key_set_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::KeySet* PartitionReadRequest::unsafe_arena_release_key_set() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.PartitionReadRequest.key_set)
  
  ::google::spanner::v1::KeySet* temp = _impl_.key_set_;
  _impl_.key_set_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::KeySet* PartitionReadRequest::_internal_mutable_key_set() {
  
  if (_impl_.key_set_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::KeySet>(GetArenaForAllocation());
    _impl_.key_set_ = p;
  }
  return _impl_.key_set_;
}
inline ::google::spanner::v1::KeySet* PartitionReadRequest::mutable_key_set() {
  ::google::spanner::v1::KeySet* _msg = _internal_mutable_key_set();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.PartitionReadRequest.key_set)
  return _msg;
}
inline void PartitionReadRequest::set_allocated_key_set(::google::spanner::v1::KeySet* key_set) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_set_);
  }
  if (key_set) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_set));
    if (message_arena != submessage_arena) {
      key_set = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_set, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_set_ = key_set;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.PartitionReadRequest.key_set)
}

// .google.spanner.v1.PartitionOptions partition_options = 9;
inline bool PartitionReadRequest::_internal_has_partition_options() const {
  return this != internal_default_instance() && _impl_.partition_options_ != nullptr;
}
inline bool PartitionReadRequest::has_partition_options() const {
  return _internal_has_partition_options();
}
inline void PartitionReadRequest::clear_partition_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.partition_options_ != nullptr) {
    delete _impl_.partition_options_;
  }
  _impl_.partition_options_ = nullptr;
}
inline const ::google::spanner::v1::PartitionOptions& PartitionReadRequest::_internal_partition_options() const {
  const ::google::spanner::v1::PartitionOptions* p = _impl_.partition_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::PartitionOptions&>(
      ::google::spanner::v1::_PartitionOptions_default_instance_);
}
inline const ::google::spanner::v1::PartitionOptions& PartitionReadRequest::partition_options() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionReadRequest.partition_options)
  return _internal_partition_options();
}
inline void PartitionReadRequest::unsafe_arena_set_allocated_partition_options(
    ::google::spanner::v1::PartitionOptions* partition_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partition_options_);
  }
  _impl_.partition_options_ = partition_options;
  if (partition_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.PartitionReadRequest.partition_options)
}
inline ::google::spanner::v1::PartitionOptions* PartitionReadRequest::release_partition_options() {
  
  ::google::spanner::v1::PartitionOptions* temp = _impl_.partition_options_;
  _impl_.partition_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::PartitionOptions* PartitionReadRequest::unsafe_arena_release_partition_options() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.PartitionReadRequest.partition_options)
  
  ::google::spanner::v1::PartitionOptions* temp = _impl_.partition_options_;
  _impl_.partition_options_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::PartitionOptions* PartitionReadRequest::_internal_mutable_partition_options() {
  
  if (_impl_.partition_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::PartitionOptions>(GetArenaForAllocation());
    _impl_.partition_options_ = p;
  }
  return _impl_.partition_options_;
}
inline ::google::spanner::v1::PartitionOptions* PartitionReadRequest::mutable_partition_options() {
  ::google::spanner::v1::PartitionOptions* _msg = _internal_mutable_partition_options();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.PartitionReadRequest.partition_options)
  return _msg;
}
inline void PartitionReadRequest::set_allocated_partition_options(::google::spanner::v1::PartitionOptions* partition_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.partition_options_;
  }
  if (partition_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(partition_options);
    if (message_arena != submessage_arena) {
      partition_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition_options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partition_options_ = partition_options;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.PartitionReadRequest.partition_options)
}

// -------------------------------------------------------------------

// Partition

// bytes partition_token = 1;
inline void Partition::clear_partition_token() {
  _impl_.partition_token_.ClearToEmpty();
}
inline const std::string& Partition::partition_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.Partition.partition_token)
  return _internal_partition_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Partition::set_partition_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.partition_token_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.Partition.partition_token)
}
inline std::string* Partition::mutable_partition_token() {
  std::string* _s = _internal_mutable_partition_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.Partition.partition_token)
  return _s;
}
inline const std::string& Partition::_internal_partition_token() const {
  return _impl_.partition_token_.Get();
}
inline void Partition::_internal_set_partition_token(const std::string& value) {
  
  _impl_.partition_token_.Set(value, GetArenaForAllocation());
}
inline std::string* Partition::_internal_mutable_partition_token() {
  
  return _impl_.partition_token_.Mutable(GetArenaForAllocation());
}
inline std::string* Partition::release_partition_token() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.Partition.partition_token)
  return _impl_.partition_token_.Release();
}
inline void Partition::set_allocated_partition_token(std::string* partition_token) {
  if (partition_token != nullptr) {
    
  } else {
    
  }
  _impl_.partition_token_.SetAllocated(partition_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.partition_token_.IsDefault()) {
    _impl_.partition_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.Partition.partition_token)
}

// -------------------------------------------------------------------

// PartitionResponse

// repeated .google.spanner.v1.Partition partitions = 1;
inline int PartitionResponse::_internal_partitions_size() const {
  return _impl_.partitions_.size();
}
inline int PartitionResponse::partitions_size() const {
  return _internal_partitions_size();
}
inline void PartitionResponse::clear_partitions() {
  _impl_.partitions_.Clear();
}
inline ::google::spanner::v1::Partition* PartitionResponse::mutable_partitions(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.PartitionResponse.partitions)
  return _impl_.partitions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Partition >*
PartitionResponse::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.v1.PartitionResponse.partitions)
  return &_impl_.partitions_;
}
inline const ::google::spanner::v1::Partition& PartitionResponse::_internal_partitions(int index) const {
  return _impl_.partitions_.Get(index);
}
inline const ::google::spanner::v1::Partition& PartitionResponse::partitions(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionResponse.partitions)
  return _internal_partitions(index);
}
inline ::google::spanner::v1::Partition* PartitionResponse::_internal_add_partitions() {
  return _impl_.partitions_.Add();
}
inline ::google::spanner::v1::Partition* PartitionResponse::add_partitions() {
  ::google::spanner::v1::Partition* _add = _internal_add_partitions();
  // @@protoc_insertion_point(field_add:google.spanner.v1.PartitionResponse.partitions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Partition >&
PartitionResponse::partitions() const {
  // @@protoc_insertion_point(field_list:google.spanner.v1.PartitionResponse.partitions)
  return _impl_.partitions_;
}

// .google.spanner.v1.Transaction transaction = 2;
inline bool PartitionResponse::_internal_has_transaction() const {
  return this != internal_default_instance() && _impl_.transaction_ != nullptr;
}
inline bool PartitionResponse::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::google::spanner::v1::Transaction& PartitionResponse::_internal_transaction() const {
  const ::google::spanner::v1::Transaction* p = _impl_.transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::Transaction&>(
      ::google::spanner::v1::_Transaction_default_instance_);
}
inline const ::google::spanner::v1::Transaction& PartitionResponse::transaction() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.PartitionResponse.transaction)
  return _internal_transaction();
}
inline void PartitionResponse::unsafe_arena_set_allocated_transaction(
    ::google::spanner::v1::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_);
  }
  _impl_.transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.PartitionResponse.transaction)
}
inline ::google::spanner::v1::Transaction* PartitionResponse::release_transaction() {
  
  ::google::spanner::v1::Transaction* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::Transaction* PartitionResponse::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.PartitionResponse.transaction)
  
  ::google::spanner::v1::Transaction* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::Transaction* PartitionResponse::_internal_mutable_transaction() {
  
  if (_impl_.transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::Transaction>(GetArenaForAllocation());
    _impl_.transaction_ = p;
  }
  return _impl_.transaction_;
}
inline ::google::spanner::v1::Transaction* PartitionResponse::mutable_transaction() {
  ::google::spanner::v1::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.PartitionResponse.transaction)
  return _msg;
}
inline void PartitionResponse::set_allocated_transaction(::google::spanner::v1::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.PartitionResponse.transaction)
}

// -------------------------------------------------------------------

// ReadRequest

// string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ReadRequest::clear_session() {
  _impl_.session_.ClearToEmpty();
}
inline const std::string& ReadRequest::session() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.session)
  return _internal_session();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadRequest::set_session(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ReadRequest.session)
}
inline std::string* ReadRequest::mutable_session() {
  std::string* _s = _internal_mutable_session();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.session)
  return _s;
}
inline const std::string& ReadRequest::_internal_session() const {
  return _impl_.session_.Get();
}
inline void ReadRequest::_internal_set_session(const std::string& value) {
  
  _impl_.session_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadRequest::_internal_mutable_session() {
  
  return _impl_.session_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadRequest::release_session() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ReadRequest.session)
  return _impl_.session_.Release();
}
inline void ReadRequest::set_allocated_session(std::string* session) {
  if (session != nullptr) {
    
  } else {
    
  }
  _impl_.session_.SetAllocated(session, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_.IsDefault()) {
    _impl_.session_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ReadRequest.session)
}

// .google.spanner.v1.TransactionSelector transaction = 2;
inline bool ReadRequest::_internal_has_transaction() const {
  return this != internal_default_instance() && _impl_.transaction_ != nullptr;
}
inline bool ReadRequest::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::google::spanner::v1::TransactionSelector& ReadRequest::_internal_transaction() const {
  const ::google::spanner::v1::TransactionSelector* p = _impl_.transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::TransactionSelector&>(
      ::google::spanner::v1::_TransactionSelector_default_instance_);
}
inline const ::google::spanner::v1::TransactionSelector& ReadRequest::transaction() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.transaction)
  return _internal_transaction();
}
inline void ReadRequest::unsafe_arena_set_allocated_transaction(
    ::google::spanner::v1::TransactionSelector* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_);
  }
  _impl_.transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.ReadRequest.transaction)
}
inline ::google::spanner::v1::TransactionSelector* ReadRequest::release_transaction() {
  
  ::google::spanner::v1::TransactionSelector* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::TransactionSelector* ReadRequest::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ReadRequest.transaction)
  
  ::google::spanner::v1::TransactionSelector* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::TransactionSelector* ReadRequest::_internal_mutable_transaction() {
  
  if (_impl_.transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::TransactionSelector>(GetArenaForAllocation());
    _impl_.transaction_ = p;
  }
  return _impl_.transaction_;
}
inline ::google::spanner::v1::TransactionSelector* ReadRequest::mutable_transaction() {
  ::google::spanner::v1::TransactionSelector* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.transaction)
  return _msg;
}
inline void ReadRequest::set_allocated_transaction(::google::spanner::v1::TransactionSelector* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ReadRequest.transaction)
}

// string table = 3 [(.google.api.field_behavior) = REQUIRED];
inline void ReadRequest::clear_table() {
  _impl_.table_.ClearToEmpty();
}
inline const std::string& ReadRequest::table() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.table)
  return _internal_table();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadRequest::set_table(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ReadRequest.table)
}
inline std::string* ReadRequest::mutable_table() {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.table)
  return _s;
}
inline const std::string& ReadRequest::_internal_table() const {
  return _impl_.table_.Get();
}
inline void ReadRequest::_internal_set_table(const std::string& value) {
  
  _impl_.table_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadRequest::_internal_mutable_table() {
  
  return _impl_.table_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadRequest::release_table() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ReadRequest.table)
  return _impl_.table_.Release();
}
inline void ReadRequest::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  _impl_.table_.SetAllocated(table, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_.IsDefault()) {
    _impl_.table_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ReadRequest.table)
}

// string index = 4;
inline void ReadRequest::clear_index() {
  _impl_.index_.ClearToEmpty();
}
inline const std::string& ReadRequest::index() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.index)
  return _internal_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadRequest::set_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ReadRequest.index)
}
inline std::string* ReadRequest::mutable_index() {
  std::string* _s = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.index)
  return _s;
}
inline const std::string& ReadRequest::_internal_index() const {
  return _impl_.index_.Get();
}
inline void ReadRequest::_internal_set_index(const std::string& value) {
  
  _impl_.index_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadRequest::_internal_mutable_index() {
  
  return _impl_.index_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadRequest::release_index() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ReadRequest.index)
  return _impl_.index_.Release();
}
inline void ReadRequest::set_allocated_index(std::string* index) {
  if (index != nullptr) {
    
  } else {
    
  }
  _impl_.index_.SetAllocated(index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_.IsDefault()) {
    _impl_.index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ReadRequest.index)
}

// repeated string columns = 5 [(.google.api.field_behavior) = REQUIRED];
inline int ReadRequest::_internal_columns_size() const {
  return _impl_.columns_.size();
}
inline int ReadRequest::columns_size() const {
  return _internal_columns_size();
}
inline void ReadRequest::clear_columns() {
  _impl_.columns_.Clear();
}
inline std::string* ReadRequest::add_columns() {
  std::string* _s = _internal_add_columns();
  // @@protoc_insertion_point(field_add_mutable:google.spanner.v1.ReadRequest.columns)
  return _s;
}
inline const std::string& ReadRequest::_internal_columns(int index) const {
  return _impl_.columns_.Get(index);
}
inline const std::string& ReadRequest::columns(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.columns)
  return _internal_columns(index);
}
inline std::string* ReadRequest::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.columns)
  return _impl_.columns_.Mutable(index);
}
inline void ReadRequest::set_columns(int index, const std::string& value) {
  _impl_.columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.ReadRequest.columns)
}
inline void ReadRequest::set_columns(int index, std::string&& value) {
  _impl_.columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.spanner.v1.ReadRequest.columns)
}
inline void ReadRequest::set_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.ReadRequest.columns)
}
inline void ReadRequest::set_columns(int index, const char* value, size_t size) {
  _impl_.columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.ReadRequest.columns)
}
inline std::string* ReadRequest::_internal_add_columns() {
  return _impl_.columns_.Add();
}
inline void ReadRequest::add_columns(const std::string& value) {
  _impl_.columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.spanner.v1.ReadRequest.columns)
}
inline void ReadRequest::add_columns(std::string&& value) {
  _impl_.columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.spanner.v1.ReadRequest.columns)
}
inline void ReadRequest::add_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.spanner.v1.ReadRequest.columns)
}
inline void ReadRequest::add_columns(const char* value, size_t size) {
  _impl_.columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.spanner.v1.ReadRequest.columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ReadRequest::columns() const {
  // @@protoc_insertion_point(field_list:google.spanner.v1.ReadRequest.columns)
  return _impl_.columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ReadRequest::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.v1.ReadRequest.columns)
  return &_impl_.columns_;
}

// .google.spanner.v1.KeySet key_set = 6 [(.google.api.field_behavior) = REQUIRED];
inline bool ReadRequest::_internal_has_key_set() const {
  return this != internal_default_instance() && _impl_.key_set_ != nullptr;
}
inline bool ReadRequest::has_key_set() const {
  return _internal_has_key_set();
}
inline const ::google::spanner::v1::KeySet& ReadRequest::_internal_key_set() const {
  const ::google::spanner::v1::KeySet* p = _impl_.key_set_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::KeySet&>(
      ::google::spanner::v1::_KeySet_default_instance_);
}
inline const ::google::spanner::v1::KeySet& ReadRequest::key_set() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.key_set)
  return _internal_key_set();
}
inline void ReadRequest::unsafe_arena_set_allocated_key_set(
    ::google::spanner::v1::KeySet* key_set) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_set_);
  }
  _impl_.key_set_ = key_set;
  if (key_set) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.ReadRequest.key_set)
}
inline ::google::spanner::v1::KeySet* ReadRequest::release_key_set() {
  
  ::google::spanner::v1::KeySet* temp = _impl_.key_set_;
  _impl_.key_set_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::KeySet* ReadRequest::unsafe_arena_release_key_set() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ReadRequest.key_set)
  
  ::google::spanner::v1::KeySet* temp = _impl_.key_set_;
  _impl_.key_set_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::KeySet* ReadRequest::_internal_mutable_key_set() {
  
  if (_impl_.key_set_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::KeySet>(GetArenaForAllocation());
    _impl_.key_set_ = p;
  }
  return _impl_.key_set_;
}
inline ::google::spanner::v1::KeySet* ReadRequest::mutable_key_set() {
  ::google::spanner::v1::KeySet* _msg = _internal_mutable_key_set();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.key_set)
  return _msg;
}
inline void ReadRequest::set_allocated_key_set(::google::spanner::v1::KeySet* key_set) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_set_);
  }
  if (key_set) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_set));
    if (message_arena != submessage_arena) {
      key_set = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_set, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_set_ = key_set;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ReadRequest.key_set)
}

// int64 limit = 8;
inline void ReadRequest::clear_limit() {
  _impl_.limit_ = int64_t{0};
}
inline int64_t ReadRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline int64_t ReadRequest::limit() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.limit)
  return _internal_limit();
}
inline void ReadRequest::_internal_set_limit(int64_t value) {
  
  _impl_.limit_ = value;
}
inline void ReadRequest::set_limit(int64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.ReadRequest.limit)
}

// bytes resume_token = 9;
inline void ReadRequest::clear_resume_token() {
  _impl_.resume_token_.ClearToEmpty();
}
inline const std::string& ReadRequest::resume_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.resume_token)
  return _internal_resume_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadRequest::set_resume_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resume_token_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ReadRequest.resume_token)
}
inline std::string* ReadRequest::mutable_resume_token() {
  std::string* _s = _internal_mutable_resume_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.resume_token)
  return _s;
}
inline const std::string& ReadRequest::_internal_resume_token() const {
  return _impl_.resume_token_.Get();
}
inline void ReadRequest::_internal_set_resume_token(const std::string& value) {
  
  _impl_.resume_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadRequest::_internal_mutable_resume_token() {
  
  return _impl_.resume_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadRequest::release_resume_token() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ReadRequest.resume_token)
  return _impl_.resume_token_.Release();
}
inline void ReadRequest::set_allocated_resume_token(std::string* resume_token) {
  if (resume_token != nullptr) {
    
  } else {
    
  }
  _impl_.resume_token_.SetAllocated(resume_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resume_token_.IsDefault()) {
    _impl_.resume_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ReadRequest.resume_token)
}

// bytes partition_token = 10;
inline void ReadRequest::clear_partition_token() {
  _impl_.partition_token_.ClearToEmpty();
}
inline const std::string& ReadRequest::partition_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.partition_token)
  return _internal_partition_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadRequest::set_partition_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.partition_token_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.ReadRequest.partition_token)
}
inline std::string* ReadRequest::mutable_partition_token() {
  std::string* _s = _internal_mutable_partition_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.partition_token)
  return _s;
}
inline const std::string& ReadRequest::_internal_partition_token() const {
  return _impl_.partition_token_.Get();
}
inline void ReadRequest::_internal_set_partition_token(const std::string& value) {
  
  _impl_.partition_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadRequest::_internal_mutable_partition_token() {
  
  return _impl_.partition_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadRequest::release_partition_token() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ReadRequest.partition_token)
  return _impl_.partition_token_.Release();
}
inline void ReadRequest::set_allocated_partition_token(std::string* partition_token) {
  if (partition_token != nullptr) {
    
  } else {
    
  }
  _impl_.partition_token_.SetAllocated(partition_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.partition_token_.IsDefault()) {
    _impl_.partition_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ReadRequest.partition_token)
}

// .google.spanner.v1.RequestOptions request_options = 11;
inline bool ReadRequest::_internal_has_request_options() const {
  return this != internal_default_instance() && _impl_.request_options_ != nullptr;
}
inline bool ReadRequest::has_request_options() const {
  return _internal_has_request_options();
}
inline void ReadRequest::clear_request_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_options_ != nullptr) {
    delete _impl_.request_options_;
  }
  _impl_.request_options_ = nullptr;
}
inline const ::google::spanner::v1::RequestOptions& ReadRequest::_internal_request_options() const {
  const ::google::spanner::v1::RequestOptions* p = _impl_.request_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::RequestOptions&>(
      ::google::spanner::v1::_RequestOptions_default_instance_);
}
inline const ::google::spanner::v1::RequestOptions& ReadRequest::request_options() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.request_options)
  return _internal_request_options();
}
inline void ReadRequest::unsafe_arena_set_allocated_request_options(
    ::google::spanner::v1::RequestOptions* request_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_options_);
  }
  _impl_.request_options_ = request_options;
  if (request_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.ReadRequest.request_options)
}
inline ::google::spanner::v1::RequestOptions* ReadRequest::release_request_options() {
  
  ::google::spanner::v1::RequestOptions* temp = _impl_.request_options_;
  _impl_.request_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::RequestOptions* ReadRequest::unsafe_arena_release_request_options() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ReadRequest.request_options)
  
  ::google::spanner::v1::RequestOptions* temp = _impl_.request_options_;
  _impl_.request_options_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::RequestOptions* ReadRequest::_internal_mutable_request_options() {
  
  if (_impl_.request_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::RequestOptions>(GetArenaForAllocation());
    _impl_.request_options_ = p;
  }
  return _impl_.request_options_;
}
inline ::google::spanner::v1::RequestOptions* ReadRequest::mutable_request_options() {
  ::google::spanner::v1::RequestOptions* _msg = _internal_mutable_request_options();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.request_options)
  return _msg;
}
inline void ReadRequest::set_allocated_request_options(::google::spanner::v1::RequestOptions* request_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_options_;
  }
  if (request_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_options);
    if (message_arena != submessage_arena) {
      request_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_options_ = request_options;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ReadRequest.request_options)
}

// -------------------------------------------------------------------

// BeginTransactionRequest

// string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void BeginTransactionRequest::clear_session() {
  _impl_.session_.ClearToEmpty();
}
inline const std::string& BeginTransactionRequest::session() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.BeginTransactionRequest.session)
  return _internal_session();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BeginTransactionRequest::set_session(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.BeginTransactionRequest.session)
}
inline std::string* BeginTransactionRequest::mutable_session() {
  std::string* _s = _internal_mutable_session();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.BeginTransactionRequest.session)
  return _s;
}
inline const std::string& BeginTransactionRequest::_internal_session() const {
  return _impl_.session_.Get();
}
inline void BeginTransactionRequest::_internal_set_session(const std::string& value) {
  
  _impl_.session_.Set(value, GetArenaForAllocation());
}
inline std::string* BeginTransactionRequest::_internal_mutable_session() {
  
  return _impl_.session_.Mutable(GetArenaForAllocation());
}
inline std::string* BeginTransactionRequest::release_session() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.BeginTransactionRequest.session)
  return _impl_.session_.Release();
}
inline void BeginTransactionRequest::set_allocated_session(std::string* session) {
  if (session != nullptr) {
    
  } else {
    
  }
  _impl_.session_.SetAllocated(session, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_.IsDefault()) {
    _impl_.session_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.BeginTransactionRequest.session)
}

// .google.spanner.v1.TransactionOptions options = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool BeginTransactionRequest::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool BeginTransactionRequest::has_options() const {
  return _internal_has_options();
}
inline const ::google::spanner::v1::TransactionOptions& BeginTransactionRequest::_internal_options() const {
  const ::google::spanner::v1::TransactionOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::TransactionOptions&>(
      ::google::spanner::v1::_TransactionOptions_default_instance_);
}
inline const ::google::spanner::v1::TransactionOptions& BeginTransactionRequest::options() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.BeginTransactionRequest.options)
  return _internal_options();
}
inline void BeginTransactionRequest::unsafe_arena_set_allocated_options(
    ::google::spanner::v1::TransactionOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.BeginTransactionRequest.options)
}
inline ::google::spanner::v1::TransactionOptions* BeginTransactionRequest::release_options() {
  
  ::google::spanner::v1::TransactionOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::TransactionOptions* BeginTransactionRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.BeginTransactionRequest.options)
  
  ::google::spanner::v1::TransactionOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::TransactionOptions* BeginTransactionRequest::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::TransactionOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::google::spanner::v1::TransactionOptions* BeginTransactionRequest::mutable_options() {
  ::google::spanner::v1::TransactionOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.BeginTransactionRequest.options)
  return _msg;
}
inline void BeginTransactionRequest::set_allocated_options(::google::spanner::v1::TransactionOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options));
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.BeginTransactionRequest.options)
}

// .google.spanner.v1.RequestOptions request_options = 3;
inline bool BeginTransactionRequest::_internal_has_request_options() const {
  return this != internal_default_instance() && _impl_.request_options_ != nullptr;
}
inline bool BeginTransactionRequest::has_request_options() const {
  return _internal_has_request_options();
}
inline void BeginTransactionRequest::clear_request_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_options_ != nullptr) {
    delete _impl_.request_options_;
  }
  _impl_.request_options_ = nullptr;
}
inline const ::google::spanner::v1::RequestOptions& BeginTransactionRequest::_internal_request_options() const {
  const ::google::spanner::v1::RequestOptions* p = _impl_.request_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::RequestOptions&>(
      ::google::spanner::v1::_RequestOptions_default_instance_);
}
inline const ::google::spanner::v1::RequestOptions& BeginTransactionRequest::request_options() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.BeginTransactionRequest.request_options)
  return _internal_request_options();
}
inline void BeginTransactionRequest::unsafe_arena_set_allocated_request_options(
    ::google::spanner::v1::RequestOptions* request_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_options_);
  }
  _impl_.request_options_ = request_options;
  if (request_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.BeginTransactionRequest.request_options)
}
inline ::google::spanner::v1::RequestOptions* BeginTransactionRequest::release_request_options() {
  
  ::google::spanner::v1::RequestOptions* temp = _impl_.request_options_;
  _impl_.request_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::RequestOptions* BeginTransactionRequest::unsafe_arena_release_request_options() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.BeginTransactionRequest.request_options)
  
  ::google::spanner::v1::RequestOptions* temp = _impl_.request_options_;
  _impl_.request_options_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::RequestOptions* BeginTransactionRequest::_internal_mutable_request_options() {
  
  if (_impl_.request_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::RequestOptions>(GetArenaForAllocation());
    _impl_.request_options_ = p;
  }
  return _impl_.request_options_;
}
inline ::google::spanner::v1::RequestOptions* BeginTransactionRequest::mutable_request_options() {
  ::google::spanner::v1::RequestOptions* _msg = _internal_mutable_request_options();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.BeginTransactionRequest.request_options)
  return _msg;
}
inline void BeginTransactionRequest::set_allocated_request_options(::google::spanner::v1::RequestOptions* request_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_options_;
  }
  if (request_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_options);
    if (message_arena != submessage_arena) {
      request_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_options_ = request_options;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.BeginTransactionRequest.request_options)
}

// -------------------------------------------------------------------

// CommitRequest

// string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CommitRequest::clear_session() {
  _impl_.session_.ClearToEmpty();
}
inline const std::string& CommitRequest::session() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.CommitRequest.session)
  return _internal_session();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommitRequest::set_session(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.CommitRequest.session)
}
inline std::string* CommitRequest::mutable_session() {
  std::string* _s = _internal_mutable_session();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.CommitRequest.session)
  return _s;
}
inline const std::string& CommitRequest::_internal_session() const {
  return _impl_.session_.Get();
}
inline void CommitRequest::_internal_set_session(const std::string& value) {
  
  _impl_.session_.Set(value, GetArenaForAllocation());
}
inline std::string* CommitRequest::_internal_mutable_session() {
  
  return _impl_.session_.Mutable(GetArenaForAllocation());
}
inline std::string* CommitRequest::release_session() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.CommitRequest.session)
  return _impl_.session_.Release();
}
inline void CommitRequest::set_allocated_session(std::string* session) {
  if (session != nullptr) {
    
  } else {
    
  }
  _impl_.session_.SetAllocated(session, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_.IsDefault()) {
    _impl_.session_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.CommitRequest.session)
}

// bytes transaction_id = 2;
inline bool CommitRequest::_internal_has_transaction_id() const {
  return transaction_case() == kTransactionId;
}
inline bool CommitRequest::has_transaction_id() const {
  return _internal_has_transaction_id();
}
inline void CommitRequest::set_has_transaction_id() {
  _impl_._oneof_case_[0] = kTransactionId;
}
inline void CommitRequest::clear_transaction_id() {
  if (_internal_has_transaction_id()) {
    _impl_.transaction_.transaction_id_.Destroy();
    clear_has_transaction();
  }
}
inline const std::string& CommitRequest::transaction_id() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.CommitRequest.transaction_id)
  return _internal_transaction_id();
}
template <typename ArgT0, typename... ArgT>
inline void CommitRequest::set_transaction_id(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_transaction_id()) {
    clear_transaction();
    set_has_transaction_id();
    _impl_.transaction_.transaction_id_.InitDefault();
  }
  _impl_.transaction_.transaction_id_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.CommitRequest.transaction_id)
}
inline std::string* CommitRequest::mutable_transaction_id() {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.CommitRequest.transaction_id)
  return _s;
}
inline const std::string& CommitRequest::_internal_transaction_id() const {
  if (_internal_has_transaction_id()) {
    return _impl_.transaction_.transaction_id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CommitRequest::_internal_set_transaction_id(const std::string& value) {
  if (!_internal_has_transaction_id()) {
    clear_transaction();
    set_has_transaction_id();
    _impl_.transaction_.transaction_id_.InitDefault();
  }
  _impl_.transaction_.transaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CommitRequest::_internal_mutable_transaction_id() {
  if (!_internal_has_transaction_id()) {
    clear_transaction();
    set_has_transaction_id();
    _impl_.transaction_.transaction_id_.InitDefault();
  }
  return _impl_.transaction_.transaction_id_.Mutable(      GetArenaForAllocation());
}
inline std::string* CommitRequest::release_transaction_id() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.CommitRequest.transaction_id)
  if (_internal_has_transaction_id()) {
    clear_has_transaction();
    return _impl_.transaction_.transaction_id_.Release();
  } else {
    return nullptr;
  }
}
inline void CommitRequest::set_allocated_transaction_id(std::string* transaction_id) {
  if (has_transaction()) {
    clear_transaction();
  }
  if (transaction_id != nullptr) {
    set_has_transaction_id();
    _impl_.transaction_.transaction_id_.InitAllocated(transaction_id, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.CommitRequest.transaction_id)
}

// .google.spanner.v1.TransactionOptions single_use_transaction = 3;
inline bool CommitRequest::_internal_has_single_use_transaction() const {
  return transaction_case() == kSingleUseTransaction;
}
inline bool CommitRequest::has_single_use_transaction() const {
  return _internal_has_single_use_transaction();
}
inline void CommitRequest::set_has_single_use_transaction() {
  _impl_._oneof_case_[0] = kSingleUseTransaction;
}
inline ::google::spanner::v1::TransactionOptions* CommitRequest::release_single_use_transaction() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.CommitRequest.single_use_transaction)
  if (_internal_has_single_use_transaction()) {
    clear_has_transaction();
    ::google::spanner::v1::TransactionOptions* temp = _impl_.transaction_.single_use_transaction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.transaction_.single_use_transaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::spanner::v1::TransactionOptions& CommitRequest::_internal_single_use_transaction() const {
  return _internal_has_single_use_transaction()
      ? *_impl_.transaction_.single_use_transaction_
      : reinterpret_cast< ::google::spanner::v1::TransactionOptions&>(::google::spanner::v1::_TransactionOptions_default_instance_);
}
inline const ::google::spanner::v1::TransactionOptions& CommitRequest::single_use_transaction() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.CommitRequest.single_use_transaction)
  return _internal_single_use_transaction();
}
inline ::google::spanner::v1::TransactionOptions* CommitRequest::unsafe_arena_release_single_use_transaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.spanner.v1.CommitRequest.single_use_transaction)
  if (_internal_has_single_use_transaction()) {
    clear_has_transaction();
    ::google::spanner::v1::TransactionOptions* temp = _impl_.transaction_.single_use_transaction_;
    _impl_.transaction_.single_use_transaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CommitRequest::unsafe_arena_set_allocated_single_use_transaction(::google::spanner::v1::TransactionOptions* single_use_transaction) {
  clear_transaction();
  if (single_use_transaction) {
    set_has_single_use_transaction();
    _impl_.transaction_.single_use_transaction_ = single_use_transaction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.CommitRequest.single_use_transaction)
}
inline ::google::spanner::v1::TransactionOptions* CommitRequest::_internal_mutable_single_use_transaction() {
  if (!_internal_has_single_use_transaction()) {
    clear_transaction();
    set_has_single_use_transaction();
    _impl_.transaction_.single_use_transaction_ = CreateMaybeMessage< ::google::spanner::v1::TransactionOptions >(GetArenaForAllocation());
  }
  return _impl_.transaction_.single_use_transaction_;
}
inline ::google::spanner::v1::TransactionOptions* CommitRequest::mutable_single_use_transaction() {
  ::google::spanner::v1::TransactionOptions* _msg = _internal_mutable_single_use_transaction();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.CommitRequest.single_use_transaction)
  return _msg;
}

// repeated .google.spanner.v1.Mutation mutations = 4;
inline int CommitRequest::_internal_mutations_size() const {
  return _impl_.mutations_.size();
}
inline int CommitRequest::mutations_size() const {
  return _internal_mutations_size();
}
inline ::google::spanner::v1::Mutation* CommitRequest::mutable_mutations(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.CommitRequest.mutations)
  return _impl_.mutations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Mutation >*
CommitRequest::mutable_mutations() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.v1.CommitRequest.mutations)
  return &_impl_.mutations_;
}
inline const ::google::spanner::v1::Mutation& CommitRequest::_internal_mutations(int index) const {
  return _impl_.mutations_.Get(index);
}
inline const ::google::spanner::v1::Mutation& CommitRequest::mutations(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.CommitRequest.mutations)
  return _internal_mutations(index);
}
inline ::google::spanner::v1::Mutation* CommitRequest::_internal_add_mutations() {
  return _impl_.mutations_.Add();
}
inline ::google::spanner::v1::Mutation* CommitRequest::add_mutations() {
  ::google::spanner::v1::Mutation* _add = _internal_add_mutations();
  // @@protoc_insertion_point(field_add:google.spanner.v1.CommitRequest.mutations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::v1::Mutation >&
CommitRequest::mutations() const {
  // @@protoc_insertion_point(field_list:google.spanner.v1.CommitRequest.mutations)
  return _impl_.mutations_;
}

// bool return_commit_stats = 5;
inline void CommitRequest::clear_return_commit_stats() {
  _impl_.return_commit_stats_ = false;
}
inline bool CommitRequest::_internal_return_commit_stats() const {
  return _impl_.return_commit_stats_;
}
inline bool CommitRequest::return_commit_stats() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.CommitRequest.return_commit_stats)
  return _internal_return_commit_stats();
}
inline void CommitRequest::_internal_set_return_commit_stats(bool value) {
  
  _impl_.return_commit_stats_ = value;
}
inline void CommitRequest::set_return_commit_stats(bool value) {
  _internal_set_return_commit_stats(value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.CommitRequest.return_commit_stats)
}

// .google.spanner.v1.RequestOptions request_options = 6;
inline bool CommitRequest::_internal_has_request_options() const {
  return this != internal_default_instance() && _impl_.request_options_ != nullptr;
}
inline bool CommitRequest::has_request_options() const {
  return _internal_has_request_options();
}
inline void CommitRequest::clear_request_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_options_ != nullptr) {
    delete _impl_.request_options_;
  }
  _impl_.request_options_ = nullptr;
}
inline const ::google::spanner::v1::RequestOptions& CommitRequest::_internal_request_options() const {
  const ::google::spanner::v1::RequestOptions* p = _impl_.request_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::v1::RequestOptions&>(
      ::google::spanner::v1::_RequestOptions_default_instance_);
}
inline const ::google::spanner::v1::RequestOptions& CommitRequest::request_options() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.CommitRequest.request_options)
  return _internal_request_options();
}
inline void CommitRequest::unsafe_arena_set_allocated_request_options(
    ::google::spanner::v1::RequestOptions* request_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_options_);
  }
  _impl_.request_options_ = request_options;
  if (request_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.v1.CommitRequest.request_options)
}
inline ::google::spanner::v1::RequestOptions* CommitRequest::release_request_options() {
  
  ::google::spanner::v1::RequestOptions* temp = _impl_.request_options_;
  _impl_.request_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::v1::RequestOptions* CommitRequest::unsafe_arena_release_request_options() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.CommitRequest.request_options)
  
  ::google::spanner::v1::RequestOptions* temp = _impl_.request_options_;
  _impl_.request_options_ = nullptr;
  return temp;
}
inline ::google::spanner::v1::RequestOptions* CommitRequest::_internal_mutable_request_options() {
  
  if (_impl_.request_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::v1::RequestOptions>(GetArenaForAllocation());
    _impl_.request_options_ = p;
  }
  return _impl_.request_options_;
}
inline ::google::spanner::v1::RequestOptions* CommitRequest::mutable_request_options() {
  ::google::spanner::v1::RequestOptions* _msg = _internal_mutable_request_options();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.CommitRequest.request_options)
  return _msg;
}
inline void CommitRequest::set_allocated_request_options(::google::spanner::v1::RequestOptions* request_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_options_;
  }
  if (request_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_options);
    if (message_arena != submessage_arena) {
      request_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_options_ = request_options;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.CommitRequest.request_options)
}

inline bool CommitRequest::has_transaction() const {
  return transaction_case() != TRANSACTION_NOT_SET;
}
inline void CommitRequest::clear_has_transaction() {
  _impl_._oneof_case_[0] = TRANSACTION_NOT_SET;
}
inline CommitRequest::TransactionCase CommitRequest::transaction_case() const {
  return CommitRequest::TransactionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RollbackRequest

// string session = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void RollbackRequest::clear_session() {
  _impl_.session_.ClearToEmpty();
}
inline const std::string& RollbackRequest::session() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.RollbackRequest.session)
  return _internal_session();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RollbackRequest::set_session(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.RollbackRequest.session)
}
inline std::string* RollbackRequest::mutable_session() {
  std::string* _s = _internal_mutable_session();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.RollbackRequest.session)
  return _s;
}
inline const std::string& RollbackRequest::_internal_session() const {
  return _impl_.session_.Get();
}
inline void RollbackRequest::_internal_set_session(const std::string& value) {
  
  _impl_.session_.Set(value, GetArenaForAllocation());
}
inline std::string* RollbackRequest::_internal_mutable_session() {
  
  return _impl_.session_.Mutable(GetArenaForAllocation());
}
inline std::string* RollbackRequest::release_session() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.RollbackRequest.session)
  return _impl_.session_.Release();
}
inline void RollbackRequest::set_allocated_session(std::string* session) {
  if (session != nullptr) {
    
  } else {
    
  }
  _impl_.session_.SetAllocated(session, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_.IsDefault()) {
    _impl_.session_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.RollbackRequest.session)
}

// bytes transaction_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void RollbackRequest::clear_transaction_id() {
  _impl_.transaction_id_.ClearToEmpty();
}
inline const std::string& RollbackRequest::transaction_id() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.RollbackRequest.transaction_id)
  return _internal_transaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RollbackRequest::set_transaction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.transaction_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.v1.RollbackRequest.transaction_id)
}
inline std::string* RollbackRequest::mutable_transaction_id() {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.RollbackRequest.transaction_id)
  return _s;
}
inline const std::string& RollbackRequest::_internal_transaction_id() const {
  return _impl_.transaction_id_.Get();
}
inline void RollbackRequest::_internal_set_transaction_id(const std::string& value) {
  
  _impl_.transaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RollbackRequest::_internal_mutable_transaction_id() {
  
  return _impl_.transaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RollbackRequest::release_transaction_id() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.RollbackRequest.transaction_id)
  return _impl_.transaction_id_.Release();
}
inline void RollbackRequest::set_allocated_transaction_id(std::string* transaction_id) {
  if (transaction_id != nullptr) {
    
  } else {
    
  }
  _impl_.transaction_id_.SetAllocated(transaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transaction_id_.IsDefault()) {
    _impl_.transaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.RollbackRequest.transaction_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace spanner
}  // namespace google

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::google::spanner::v1::RequestOptions_Priority> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::spanner::v1::RequestOptions_Priority>() {
  return ::google::spanner::v1::RequestOptions_Priority_descriptor();
}
template <> struct is_proto_enum< ::google::spanner::v1::ExecuteSqlRequest_QueryMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::spanner::v1::ExecuteSqlRequest_QueryMode>() {
  return ::google::spanner::v1::ExecuteSqlRequest_QueryMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_google_2fspanner_2fv1_2fspanner_2eproto
