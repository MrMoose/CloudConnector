// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/spanner/admin/database/v1/spanner_database_admin.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/api/client.pb.h"
#include "google/api/field_behavior.pb.h"
#include "google/api/resource.pb.h"
#include "google/iam/v1/iam_policy.pb.h"
#include "google/iam/v1/policy.pb.h"
#include "google/longrunning/operations.pb.h"
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "google/spanner/admin/database/v1/backup.pb.h"
#include "google/spanner/admin/database/v1/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
namespace google {
namespace spanner {
namespace admin {
namespace database {
namespace v1 {
class CreateDatabaseMetadata;
struct CreateDatabaseMetadataDefaultTypeInternal;
extern CreateDatabaseMetadataDefaultTypeInternal _CreateDatabaseMetadata_default_instance_;
class CreateDatabaseRequest;
struct CreateDatabaseRequestDefaultTypeInternal;
extern CreateDatabaseRequestDefaultTypeInternal _CreateDatabaseRequest_default_instance_;
class Database;
struct DatabaseDefaultTypeInternal;
extern DatabaseDefaultTypeInternal _Database_default_instance_;
class DatabaseRole;
struct DatabaseRoleDefaultTypeInternal;
extern DatabaseRoleDefaultTypeInternal _DatabaseRole_default_instance_;
class DropDatabaseRequest;
struct DropDatabaseRequestDefaultTypeInternal;
extern DropDatabaseRequestDefaultTypeInternal _DropDatabaseRequest_default_instance_;
class GetDatabaseDdlRequest;
struct GetDatabaseDdlRequestDefaultTypeInternal;
extern GetDatabaseDdlRequestDefaultTypeInternal _GetDatabaseDdlRequest_default_instance_;
class GetDatabaseDdlResponse;
struct GetDatabaseDdlResponseDefaultTypeInternal;
extern GetDatabaseDdlResponseDefaultTypeInternal _GetDatabaseDdlResponse_default_instance_;
class GetDatabaseRequest;
struct GetDatabaseRequestDefaultTypeInternal;
extern GetDatabaseRequestDefaultTypeInternal _GetDatabaseRequest_default_instance_;
class ListDatabaseOperationsRequest;
struct ListDatabaseOperationsRequestDefaultTypeInternal;
extern ListDatabaseOperationsRequestDefaultTypeInternal _ListDatabaseOperationsRequest_default_instance_;
class ListDatabaseOperationsResponse;
struct ListDatabaseOperationsResponseDefaultTypeInternal;
extern ListDatabaseOperationsResponseDefaultTypeInternal _ListDatabaseOperationsResponse_default_instance_;
class ListDatabaseRolesRequest;
struct ListDatabaseRolesRequestDefaultTypeInternal;
extern ListDatabaseRolesRequestDefaultTypeInternal _ListDatabaseRolesRequest_default_instance_;
class ListDatabaseRolesResponse;
struct ListDatabaseRolesResponseDefaultTypeInternal;
extern ListDatabaseRolesResponseDefaultTypeInternal _ListDatabaseRolesResponse_default_instance_;
class ListDatabasesRequest;
struct ListDatabasesRequestDefaultTypeInternal;
extern ListDatabasesRequestDefaultTypeInternal _ListDatabasesRequest_default_instance_;
class ListDatabasesResponse;
struct ListDatabasesResponseDefaultTypeInternal;
extern ListDatabasesResponseDefaultTypeInternal _ListDatabasesResponse_default_instance_;
class OptimizeRestoredDatabaseMetadata;
struct OptimizeRestoredDatabaseMetadataDefaultTypeInternal;
extern OptimizeRestoredDatabaseMetadataDefaultTypeInternal _OptimizeRestoredDatabaseMetadata_default_instance_;
class RestoreDatabaseEncryptionConfig;
struct RestoreDatabaseEncryptionConfigDefaultTypeInternal;
extern RestoreDatabaseEncryptionConfigDefaultTypeInternal _RestoreDatabaseEncryptionConfig_default_instance_;
class RestoreDatabaseMetadata;
struct RestoreDatabaseMetadataDefaultTypeInternal;
extern RestoreDatabaseMetadataDefaultTypeInternal _RestoreDatabaseMetadata_default_instance_;
class RestoreDatabaseRequest;
struct RestoreDatabaseRequestDefaultTypeInternal;
extern RestoreDatabaseRequestDefaultTypeInternal _RestoreDatabaseRequest_default_instance_;
class RestoreInfo;
struct RestoreInfoDefaultTypeInternal;
extern RestoreInfoDefaultTypeInternal _RestoreInfo_default_instance_;
class UpdateDatabaseDdlMetadata;
struct UpdateDatabaseDdlMetadataDefaultTypeInternal;
extern UpdateDatabaseDdlMetadataDefaultTypeInternal _UpdateDatabaseDdlMetadata_default_instance_;
class UpdateDatabaseDdlRequest;
struct UpdateDatabaseDdlRequestDefaultTypeInternal;
extern UpdateDatabaseDdlRequestDefaultTypeInternal _UpdateDatabaseDdlRequest_default_instance_;
}  // namespace v1
}  // namespace database
}  // namespace admin
}  // namespace spanner
}  // namespace google
PROTOBUF_NAMESPACE_OPEN
template<> ::google::spanner::admin::database::v1::CreateDatabaseMetadata* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::CreateDatabaseMetadata>(Arena*);
template<> ::google::spanner::admin::database::v1::CreateDatabaseRequest* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::CreateDatabaseRequest>(Arena*);
template<> ::google::spanner::admin::database::v1::Database* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::Database>(Arena*);
template<> ::google::spanner::admin::database::v1::DatabaseRole* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::DatabaseRole>(Arena*);
template<> ::google::spanner::admin::database::v1::DropDatabaseRequest* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::DropDatabaseRequest>(Arena*);
template<> ::google::spanner::admin::database::v1::GetDatabaseDdlRequest* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::GetDatabaseDdlRequest>(Arena*);
template<> ::google::spanner::admin::database::v1::GetDatabaseDdlResponse* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::GetDatabaseDdlResponse>(Arena*);
template<> ::google::spanner::admin::database::v1::GetDatabaseRequest* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::GetDatabaseRequest>(Arena*);
template<> ::google::spanner::admin::database::v1::ListDatabaseOperationsRequest* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::ListDatabaseOperationsRequest>(Arena*);
template<> ::google::spanner::admin::database::v1::ListDatabaseOperationsResponse* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::ListDatabaseOperationsResponse>(Arena*);
template<> ::google::spanner::admin::database::v1::ListDatabaseRolesRequest* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::ListDatabaseRolesRequest>(Arena*);
template<> ::google::spanner::admin::database::v1::ListDatabaseRolesResponse* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::ListDatabaseRolesResponse>(Arena*);
template<> ::google::spanner::admin::database::v1::ListDatabasesRequest* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::ListDatabasesRequest>(Arena*);
template<> ::google::spanner::admin::database::v1::ListDatabasesResponse* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::ListDatabasesResponse>(Arena*);
template<> ::google::spanner::admin::database::v1::OptimizeRestoredDatabaseMetadata* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::OptimizeRestoredDatabaseMetadata>(Arena*);
template<> ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig>(Arena*);
template<> ::google::spanner::admin::database::v1::RestoreDatabaseMetadata* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::RestoreDatabaseMetadata>(Arena*);
template<> ::google::spanner::admin::database::v1::RestoreDatabaseRequest* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::RestoreDatabaseRequest>(Arena*);
template<> ::google::spanner::admin::database::v1::RestoreInfo* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::RestoreInfo>(Arena*);
template<> ::google::spanner::admin::database::v1::UpdateDatabaseDdlMetadata* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::UpdateDatabaseDdlMetadata>(Arena*);
template<> ::google::spanner::admin::database::v1::UpdateDatabaseDdlRequest* Arena::CreateMaybeMessage<::google::spanner::admin::database::v1::UpdateDatabaseDdlRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace google {
namespace spanner {
namespace admin {
namespace database {
namespace v1 {

enum Database_State : int {
  Database_State_STATE_UNSPECIFIED = 0,
  Database_State_CREATING = 1,
  Database_State_READY = 2,
  Database_State_READY_OPTIMIZING = 3,
  Database_State_Database_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Database_State_Database_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Database_State_IsValid(int value);
constexpr Database_State Database_State_State_MIN = Database_State_STATE_UNSPECIFIED;
constexpr Database_State Database_State_State_MAX = Database_State_READY_OPTIMIZING;
constexpr int Database_State_State_ARRAYSIZE = Database_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Database_State_descriptor();
template<typename T>
inline const std::string& Database_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Database_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Database_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Database_State_descriptor(), enum_t_value);
}
inline bool Database_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Database_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Database_State>(
    Database_State_descriptor(), name, value);
}
enum RestoreDatabaseEncryptionConfig_EncryptionType : int {
  RestoreDatabaseEncryptionConfig_EncryptionType_ENCRYPTION_TYPE_UNSPECIFIED = 0,
  RestoreDatabaseEncryptionConfig_EncryptionType_USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION = 1,
  RestoreDatabaseEncryptionConfig_EncryptionType_GOOGLE_DEFAULT_ENCRYPTION = 2,
  RestoreDatabaseEncryptionConfig_EncryptionType_CUSTOMER_MANAGED_ENCRYPTION = 3,
  RestoreDatabaseEncryptionConfig_EncryptionType_RestoreDatabaseEncryptionConfig_EncryptionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RestoreDatabaseEncryptionConfig_EncryptionType_RestoreDatabaseEncryptionConfig_EncryptionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RestoreDatabaseEncryptionConfig_EncryptionType_IsValid(int value);
constexpr RestoreDatabaseEncryptionConfig_EncryptionType RestoreDatabaseEncryptionConfig_EncryptionType_EncryptionType_MIN = RestoreDatabaseEncryptionConfig_EncryptionType_ENCRYPTION_TYPE_UNSPECIFIED;
constexpr RestoreDatabaseEncryptionConfig_EncryptionType RestoreDatabaseEncryptionConfig_EncryptionType_EncryptionType_MAX = RestoreDatabaseEncryptionConfig_EncryptionType_CUSTOMER_MANAGED_ENCRYPTION;
constexpr int RestoreDatabaseEncryptionConfig_EncryptionType_EncryptionType_ARRAYSIZE = RestoreDatabaseEncryptionConfig_EncryptionType_EncryptionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RestoreDatabaseEncryptionConfig_EncryptionType_descriptor();
template<typename T>
inline const std::string& RestoreDatabaseEncryptionConfig_EncryptionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RestoreDatabaseEncryptionConfig_EncryptionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RestoreDatabaseEncryptionConfig_EncryptionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RestoreDatabaseEncryptionConfig_EncryptionType_descriptor(), enum_t_value);
}
inline bool RestoreDatabaseEncryptionConfig_EncryptionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RestoreDatabaseEncryptionConfig_EncryptionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RestoreDatabaseEncryptionConfig_EncryptionType>(
    RestoreDatabaseEncryptionConfig_EncryptionType_descriptor(), name, value);
}
enum RestoreSourceType : int {
  TYPE_UNSPECIFIED = 0,
  BACKUP = 1,
  RestoreSourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RestoreSourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RestoreSourceType_IsValid(int value);
constexpr RestoreSourceType RestoreSourceType_MIN = TYPE_UNSPECIFIED;
constexpr RestoreSourceType RestoreSourceType_MAX = BACKUP;
constexpr int RestoreSourceType_ARRAYSIZE = RestoreSourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RestoreSourceType_descriptor();
template<typename T>
inline const std::string& RestoreSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RestoreSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RestoreSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RestoreSourceType_descriptor(), enum_t_value);
}
inline bool RestoreSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RestoreSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RestoreSourceType>(
    RestoreSourceType_descriptor(), name, value);
}
// ===================================================================

class RestoreInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.RestoreInfo) */ {
 public:
  inline RestoreInfo() : RestoreInfo(nullptr) {}
  ~RestoreInfo() override;
  explicit PROTOBUF_CONSTEXPR RestoreInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RestoreInfo(const RestoreInfo& from);
  RestoreInfo(RestoreInfo&& from) noexcept
    : RestoreInfo() {
    *this = ::std::move(from);
  }

  inline RestoreInfo& operator=(const RestoreInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestoreInfo& operator=(RestoreInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestoreInfo& default_instance() {
    return *internal_default_instance();
  }
  enum SourceInfoCase {
    kBackupInfo = 2,
    SOURCE_INFO_NOT_SET = 0,
  };

  static inline const RestoreInfo* internal_default_instance() {
    return reinterpret_cast<const RestoreInfo*>(
               &_RestoreInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RestoreInfo& a, RestoreInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RestoreInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestoreInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestoreInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RestoreInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RestoreInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RestoreInfo& from) {
    RestoreInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestoreInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.RestoreInfo";
  }
  protected:
  explicit RestoreInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceTypeFieldNumber = 1,
    kBackupInfoFieldNumber = 2,
  };
  // .google.spanner.admin.database.v1.RestoreSourceType source_type = 1;
  void clear_source_type();
  ::google::spanner::admin::database::v1::RestoreSourceType source_type() const;
  void set_source_type(::google::spanner::admin::database::v1::RestoreSourceType value);
  private:
  ::google::spanner::admin::database::v1::RestoreSourceType _internal_source_type() const;
  void _internal_set_source_type(::google::spanner::admin::database::v1::RestoreSourceType value);
  public:

  // .google.spanner.admin.database.v1.BackupInfo backup_info = 2;
  bool has_backup_info() const;
  private:
  bool _internal_has_backup_info() const;
  public:
  void clear_backup_info();
  const ::google::spanner::admin::database::v1::BackupInfo& backup_info() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::database::v1::BackupInfo* release_backup_info();
  ::google::spanner::admin::database::v1::BackupInfo* mutable_backup_info();
  void set_allocated_backup_info(::google::spanner::admin::database::v1::BackupInfo* backup_info);
  private:
  const ::google::spanner::admin::database::v1::BackupInfo& _internal_backup_info() const;
  ::google::spanner::admin::database::v1::BackupInfo* _internal_mutable_backup_info();
  public:
  void unsafe_arena_set_allocated_backup_info(
      ::google::spanner::admin::database::v1::BackupInfo* backup_info);
  ::google::spanner::admin::database::v1::BackupInfo* unsafe_arena_release_backup_info();

  void clear_source_info();
  SourceInfoCase source_info_case() const;
  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.RestoreInfo)
 private:
  class _Internal;
  void set_has_backup_info();

  inline bool has_source_info() const;
  inline void clear_has_source_info();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int source_type_;
    union SourceInfoUnion {
      constexpr SourceInfoUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::google::spanner::admin::database::v1::BackupInfo* backup_info_;
    } source_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class Database final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.Database) */ {
 public:
  inline Database() : Database(nullptr) {}
  ~Database() override;
  explicit PROTOBUF_CONSTEXPR Database(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Database(const Database& from);
  Database(Database&& from) noexcept
    : Database() {
    *this = ::std::move(from);
  }

  inline Database& operator=(const Database& from) {
    CopyFrom(from);
    return *this;
  }
  inline Database& operator=(Database&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Database& default_instance() {
    return *internal_default_instance();
  }
  static inline const Database* internal_default_instance() {
    return reinterpret_cast<const Database*>(
               &_Database_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Database& a, Database& b) {
    a.Swap(&b);
  }
  inline void Swap(Database* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Database* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Database* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Database>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Database& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Database& from) {
    Database::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Database* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.Database";
  }
  protected:
  explicit Database(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Database_State State;
  static constexpr State STATE_UNSPECIFIED =
    Database_State_STATE_UNSPECIFIED;
  static constexpr State CREATING =
    Database_State_CREATING;
  static constexpr State READY =
    Database_State_READY;
  static constexpr State READY_OPTIMIZING =
    Database_State_READY_OPTIMIZING;
  static inline bool State_IsValid(int value) {
    return Database_State_IsValid(value);
  }
  static constexpr State State_MIN =
    Database_State_State_MIN;
  static constexpr State State_MAX =
    Database_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    Database_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return Database_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return Database_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return Database_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEncryptionInfoFieldNumber = 8,
    kNameFieldNumber = 1,
    kVersionRetentionPeriodFieldNumber = 6,
    kDefaultLeaderFieldNumber = 9,
    kCreateTimeFieldNumber = 3,
    kRestoreInfoFieldNumber = 4,
    kEncryptionConfigFieldNumber = 5,
    kEarliestVersionTimeFieldNumber = 7,
    kStateFieldNumber = 2,
    kDatabaseDialectFieldNumber = 10,
  };
  // repeated .google.spanner.admin.database.v1.EncryptionInfo encryption_info = 8 [(.google.api.field_behavior) = OUTPUT_ONLY];
  int encryption_info_size() const;
  private:
  int _internal_encryption_info_size() const;
  public:
  void clear_encryption_info();
  ::google::spanner::admin::database::v1::EncryptionInfo* mutable_encryption_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::EncryptionInfo >*
      mutable_encryption_info();
  private:
  const ::google::spanner::admin::database::v1::EncryptionInfo& _internal_encryption_info(int index) const;
  ::google::spanner::admin::database::v1::EncryptionInfo* _internal_add_encryption_info();
  public:
  const ::google::spanner::admin::database::v1::EncryptionInfo& encryption_info(int index) const;
  ::google::spanner::admin::database::v1::EncryptionInfo* add_encryption_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::EncryptionInfo >&
      encryption_info() const;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version_retention_period = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_version_retention_period();
  const std::string& version_retention_period() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version_retention_period(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version_retention_period();
  PROTOBUF_NODISCARD std::string* release_version_retention_period();
  void set_allocated_version_retention_period(std::string* version_retention_period);
  private:
  const std::string& _internal_version_retention_period() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version_retention_period(const std::string& value);
  std::string* _internal_mutable_version_retention_period();
  public:

  // string default_leader = 9 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_default_leader();
  const std::string& default_leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_leader();
  PROTOBUF_NODISCARD std::string* release_default_leader();
  void set_allocated_default_leader(std::string* default_leader);
  private:
  const std::string& _internal_default_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_leader(const std::string& value);
  std::string* _internal_mutable_default_leader();
  public:

  // .google.protobuf.Timestamp create_time = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_time();
  void set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_time();
  public:
  void unsafe_arena_set_allocated_create_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_time();

  // .google.spanner.admin.database.v1.RestoreInfo restore_info = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_restore_info() const;
  private:
  bool _internal_has_restore_info() const;
  public:
  void clear_restore_info();
  const ::google::spanner::admin::database::v1::RestoreInfo& restore_info() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::database::v1::RestoreInfo* release_restore_info();
  ::google::spanner::admin::database::v1::RestoreInfo* mutable_restore_info();
  void set_allocated_restore_info(::google::spanner::admin::database::v1::RestoreInfo* restore_info);
  private:
  const ::google::spanner::admin::database::v1::RestoreInfo& _internal_restore_info() const;
  ::google::spanner::admin::database::v1::RestoreInfo* _internal_mutable_restore_info();
  public:
  void unsafe_arena_set_allocated_restore_info(
      ::google::spanner::admin::database::v1::RestoreInfo* restore_info);
  ::google::spanner::admin::database::v1::RestoreInfo* unsafe_arena_release_restore_info();

  // .google.spanner.admin.database.v1.EncryptionConfig encryption_config = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_encryption_config() const;
  private:
  bool _internal_has_encryption_config() const;
  public:
  void clear_encryption_config();
  const ::google::spanner::admin::database::v1::EncryptionConfig& encryption_config() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::database::v1::EncryptionConfig* release_encryption_config();
  ::google::spanner::admin::database::v1::EncryptionConfig* mutable_encryption_config();
  void set_allocated_encryption_config(::google::spanner::admin::database::v1::EncryptionConfig* encryption_config);
  private:
  const ::google::spanner::admin::database::v1::EncryptionConfig& _internal_encryption_config() const;
  ::google::spanner::admin::database::v1::EncryptionConfig* _internal_mutable_encryption_config();
  public:
  void unsafe_arena_set_allocated_encryption_config(
      ::google::spanner::admin::database::v1::EncryptionConfig* encryption_config);
  ::google::spanner::admin::database::v1::EncryptionConfig* unsafe_arena_release_encryption_config();

  // .google.protobuf.Timestamp earliest_version_time = 7 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_earliest_version_time() const;
  private:
  bool _internal_has_earliest_version_time() const;
  public:
  void clear_earliest_version_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& earliest_version_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_earliest_version_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_earliest_version_time();
  void set_allocated_earliest_version_time(::PROTOBUF_NAMESPACE_ID::Timestamp* earliest_version_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_earliest_version_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_earliest_version_time();
  public:
  void unsafe_arena_set_allocated_earliest_version_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* earliest_version_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_earliest_version_time();

  // .google.spanner.admin.database.v1.Database.State state = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_state();
  ::google::spanner::admin::database::v1::Database_State state() const;
  void set_state(::google::spanner::admin::database::v1::Database_State value);
  private:
  ::google::spanner::admin::database::v1::Database_State _internal_state() const;
  void _internal_set_state(::google::spanner::admin::database::v1::Database_State value);
  public:

  // .google.spanner.admin.database.v1.DatabaseDialect database_dialect = 10 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_database_dialect();
  ::google::spanner::admin::database::v1::DatabaseDialect database_dialect() const;
  void set_database_dialect(::google::spanner::admin::database::v1::DatabaseDialect value);
  private:
  ::google::spanner::admin::database::v1::DatabaseDialect _internal_database_dialect() const;
  void _internal_set_database_dialect(::google::spanner::admin::database::v1::DatabaseDialect value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.Database)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::EncryptionInfo > encryption_info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_retention_period_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_leader_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time_;
    ::google::spanner::admin::database::v1::RestoreInfo* restore_info_;
    ::google::spanner::admin::database::v1::EncryptionConfig* encryption_config_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* earliest_version_time_;
    int state_;
    int database_dialect_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class ListDatabasesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.ListDatabasesRequest) */ {
 public:
  inline ListDatabasesRequest() : ListDatabasesRequest(nullptr) {}
  ~ListDatabasesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListDatabasesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDatabasesRequest(const ListDatabasesRequest& from);
  ListDatabasesRequest(ListDatabasesRequest&& from) noexcept
    : ListDatabasesRequest() {
    *this = ::std::move(from);
  }

  inline ListDatabasesRequest& operator=(const ListDatabasesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDatabasesRequest& operator=(ListDatabasesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDatabasesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDatabasesRequest* internal_default_instance() {
    return reinterpret_cast<const ListDatabasesRequest*>(
               &_ListDatabasesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ListDatabasesRequest& a, ListDatabasesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDatabasesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDatabasesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDatabasesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDatabasesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDatabasesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListDatabasesRequest& from) {
    ListDatabasesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDatabasesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.ListDatabasesRequest";
  }
  protected:
  explicit ListDatabasesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 4,
    kPageSizeFieldNumber = 3,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 4;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 3;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.ListDatabasesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class ListDatabasesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.ListDatabasesResponse) */ {
 public:
  inline ListDatabasesResponse() : ListDatabasesResponse(nullptr) {}
  ~ListDatabasesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListDatabasesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDatabasesResponse(const ListDatabasesResponse& from);
  ListDatabasesResponse(ListDatabasesResponse&& from) noexcept
    : ListDatabasesResponse() {
    *this = ::std::move(from);
  }

  inline ListDatabasesResponse& operator=(const ListDatabasesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDatabasesResponse& operator=(ListDatabasesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDatabasesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDatabasesResponse* internal_default_instance() {
    return reinterpret_cast<const ListDatabasesResponse*>(
               &_ListDatabasesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ListDatabasesResponse& a, ListDatabasesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDatabasesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDatabasesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDatabasesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDatabasesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDatabasesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListDatabasesResponse& from) {
    ListDatabasesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDatabasesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.ListDatabasesResponse";
  }
  protected:
  explicit ListDatabasesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabasesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.spanner.admin.database.v1.Database databases = 1;
  int databases_size() const;
  private:
  int _internal_databases_size() const;
  public:
  void clear_databases();
  ::google::spanner::admin::database::v1::Database* mutable_databases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::Database >*
      mutable_databases();
  private:
  const ::google::spanner::admin::database::v1::Database& _internal_databases(int index) const;
  ::google::spanner::admin::database::v1::Database* _internal_add_databases();
  public:
  const ::google::spanner::admin::database::v1::Database& databases(int index) const;
  ::google::spanner::admin::database::v1::Database* add_databases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::Database >&
      databases() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.ListDatabasesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::Database > databases_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class CreateDatabaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.CreateDatabaseRequest) */ {
 public:
  inline CreateDatabaseRequest() : CreateDatabaseRequest(nullptr) {}
  ~CreateDatabaseRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateDatabaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDatabaseRequest(const CreateDatabaseRequest& from);
  CreateDatabaseRequest(CreateDatabaseRequest&& from) noexcept
    : CreateDatabaseRequest() {
    *this = ::std::move(from);
  }

  inline CreateDatabaseRequest& operator=(const CreateDatabaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDatabaseRequest& operator=(CreateDatabaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDatabaseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDatabaseRequest* internal_default_instance() {
    return reinterpret_cast<const CreateDatabaseRequest*>(
               &_CreateDatabaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateDatabaseRequest& a, CreateDatabaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDatabaseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDatabaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDatabaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateDatabaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateDatabaseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateDatabaseRequest& from) {
    CreateDatabaseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateDatabaseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.CreateDatabaseRequest";
  }
  protected:
  explicit CreateDatabaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtraStatementsFieldNumber = 3,
    kParentFieldNumber = 1,
    kCreateStatementFieldNumber = 2,
    kEncryptionConfigFieldNumber = 4,
    kDatabaseDialectFieldNumber = 5,
  };
  // repeated string extra_statements = 3 [(.google.api.field_behavior) = OPTIONAL];
  int extra_statements_size() const;
  private:
  int _internal_extra_statements_size() const;
  public:
  void clear_extra_statements();
  const std::string& extra_statements(int index) const;
  std::string* mutable_extra_statements(int index);
  void set_extra_statements(int index, const std::string& value);
  void set_extra_statements(int index, std::string&& value);
  void set_extra_statements(int index, const char* value);
  void set_extra_statements(int index, const char* value, size_t size);
  std::string* add_extra_statements();
  void add_extra_statements(const std::string& value);
  void add_extra_statements(std::string&& value);
  void add_extra_statements(const char* value);
  void add_extra_statements(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& extra_statements() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_extra_statements();
  private:
  const std::string& _internal_extra_statements(int index) const;
  std::string* _internal_add_extra_statements();
  public:

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string create_statement = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_create_statement();
  const std::string& create_statement() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_statement(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_statement();
  PROTOBUF_NODISCARD std::string* release_create_statement();
  void set_allocated_create_statement(std::string* create_statement);
  private:
  const std::string& _internal_create_statement() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_statement(const std::string& value);
  std::string* _internal_mutable_create_statement();
  public:

  // .google.spanner.admin.database.v1.EncryptionConfig encryption_config = 4 [(.google.api.field_behavior) = OPTIONAL];
  bool has_encryption_config() const;
  private:
  bool _internal_has_encryption_config() const;
  public:
  void clear_encryption_config();
  const ::google::spanner::admin::database::v1::EncryptionConfig& encryption_config() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::database::v1::EncryptionConfig* release_encryption_config();
  ::google::spanner::admin::database::v1::EncryptionConfig* mutable_encryption_config();
  void set_allocated_encryption_config(::google::spanner::admin::database::v1::EncryptionConfig* encryption_config);
  private:
  const ::google::spanner::admin::database::v1::EncryptionConfig& _internal_encryption_config() const;
  ::google::spanner::admin::database::v1::EncryptionConfig* _internal_mutable_encryption_config();
  public:
  void unsafe_arena_set_allocated_encryption_config(
      ::google::spanner::admin::database::v1::EncryptionConfig* encryption_config);
  ::google::spanner::admin::database::v1::EncryptionConfig* unsafe_arena_release_encryption_config();

  // .google.spanner.admin.database.v1.DatabaseDialect database_dialect = 5 [(.google.api.field_behavior) = OPTIONAL];
  void clear_database_dialect();
  ::google::spanner::admin::database::v1::DatabaseDialect database_dialect() const;
  void set_database_dialect(::google::spanner::admin::database::v1::DatabaseDialect value);
  private:
  ::google::spanner::admin::database::v1::DatabaseDialect _internal_database_dialect() const;
  void _internal_set_database_dialect(::google::spanner::admin::database::v1::DatabaseDialect value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.CreateDatabaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> extra_statements_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_statement_;
    ::google::spanner::admin::database::v1::EncryptionConfig* encryption_config_;
    int database_dialect_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class CreateDatabaseMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.CreateDatabaseMetadata) */ {
 public:
  inline CreateDatabaseMetadata() : CreateDatabaseMetadata(nullptr) {}
  ~CreateDatabaseMetadata() override;
  explicit PROTOBUF_CONSTEXPR CreateDatabaseMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDatabaseMetadata(const CreateDatabaseMetadata& from);
  CreateDatabaseMetadata(CreateDatabaseMetadata&& from) noexcept
    : CreateDatabaseMetadata() {
    *this = ::std::move(from);
  }

  inline CreateDatabaseMetadata& operator=(const CreateDatabaseMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDatabaseMetadata& operator=(CreateDatabaseMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDatabaseMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDatabaseMetadata* internal_default_instance() {
    return reinterpret_cast<const CreateDatabaseMetadata*>(
               &_CreateDatabaseMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateDatabaseMetadata& a, CreateDatabaseMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDatabaseMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDatabaseMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDatabaseMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateDatabaseMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateDatabaseMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateDatabaseMetadata& from) {
    CreateDatabaseMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateDatabaseMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.CreateDatabaseMetadata";
  }
  protected:
  explicit CreateDatabaseMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseFieldNumber = 1,
  };
  // string database = 1 [(.google.api.resource_reference) = {
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.CreateDatabaseMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class GetDatabaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.GetDatabaseRequest) */ {
 public:
  inline GetDatabaseRequest() : GetDatabaseRequest(nullptr) {}
  ~GetDatabaseRequest() override;
  explicit PROTOBUF_CONSTEXPR GetDatabaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDatabaseRequest(const GetDatabaseRequest& from);
  GetDatabaseRequest(GetDatabaseRequest&& from) noexcept
    : GetDatabaseRequest() {
    *this = ::std::move(from);
  }

  inline GetDatabaseRequest& operator=(const GetDatabaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDatabaseRequest& operator=(GetDatabaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDatabaseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDatabaseRequest* internal_default_instance() {
    return reinterpret_cast<const GetDatabaseRequest*>(
               &_GetDatabaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetDatabaseRequest& a, GetDatabaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDatabaseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDatabaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDatabaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDatabaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDatabaseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDatabaseRequest& from) {
    GetDatabaseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDatabaseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.GetDatabaseRequest";
  }
  protected:
  explicit GetDatabaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.GetDatabaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class UpdateDatabaseDdlRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest) */ {
 public:
  inline UpdateDatabaseDdlRequest() : UpdateDatabaseDdlRequest(nullptr) {}
  ~UpdateDatabaseDdlRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateDatabaseDdlRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateDatabaseDdlRequest(const UpdateDatabaseDdlRequest& from);
  UpdateDatabaseDdlRequest(UpdateDatabaseDdlRequest&& from) noexcept
    : UpdateDatabaseDdlRequest() {
    *this = ::std::move(from);
  }

  inline UpdateDatabaseDdlRequest& operator=(const UpdateDatabaseDdlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateDatabaseDdlRequest& operator=(UpdateDatabaseDdlRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateDatabaseDdlRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateDatabaseDdlRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateDatabaseDdlRequest*>(
               &_UpdateDatabaseDdlRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UpdateDatabaseDdlRequest& a, UpdateDatabaseDdlRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateDatabaseDdlRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateDatabaseDdlRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateDatabaseDdlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateDatabaseDdlRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateDatabaseDdlRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateDatabaseDdlRequest& from) {
    UpdateDatabaseDdlRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateDatabaseDdlRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.UpdateDatabaseDdlRequest";
  }
  protected:
  explicit UpdateDatabaseDdlRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatementsFieldNumber = 2,
    kDatabaseFieldNumber = 1,
    kOperationIdFieldNumber = 3,
  };
  // repeated string statements = 2 [(.google.api.field_behavior) = REQUIRED];
  int statements_size() const;
  private:
  int _internal_statements_size() const;
  public:
  void clear_statements();
  const std::string& statements(int index) const;
  std::string* mutable_statements(int index);
  void set_statements(int index, const std::string& value);
  void set_statements(int index, std::string&& value);
  void set_statements(int index, const char* value);
  void set_statements(int index, const char* value, size_t size);
  std::string* add_statements();
  void add_statements(const std::string& value);
  void add_statements(std::string&& value);
  void add_statements(const char* value);
  void add_statements(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& statements() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_statements();
  private:
  const std::string& _internal_statements(int index) const;
  std::string* _internal_add_statements();
  public:

  // string database = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // string operation_id = 3;
  void clear_operation_id();
  const std::string& operation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation_id();
  PROTOBUF_NODISCARD std::string* release_operation_id();
  void set_allocated_operation_id(std::string* operation_id);
  private:
  const std::string& _internal_operation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_id(const std::string& value);
  std::string* _internal_mutable_operation_id();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> statements_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class UpdateDatabaseDdlMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata) */ {
 public:
  inline UpdateDatabaseDdlMetadata() : UpdateDatabaseDdlMetadata(nullptr) {}
  ~UpdateDatabaseDdlMetadata() override;
  explicit PROTOBUF_CONSTEXPR UpdateDatabaseDdlMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateDatabaseDdlMetadata(const UpdateDatabaseDdlMetadata& from);
  UpdateDatabaseDdlMetadata(UpdateDatabaseDdlMetadata&& from) noexcept
    : UpdateDatabaseDdlMetadata() {
    *this = ::std::move(from);
  }

  inline UpdateDatabaseDdlMetadata& operator=(const UpdateDatabaseDdlMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateDatabaseDdlMetadata& operator=(UpdateDatabaseDdlMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateDatabaseDdlMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateDatabaseDdlMetadata* internal_default_instance() {
    return reinterpret_cast<const UpdateDatabaseDdlMetadata*>(
               &_UpdateDatabaseDdlMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UpdateDatabaseDdlMetadata& a, UpdateDatabaseDdlMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateDatabaseDdlMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateDatabaseDdlMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateDatabaseDdlMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateDatabaseDdlMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateDatabaseDdlMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateDatabaseDdlMetadata& from) {
    UpdateDatabaseDdlMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateDatabaseDdlMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata";
  }
  protected:
  explicit UpdateDatabaseDdlMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatementsFieldNumber = 2,
    kCommitTimestampsFieldNumber = 3,
    kProgressFieldNumber = 5,
    kDatabaseFieldNumber = 1,
    kThrottledFieldNumber = 4,
  };
  // repeated string statements = 2;
  int statements_size() const;
  private:
  int _internal_statements_size() const;
  public:
  void clear_statements();
  const std::string& statements(int index) const;
  std::string* mutable_statements(int index);
  void set_statements(int index, const std::string& value);
  void set_statements(int index, std::string&& value);
  void set_statements(int index, const char* value);
  void set_statements(int index, const char* value, size_t size);
  std::string* add_statements();
  void add_statements(const std::string& value);
  void add_statements(std::string&& value);
  void add_statements(const char* value);
  void add_statements(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& statements() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_statements();
  private:
  const std::string& _internal_statements(int index) const;
  std::string* _internal_add_statements();
  public:

  // repeated .google.protobuf.Timestamp commit_timestamps = 3;
  int commit_timestamps_size() const;
  private:
  int _internal_commit_timestamps_size() const;
  public:
  void clear_commit_timestamps();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_commit_timestamps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Timestamp >*
      mutable_commit_timestamps();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_commit_timestamps(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_add_commit_timestamps();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& commit_timestamps(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* add_commit_timestamps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Timestamp >&
      commit_timestamps() const;

  // repeated .google.spanner.admin.database.v1.OperationProgress progress = 5;
  int progress_size() const;
  private:
  int _internal_progress_size() const;
  public:
  void clear_progress();
  ::google::spanner::admin::database::v1::OperationProgress* mutable_progress(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::OperationProgress >*
      mutable_progress();
  private:
  const ::google::spanner::admin::database::v1::OperationProgress& _internal_progress(int index) const;
  ::google::spanner::admin::database::v1::OperationProgress* _internal_add_progress();
  public:
  const ::google::spanner::admin::database::v1::OperationProgress& progress(int index) const;
  ::google::spanner::admin::database::v1::OperationProgress* add_progress();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::OperationProgress >&
      progress() const;

  // string database = 1 [(.google.api.resource_reference) = {
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // bool throttled = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_throttled();
  bool throttled() const;
  void set_throttled(bool value);
  private:
  bool _internal_throttled() const;
  void _internal_set_throttled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> statements_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Timestamp > commit_timestamps_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::OperationProgress > progress_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
    bool throttled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class DropDatabaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.DropDatabaseRequest) */ {
 public:
  inline DropDatabaseRequest() : DropDatabaseRequest(nullptr) {}
  ~DropDatabaseRequest() override;
  explicit PROTOBUF_CONSTEXPR DropDatabaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropDatabaseRequest(const DropDatabaseRequest& from);
  DropDatabaseRequest(DropDatabaseRequest&& from) noexcept
    : DropDatabaseRequest() {
    *this = ::std::move(from);
  }

  inline DropDatabaseRequest& operator=(const DropDatabaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropDatabaseRequest& operator=(DropDatabaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropDatabaseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropDatabaseRequest* internal_default_instance() {
    return reinterpret_cast<const DropDatabaseRequest*>(
               &_DropDatabaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DropDatabaseRequest& a, DropDatabaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DropDatabaseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropDatabaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropDatabaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropDatabaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropDatabaseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropDatabaseRequest& from) {
    DropDatabaseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropDatabaseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.DropDatabaseRequest";
  }
  protected:
  explicit DropDatabaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseFieldNumber = 1,
  };
  // string database = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.DropDatabaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class GetDatabaseDdlRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.GetDatabaseDdlRequest) */ {
 public:
  inline GetDatabaseDdlRequest() : GetDatabaseDdlRequest(nullptr) {}
  ~GetDatabaseDdlRequest() override;
  explicit PROTOBUF_CONSTEXPR GetDatabaseDdlRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDatabaseDdlRequest(const GetDatabaseDdlRequest& from);
  GetDatabaseDdlRequest(GetDatabaseDdlRequest&& from) noexcept
    : GetDatabaseDdlRequest() {
    *this = ::std::move(from);
  }

  inline GetDatabaseDdlRequest& operator=(const GetDatabaseDdlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDatabaseDdlRequest& operator=(GetDatabaseDdlRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDatabaseDdlRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDatabaseDdlRequest* internal_default_instance() {
    return reinterpret_cast<const GetDatabaseDdlRequest*>(
               &_GetDatabaseDdlRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetDatabaseDdlRequest& a, GetDatabaseDdlRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDatabaseDdlRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDatabaseDdlRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDatabaseDdlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDatabaseDdlRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDatabaseDdlRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDatabaseDdlRequest& from) {
    GetDatabaseDdlRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDatabaseDdlRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.GetDatabaseDdlRequest";
  }
  protected:
  explicit GetDatabaseDdlRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseFieldNumber = 1,
  };
  // string database = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_NODISCARD std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.GetDatabaseDdlRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class GetDatabaseDdlResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.GetDatabaseDdlResponse) */ {
 public:
  inline GetDatabaseDdlResponse() : GetDatabaseDdlResponse(nullptr) {}
  ~GetDatabaseDdlResponse() override;
  explicit PROTOBUF_CONSTEXPR GetDatabaseDdlResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDatabaseDdlResponse(const GetDatabaseDdlResponse& from);
  GetDatabaseDdlResponse(GetDatabaseDdlResponse&& from) noexcept
    : GetDatabaseDdlResponse() {
    *this = ::std::move(from);
  }

  inline GetDatabaseDdlResponse& operator=(const GetDatabaseDdlResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDatabaseDdlResponse& operator=(GetDatabaseDdlResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDatabaseDdlResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDatabaseDdlResponse* internal_default_instance() {
    return reinterpret_cast<const GetDatabaseDdlResponse*>(
               &_GetDatabaseDdlResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetDatabaseDdlResponse& a, GetDatabaseDdlResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDatabaseDdlResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDatabaseDdlResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDatabaseDdlResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDatabaseDdlResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDatabaseDdlResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDatabaseDdlResponse& from) {
    GetDatabaseDdlResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDatabaseDdlResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.GetDatabaseDdlResponse";
  }
  protected:
  explicit GetDatabaseDdlResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatementsFieldNumber = 1,
  };
  // repeated string statements = 1;
  int statements_size() const;
  private:
  int _internal_statements_size() const;
  public:
  void clear_statements();
  const std::string& statements(int index) const;
  std::string* mutable_statements(int index);
  void set_statements(int index, const std::string& value);
  void set_statements(int index, std::string&& value);
  void set_statements(int index, const char* value);
  void set_statements(int index, const char* value, size_t size);
  std::string* add_statements();
  void add_statements(const std::string& value);
  void add_statements(std::string&& value);
  void add_statements(const char* value);
  void add_statements(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& statements() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_statements();
  private:
  const std::string& _internal_statements(int index) const;
  std::string* _internal_add_statements();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.GetDatabaseDdlResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> statements_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class ListDatabaseOperationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.ListDatabaseOperationsRequest) */ {
 public:
  inline ListDatabaseOperationsRequest() : ListDatabaseOperationsRequest(nullptr) {}
  ~ListDatabaseOperationsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListDatabaseOperationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDatabaseOperationsRequest(const ListDatabaseOperationsRequest& from);
  ListDatabaseOperationsRequest(ListDatabaseOperationsRequest&& from) noexcept
    : ListDatabaseOperationsRequest() {
    *this = ::std::move(from);
  }

  inline ListDatabaseOperationsRequest& operator=(const ListDatabaseOperationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDatabaseOperationsRequest& operator=(ListDatabaseOperationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDatabaseOperationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDatabaseOperationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListDatabaseOperationsRequest*>(
               &_ListDatabaseOperationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListDatabaseOperationsRequest& a, ListDatabaseOperationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDatabaseOperationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDatabaseOperationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDatabaseOperationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDatabaseOperationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDatabaseOperationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListDatabaseOperationsRequest& from) {
    ListDatabaseOperationsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDatabaseOperationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.ListDatabaseOperationsRequest";
  }
  protected:
  explicit ListDatabaseOperationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kFilterFieldNumber = 2,
    kPageTokenFieldNumber = 4,
    kPageSizeFieldNumber = 3,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string filter = 2;
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // string page_token = 4;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 3;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.ListDatabaseOperationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class ListDatabaseOperationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.ListDatabaseOperationsResponse) */ {
 public:
  inline ListDatabaseOperationsResponse() : ListDatabaseOperationsResponse(nullptr) {}
  ~ListDatabaseOperationsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListDatabaseOperationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDatabaseOperationsResponse(const ListDatabaseOperationsResponse& from);
  ListDatabaseOperationsResponse(ListDatabaseOperationsResponse&& from) noexcept
    : ListDatabaseOperationsResponse() {
    *this = ::std::move(from);
  }

  inline ListDatabaseOperationsResponse& operator=(const ListDatabaseOperationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDatabaseOperationsResponse& operator=(ListDatabaseOperationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDatabaseOperationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDatabaseOperationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListDatabaseOperationsResponse*>(
               &_ListDatabaseOperationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListDatabaseOperationsResponse& a, ListDatabaseOperationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDatabaseOperationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDatabaseOperationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDatabaseOperationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDatabaseOperationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDatabaseOperationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListDatabaseOperationsResponse& from) {
    ListDatabaseOperationsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDatabaseOperationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.ListDatabaseOperationsResponse";
  }
  protected:
  explicit ListDatabaseOperationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.longrunning.Operation operations = 1;
  int operations_size() const;
  private:
  int _internal_operations_size() const;
  public:
  void clear_operations();
  ::google::longrunning::Operation* mutable_operations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::longrunning::Operation >*
      mutable_operations();
  private:
  const ::google::longrunning::Operation& _internal_operations(int index) const;
  ::google::longrunning::Operation* _internal_add_operations();
  public:
  const ::google::longrunning::Operation& operations(int index) const;
  ::google::longrunning::Operation* add_operations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::longrunning::Operation >&
      operations() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.ListDatabaseOperationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::longrunning::Operation > operations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class RestoreDatabaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.RestoreDatabaseRequest) */ {
 public:
  inline RestoreDatabaseRequest() : RestoreDatabaseRequest(nullptr) {}
  ~RestoreDatabaseRequest() override;
  explicit PROTOBUF_CONSTEXPR RestoreDatabaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RestoreDatabaseRequest(const RestoreDatabaseRequest& from);
  RestoreDatabaseRequest(RestoreDatabaseRequest&& from) noexcept
    : RestoreDatabaseRequest() {
    *this = ::std::move(from);
  }

  inline RestoreDatabaseRequest& operator=(const RestoreDatabaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestoreDatabaseRequest& operator=(RestoreDatabaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestoreDatabaseRequest& default_instance() {
    return *internal_default_instance();
  }
  enum SourceCase {
    kBackup = 3,
    SOURCE_NOT_SET = 0,
  };

  static inline const RestoreDatabaseRequest* internal_default_instance() {
    return reinterpret_cast<const RestoreDatabaseRequest*>(
               &_RestoreDatabaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RestoreDatabaseRequest& a, RestoreDatabaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RestoreDatabaseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestoreDatabaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestoreDatabaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RestoreDatabaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RestoreDatabaseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RestoreDatabaseRequest& from) {
    RestoreDatabaseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestoreDatabaseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.RestoreDatabaseRequest";
  }
  protected:
  explicit RestoreDatabaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kDatabaseIdFieldNumber = 2,
    kEncryptionConfigFieldNumber = 4,
    kBackupFieldNumber = 3,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string database_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_database_id();
  const std::string& database_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database_id();
  PROTOBUF_NODISCARD std::string* release_database_id();
  void set_allocated_database_id(std::string* database_id);
  private:
  const std::string& _internal_database_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database_id(const std::string& value);
  std::string* _internal_mutable_database_id();
  public:

  // .google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig encryption_config = 4 [(.google.api.field_behavior) = OPTIONAL];
  bool has_encryption_config() const;
  private:
  bool _internal_has_encryption_config() const;
  public:
  void clear_encryption_config();
  const ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig& encryption_config() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* release_encryption_config();
  ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* mutable_encryption_config();
  void set_allocated_encryption_config(::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* encryption_config);
  private:
  const ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig& _internal_encryption_config() const;
  ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* _internal_mutable_encryption_config();
  public:
  void unsafe_arena_set_allocated_encryption_config(
      ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* encryption_config);
  ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* unsafe_arena_release_encryption_config();

  // string backup = 3 [(.google.api.resource_reference) = {
  bool has_backup() const;
  private:
  bool _internal_has_backup() const;
  public:
  void clear_backup();
  const std::string& backup() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backup(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backup();
  PROTOBUF_NODISCARD std::string* release_backup();
  void set_allocated_backup(std::string* backup);
  private:
  const std::string& _internal_backup() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backup(const std::string& value);
  std::string* _internal_mutable_backup();
  public:

  void clear_source();
  SourceCase source_case() const;
  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.RestoreDatabaseRequest)
 private:
  class _Internal;
  void set_has_backup();

  inline bool has_source() const;
  inline void clear_has_source();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_id_;
    ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* encryption_config_;
    union SourceUnion {
      constexpr SourceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backup_;
    } source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class RestoreDatabaseEncryptionConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig) */ {
 public:
  inline RestoreDatabaseEncryptionConfig() : RestoreDatabaseEncryptionConfig(nullptr) {}
  ~RestoreDatabaseEncryptionConfig() override;
  explicit PROTOBUF_CONSTEXPR RestoreDatabaseEncryptionConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RestoreDatabaseEncryptionConfig(const RestoreDatabaseEncryptionConfig& from);
  RestoreDatabaseEncryptionConfig(RestoreDatabaseEncryptionConfig&& from) noexcept
    : RestoreDatabaseEncryptionConfig() {
    *this = ::std::move(from);
  }

  inline RestoreDatabaseEncryptionConfig& operator=(const RestoreDatabaseEncryptionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestoreDatabaseEncryptionConfig& operator=(RestoreDatabaseEncryptionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestoreDatabaseEncryptionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RestoreDatabaseEncryptionConfig* internal_default_instance() {
    return reinterpret_cast<const RestoreDatabaseEncryptionConfig*>(
               &_RestoreDatabaseEncryptionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RestoreDatabaseEncryptionConfig& a, RestoreDatabaseEncryptionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RestoreDatabaseEncryptionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestoreDatabaseEncryptionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestoreDatabaseEncryptionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RestoreDatabaseEncryptionConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RestoreDatabaseEncryptionConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RestoreDatabaseEncryptionConfig& from) {
    RestoreDatabaseEncryptionConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestoreDatabaseEncryptionConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig";
  }
  protected:
  explicit RestoreDatabaseEncryptionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RestoreDatabaseEncryptionConfig_EncryptionType EncryptionType;
  static constexpr EncryptionType ENCRYPTION_TYPE_UNSPECIFIED =
    RestoreDatabaseEncryptionConfig_EncryptionType_ENCRYPTION_TYPE_UNSPECIFIED;
  static constexpr EncryptionType USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION =
    RestoreDatabaseEncryptionConfig_EncryptionType_USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION;
  static constexpr EncryptionType GOOGLE_DEFAULT_ENCRYPTION =
    RestoreDatabaseEncryptionConfig_EncryptionType_GOOGLE_DEFAULT_ENCRYPTION;
  static constexpr EncryptionType CUSTOMER_MANAGED_ENCRYPTION =
    RestoreDatabaseEncryptionConfig_EncryptionType_CUSTOMER_MANAGED_ENCRYPTION;
  static inline bool EncryptionType_IsValid(int value) {
    return RestoreDatabaseEncryptionConfig_EncryptionType_IsValid(value);
  }
  static constexpr EncryptionType EncryptionType_MIN =
    RestoreDatabaseEncryptionConfig_EncryptionType_EncryptionType_MIN;
  static constexpr EncryptionType EncryptionType_MAX =
    RestoreDatabaseEncryptionConfig_EncryptionType_EncryptionType_MAX;
  static constexpr int EncryptionType_ARRAYSIZE =
    RestoreDatabaseEncryptionConfig_EncryptionType_EncryptionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EncryptionType_descriptor() {
    return RestoreDatabaseEncryptionConfig_EncryptionType_descriptor();
  }
  template<typename T>
  static inline const std::string& EncryptionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EncryptionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EncryptionType_Name.");
    return RestoreDatabaseEncryptionConfig_EncryptionType_Name(enum_t_value);
  }
  static inline bool EncryptionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EncryptionType* value) {
    return RestoreDatabaseEncryptionConfig_EncryptionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKmsKeyNameFieldNumber = 2,
    kEncryptionTypeFieldNumber = 1,
  };
  // string kms_key_name = 2 [(.google.api.field_behavior) = OPTIONAL, (.google.api.resource_reference) = {
  void clear_kms_key_name();
  const std::string& kms_key_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kms_key_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kms_key_name();
  PROTOBUF_NODISCARD std::string* release_kms_key_name();
  void set_allocated_kms_key_name(std::string* kms_key_name);
  private:
  const std::string& _internal_kms_key_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kms_key_name(const std::string& value);
  std::string* _internal_mutable_kms_key_name();
  public:

  // .google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig.EncryptionType encryption_type = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_encryption_type();
  ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig_EncryptionType encryption_type() const;
  void set_encryption_type(::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig_EncryptionType value);
  private:
  ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig_EncryptionType _internal_encryption_type() const;
  void _internal_set_encryption_type(::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig_EncryptionType value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kms_key_name_;
    int encryption_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class RestoreDatabaseMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.RestoreDatabaseMetadata) */ {
 public:
  inline RestoreDatabaseMetadata() : RestoreDatabaseMetadata(nullptr) {}
  ~RestoreDatabaseMetadata() override;
  explicit PROTOBUF_CONSTEXPR RestoreDatabaseMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RestoreDatabaseMetadata(const RestoreDatabaseMetadata& from);
  RestoreDatabaseMetadata(RestoreDatabaseMetadata&& from) noexcept
    : RestoreDatabaseMetadata() {
    *this = ::std::move(from);
  }

  inline RestoreDatabaseMetadata& operator=(const RestoreDatabaseMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestoreDatabaseMetadata& operator=(RestoreDatabaseMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestoreDatabaseMetadata& default_instance() {
    return *internal_default_instance();
  }
  enum SourceInfoCase {
    kBackupInfo = 3,
    SOURCE_INFO_NOT_SET = 0,
  };

  static inline const RestoreDatabaseMetadata* internal_default_instance() {
    return reinterpret_cast<const RestoreDatabaseMetadata*>(
               &_RestoreDatabaseMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RestoreDatabaseMetadata& a, RestoreDatabaseMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(RestoreDatabaseMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestoreDatabaseMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestoreDatabaseMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RestoreDatabaseMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RestoreDatabaseMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RestoreDatabaseMetadata& from) {
    RestoreDatabaseMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestoreDatabaseMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.RestoreDatabaseMetadata";
  }
  protected:
  explicit RestoreDatabaseMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kOptimizeDatabaseOperationNameFieldNumber = 6,
    kProgressFieldNumber = 4,
    kCancelTimeFieldNumber = 5,
    kSourceTypeFieldNumber = 2,
    kBackupInfoFieldNumber = 3,
  };
  // string name = 1 [(.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string optimize_database_operation_name = 6;
  void clear_optimize_database_operation_name();
  const std::string& optimize_database_operation_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_optimize_database_operation_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_optimize_database_operation_name();
  PROTOBUF_NODISCARD std::string* release_optimize_database_operation_name();
  void set_allocated_optimize_database_operation_name(std::string* optimize_database_operation_name);
  private:
  const std::string& _internal_optimize_database_operation_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_optimize_database_operation_name(const std::string& value);
  std::string* _internal_mutable_optimize_database_operation_name();
  public:

  // .google.spanner.admin.database.v1.OperationProgress progress = 4;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  const ::google::spanner::admin::database::v1::OperationProgress& progress() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::database::v1::OperationProgress* release_progress();
  ::google::spanner::admin::database::v1::OperationProgress* mutable_progress();
  void set_allocated_progress(::google::spanner::admin::database::v1::OperationProgress* progress);
  private:
  const ::google::spanner::admin::database::v1::OperationProgress& _internal_progress() const;
  ::google::spanner::admin::database::v1::OperationProgress* _internal_mutable_progress();
  public:
  void unsafe_arena_set_allocated_progress(
      ::google::spanner::admin::database::v1::OperationProgress* progress);
  ::google::spanner::admin::database::v1::OperationProgress* unsafe_arena_release_progress();

  // .google.protobuf.Timestamp cancel_time = 5;
  bool has_cancel_time() const;
  private:
  bool _internal_has_cancel_time() const;
  public:
  void clear_cancel_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& cancel_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_cancel_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_cancel_time();
  void set_allocated_cancel_time(::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_cancel_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_cancel_time();
  public:
  void unsafe_arena_set_allocated_cancel_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_cancel_time();

  // .google.spanner.admin.database.v1.RestoreSourceType source_type = 2;
  void clear_source_type();
  ::google::spanner::admin::database::v1::RestoreSourceType source_type() const;
  void set_source_type(::google::spanner::admin::database::v1::RestoreSourceType value);
  private:
  ::google::spanner::admin::database::v1::RestoreSourceType _internal_source_type() const;
  void _internal_set_source_type(::google::spanner::admin::database::v1::RestoreSourceType value);
  public:

  // .google.spanner.admin.database.v1.BackupInfo backup_info = 3;
  bool has_backup_info() const;
  private:
  bool _internal_has_backup_info() const;
  public:
  void clear_backup_info();
  const ::google::spanner::admin::database::v1::BackupInfo& backup_info() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::database::v1::BackupInfo* release_backup_info();
  ::google::spanner::admin::database::v1::BackupInfo* mutable_backup_info();
  void set_allocated_backup_info(::google::spanner::admin::database::v1::BackupInfo* backup_info);
  private:
  const ::google::spanner::admin::database::v1::BackupInfo& _internal_backup_info() const;
  ::google::spanner::admin::database::v1::BackupInfo* _internal_mutable_backup_info();
  public:
  void unsafe_arena_set_allocated_backup_info(
      ::google::spanner::admin::database::v1::BackupInfo* backup_info);
  ::google::spanner::admin::database::v1::BackupInfo* unsafe_arena_release_backup_info();

  void clear_source_info();
  SourceInfoCase source_info_case() const;
  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.RestoreDatabaseMetadata)
 private:
  class _Internal;
  void set_has_backup_info();

  inline bool has_source_info() const;
  inline void clear_has_source_info();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr optimize_database_operation_name_;
    ::google::spanner::admin::database::v1::OperationProgress* progress_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time_;
    int source_type_;
    union SourceInfoUnion {
      constexpr SourceInfoUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::google::spanner::admin::database::v1::BackupInfo* backup_info_;
    } source_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class OptimizeRestoredDatabaseMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata) */ {
 public:
  inline OptimizeRestoredDatabaseMetadata() : OptimizeRestoredDatabaseMetadata(nullptr) {}
  ~OptimizeRestoredDatabaseMetadata() override;
  explicit PROTOBUF_CONSTEXPR OptimizeRestoredDatabaseMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OptimizeRestoredDatabaseMetadata(const OptimizeRestoredDatabaseMetadata& from);
  OptimizeRestoredDatabaseMetadata(OptimizeRestoredDatabaseMetadata&& from) noexcept
    : OptimizeRestoredDatabaseMetadata() {
    *this = ::std::move(from);
  }

  inline OptimizeRestoredDatabaseMetadata& operator=(const OptimizeRestoredDatabaseMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptimizeRestoredDatabaseMetadata& operator=(OptimizeRestoredDatabaseMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptimizeRestoredDatabaseMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const OptimizeRestoredDatabaseMetadata* internal_default_instance() {
    return reinterpret_cast<const OptimizeRestoredDatabaseMetadata*>(
               &_OptimizeRestoredDatabaseMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(OptimizeRestoredDatabaseMetadata& a, OptimizeRestoredDatabaseMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(OptimizeRestoredDatabaseMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptimizeRestoredDatabaseMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptimizeRestoredDatabaseMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OptimizeRestoredDatabaseMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OptimizeRestoredDatabaseMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OptimizeRestoredDatabaseMetadata& from) {
    OptimizeRestoredDatabaseMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptimizeRestoredDatabaseMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata";
  }
  protected:
  explicit OptimizeRestoredDatabaseMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kProgressFieldNumber = 2,
  };
  // string name = 1 [(.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.spanner.admin.database.v1.OperationProgress progress = 2;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  const ::google::spanner::admin::database::v1::OperationProgress& progress() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::database::v1::OperationProgress* release_progress();
  ::google::spanner::admin::database::v1::OperationProgress* mutable_progress();
  void set_allocated_progress(::google::spanner::admin::database::v1::OperationProgress* progress);
  private:
  const ::google::spanner::admin::database::v1::OperationProgress& _internal_progress() const;
  ::google::spanner::admin::database::v1::OperationProgress* _internal_mutable_progress();
  public:
  void unsafe_arena_set_allocated_progress(
      ::google::spanner::admin::database::v1::OperationProgress* progress);
  ::google::spanner::admin::database::v1::OperationProgress* unsafe_arena_release_progress();

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::google::spanner::admin::database::v1::OperationProgress* progress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class DatabaseRole final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.DatabaseRole) */ {
 public:
  inline DatabaseRole() : DatabaseRole(nullptr) {}
  ~DatabaseRole() override;
  explicit PROTOBUF_CONSTEXPR DatabaseRole(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatabaseRole(const DatabaseRole& from);
  DatabaseRole(DatabaseRole&& from) noexcept
    : DatabaseRole() {
    *this = ::std::move(from);
  }

  inline DatabaseRole& operator=(const DatabaseRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatabaseRole& operator=(DatabaseRole&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatabaseRole& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatabaseRole* internal_default_instance() {
    return reinterpret_cast<const DatabaseRole*>(
               &_DatabaseRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DatabaseRole& a, DatabaseRole& b) {
    a.Swap(&b);
  }
  inline void Swap(DatabaseRole* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatabaseRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatabaseRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatabaseRole>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatabaseRole& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatabaseRole& from) {
    DatabaseRole::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatabaseRole* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.DatabaseRole";
  }
  protected:
  explicit DatabaseRole(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.DatabaseRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class ListDatabaseRolesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.ListDatabaseRolesRequest) */ {
 public:
  inline ListDatabaseRolesRequest() : ListDatabaseRolesRequest(nullptr) {}
  ~ListDatabaseRolesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListDatabaseRolesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDatabaseRolesRequest(const ListDatabaseRolesRequest& from);
  ListDatabaseRolesRequest(ListDatabaseRolesRequest&& from) noexcept
    : ListDatabaseRolesRequest() {
    *this = ::std::move(from);
  }

  inline ListDatabaseRolesRequest& operator=(const ListDatabaseRolesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDatabaseRolesRequest& operator=(ListDatabaseRolesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDatabaseRolesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDatabaseRolesRequest* internal_default_instance() {
    return reinterpret_cast<const ListDatabaseRolesRequest*>(
               &_ListDatabaseRolesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ListDatabaseRolesRequest& a, ListDatabaseRolesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDatabaseRolesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDatabaseRolesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDatabaseRolesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDatabaseRolesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDatabaseRolesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListDatabaseRolesRequest& from) {
    ListDatabaseRolesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDatabaseRolesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.ListDatabaseRolesRequest";
  }
  protected:
  explicit ListDatabaseRolesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 3;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.ListDatabaseRolesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class ListDatabaseRolesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.database.v1.ListDatabaseRolesResponse) */ {
 public:
  inline ListDatabaseRolesResponse() : ListDatabaseRolesResponse(nullptr) {}
  ~ListDatabaseRolesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListDatabaseRolesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDatabaseRolesResponse(const ListDatabaseRolesResponse& from);
  ListDatabaseRolesResponse(ListDatabaseRolesResponse&& from) noexcept
    : ListDatabaseRolesResponse() {
    *this = ::std::move(from);
  }

  inline ListDatabaseRolesResponse& operator=(const ListDatabaseRolesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDatabaseRolesResponse& operator=(ListDatabaseRolesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDatabaseRolesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDatabaseRolesResponse* internal_default_instance() {
    return reinterpret_cast<const ListDatabaseRolesResponse*>(
               &_ListDatabaseRolesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ListDatabaseRolesResponse& a, ListDatabaseRolesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDatabaseRolesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDatabaseRolesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDatabaseRolesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDatabaseRolesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDatabaseRolesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListDatabaseRolesResponse& from) {
    ListDatabaseRolesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDatabaseRolesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.database.v1.ListDatabaseRolesResponse";
  }
  protected:
  explicit ListDatabaseRolesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseRolesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.spanner.admin.database.v1.DatabaseRole database_roles = 1;
  int database_roles_size() const;
  private:
  int _internal_database_roles_size() const;
  public:
  void clear_database_roles();
  ::google::spanner::admin::database::v1::DatabaseRole* mutable_database_roles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::DatabaseRole >*
      mutable_database_roles();
  private:
  const ::google::spanner::admin::database::v1::DatabaseRole& _internal_database_roles(int index) const;
  ::google::spanner::admin::database::v1::DatabaseRole* _internal_add_database_roles();
  public:
  const ::google::spanner::admin::database::v1::DatabaseRole& database_roles(int index) const;
  ::google::spanner::admin::database::v1::DatabaseRole* add_database_roles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::DatabaseRole >&
      database_roles() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.database.v1.ListDatabaseRolesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::DatabaseRole > database_roles_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RestoreInfo

// .google.spanner.admin.database.v1.RestoreSourceType source_type = 1;
inline void RestoreInfo::clear_source_type() {
  _impl_.source_type_ = 0;
}
inline ::google::spanner::admin::database::v1::RestoreSourceType RestoreInfo::_internal_source_type() const {
  return static_cast< ::google::spanner::admin::database::v1::RestoreSourceType >(_impl_.source_type_);
}
inline ::google::spanner::admin::database::v1::RestoreSourceType RestoreInfo::source_type() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.RestoreInfo.source_type)
  return _internal_source_type();
}
inline void RestoreInfo::_internal_set_source_type(::google::spanner::admin::database::v1::RestoreSourceType value) {
  
  _impl_.source_type_ = value;
}
inline void RestoreInfo::set_source_type(::google::spanner::admin::database::v1::RestoreSourceType value) {
  _internal_set_source_type(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.RestoreInfo.source_type)
}

// .google.spanner.admin.database.v1.BackupInfo backup_info = 2;
inline bool RestoreInfo::_internal_has_backup_info() const {
  return source_info_case() == kBackupInfo;
}
inline bool RestoreInfo::has_backup_info() const {
  return _internal_has_backup_info();
}
inline void RestoreInfo::set_has_backup_info() {
  _impl_._oneof_case_[0] = kBackupInfo;
}
inline ::google::spanner::admin::database::v1::BackupInfo* RestoreInfo::release_backup_info() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.RestoreInfo.backup_info)
  if (_internal_has_backup_info()) {
    clear_has_source_info();
    ::google::spanner::admin::database::v1::BackupInfo* temp = _impl_.source_info_.backup_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.source_info_.backup_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::spanner::admin::database::v1::BackupInfo& RestoreInfo::_internal_backup_info() const {
  return _internal_has_backup_info()
      ? *_impl_.source_info_.backup_info_
      : reinterpret_cast< ::google::spanner::admin::database::v1::BackupInfo&>(::google::spanner::admin::database::v1::_BackupInfo_default_instance_);
}
inline const ::google::spanner::admin::database::v1::BackupInfo& RestoreInfo::backup_info() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.RestoreInfo.backup_info)
  return _internal_backup_info();
}
inline ::google::spanner::admin::database::v1::BackupInfo* RestoreInfo::unsafe_arena_release_backup_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.spanner.admin.database.v1.RestoreInfo.backup_info)
  if (_internal_has_backup_info()) {
    clear_has_source_info();
    ::google::spanner::admin::database::v1::BackupInfo* temp = _impl_.source_info_.backup_info_;
    _impl_.source_info_.backup_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RestoreInfo::unsafe_arena_set_allocated_backup_info(::google::spanner::admin::database::v1::BackupInfo* backup_info) {
  clear_source_info();
  if (backup_info) {
    set_has_backup_info();
    _impl_.source_info_.backup_info_ = backup_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.database.v1.RestoreInfo.backup_info)
}
inline ::google::spanner::admin::database::v1::BackupInfo* RestoreInfo::_internal_mutable_backup_info() {
  if (!_internal_has_backup_info()) {
    clear_source_info();
    set_has_backup_info();
    _impl_.source_info_.backup_info_ = CreateMaybeMessage< ::google::spanner::admin::database::v1::BackupInfo >(GetArenaForAllocation());
  }
  return _impl_.source_info_.backup_info_;
}
inline ::google::spanner::admin::database::v1::BackupInfo* RestoreInfo::mutable_backup_info() {
  ::google::spanner::admin::database::v1::BackupInfo* _msg = _internal_mutable_backup_info();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.RestoreInfo.backup_info)
  return _msg;
}

inline bool RestoreInfo::has_source_info() const {
  return source_info_case() != SOURCE_INFO_NOT_SET;
}
inline void RestoreInfo::clear_has_source_info() {
  _impl_._oneof_case_[0] = SOURCE_INFO_NOT_SET;
}
inline RestoreInfo::SourceInfoCase RestoreInfo::source_info_case() const {
  return RestoreInfo::SourceInfoCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Database

// string name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void Database::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Database::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.Database.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Database::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.Database.name)
}
inline std::string* Database::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.Database.name)
  return _s;
}
inline const std::string& Database::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Database::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Database::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Database::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.Database.name)
  return _impl_.name_.Release();
}
inline void Database::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.Database.name)
}

// .google.spanner.admin.database.v1.Database.State state = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Database::clear_state() {
  _impl_.state_ = 0;
}
inline ::google::spanner::admin::database::v1::Database_State Database::_internal_state() const {
  return static_cast< ::google::spanner::admin::database::v1::Database_State >(_impl_.state_);
}
inline ::google::spanner::admin::database::v1::Database_State Database::state() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.Database.state)
  return _internal_state();
}
inline void Database::_internal_set_state(::google::spanner::admin::database::v1::Database_State value) {
  
  _impl_.state_ = value;
}
inline void Database::set_state(::google::spanner::admin::database::v1::Database_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.Database.state)
}

// .google.protobuf.Timestamp create_time = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Database::_internal_has_create_time() const {
  return this != internal_default_instance() && _impl_.create_time_ != nullptr;
}
inline bool Database::has_create_time() const {
  return _internal_has_create_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Database::_internal_create_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.create_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Database::create_time() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.Database.create_time)
  return _internal_create_time();
}
inline void Database::unsafe_arena_set_allocated_create_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  _impl_.create_time_ = create_time;
  if (create_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.database.v1.Database.create_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Database::release_create_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Database::unsafe_arena_release_create_time() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.Database.create_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Database::_internal_mutable_create_time() {
  
  if (_impl_.create_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.create_time_ = p;
  }
  return _impl_.create_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Database::mutable_create_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.Database.create_time)
  return _msg;
}
inline void Database::set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  if (create_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time));
    if (message_arena != submessage_arena) {
      create_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.Database.create_time)
}

// .google.spanner.admin.database.v1.RestoreInfo restore_info = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Database::_internal_has_restore_info() const {
  return this != internal_default_instance() && _impl_.restore_info_ != nullptr;
}
inline bool Database::has_restore_info() const {
  return _internal_has_restore_info();
}
inline void Database::clear_restore_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.restore_info_ != nullptr) {
    delete _impl_.restore_info_;
  }
  _impl_.restore_info_ = nullptr;
}
inline const ::google::spanner::admin::database::v1::RestoreInfo& Database::_internal_restore_info() const {
  const ::google::spanner::admin::database::v1::RestoreInfo* p = _impl_.restore_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::database::v1::RestoreInfo&>(
      ::google::spanner::admin::database::v1::_RestoreInfo_default_instance_);
}
inline const ::google::spanner::admin::database::v1::RestoreInfo& Database::restore_info() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.Database.restore_info)
  return _internal_restore_info();
}
inline void Database::unsafe_arena_set_allocated_restore_info(
    ::google::spanner::admin::database::v1::RestoreInfo* restore_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.restore_info_);
  }
  _impl_.restore_info_ = restore_info;
  if (restore_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.database.v1.Database.restore_info)
}
inline ::google::spanner::admin::database::v1::RestoreInfo* Database::release_restore_info() {
  
  ::google::spanner::admin::database::v1::RestoreInfo* temp = _impl_.restore_info_;
  _impl_.restore_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::database::v1::RestoreInfo* Database::unsafe_arena_release_restore_info() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.Database.restore_info)
  
  ::google::spanner::admin::database::v1::RestoreInfo* temp = _impl_.restore_info_;
  _impl_.restore_info_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::database::v1::RestoreInfo* Database::_internal_mutable_restore_info() {
  
  if (_impl_.restore_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::database::v1::RestoreInfo>(GetArenaForAllocation());
    _impl_.restore_info_ = p;
  }
  return _impl_.restore_info_;
}
inline ::google::spanner::admin::database::v1::RestoreInfo* Database::mutable_restore_info() {
  ::google::spanner::admin::database::v1::RestoreInfo* _msg = _internal_mutable_restore_info();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.Database.restore_info)
  return _msg;
}
inline void Database::set_allocated_restore_info(::google::spanner::admin::database::v1::RestoreInfo* restore_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.restore_info_;
  }
  if (restore_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(restore_info);
    if (message_arena != submessage_arena) {
      restore_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, restore_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.restore_info_ = restore_info;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.Database.restore_info)
}

// .google.spanner.admin.database.v1.EncryptionConfig encryption_config = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Database::_internal_has_encryption_config() const {
  return this != internal_default_instance() && _impl_.encryption_config_ != nullptr;
}
inline bool Database::has_encryption_config() const {
  return _internal_has_encryption_config();
}
inline const ::google::spanner::admin::database::v1::EncryptionConfig& Database::_internal_encryption_config() const {
  const ::google::spanner::admin::database::v1::EncryptionConfig* p = _impl_.encryption_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::database::v1::EncryptionConfig&>(
      ::google::spanner::admin::database::v1::_EncryptionConfig_default_instance_);
}
inline const ::google::spanner::admin::database::v1::EncryptionConfig& Database::encryption_config() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.Database.encryption_config)
  return _internal_encryption_config();
}
inline void Database::unsafe_arena_set_allocated_encryption_config(
    ::google::spanner::admin::database::v1::EncryptionConfig* encryption_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encryption_config_);
  }
  _impl_.encryption_config_ = encryption_config;
  if (encryption_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.database.v1.Database.encryption_config)
}
inline ::google::spanner::admin::database::v1::EncryptionConfig* Database::release_encryption_config() {
  
  ::google::spanner::admin::database::v1::EncryptionConfig* temp = _impl_.encryption_config_;
  _impl_.encryption_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::database::v1::EncryptionConfig* Database::unsafe_arena_release_encryption_config() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.Database.encryption_config)
  
  ::google::spanner::admin::database::v1::EncryptionConfig* temp = _impl_.encryption_config_;
  _impl_.encryption_config_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::database::v1::EncryptionConfig* Database::_internal_mutable_encryption_config() {
  
  if (_impl_.encryption_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::database::v1::EncryptionConfig>(GetArenaForAllocation());
    _impl_.encryption_config_ = p;
  }
  return _impl_.encryption_config_;
}
inline ::google::spanner::admin::database::v1::EncryptionConfig* Database::mutable_encryption_config() {
  ::google::spanner::admin::database::v1::EncryptionConfig* _msg = _internal_mutable_encryption_config();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.Database.encryption_config)
  return _msg;
}
inline void Database::set_allocated_encryption_config(::google::spanner::admin::database::v1::EncryptionConfig* encryption_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encryption_config_);
  }
  if (encryption_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encryption_config));
    if (message_arena != submessage_arena) {
      encryption_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encryption_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.encryption_config_ = encryption_config;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.Database.encryption_config)
}

// repeated .google.spanner.admin.database.v1.EncryptionInfo encryption_info = 8 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline int Database::_internal_encryption_info_size() const {
  return _impl_.encryption_info_.size();
}
inline int Database::encryption_info_size() const {
  return _internal_encryption_info_size();
}
inline ::google::spanner::admin::database::v1::EncryptionInfo* Database::mutable_encryption_info(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.Database.encryption_info)
  return _impl_.encryption_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::EncryptionInfo >*
Database::mutable_encryption_info() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.database.v1.Database.encryption_info)
  return &_impl_.encryption_info_;
}
inline const ::google::spanner::admin::database::v1::EncryptionInfo& Database::_internal_encryption_info(int index) const {
  return _impl_.encryption_info_.Get(index);
}
inline const ::google::spanner::admin::database::v1::EncryptionInfo& Database::encryption_info(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.Database.encryption_info)
  return _internal_encryption_info(index);
}
inline ::google::spanner::admin::database::v1::EncryptionInfo* Database::_internal_add_encryption_info() {
  return _impl_.encryption_info_.Add();
}
inline ::google::spanner::admin::database::v1::EncryptionInfo* Database::add_encryption_info() {
  ::google::spanner::admin::database::v1::EncryptionInfo* _add = _internal_add_encryption_info();
  // @@protoc_insertion_point(field_add:google.spanner.admin.database.v1.Database.encryption_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::EncryptionInfo >&
Database::encryption_info() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.database.v1.Database.encryption_info)
  return _impl_.encryption_info_;
}

// string version_retention_period = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Database::clear_version_retention_period() {
  _impl_.version_retention_period_.ClearToEmpty();
}
inline const std::string& Database::version_retention_period() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.Database.version_retention_period)
  return _internal_version_retention_period();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Database::set_version_retention_period(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_retention_period_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.Database.version_retention_period)
}
inline std::string* Database::mutable_version_retention_period() {
  std::string* _s = _internal_mutable_version_retention_period();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.Database.version_retention_period)
  return _s;
}
inline const std::string& Database::_internal_version_retention_period() const {
  return _impl_.version_retention_period_.Get();
}
inline void Database::_internal_set_version_retention_period(const std::string& value) {
  
  _impl_.version_retention_period_.Set(value, GetArenaForAllocation());
}
inline std::string* Database::_internal_mutable_version_retention_period() {
  
  return _impl_.version_retention_period_.Mutable(GetArenaForAllocation());
}
inline std::string* Database::release_version_retention_period() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.Database.version_retention_period)
  return _impl_.version_retention_period_.Release();
}
inline void Database::set_allocated_version_retention_period(std::string* version_retention_period) {
  if (version_retention_period != nullptr) {
    
  } else {
    
  }
  _impl_.version_retention_period_.SetAllocated(version_retention_period, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_retention_period_.IsDefault()) {
    _impl_.version_retention_period_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.Database.version_retention_period)
}

// .google.protobuf.Timestamp earliest_version_time = 7 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Database::_internal_has_earliest_version_time() const {
  return this != internal_default_instance() && _impl_.earliest_version_time_ != nullptr;
}
inline bool Database::has_earliest_version_time() const {
  return _internal_has_earliest_version_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Database::_internal_earliest_version_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.earliest_version_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Database::earliest_version_time() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.Database.earliest_version_time)
  return _internal_earliest_version_time();
}
inline void Database::unsafe_arena_set_allocated_earliest_version_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* earliest_version_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.earliest_version_time_);
  }
  _impl_.earliest_version_time_ = earliest_version_time;
  if (earliest_version_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.database.v1.Database.earliest_version_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Database::release_earliest_version_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.earliest_version_time_;
  _impl_.earliest_version_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Database::unsafe_arena_release_earliest_version_time() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.Database.earliest_version_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.earliest_version_time_;
  _impl_.earliest_version_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Database::_internal_mutable_earliest_version_time() {
  
  if (_impl_.earliest_version_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.earliest_version_time_ = p;
  }
  return _impl_.earliest_version_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Database::mutable_earliest_version_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_earliest_version_time();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.Database.earliest_version_time)
  return _msg;
}
inline void Database::set_allocated_earliest_version_time(::PROTOBUF_NAMESPACE_ID::Timestamp* earliest_version_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.earliest_version_time_);
  }
  if (earliest_version_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(earliest_version_time));
    if (message_arena != submessage_arena) {
      earliest_version_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, earliest_version_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.earliest_version_time_ = earliest_version_time;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.Database.earliest_version_time)
}

// string default_leader = 9 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Database::clear_default_leader() {
  _impl_.default_leader_.ClearToEmpty();
}
inline const std::string& Database::default_leader() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.Database.default_leader)
  return _internal_default_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Database::set_default_leader(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default_leader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.Database.default_leader)
}
inline std::string* Database::mutable_default_leader() {
  std::string* _s = _internal_mutable_default_leader();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.Database.default_leader)
  return _s;
}
inline const std::string& Database::_internal_default_leader() const {
  return _impl_.default_leader_.Get();
}
inline void Database::_internal_set_default_leader(const std::string& value) {
  
  _impl_.default_leader_.Set(value, GetArenaForAllocation());
}
inline std::string* Database::_internal_mutable_default_leader() {
  
  return _impl_.default_leader_.Mutable(GetArenaForAllocation());
}
inline std::string* Database::release_default_leader() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.Database.default_leader)
  return _impl_.default_leader_.Release();
}
inline void Database::set_allocated_default_leader(std::string* default_leader) {
  if (default_leader != nullptr) {
    
  } else {
    
  }
  _impl_.default_leader_.SetAllocated(default_leader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default_leader_.IsDefault()) {
    _impl_.default_leader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.Database.default_leader)
}

// .google.spanner.admin.database.v1.DatabaseDialect database_dialect = 10 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Database::clear_database_dialect() {
  _impl_.database_dialect_ = 0;
}
inline ::google::spanner::admin::database::v1::DatabaseDialect Database::_internal_database_dialect() const {
  return static_cast< ::google::spanner::admin::database::v1::DatabaseDialect >(_impl_.database_dialect_);
}
inline ::google::spanner::admin::database::v1::DatabaseDialect Database::database_dialect() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.Database.database_dialect)
  return _internal_database_dialect();
}
inline void Database::_internal_set_database_dialect(::google::spanner::admin::database::v1::DatabaseDialect value) {
  
  _impl_.database_dialect_ = value;
}
inline void Database::set_database_dialect(::google::spanner::admin::database::v1::DatabaseDialect value) {
  _internal_set_database_dialect(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.Database.database_dialect)
}

// -------------------------------------------------------------------

// ListDatabasesRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListDatabasesRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListDatabasesRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabasesRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDatabasesRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.ListDatabasesRequest.parent)
}
inline std::string* ListDatabasesRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.ListDatabasesRequest.parent)
  return _s;
}
inline const std::string& ListDatabasesRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListDatabasesRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDatabasesRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDatabasesRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.ListDatabasesRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListDatabasesRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.ListDatabasesRequest.parent)
}

// int32 page_size = 3;
inline void ListDatabasesRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListDatabasesRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListDatabasesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabasesRequest.page_size)
  return _internal_page_size();
}
inline void ListDatabasesRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListDatabasesRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.ListDatabasesRequest.page_size)
}

// string page_token = 4;
inline void ListDatabasesRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListDatabasesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabasesRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDatabasesRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.ListDatabasesRequest.page_token)
}
inline std::string* ListDatabasesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.ListDatabasesRequest.page_token)
  return _s;
}
inline const std::string& ListDatabasesRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListDatabasesRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDatabasesRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDatabasesRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.ListDatabasesRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListDatabasesRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.ListDatabasesRequest.page_token)
}

// -------------------------------------------------------------------

// ListDatabasesResponse

// repeated .google.spanner.admin.database.v1.Database databases = 1;
inline int ListDatabasesResponse::_internal_databases_size() const {
  return _impl_.databases_.size();
}
inline int ListDatabasesResponse::databases_size() const {
  return _internal_databases_size();
}
inline void ListDatabasesResponse::clear_databases() {
  _impl_.databases_.Clear();
}
inline ::google::spanner::admin::database::v1::Database* ListDatabasesResponse::mutable_databases(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.ListDatabasesResponse.databases)
  return _impl_.databases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::Database >*
ListDatabasesResponse::mutable_databases() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.database.v1.ListDatabasesResponse.databases)
  return &_impl_.databases_;
}
inline const ::google::spanner::admin::database::v1::Database& ListDatabasesResponse::_internal_databases(int index) const {
  return _impl_.databases_.Get(index);
}
inline const ::google::spanner::admin::database::v1::Database& ListDatabasesResponse::databases(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabasesResponse.databases)
  return _internal_databases(index);
}
inline ::google::spanner::admin::database::v1::Database* ListDatabasesResponse::_internal_add_databases() {
  return _impl_.databases_.Add();
}
inline ::google::spanner::admin::database::v1::Database* ListDatabasesResponse::add_databases() {
  ::google::spanner::admin::database::v1::Database* _add = _internal_add_databases();
  // @@protoc_insertion_point(field_add:google.spanner.admin.database.v1.ListDatabasesResponse.databases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::Database >&
ListDatabasesResponse::databases() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.database.v1.ListDatabasesResponse.databases)
  return _impl_.databases_;
}

// string next_page_token = 2;
inline void ListDatabasesResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListDatabasesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabasesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDatabasesResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.ListDatabasesResponse.next_page_token)
}
inline std::string* ListDatabasesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.ListDatabasesResponse.next_page_token)
  return _s;
}
inline const std::string& ListDatabasesResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListDatabasesResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDatabasesResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDatabasesResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.ListDatabasesResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListDatabasesResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.ListDatabasesResponse.next_page_token)
}

// -------------------------------------------------------------------

// CreateDatabaseRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CreateDatabaseRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& CreateDatabaseRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.CreateDatabaseRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDatabaseRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.CreateDatabaseRequest.parent)
}
inline std::string* CreateDatabaseRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.CreateDatabaseRequest.parent)
  return _s;
}
inline const std::string& CreateDatabaseRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void CreateDatabaseRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateDatabaseRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateDatabaseRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.CreateDatabaseRequest.parent)
  return _impl_.parent_.Release();
}
inline void CreateDatabaseRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.CreateDatabaseRequest.parent)
}

// string create_statement = 2 [(.google.api.field_behavior) = REQUIRED];
inline void CreateDatabaseRequest::clear_create_statement() {
  _impl_.create_statement_.ClearToEmpty();
}
inline const std::string& CreateDatabaseRequest::create_statement() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.CreateDatabaseRequest.create_statement)
  return _internal_create_statement();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDatabaseRequest::set_create_statement(ArgT0&& arg0, ArgT... args) {
 
 _impl_.create_statement_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.CreateDatabaseRequest.create_statement)
}
inline std::string* CreateDatabaseRequest::mutable_create_statement() {
  std::string* _s = _internal_mutable_create_statement();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.CreateDatabaseRequest.create_statement)
  return _s;
}
inline const std::string& CreateDatabaseRequest::_internal_create_statement() const {
  return _impl_.create_statement_.Get();
}
inline void CreateDatabaseRequest::_internal_set_create_statement(const std::string& value) {
  
  _impl_.create_statement_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateDatabaseRequest::_internal_mutable_create_statement() {
  
  return _impl_.create_statement_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateDatabaseRequest::release_create_statement() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.CreateDatabaseRequest.create_statement)
  return _impl_.create_statement_.Release();
}
inline void CreateDatabaseRequest::set_allocated_create_statement(std::string* create_statement) {
  if (create_statement != nullptr) {
    
  } else {
    
  }
  _impl_.create_statement_.SetAllocated(create_statement, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.create_statement_.IsDefault()) {
    _impl_.create_statement_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.CreateDatabaseRequest.create_statement)
}

// repeated string extra_statements = 3 [(.google.api.field_behavior) = OPTIONAL];
inline int CreateDatabaseRequest::_internal_extra_statements_size() const {
  return _impl_.extra_statements_.size();
}
inline int CreateDatabaseRequest::extra_statements_size() const {
  return _internal_extra_statements_size();
}
inline void CreateDatabaseRequest::clear_extra_statements() {
  _impl_.extra_statements_.Clear();
}
inline std::string* CreateDatabaseRequest::add_extra_statements() {
  std::string* _s = _internal_add_extra_statements();
  // @@protoc_insertion_point(field_add_mutable:google.spanner.admin.database.v1.CreateDatabaseRequest.extra_statements)
  return _s;
}
inline const std::string& CreateDatabaseRequest::_internal_extra_statements(int index) const {
  return _impl_.extra_statements_.Get(index);
}
inline const std::string& CreateDatabaseRequest::extra_statements(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.CreateDatabaseRequest.extra_statements)
  return _internal_extra_statements(index);
}
inline std::string* CreateDatabaseRequest::mutable_extra_statements(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.CreateDatabaseRequest.extra_statements)
  return _impl_.extra_statements_.Mutable(index);
}
inline void CreateDatabaseRequest::set_extra_statements(int index, const std::string& value) {
  _impl_.extra_statements_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.CreateDatabaseRequest.extra_statements)
}
inline void CreateDatabaseRequest::set_extra_statements(int index, std::string&& value) {
  _impl_.extra_statements_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.CreateDatabaseRequest.extra_statements)
}
inline void CreateDatabaseRequest::set_extra_statements(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.extra_statements_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.spanner.admin.database.v1.CreateDatabaseRequest.extra_statements)
}
inline void CreateDatabaseRequest::set_extra_statements(int index, const char* value, size_t size) {
  _impl_.extra_statements_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.spanner.admin.database.v1.CreateDatabaseRequest.extra_statements)
}
inline std::string* CreateDatabaseRequest::_internal_add_extra_statements() {
  return _impl_.extra_statements_.Add();
}
inline void CreateDatabaseRequest::add_extra_statements(const std::string& value) {
  _impl_.extra_statements_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.spanner.admin.database.v1.CreateDatabaseRequest.extra_statements)
}
inline void CreateDatabaseRequest::add_extra_statements(std::string&& value) {
  _impl_.extra_statements_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.spanner.admin.database.v1.CreateDatabaseRequest.extra_statements)
}
inline void CreateDatabaseRequest::add_extra_statements(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.extra_statements_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.spanner.admin.database.v1.CreateDatabaseRequest.extra_statements)
}
inline void CreateDatabaseRequest::add_extra_statements(const char* value, size_t size) {
  _impl_.extra_statements_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.spanner.admin.database.v1.CreateDatabaseRequest.extra_statements)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateDatabaseRequest::extra_statements() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.database.v1.CreateDatabaseRequest.extra_statements)
  return _impl_.extra_statements_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateDatabaseRequest::mutable_extra_statements() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.database.v1.CreateDatabaseRequest.extra_statements)
  return &_impl_.extra_statements_;
}

// .google.spanner.admin.database.v1.EncryptionConfig encryption_config = 4 [(.google.api.field_behavior) = OPTIONAL];
inline bool CreateDatabaseRequest::_internal_has_encryption_config() const {
  return this != internal_default_instance() && _impl_.encryption_config_ != nullptr;
}
inline bool CreateDatabaseRequest::has_encryption_config() const {
  return _internal_has_encryption_config();
}
inline const ::google::spanner::admin::database::v1::EncryptionConfig& CreateDatabaseRequest::_internal_encryption_config() const {
  const ::google::spanner::admin::database::v1::EncryptionConfig* p = _impl_.encryption_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::database::v1::EncryptionConfig&>(
      ::google::spanner::admin::database::v1::_EncryptionConfig_default_instance_);
}
inline const ::google::spanner::admin::database::v1::EncryptionConfig& CreateDatabaseRequest::encryption_config() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.CreateDatabaseRequest.encryption_config)
  return _internal_encryption_config();
}
inline void CreateDatabaseRequest::unsafe_arena_set_allocated_encryption_config(
    ::google::spanner::admin::database::v1::EncryptionConfig* encryption_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encryption_config_);
  }
  _impl_.encryption_config_ = encryption_config;
  if (encryption_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.database.v1.CreateDatabaseRequest.encryption_config)
}
inline ::google::spanner::admin::database::v1::EncryptionConfig* CreateDatabaseRequest::release_encryption_config() {
  
  ::google::spanner::admin::database::v1::EncryptionConfig* temp = _impl_.encryption_config_;
  _impl_.encryption_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::database::v1::EncryptionConfig* CreateDatabaseRequest::unsafe_arena_release_encryption_config() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.CreateDatabaseRequest.encryption_config)
  
  ::google::spanner::admin::database::v1::EncryptionConfig* temp = _impl_.encryption_config_;
  _impl_.encryption_config_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::database::v1::EncryptionConfig* CreateDatabaseRequest::_internal_mutable_encryption_config() {
  
  if (_impl_.encryption_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::database::v1::EncryptionConfig>(GetArenaForAllocation());
    _impl_.encryption_config_ = p;
  }
  return _impl_.encryption_config_;
}
inline ::google::spanner::admin::database::v1::EncryptionConfig* CreateDatabaseRequest::mutable_encryption_config() {
  ::google::spanner::admin::database::v1::EncryptionConfig* _msg = _internal_mutable_encryption_config();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.CreateDatabaseRequest.encryption_config)
  return _msg;
}
inline void CreateDatabaseRequest::set_allocated_encryption_config(::google::spanner::admin::database::v1::EncryptionConfig* encryption_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encryption_config_);
  }
  if (encryption_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encryption_config));
    if (message_arena != submessage_arena) {
      encryption_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encryption_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.encryption_config_ = encryption_config;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.CreateDatabaseRequest.encryption_config)
}

// .google.spanner.admin.database.v1.DatabaseDialect database_dialect = 5 [(.google.api.field_behavior) = OPTIONAL];
inline void CreateDatabaseRequest::clear_database_dialect() {
  _impl_.database_dialect_ = 0;
}
inline ::google::spanner::admin::database::v1::DatabaseDialect CreateDatabaseRequest::_internal_database_dialect() const {
  return static_cast< ::google::spanner::admin::database::v1::DatabaseDialect >(_impl_.database_dialect_);
}
inline ::google::spanner::admin::database::v1::DatabaseDialect CreateDatabaseRequest::database_dialect() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.CreateDatabaseRequest.database_dialect)
  return _internal_database_dialect();
}
inline void CreateDatabaseRequest::_internal_set_database_dialect(::google::spanner::admin::database::v1::DatabaseDialect value) {
  
  _impl_.database_dialect_ = value;
}
inline void CreateDatabaseRequest::set_database_dialect(::google::spanner::admin::database::v1::DatabaseDialect value) {
  _internal_set_database_dialect(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.CreateDatabaseRequest.database_dialect)
}

// -------------------------------------------------------------------

// CreateDatabaseMetadata

// string database = 1 [(.google.api.resource_reference) = {
inline void CreateDatabaseMetadata::clear_database() {
  _impl_.database_.ClearToEmpty();
}
inline const std::string& CreateDatabaseMetadata::database() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.CreateDatabaseMetadata.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDatabaseMetadata::set_database(ArgT0&& arg0, ArgT... args) {
 
 _impl_.database_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.CreateDatabaseMetadata.database)
}
inline std::string* CreateDatabaseMetadata::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.CreateDatabaseMetadata.database)
  return _s;
}
inline const std::string& CreateDatabaseMetadata::_internal_database() const {
  return _impl_.database_.Get();
}
inline void CreateDatabaseMetadata::_internal_set_database(const std::string& value) {
  
  _impl_.database_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateDatabaseMetadata::_internal_mutable_database() {
  
  return _impl_.database_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateDatabaseMetadata::release_database() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.CreateDatabaseMetadata.database)
  return _impl_.database_.Release();
}
inline void CreateDatabaseMetadata::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    
  } else {
    
  }
  _impl_.database_.SetAllocated(database, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.database_.IsDefault()) {
    _impl_.database_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.CreateDatabaseMetadata.database)
}

// -------------------------------------------------------------------

// GetDatabaseRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetDatabaseRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetDatabaseRequest::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.GetDatabaseRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDatabaseRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.GetDatabaseRequest.name)
}
inline std::string* GetDatabaseRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.GetDatabaseRequest.name)
  return _s;
}
inline const std::string& GetDatabaseRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetDatabaseRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDatabaseRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDatabaseRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.GetDatabaseRequest.name)
  return _impl_.name_.Release();
}
inline void GetDatabaseRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.GetDatabaseRequest.name)
}

// -------------------------------------------------------------------

// UpdateDatabaseDdlRequest

// string database = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void UpdateDatabaseDdlRequest::clear_database() {
  _impl_.database_.ClearToEmpty();
}
inline const std::string& UpdateDatabaseDdlRequest::database() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateDatabaseDdlRequest::set_database(ArgT0&& arg0, ArgT... args) {
 
 _impl_.database_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.database)
}
inline std::string* UpdateDatabaseDdlRequest::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.database)
  return _s;
}
inline const std::string& UpdateDatabaseDdlRequest::_internal_database() const {
  return _impl_.database_.Get();
}
inline void UpdateDatabaseDdlRequest::_internal_set_database(const std::string& value) {
  
  _impl_.database_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateDatabaseDdlRequest::_internal_mutable_database() {
  
  return _impl_.database_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateDatabaseDdlRequest::release_database() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.database)
  return _impl_.database_.Release();
}
inline void UpdateDatabaseDdlRequest::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    
  } else {
    
  }
  _impl_.database_.SetAllocated(database, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.database_.IsDefault()) {
    _impl_.database_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.database)
}

// repeated string statements = 2 [(.google.api.field_behavior) = REQUIRED];
inline int UpdateDatabaseDdlRequest::_internal_statements_size() const {
  return _impl_.statements_.size();
}
inline int UpdateDatabaseDdlRequest::statements_size() const {
  return _internal_statements_size();
}
inline void UpdateDatabaseDdlRequest::clear_statements() {
  _impl_.statements_.Clear();
}
inline std::string* UpdateDatabaseDdlRequest::add_statements() {
  std::string* _s = _internal_add_statements();
  // @@protoc_insertion_point(field_add_mutable:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.statements)
  return _s;
}
inline const std::string& UpdateDatabaseDdlRequest::_internal_statements(int index) const {
  return _impl_.statements_.Get(index);
}
inline const std::string& UpdateDatabaseDdlRequest::statements(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.statements)
  return _internal_statements(index);
}
inline std::string* UpdateDatabaseDdlRequest::mutable_statements(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.statements)
  return _impl_.statements_.Mutable(index);
}
inline void UpdateDatabaseDdlRequest::set_statements(int index, const std::string& value) {
  _impl_.statements_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.statements)
}
inline void UpdateDatabaseDdlRequest::set_statements(int index, std::string&& value) {
  _impl_.statements_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.statements)
}
inline void UpdateDatabaseDdlRequest::set_statements(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.statements_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.statements)
}
inline void UpdateDatabaseDdlRequest::set_statements(int index, const char* value, size_t size) {
  _impl_.statements_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.statements)
}
inline std::string* UpdateDatabaseDdlRequest::_internal_add_statements() {
  return _impl_.statements_.Add();
}
inline void UpdateDatabaseDdlRequest::add_statements(const std::string& value) {
  _impl_.statements_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.statements)
}
inline void UpdateDatabaseDdlRequest::add_statements(std::string&& value) {
  _impl_.statements_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.statements)
}
inline void UpdateDatabaseDdlRequest::add_statements(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.statements_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.statements)
}
inline void UpdateDatabaseDdlRequest::add_statements(const char* value, size_t size) {
  _impl_.statements_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.statements)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdateDatabaseDdlRequest::statements() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.statements)
  return _impl_.statements_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdateDatabaseDdlRequest::mutable_statements() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.statements)
  return &_impl_.statements_;
}

// string operation_id = 3;
inline void UpdateDatabaseDdlRequest::clear_operation_id() {
  _impl_.operation_id_.ClearToEmpty();
}
inline const std::string& UpdateDatabaseDdlRequest::operation_id() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.operation_id)
  return _internal_operation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateDatabaseDdlRequest::set_operation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.operation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.operation_id)
}
inline std::string* UpdateDatabaseDdlRequest::mutable_operation_id() {
  std::string* _s = _internal_mutable_operation_id();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.operation_id)
  return _s;
}
inline const std::string& UpdateDatabaseDdlRequest::_internal_operation_id() const {
  return _impl_.operation_id_.Get();
}
inline void UpdateDatabaseDdlRequest::_internal_set_operation_id(const std::string& value) {
  
  _impl_.operation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateDatabaseDdlRequest::_internal_mutable_operation_id() {
  
  return _impl_.operation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateDatabaseDdlRequest::release_operation_id() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.operation_id)
  return _impl_.operation_id_.Release();
}
inline void UpdateDatabaseDdlRequest::set_allocated_operation_id(std::string* operation_id) {
  if (operation_id != nullptr) {
    
  } else {
    
  }
  _impl_.operation_id_.SetAllocated(operation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.operation_id_.IsDefault()) {
    _impl_.operation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.operation_id)
}

// -------------------------------------------------------------------

// UpdateDatabaseDdlMetadata

// string database = 1 [(.google.api.resource_reference) = {
inline void UpdateDatabaseDdlMetadata::clear_database() {
  _impl_.database_.ClearToEmpty();
}
inline const std::string& UpdateDatabaseDdlMetadata::database() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateDatabaseDdlMetadata::set_database(ArgT0&& arg0, ArgT... args) {
 
 _impl_.database_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.database)
}
inline std::string* UpdateDatabaseDdlMetadata::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.database)
  return _s;
}
inline const std::string& UpdateDatabaseDdlMetadata::_internal_database() const {
  return _impl_.database_.Get();
}
inline void UpdateDatabaseDdlMetadata::_internal_set_database(const std::string& value) {
  
  _impl_.database_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateDatabaseDdlMetadata::_internal_mutable_database() {
  
  return _impl_.database_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateDatabaseDdlMetadata::release_database() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.database)
  return _impl_.database_.Release();
}
inline void UpdateDatabaseDdlMetadata::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    
  } else {
    
  }
  _impl_.database_.SetAllocated(database, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.database_.IsDefault()) {
    _impl_.database_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.database)
}

// repeated string statements = 2;
inline int UpdateDatabaseDdlMetadata::_internal_statements_size() const {
  return _impl_.statements_.size();
}
inline int UpdateDatabaseDdlMetadata::statements_size() const {
  return _internal_statements_size();
}
inline void UpdateDatabaseDdlMetadata::clear_statements() {
  _impl_.statements_.Clear();
}
inline std::string* UpdateDatabaseDdlMetadata::add_statements() {
  std::string* _s = _internal_add_statements();
  // @@protoc_insertion_point(field_add_mutable:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.statements)
  return _s;
}
inline const std::string& UpdateDatabaseDdlMetadata::_internal_statements(int index) const {
  return _impl_.statements_.Get(index);
}
inline const std::string& UpdateDatabaseDdlMetadata::statements(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.statements)
  return _internal_statements(index);
}
inline std::string* UpdateDatabaseDdlMetadata::mutable_statements(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.statements)
  return _impl_.statements_.Mutable(index);
}
inline void UpdateDatabaseDdlMetadata::set_statements(int index, const std::string& value) {
  _impl_.statements_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.statements)
}
inline void UpdateDatabaseDdlMetadata::set_statements(int index, std::string&& value) {
  _impl_.statements_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.statements)
}
inline void UpdateDatabaseDdlMetadata::set_statements(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.statements_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.statements)
}
inline void UpdateDatabaseDdlMetadata::set_statements(int index, const char* value, size_t size) {
  _impl_.statements_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.statements)
}
inline std::string* UpdateDatabaseDdlMetadata::_internal_add_statements() {
  return _impl_.statements_.Add();
}
inline void UpdateDatabaseDdlMetadata::add_statements(const std::string& value) {
  _impl_.statements_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.statements)
}
inline void UpdateDatabaseDdlMetadata::add_statements(std::string&& value) {
  _impl_.statements_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.statements)
}
inline void UpdateDatabaseDdlMetadata::add_statements(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.statements_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.statements)
}
inline void UpdateDatabaseDdlMetadata::add_statements(const char* value, size_t size) {
  _impl_.statements_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.statements)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdateDatabaseDdlMetadata::statements() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.statements)
  return _impl_.statements_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdateDatabaseDdlMetadata::mutable_statements() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.statements)
  return &_impl_.statements_;
}

// repeated .google.protobuf.Timestamp commit_timestamps = 3;
inline int UpdateDatabaseDdlMetadata::_internal_commit_timestamps_size() const {
  return _impl_.commit_timestamps_.size();
}
inline int UpdateDatabaseDdlMetadata::commit_timestamps_size() const {
  return _internal_commit_timestamps_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateDatabaseDdlMetadata::mutable_commit_timestamps(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.commit_timestamps)
  return _impl_.commit_timestamps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Timestamp >*
UpdateDatabaseDdlMetadata::mutable_commit_timestamps() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.commit_timestamps)
  return &_impl_.commit_timestamps_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateDatabaseDdlMetadata::_internal_commit_timestamps(int index) const {
  return _impl_.commit_timestamps_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateDatabaseDdlMetadata::commit_timestamps(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.commit_timestamps)
  return _internal_commit_timestamps(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateDatabaseDdlMetadata::_internal_add_commit_timestamps() {
  return _impl_.commit_timestamps_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateDatabaseDdlMetadata::add_commit_timestamps() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _add = _internal_add_commit_timestamps();
  // @@protoc_insertion_point(field_add:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.commit_timestamps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Timestamp >&
UpdateDatabaseDdlMetadata::commit_timestamps() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.commit_timestamps)
  return _impl_.commit_timestamps_;
}

// bool throttled = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void UpdateDatabaseDdlMetadata::clear_throttled() {
  _impl_.throttled_ = false;
}
inline bool UpdateDatabaseDdlMetadata::_internal_throttled() const {
  return _impl_.throttled_;
}
inline bool UpdateDatabaseDdlMetadata::throttled() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.throttled)
  return _internal_throttled();
}
inline void UpdateDatabaseDdlMetadata::_internal_set_throttled(bool value) {
  
  _impl_.throttled_ = value;
}
inline void UpdateDatabaseDdlMetadata::set_throttled(bool value) {
  _internal_set_throttled(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.throttled)
}

// repeated .google.spanner.admin.database.v1.OperationProgress progress = 5;
inline int UpdateDatabaseDdlMetadata::_internal_progress_size() const {
  return _impl_.progress_.size();
}
inline int UpdateDatabaseDdlMetadata::progress_size() const {
  return _internal_progress_size();
}
inline ::google::spanner::admin::database::v1::OperationProgress* UpdateDatabaseDdlMetadata::mutable_progress(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.progress)
  return _impl_.progress_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::OperationProgress >*
UpdateDatabaseDdlMetadata::mutable_progress() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.progress)
  return &_impl_.progress_;
}
inline const ::google::spanner::admin::database::v1::OperationProgress& UpdateDatabaseDdlMetadata::_internal_progress(int index) const {
  return _impl_.progress_.Get(index);
}
inline const ::google::spanner::admin::database::v1::OperationProgress& UpdateDatabaseDdlMetadata::progress(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.progress)
  return _internal_progress(index);
}
inline ::google::spanner::admin::database::v1::OperationProgress* UpdateDatabaseDdlMetadata::_internal_add_progress() {
  return _impl_.progress_.Add();
}
inline ::google::spanner::admin::database::v1::OperationProgress* UpdateDatabaseDdlMetadata::add_progress() {
  ::google::spanner::admin::database::v1::OperationProgress* _add = _internal_add_progress();
  // @@protoc_insertion_point(field_add:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.progress)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::OperationProgress >&
UpdateDatabaseDdlMetadata::progress() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata.progress)
  return _impl_.progress_;
}

// -------------------------------------------------------------------

// DropDatabaseRequest

// string database = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DropDatabaseRequest::clear_database() {
  _impl_.database_.ClearToEmpty();
}
inline const std::string& DropDatabaseRequest::database() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.DropDatabaseRequest.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropDatabaseRequest::set_database(ArgT0&& arg0, ArgT... args) {
 
 _impl_.database_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.DropDatabaseRequest.database)
}
inline std::string* DropDatabaseRequest::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.DropDatabaseRequest.database)
  return _s;
}
inline const std::string& DropDatabaseRequest::_internal_database() const {
  return _impl_.database_.Get();
}
inline void DropDatabaseRequest::_internal_set_database(const std::string& value) {
  
  _impl_.database_.Set(value, GetArenaForAllocation());
}
inline std::string* DropDatabaseRequest::_internal_mutable_database() {
  
  return _impl_.database_.Mutable(GetArenaForAllocation());
}
inline std::string* DropDatabaseRequest::release_database() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.DropDatabaseRequest.database)
  return _impl_.database_.Release();
}
inline void DropDatabaseRequest::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    
  } else {
    
  }
  _impl_.database_.SetAllocated(database, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.database_.IsDefault()) {
    _impl_.database_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.DropDatabaseRequest.database)
}

// -------------------------------------------------------------------

// GetDatabaseDdlRequest

// string database = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetDatabaseDdlRequest::clear_database() {
  _impl_.database_.ClearToEmpty();
}
inline const std::string& GetDatabaseDdlRequest::database() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.GetDatabaseDdlRequest.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDatabaseDdlRequest::set_database(ArgT0&& arg0, ArgT... args) {
 
 _impl_.database_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.GetDatabaseDdlRequest.database)
}
inline std::string* GetDatabaseDdlRequest::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.GetDatabaseDdlRequest.database)
  return _s;
}
inline const std::string& GetDatabaseDdlRequest::_internal_database() const {
  return _impl_.database_.Get();
}
inline void GetDatabaseDdlRequest::_internal_set_database(const std::string& value) {
  
  _impl_.database_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDatabaseDdlRequest::_internal_mutable_database() {
  
  return _impl_.database_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDatabaseDdlRequest::release_database() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.GetDatabaseDdlRequest.database)
  return _impl_.database_.Release();
}
inline void GetDatabaseDdlRequest::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    
  } else {
    
  }
  _impl_.database_.SetAllocated(database, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.database_.IsDefault()) {
    _impl_.database_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.GetDatabaseDdlRequest.database)
}

// -------------------------------------------------------------------

// GetDatabaseDdlResponse

// repeated string statements = 1;
inline int GetDatabaseDdlResponse::_internal_statements_size() const {
  return _impl_.statements_.size();
}
inline int GetDatabaseDdlResponse::statements_size() const {
  return _internal_statements_size();
}
inline void GetDatabaseDdlResponse::clear_statements() {
  _impl_.statements_.Clear();
}
inline std::string* GetDatabaseDdlResponse::add_statements() {
  std::string* _s = _internal_add_statements();
  // @@protoc_insertion_point(field_add_mutable:google.spanner.admin.database.v1.GetDatabaseDdlResponse.statements)
  return _s;
}
inline const std::string& GetDatabaseDdlResponse::_internal_statements(int index) const {
  return _impl_.statements_.Get(index);
}
inline const std::string& GetDatabaseDdlResponse::statements(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.GetDatabaseDdlResponse.statements)
  return _internal_statements(index);
}
inline std::string* GetDatabaseDdlResponse::mutable_statements(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.GetDatabaseDdlResponse.statements)
  return _impl_.statements_.Mutable(index);
}
inline void GetDatabaseDdlResponse::set_statements(int index, const std::string& value) {
  _impl_.statements_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.GetDatabaseDdlResponse.statements)
}
inline void GetDatabaseDdlResponse::set_statements(int index, std::string&& value) {
  _impl_.statements_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.GetDatabaseDdlResponse.statements)
}
inline void GetDatabaseDdlResponse::set_statements(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.statements_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.spanner.admin.database.v1.GetDatabaseDdlResponse.statements)
}
inline void GetDatabaseDdlResponse::set_statements(int index, const char* value, size_t size) {
  _impl_.statements_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.spanner.admin.database.v1.GetDatabaseDdlResponse.statements)
}
inline std::string* GetDatabaseDdlResponse::_internal_add_statements() {
  return _impl_.statements_.Add();
}
inline void GetDatabaseDdlResponse::add_statements(const std::string& value) {
  _impl_.statements_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.spanner.admin.database.v1.GetDatabaseDdlResponse.statements)
}
inline void GetDatabaseDdlResponse::add_statements(std::string&& value) {
  _impl_.statements_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.spanner.admin.database.v1.GetDatabaseDdlResponse.statements)
}
inline void GetDatabaseDdlResponse::add_statements(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.statements_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.spanner.admin.database.v1.GetDatabaseDdlResponse.statements)
}
inline void GetDatabaseDdlResponse::add_statements(const char* value, size_t size) {
  _impl_.statements_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.spanner.admin.database.v1.GetDatabaseDdlResponse.statements)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetDatabaseDdlResponse::statements() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.database.v1.GetDatabaseDdlResponse.statements)
  return _impl_.statements_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetDatabaseDdlResponse::mutable_statements() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.database.v1.GetDatabaseDdlResponse.statements)
  return &_impl_.statements_;
}

// -------------------------------------------------------------------

// ListDatabaseOperationsRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListDatabaseOperationsRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListDatabaseOperationsRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDatabaseOperationsRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.parent)
}
inline std::string* ListDatabaseOperationsRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.parent)
  return _s;
}
inline const std::string& ListDatabaseOperationsRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListDatabaseOperationsRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDatabaseOperationsRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDatabaseOperationsRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListDatabaseOperationsRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.parent)
}

// string filter = 2;
inline void ListDatabaseOperationsRequest::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& ListDatabaseOperationsRequest::filter() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDatabaseOperationsRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.filter)
}
inline std::string* ListDatabaseOperationsRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.filter)
  return _s;
}
inline const std::string& ListDatabaseOperationsRequest::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void ListDatabaseOperationsRequest::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDatabaseOperationsRequest::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDatabaseOperationsRequest::release_filter() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.filter)
  return _impl_.filter_.Release();
}
inline void ListDatabaseOperationsRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.filter)
}

// int32 page_size = 3;
inline void ListDatabaseOperationsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListDatabaseOperationsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListDatabaseOperationsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.page_size)
  return _internal_page_size();
}
inline void ListDatabaseOperationsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListDatabaseOperationsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.page_size)
}

// string page_token = 4;
inline void ListDatabaseOperationsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListDatabaseOperationsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDatabaseOperationsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.page_token)
}
inline std::string* ListDatabaseOperationsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.page_token)
  return _s;
}
inline const std::string& ListDatabaseOperationsRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListDatabaseOperationsRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDatabaseOperationsRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDatabaseOperationsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListDatabaseOperationsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.ListDatabaseOperationsRequest.page_token)
}

// -------------------------------------------------------------------

// ListDatabaseOperationsResponse

// repeated .google.longrunning.Operation operations = 1;
inline int ListDatabaseOperationsResponse::_internal_operations_size() const {
  return _impl_.operations_.size();
}
inline int ListDatabaseOperationsResponse::operations_size() const {
  return _internal_operations_size();
}
inline ::google::longrunning::Operation* ListDatabaseOperationsResponse::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.ListDatabaseOperationsResponse.operations)
  return _impl_.operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::longrunning::Operation >*
ListDatabaseOperationsResponse::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.database.v1.ListDatabaseOperationsResponse.operations)
  return &_impl_.operations_;
}
inline const ::google::longrunning::Operation& ListDatabaseOperationsResponse::_internal_operations(int index) const {
  return _impl_.operations_.Get(index);
}
inline const ::google::longrunning::Operation& ListDatabaseOperationsResponse::operations(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabaseOperationsResponse.operations)
  return _internal_operations(index);
}
inline ::google::longrunning::Operation* ListDatabaseOperationsResponse::_internal_add_operations() {
  return _impl_.operations_.Add();
}
inline ::google::longrunning::Operation* ListDatabaseOperationsResponse::add_operations() {
  ::google::longrunning::Operation* _add = _internal_add_operations();
  // @@protoc_insertion_point(field_add:google.spanner.admin.database.v1.ListDatabaseOperationsResponse.operations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::longrunning::Operation >&
ListDatabaseOperationsResponse::operations() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.database.v1.ListDatabaseOperationsResponse.operations)
  return _impl_.operations_;
}

// string next_page_token = 2;
inline void ListDatabaseOperationsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListDatabaseOperationsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabaseOperationsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDatabaseOperationsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.ListDatabaseOperationsResponse.next_page_token)
}
inline std::string* ListDatabaseOperationsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.ListDatabaseOperationsResponse.next_page_token)
  return _s;
}
inline const std::string& ListDatabaseOperationsResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListDatabaseOperationsResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDatabaseOperationsResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDatabaseOperationsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.ListDatabaseOperationsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListDatabaseOperationsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.ListDatabaseOperationsResponse.next_page_token)
}

// -------------------------------------------------------------------

// RestoreDatabaseRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void RestoreDatabaseRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& RestoreDatabaseRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.RestoreDatabaseRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RestoreDatabaseRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.RestoreDatabaseRequest.parent)
}
inline std::string* RestoreDatabaseRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.RestoreDatabaseRequest.parent)
  return _s;
}
inline const std::string& RestoreDatabaseRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void RestoreDatabaseRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* RestoreDatabaseRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* RestoreDatabaseRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.RestoreDatabaseRequest.parent)
  return _impl_.parent_.Release();
}
inline void RestoreDatabaseRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.RestoreDatabaseRequest.parent)
}

// string database_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void RestoreDatabaseRequest::clear_database_id() {
  _impl_.database_id_.ClearToEmpty();
}
inline const std::string& RestoreDatabaseRequest::database_id() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.RestoreDatabaseRequest.database_id)
  return _internal_database_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RestoreDatabaseRequest::set_database_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.database_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.RestoreDatabaseRequest.database_id)
}
inline std::string* RestoreDatabaseRequest::mutable_database_id() {
  std::string* _s = _internal_mutable_database_id();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.RestoreDatabaseRequest.database_id)
  return _s;
}
inline const std::string& RestoreDatabaseRequest::_internal_database_id() const {
  return _impl_.database_id_.Get();
}
inline void RestoreDatabaseRequest::_internal_set_database_id(const std::string& value) {
  
  _impl_.database_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RestoreDatabaseRequest::_internal_mutable_database_id() {
  
  return _impl_.database_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RestoreDatabaseRequest::release_database_id() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.RestoreDatabaseRequest.database_id)
  return _impl_.database_id_.Release();
}
inline void RestoreDatabaseRequest::set_allocated_database_id(std::string* database_id) {
  if (database_id != nullptr) {
    
  } else {
    
  }
  _impl_.database_id_.SetAllocated(database_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.database_id_.IsDefault()) {
    _impl_.database_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.RestoreDatabaseRequest.database_id)
}

// string backup = 3 [(.google.api.resource_reference) = {
inline bool RestoreDatabaseRequest::_internal_has_backup() const {
  return source_case() == kBackup;
}
inline bool RestoreDatabaseRequest::has_backup() const {
  return _internal_has_backup();
}
inline void RestoreDatabaseRequest::set_has_backup() {
  _impl_._oneof_case_[0] = kBackup;
}
inline void RestoreDatabaseRequest::clear_backup() {
  if (_internal_has_backup()) {
    _impl_.source_.backup_.Destroy();
    clear_has_source();
  }
}
inline const std::string& RestoreDatabaseRequest::backup() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.RestoreDatabaseRequest.backup)
  return _internal_backup();
}
template <typename ArgT0, typename... ArgT>
inline void RestoreDatabaseRequest::set_backup(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_backup()) {
    clear_source();
    set_has_backup();
    _impl_.source_.backup_.InitDefault();
  }
  _impl_.source_.backup_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.RestoreDatabaseRequest.backup)
}
inline std::string* RestoreDatabaseRequest::mutable_backup() {
  std::string* _s = _internal_mutable_backup();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.RestoreDatabaseRequest.backup)
  return _s;
}
inline const std::string& RestoreDatabaseRequest::_internal_backup() const {
  if (_internal_has_backup()) {
    return _impl_.source_.backup_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RestoreDatabaseRequest::_internal_set_backup(const std::string& value) {
  if (!_internal_has_backup()) {
    clear_source();
    set_has_backup();
    _impl_.source_.backup_.InitDefault();
  }
  _impl_.source_.backup_.Set(value, GetArenaForAllocation());
}
inline std::string* RestoreDatabaseRequest::_internal_mutable_backup() {
  if (!_internal_has_backup()) {
    clear_source();
    set_has_backup();
    _impl_.source_.backup_.InitDefault();
  }
  return _impl_.source_.backup_.Mutable(      GetArenaForAllocation());
}
inline std::string* RestoreDatabaseRequest::release_backup() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.RestoreDatabaseRequest.backup)
  if (_internal_has_backup()) {
    clear_has_source();
    return _impl_.source_.backup_.Release();
  } else {
    return nullptr;
  }
}
inline void RestoreDatabaseRequest::set_allocated_backup(std::string* backup) {
  if (has_source()) {
    clear_source();
  }
  if (backup != nullptr) {
    set_has_backup();
    _impl_.source_.backup_.InitAllocated(backup, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.RestoreDatabaseRequest.backup)
}

// .google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig encryption_config = 4 [(.google.api.field_behavior) = OPTIONAL];
inline bool RestoreDatabaseRequest::_internal_has_encryption_config() const {
  return this != internal_default_instance() && _impl_.encryption_config_ != nullptr;
}
inline bool RestoreDatabaseRequest::has_encryption_config() const {
  return _internal_has_encryption_config();
}
inline void RestoreDatabaseRequest::clear_encryption_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.encryption_config_ != nullptr) {
    delete _impl_.encryption_config_;
  }
  _impl_.encryption_config_ = nullptr;
}
inline const ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig& RestoreDatabaseRequest::_internal_encryption_config() const {
  const ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* p = _impl_.encryption_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig&>(
      ::google::spanner::admin::database::v1::_RestoreDatabaseEncryptionConfig_default_instance_);
}
inline const ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig& RestoreDatabaseRequest::encryption_config() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.RestoreDatabaseRequest.encryption_config)
  return _internal_encryption_config();
}
inline void RestoreDatabaseRequest::unsafe_arena_set_allocated_encryption_config(
    ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* encryption_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encryption_config_);
  }
  _impl_.encryption_config_ = encryption_config;
  if (encryption_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.database.v1.RestoreDatabaseRequest.encryption_config)
}
inline ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* RestoreDatabaseRequest::release_encryption_config() {
  
  ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* temp = _impl_.encryption_config_;
  _impl_.encryption_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* RestoreDatabaseRequest::unsafe_arena_release_encryption_config() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.RestoreDatabaseRequest.encryption_config)
  
  ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* temp = _impl_.encryption_config_;
  _impl_.encryption_config_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* RestoreDatabaseRequest::_internal_mutable_encryption_config() {
  
  if (_impl_.encryption_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig>(GetArenaForAllocation());
    _impl_.encryption_config_ = p;
  }
  return _impl_.encryption_config_;
}
inline ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* RestoreDatabaseRequest::mutable_encryption_config() {
  ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* _msg = _internal_mutable_encryption_config();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.RestoreDatabaseRequest.encryption_config)
  return _msg;
}
inline void RestoreDatabaseRequest::set_allocated_encryption_config(::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig* encryption_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.encryption_config_;
  }
  if (encryption_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(encryption_config);
    if (message_arena != submessage_arena) {
      encryption_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encryption_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.encryption_config_ = encryption_config;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.RestoreDatabaseRequest.encryption_config)
}

inline bool RestoreDatabaseRequest::has_source() const {
  return source_case() != SOURCE_NOT_SET;
}
inline void RestoreDatabaseRequest::clear_has_source() {
  _impl_._oneof_case_[0] = SOURCE_NOT_SET;
}
inline RestoreDatabaseRequest::SourceCase RestoreDatabaseRequest::source_case() const {
  return RestoreDatabaseRequest::SourceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RestoreDatabaseEncryptionConfig

// .google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig.EncryptionType encryption_type = 1 [(.google.api.field_behavior) = REQUIRED];
inline void RestoreDatabaseEncryptionConfig::clear_encryption_type() {
  _impl_.encryption_type_ = 0;
}
inline ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig_EncryptionType RestoreDatabaseEncryptionConfig::_internal_encryption_type() const {
  return static_cast< ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig_EncryptionType >(_impl_.encryption_type_);
}
inline ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig_EncryptionType RestoreDatabaseEncryptionConfig::encryption_type() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig.encryption_type)
  return _internal_encryption_type();
}
inline void RestoreDatabaseEncryptionConfig::_internal_set_encryption_type(::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig_EncryptionType value) {
  
  _impl_.encryption_type_ = value;
}
inline void RestoreDatabaseEncryptionConfig::set_encryption_type(::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig_EncryptionType value) {
  _internal_set_encryption_type(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig.encryption_type)
}

// string kms_key_name = 2 [(.google.api.field_behavior) = OPTIONAL, (.google.api.resource_reference) = {
inline void RestoreDatabaseEncryptionConfig::clear_kms_key_name() {
  _impl_.kms_key_name_.ClearToEmpty();
}
inline const std::string& RestoreDatabaseEncryptionConfig::kms_key_name() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig.kms_key_name)
  return _internal_kms_key_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RestoreDatabaseEncryptionConfig::set_kms_key_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.kms_key_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig.kms_key_name)
}
inline std::string* RestoreDatabaseEncryptionConfig::mutable_kms_key_name() {
  std::string* _s = _internal_mutable_kms_key_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig.kms_key_name)
  return _s;
}
inline const std::string& RestoreDatabaseEncryptionConfig::_internal_kms_key_name() const {
  return _impl_.kms_key_name_.Get();
}
inline void RestoreDatabaseEncryptionConfig::_internal_set_kms_key_name(const std::string& value) {
  
  _impl_.kms_key_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RestoreDatabaseEncryptionConfig::_internal_mutable_kms_key_name() {
  
  return _impl_.kms_key_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RestoreDatabaseEncryptionConfig::release_kms_key_name() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig.kms_key_name)
  return _impl_.kms_key_name_.Release();
}
inline void RestoreDatabaseEncryptionConfig::set_allocated_kms_key_name(std::string* kms_key_name) {
  if (kms_key_name != nullptr) {
    
  } else {
    
  }
  _impl_.kms_key_name_.SetAllocated(kms_key_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kms_key_name_.IsDefault()) {
    _impl_.kms_key_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig.kms_key_name)
}

// -------------------------------------------------------------------

// RestoreDatabaseMetadata

// string name = 1 [(.google.api.resource_reference) = {
inline void RestoreDatabaseMetadata::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RestoreDatabaseMetadata::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.RestoreDatabaseMetadata.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RestoreDatabaseMetadata::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.RestoreDatabaseMetadata.name)
}
inline std::string* RestoreDatabaseMetadata::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.RestoreDatabaseMetadata.name)
  return _s;
}
inline const std::string& RestoreDatabaseMetadata::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RestoreDatabaseMetadata::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RestoreDatabaseMetadata::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RestoreDatabaseMetadata::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.RestoreDatabaseMetadata.name)
  return _impl_.name_.Release();
}
inline void RestoreDatabaseMetadata::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.RestoreDatabaseMetadata.name)
}

// .google.spanner.admin.database.v1.RestoreSourceType source_type = 2;
inline void RestoreDatabaseMetadata::clear_source_type() {
  _impl_.source_type_ = 0;
}
inline ::google::spanner::admin::database::v1::RestoreSourceType RestoreDatabaseMetadata::_internal_source_type() const {
  return static_cast< ::google::spanner::admin::database::v1::RestoreSourceType >(_impl_.source_type_);
}
inline ::google::spanner::admin::database::v1::RestoreSourceType RestoreDatabaseMetadata::source_type() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.RestoreDatabaseMetadata.source_type)
  return _internal_source_type();
}
inline void RestoreDatabaseMetadata::_internal_set_source_type(::google::spanner::admin::database::v1::RestoreSourceType value) {
  
  _impl_.source_type_ = value;
}
inline void RestoreDatabaseMetadata::set_source_type(::google::spanner::admin::database::v1::RestoreSourceType value) {
  _internal_set_source_type(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.RestoreDatabaseMetadata.source_type)
}

// .google.spanner.admin.database.v1.BackupInfo backup_info = 3;
inline bool RestoreDatabaseMetadata::_internal_has_backup_info() const {
  return source_info_case() == kBackupInfo;
}
inline bool RestoreDatabaseMetadata::has_backup_info() const {
  return _internal_has_backup_info();
}
inline void RestoreDatabaseMetadata::set_has_backup_info() {
  _impl_._oneof_case_[0] = kBackupInfo;
}
inline ::google::spanner::admin::database::v1::BackupInfo* RestoreDatabaseMetadata::release_backup_info() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.RestoreDatabaseMetadata.backup_info)
  if (_internal_has_backup_info()) {
    clear_has_source_info();
    ::google::spanner::admin::database::v1::BackupInfo* temp = _impl_.source_info_.backup_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.source_info_.backup_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::spanner::admin::database::v1::BackupInfo& RestoreDatabaseMetadata::_internal_backup_info() const {
  return _internal_has_backup_info()
      ? *_impl_.source_info_.backup_info_
      : reinterpret_cast< ::google::spanner::admin::database::v1::BackupInfo&>(::google::spanner::admin::database::v1::_BackupInfo_default_instance_);
}
inline const ::google::spanner::admin::database::v1::BackupInfo& RestoreDatabaseMetadata::backup_info() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.RestoreDatabaseMetadata.backup_info)
  return _internal_backup_info();
}
inline ::google::spanner::admin::database::v1::BackupInfo* RestoreDatabaseMetadata::unsafe_arena_release_backup_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.spanner.admin.database.v1.RestoreDatabaseMetadata.backup_info)
  if (_internal_has_backup_info()) {
    clear_has_source_info();
    ::google::spanner::admin::database::v1::BackupInfo* temp = _impl_.source_info_.backup_info_;
    _impl_.source_info_.backup_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RestoreDatabaseMetadata::unsafe_arena_set_allocated_backup_info(::google::spanner::admin::database::v1::BackupInfo* backup_info) {
  clear_source_info();
  if (backup_info) {
    set_has_backup_info();
    _impl_.source_info_.backup_info_ = backup_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.database.v1.RestoreDatabaseMetadata.backup_info)
}
inline ::google::spanner::admin::database::v1::BackupInfo* RestoreDatabaseMetadata::_internal_mutable_backup_info() {
  if (!_internal_has_backup_info()) {
    clear_source_info();
    set_has_backup_info();
    _impl_.source_info_.backup_info_ = CreateMaybeMessage< ::google::spanner::admin::database::v1::BackupInfo >(GetArenaForAllocation());
  }
  return _impl_.source_info_.backup_info_;
}
inline ::google::spanner::admin::database::v1::BackupInfo* RestoreDatabaseMetadata::mutable_backup_info() {
  ::google::spanner::admin::database::v1::BackupInfo* _msg = _internal_mutable_backup_info();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.RestoreDatabaseMetadata.backup_info)
  return _msg;
}

// .google.spanner.admin.database.v1.OperationProgress progress = 4;
inline bool RestoreDatabaseMetadata::_internal_has_progress() const {
  return this != internal_default_instance() && _impl_.progress_ != nullptr;
}
inline bool RestoreDatabaseMetadata::has_progress() const {
  return _internal_has_progress();
}
inline const ::google::spanner::admin::database::v1::OperationProgress& RestoreDatabaseMetadata::_internal_progress() const {
  const ::google::spanner::admin::database::v1::OperationProgress* p = _impl_.progress_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::database::v1::OperationProgress&>(
      ::google::spanner::admin::database::v1::_OperationProgress_default_instance_);
}
inline const ::google::spanner::admin::database::v1::OperationProgress& RestoreDatabaseMetadata::progress() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.RestoreDatabaseMetadata.progress)
  return _internal_progress();
}
inline void RestoreDatabaseMetadata::unsafe_arena_set_allocated_progress(
    ::google::spanner::admin::database::v1::OperationProgress* progress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  _impl_.progress_ = progress;
  if (progress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.database.v1.RestoreDatabaseMetadata.progress)
}
inline ::google::spanner::admin::database::v1::OperationProgress* RestoreDatabaseMetadata::release_progress() {
  
  ::google::spanner::admin::database::v1::OperationProgress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::database::v1::OperationProgress* RestoreDatabaseMetadata::unsafe_arena_release_progress() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.RestoreDatabaseMetadata.progress)
  
  ::google::spanner::admin::database::v1::OperationProgress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::database::v1::OperationProgress* RestoreDatabaseMetadata::_internal_mutable_progress() {
  
  if (_impl_.progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::database::v1::OperationProgress>(GetArenaForAllocation());
    _impl_.progress_ = p;
  }
  return _impl_.progress_;
}
inline ::google::spanner::admin::database::v1::OperationProgress* RestoreDatabaseMetadata::mutable_progress() {
  ::google::spanner::admin::database::v1::OperationProgress* _msg = _internal_mutable_progress();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.RestoreDatabaseMetadata.progress)
  return _msg;
}
inline void RestoreDatabaseMetadata::set_allocated_progress(::google::spanner::admin::database::v1::OperationProgress* progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  if (progress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(progress));
    if (message_arena != submessage_arena) {
      progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, progress, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.progress_ = progress;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.RestoreDatabaseMetadata.progress)
}

// .google.protobuf.Timestamp cancel_time = 5;
inline bool RestoreDatabaseMetadata::_internal_has_cancel_time() const {
  return this != internal_default_instance() && _impl_.cancel_time_ != nullptr;
}
inline bool RestoreDatabaseMetadata::has_cancel_time() const {
  return _internal_has_cancel_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RestoreDatabaseMetadata::_internal_cancel_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.cancel_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RestoreDatabaseMetadata::cancel_time() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.RestoreDatabaseMetadata.cancel_time)
  return _internal_cancel_time();
}
inline void RestoreDatabaseMetadata::unsafe_arena_set_allocated_cancel_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cancel_time_);
  }
  _impl_.cancel_time_ = cancel_time;
  if (cancel_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.database.v1.RestoreDatabaseMetadata.cancel_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RestoreDatabaseMetadata::release_cancel_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.cancel_time_;
  _impl_.cancel_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RestoreDatabaseMetadata::unsafe_arena_release_cancel_time() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.RestoreDatabaseMetadata.cancel_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.cancel_time_;
  _impl_.cancel_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RestoreDatabaseMetadata::_internal_mutable_cancel_time() {
  
  if (_impl_.cancel_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.cancel_time_ = p;
  }
  return _impl_.cancel_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RestoreDatabaseMetadata::mutable_cancel_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_cancel_time();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.RestoreDatabaseMetadata.cancel_time)
  return _msg;
}
inline void RestoreDatabaseMetadata::set_allocated_cancel_time(::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cancel_time_);
  }
  if (cancel_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cancel_time));
    if (message_arena != submessage_arena) {
      cancel_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cancel_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cancel_time_ = cancel_time;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.RestoreDatabaseMetadata.cancel_time)
}

// string optimize_database_operation_name = 6;
inline void RestoreDatabaseMetadata::clear_optimize_database_operation_name() {
  _impl_.optimize_database_operation_name_.ClearToEmpty();
}
inline const std::string& RestoreDatabaseMetadata::optimize_database_operation_name() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.RestoreDatabaseMetadata.optimize_database_operation_name)
  return _internal_optimize_database_operation_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RestoreDatabaseMetadata::set_optimize_database_operation_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.optimize_database_operation_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.RestoreDatabaseMetadata.optimize_database_operation_name)
}
inline std::string* RestoreDatabaseMetadata::mutable_optimize_database_operation_name() {
  std::string* _s = _internal_mutable_optimize_database_operation_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.RestoreDatabaseMetadata.optimize_database_operation_name)
  return _s;
}
inline const std::string& RestoreDatabaseMetadata::_internal_optimize_database_operation_name() const {
  return _impl_.optimize_database_operation_name_.Get();
}
inline void RestoreDatabaseMetadata::_internal_set_optimize_database_operation_name(const std::string& value) {
  
  _impl_.optimize_database_operation_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RestoreDatabaseMetadata::_internal_mutable_optimize_database_operation_name() {
  
  return _impl_.optimize_database_operation_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RestoreDatabaseMetadata::release_optimize_database_operation_name() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.RestoreDatabaseMetadata.optimize_database_operation_name)
  return _impl_.optimize_database_operation_name_.Release();
}
inline void RestoreDatabaseMetadata::set_allocated_optimize_database_operation_name(std::string* optimize_database_operation_name) {
  if (optimize_database_operation_name != nullptr) {
    
  } else {
    
  }
  _impl_.optimize_database_operation_name_.SetAllocated(optimize_database_operation_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.optimize_database_operation_name_.IsDefault()) {
    _impl_.optimize_database_operation_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.RestoreDatabaseMetadata.optimize_database_operation_name)
}

inline bool RestoreDatabaseMetadata::has_source_info() const {
  return source_info_case() != SOURCE_INFO_NOT_SET;
}
inline void RestoreDatabaseMetadata::clear_has_source_info() {
  _impl_._oneof_case_[0] = SOURCE_INFO_NOT_SET;
}
inline RestoreDatabaseMetadata::SourceInfoCase RestoreDatabaseMetadata::source_info_case() const {
  return RestoreDatabaseMetadata::SourceInfoCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OptimizeRestoredDatabaseMetadata

// string name = 1 [(.google.api.resource_reference) = {
inline void OptimizeRestoredDatabaseMetadata::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& OptimizeRestoredDatabaseMetadata::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OptimizeRestoredDatabaseMetadata::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata.name)
}
inline std::string* OptimizeRestoredDatabaseMetadata::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata.name)
  return _s;
}
inline const std::string& OptimizeRestoredDatabaseMetadata::_internal_name() const {
  return _impl_.name_.Get();
}
inline void OptimizeRestoredDatabaseMetadata::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* OptimizeRestoredDatabaseMetadata::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* OptimizeRestoredDatabaseMetadata::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata.name)
  return _impl_.name_.Release();
}
inline void OptimizeRestoredDatabaseMetadata::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata.name)
}

// .google.spanner.admin.database.v1.OperationProgress progress = 2;
inline bool OptimizeRestoredDatabaseMetadata::_internal_has_progress() const {
  return this != internal_default_instance() && _impl_.progress_ != nullptr;
}
inline bool OptimizeRestoredDatabaseMetadata::has_progress() const {
  return _internal_has_progress();
}
inline const ::google::spanner::admin::database::v1::OperationProgress& OptimizeRestoredDatabaseMetadata::_internal_progress() const {
  const ::google::spanner::admin::database::v1::OperationProgress* p = _impl_.progress_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::database::v1::OperationProgress&>(
      ::google::spanner::admin::database::v1::_OperationProgress_default_instance_);
}
inline const ::google::spanner::admin::database::v1::OperationProgress& OptimizeRestoredDatabaseMetadata::progress() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata.progress)
  return _internal_progress();
}
inline void OptimizeRestoredDatabaseMetadata::unsafe_arena_set_allocated_progress(
    ::google::spanner::admin::database::v1::OperationProgress* progress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  _impl_.progress_ = progress;
  if (progress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata.progress)
}
inline ::google::spanner::admin::database::v1::OperationProgress* OptimizeRestoredDatabaseMetadata::release_progress() {
  
  ::google::spanner::admin::database::v1::OperationProgress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::database::v1::OperationProgress* OptimizeRestoredDatabaseMetadata::unsafe_arena_release_progress() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata.progress)
  
  ::google::spanner::admin::database::v1::OperationProgress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::database::v1::OperationProgress* OptimizeRestoredDatabaseMetadata::_internal_mutable_progress() {
  
  if (_impl_.progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::database::v1::OperationProgress>(GetArenaForAllocation());
    _impl_.progress_ = p;
  }
  return _impl_.progress_;
}
inline ::google::spanner::admin::database::v1::OperationProgress* OptimizeRestoredDatabaseMetadata::mutable_progress() {
  ::google::spanner::admin::database::v1::OperationProgress* _msg = _internal_mutable_progress();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata.progress)
  return _msg;
}
inline void OptimizeRestoredDatabaseMetadata::set_allocated_progress(::google::spanner::admin::database::v1::OperationProgress* progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  if (progress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(progress));
    if (message_arena != submessage_arena) {
      progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, progress, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.progress_ = progress;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata.progress)
}

// -------------------------------------------------------------------

// DatabaseRole

// string name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void DatabaseRole::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DatabaseRole::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.DatabaseRole.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatabaseRole::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.DatabaseRole.name)
}
inline std::string* DatabaseRole::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.DatabaseRole.name)
  return _s;
}
inline const std::string& DatabaseRole::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DatabaseRole::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DatabaseRole::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DatabaseRole::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.DatabaseRole.name)
  return _impl_.name_.Release();
}
inline void DatabaseRole::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.DatabaseRole.name)
}

// -------------------------------------------------------------------

// ListDatabaseRolesRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListDatabaseRolesRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListDatabaseRolesRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabaseRolesRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDatabaseRolesRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.ListDatabaseRolesRequest.parent)
}
inline std::string* ListDatabaseRolesRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.ListDatabaseRolesRequest.parent)
  return _s;
}
inline const std::string& ListDatabaseRolesRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListDatabaseRolesRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDatabaseRolesRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDatabaseRolesRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.ListDatabaseRolesRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListDatabaseRolesRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.ListDatabaseRolesRequest.parent)
}

// int32 page_size = 2;
inline void ListDatabaseRolesRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListDatabaseRolesRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListDatabaseRolesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabaseRolesRequest.page_size)
  return _internal_page_size();
}
inline void ListDatabaseRolesRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListDatabaseRolesRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.ListDatabaseRolesRequest.page_size)
}

// string page_token = 3;
inline void ListDatabaseRolesRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListDatabaseRolesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabaseRolesRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDatabaseRolesRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.ListDatabaseRolesRequest.page_token)
}
inline std::string* ListDatabaseRolesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.ListDatabaseRolesRequest.page_token)
  return _s;
}
inline const std::string& ListDatabaseRolesRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListDatabaseRolesRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDatabaseRolesRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDatabaseRolesRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.ListDatabaseRolesRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListDatabaseRolesRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.ListDatabaseRolesRequest.page_token)
}

// -------------------------------------------------------------------

// ListDatabaseRolesResponse

// repeated .google.spanner.admin.database.v1.DatabaseRole database_roles = 1;
inline int ListDatabaseRolesResponse::_internal_database_roles_size() const {
  return _impl_.database_roles_.size();
}
inline int ListDatabaseRolesResponse::database_roles_size() const {
  return _internal_database_roles_size();
}
inline void ListDatabaseRolesResponse::clear_database_roles() {
  _impl_.database_roles_.Clear();
}
inline ::google::spanner::admin::database::v1::DatabaseRole* ListDatabaseRolesResponse::mutable_database_roles(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.ListDatabaseRolesResponse.database_roles)
  return _impl_.database_roles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::DatabaseRole >*
ListDatabaseRolesResponse::mutable_database_roles() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.database.v1.ListDatabaseRolesResponse.database_roles)
  return &_impl_.database_roles_;
}
inline const ::google::spanner::admin::database::v1::DatabaseRole& ListDatabaseRolesResponse::_internal_database_roles(int index) const {
  return _impl_.database_roles_.Get(index);
}
inline const ::google::spanner::admin::database::v1::DatabaseRole& ListDatabaseRolesResponse::database_roles(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabaseRolesResponse.database_roles)
  return _internal_database_roles(index);
}
inline ::google::spanner::admin::database::v1::DatabaseRole* ListDatabaseRolesResponse::_internal_add_database_roles() {
  return _impl_.database_roles_.Add();
}
inline ::google::spanner::admin::database::v1::DatabaseRole* ListDatabaseRolesResponse::add_database_roles() {
  ::google::spanner::admin::database::v1::DatabaseRole* _add = _internal_add_database_roles();
  // @@protoc_insertion_point(field_add:google.spanner.admin.database.v1.ListDatabaseRolesResponse.database_roles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::database::v1::DatabaseRole >&
ListDatabaseRolesResponse::database_roles() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.database.v1.ListDatabaseRolesResponse.database_roles)
  return _impl_.database_roles_;
}

// string next_page_token = 2;
inline void ListDatabaseRolesResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListDatabaseRolesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.database.v1.ListDatabaseRolesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDatabaseRolesResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.database.v1.ListDatabaseRolesResponse.next_page_token)
}
inline std::string* ListDatabaseRolesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.database.v1.ListDatabaseRolesResponse.next_page_token)
  return _s;
}
inline const std::string& ListDatabaseRolesResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListDatabaseRolesResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDatabaseRolesResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDatabaseRolesResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.database.v1.ListDatabaseRolesResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListDatabaseRolesResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.database.v1.ListDatabaseRolesResponse.next_page_token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace database
}  // namespace admin
}  // namespace spanner
}  // namespace google

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::google::spanner::admin::database::v1::Database_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::spanner::admin::database::v1::Database_State>() {
  return ::google::spanner::admin::database::v1::Database_State_descriptor();
}
template <> struct is_proto_enum< ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig_EncryptionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig_EncryptionType>() {
  return ::google::spanner::admin::database::v1::RestoreDatabaseEncryptionConfig_EncryptionType_descriptor();
}
template <> struct is_proto_enum< ::google::spanner::admin::database::v1::RestoreSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::spanner::admin::database::v1::RestoreSourceType>() {
  return ::google::spanner::admin::database::v1::RestoreSourceType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_google_2fspanner_2fadmin_2fdatabase_2fv1_2fspanner_5fdatabase_5fadmin_2eproto
