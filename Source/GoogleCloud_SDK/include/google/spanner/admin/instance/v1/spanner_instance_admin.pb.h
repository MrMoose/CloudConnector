// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/spanner/admin/instance/v1/spanner_instance_admin.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/api/client.pb.h"
#include "google/api/field_behavior.pb.h"
#include "google/api/resource.pb.h"
#include "google/iam/v1/iam_policy.pb.h"
#include "google/iam/v1/policy.pb.h"
#include "google/longrunning/operations.pb.h"
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/field_mask.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "google/spanner/admin/instance/v1/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
namespace google {
namespace spanner {
namespace admin {
namespace instance {
namespace v1 {
class CreateInstanceConfigMetadata;
struct CreateInstanceConfigMetadataDefaultTypeInternal;
extern CreateInstanceConfigMetadataDefaultTypeInternal _CreateInstanceConfigMetadata_default_instance_;
class CreateInstanceConfigRequest;
struct CreateInstanceConfigRequestDefaultTypeInternal;
extern CreateInstanceConfigRequestDefaultTypeInternal _CreateInstanceConfigRequest_default_instance_;
class CreateInstanceMetadata;
struct CreateInstanceMetadataDefaultTypeInternal;
extern CreateInstanceMetadataDefaultTypeInternal _CreateInstanceMetadata_default_instance_;
class CreateInstanceRequest;
struct CreateInstanceRequestDefaultTypeInternal;
extern CreateInstanceRequestDefaultTypeInternal _CreateInstanceRequest_default_instance_;
class DeleteInstanceConfigRequest;
struct DeleteInstanceConfigRequestDefaultTypeInternal;
extern DeleteInstanceConfigRequestDefaultTypeInternal _DeleteInstanceConfigRequest_default_instance_;
class DeleteInstanceRequest;
struct DeleteInstanceRequestDefaultTypeInternal;
extern DeleteInstanceRequestDefaultTypeInternal _DeleteInstanceRequest_default_instance_;
class GetInstanceConfigRequest;
struct GetInstanceConfigRequestDefaultTypeInternal;
extern GetInstanceConfigRequestDefaultTypeInternal _GetInstanceConfigRequest_default_instance_;
class GetInstanceRequest;
struct GetInstanceRequestDefaultTypeInternal;
extern GetInstanceRequestDefaultTypeInternal _GetInstanceRequest_default_instance_;
class Instance;
struct InstanceDefaultTypeInternal;
extern InstanceDefaultTypeInternal _Instance_default_instance_;
class InstanceConfig;
struct InstanceConfigDefaultTypeInternal;
extern InstanceConfigDefaultTypeInternal _InstanceConfig_default_instance_;
class InstanceConfig_LabelsEntry_DoNotUse;
struct InstanceConfig_LabelsEntry_DoNotUseDefaultTypeInternal;
extern InstanceConfig_LabelsEntry_DoNotUseDefaultTypeInternal _InstanceConfig_LabelsEntry_DoNotUse_default_instance_;
class Instance_LabelsEntry_DoNotUse;
struct Instance_LabelsEntry_DoNotUseDefaultTypeInternal;
extern Instance_LabelsEntry_DoNotUseDefaultTypeInternal _Instance_LabelsEntry_DoNotUse_default_instance_;
class ListInstanceConfigOperationsRequest;
struct ListInstanceConfigOperationsRequestDefaultTypeInternal;
extern ListInstanceConfigOperationsRequestDefaultTypeInternal _ListInstanceConfigOperationsRequest_default_instance_;
class ListInstanceConfigOperationsResponse;
struct ListInstanceConfigOperationsResponseDefaultTypeInternal;
extern ListInstanceConfigOperationsResponseDefaultTypeInternal _ListInstanceConfigOperationsResponse_default_instance_;
class ListInstanceConfigsRequest;
struct ListInstanceConfigsRequestDefaultTypeInternal;
extern ListInstanceConfigsRequestDefaultTypeInternal _ListInstanceConfigsRequest_default_instance_;
class ListInstanceConfigsResponse;
struct ListInstanceConfigsResponseDefaultTypeInternal;
extern ListInstanceConfigsResponseDefaultTypeInternal _ListInstanceConfigsResponse_default_instance_;
class ListInstancesRequest;
struct ListInstancesRequestDefaultTypeInternal;
extern ListInstancesRequestDefaultTypeInternal _ListInstancesRequest_default_instance_;
class ListInstancesResponse;
struct ListInstancesResponseDefaultTypeInternal;
extern ListInstancesResponseDefaultTypeInternal _ListInstancesResponse_default_instance_;
class ReplicaInfo;
struct ReplicaInfoDefaultTypeInternal;
extern ReplicaInfoDefaultTypeInternal _ReplicaInfo_default_instance_;
class UpdateInstanceConfigMetadata;
struct UpdateInstanceConfigMetadataDefaultTypeInternal;
extern UpdateInstanceConfigMetadataDefaultTypeInternal _UpdateInstanceConfigMetadata_default_instance_;
class UpdateInstanceConfigRequest;
struct UpdateInstanceConfigRequestDefaultTypeInternal;
extern UpdateInstanceConfigRequestDefaultTypeInternal _UpdateInstanceConfigRequest_default_instance_;
class UpdateInstanceMetadata;
struct UpdateInstanceMetadataDefaultTypeInternal;
extern UpdateInstanceMetadataDefaultTypeInternal _UpdateInstanceMetadata_default_instance_;
class UpdateInstanceRequest;
struct UpdateInstanceRequestDefaultTypeInternal;
extern UpdateInstanceRequestDefaultTypeInternal _UpdateInstanceRequest_default_instance_;
}  // namespace v1
}  // namespace instance
}  // namespace admin
}  // namespace spanner
}  // namespace google
PROTOBUF_NAMESPACE_OPEN
template<> ::google::spanner::admin::instance::v1::CreateInstanceConfigMetadata* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::CreateInstanceConfigMetadata>(Arena*);
template<> ::google::spanner::admin::instance::v1::CreateInstanceConfigRequest* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::CreateInstanceConfigRequest>(Arena*);
template<> ::google::spanner::admin::instance::v1::CreateInstanceMetadata* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::CreateInstanceMetadata>(Arena*);
template<> ::google::spanner::admin::instance::v1::CreateInstanceRequest* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::CreateInstanceRequest>(Arena*);
template<> ::google::spanner::admin::instance::v1::DeleteInstanceConfigRequest* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::DeleteInstanceConfigRequest>(Arena*);
template<> ::google::spanner::admin::instance::v1::DeleteInstanceRequest* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::DeleteInstanceRequest>(Arena*);
template<> ::google::spanner::admin::instance::v1::GetInstanceConfigRequest* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::GetInstanceConfigRequest>(Arena*);
template<> ::google::spanner::admin::instance::v1::GetInstanceRequest* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::GetInstanceRequest>(Arena*);
template<> ::google::spanner::admin::instance::v1::Instance* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::Instance>(Arena*);
template<> ::google::spanner::admin::instance::v1::InstanceConfig* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::InstanceConfig>(Arena*);
template<> ::google::spanner::admin::instance::v1::InstanceConfig_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::InstanceConfig_LabelsEntry_DoNotUse>(Arena*);
template<> ::google::spanner::admin::instance::v1::Instance_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::Instance_LabelsEntry_DoNotUse>(Arena*);
template<> ::google::spanner::admin::instance::v1::ListInstanceConfigOperationsRequest* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::ListInstanceConfigOperationsRequest>(Arena*);
template<> ::google::spanner::admin::instance::v1::ListInstanceConfigOperationsResponse* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::ListInstanceConfigOperationsResponse>(Arena*);
template<> ::google::spanner::admin::instance::v1::ListInstanceConfigsRequest* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::ListInstanceConfigsRequest>(Arena*);
template<> ::google::spanner::admin::instance::v1::ListInstanceConfigsResponse* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::ListInstanceConfigsResponse>(Arena*);
template<> ::google::spanner::admin::instance::v1::ListInstancesRequest* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::ListInstancesRequest>(Arena*);
template<> ::google::spanner::admin::instance::v1::ListInstancesResponse* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::ListInstancesResponse>(Arena*);
template<> ::google::spanner::admin::instance::v1::ReplicaInfo* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::ReplicaInfo>(Arena*);
template<> ::google::spanner::admin::instance::v1::UpdateInstanceConfigMetadata* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::UpdateInstanceConfigMetadata>(Arena*);
template<> ::google::spanner::admin::instance::v1::UpdateInstanceConfigRequest* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::UpdateInstanceConfigRequest>(Arena*);
template<> ::google::spanner::admin::instance::v1::UpdateInstanceMetadata* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::UpdateInstanceMetadata>(Arena*);
template<> ::google::spanner::admin::instance::v1::UpdateInstanceRequest* Arena::CreateMaybeMessage<::google::spanner::admin::instance::v1::UpdateInstanceRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace google {
namespace spanner {
namespace admin {
namespace instance {
namespace v1 {

enum ReplicaInfo_ReplicaType : int {
  ReplicaInfo_ReplicaType_TYPE_UNSPECIFIED = 0,
  ReplicaInfo_ReplicaType_READ_WRITE = 1,
  ReplicaInfo_ReplicaType_READ_ONLY = 2,
  ReplicaInfo_ReplicaType_WITNESS = 3,
  ReplicaInfo_ReplicaType_ReplicaInfo_ReplicaType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ReplicaInfo_ReplicaType_ReplicaInfo_ReplicaType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ReplicaInfo_ReplicaType_IsValid(int value);
constexpr ReplicaInfo_ReplicaType ReplicaInfo_ReplicaType_ReplicaType_MIN = ReplicaInfo_ReplicaType_TYPE_UNSPECIFIED;
constexpr ReplicaInfo_ReplicaType ReplicaInfo_ReplicaType_ReplicaType_MAX = ReplicaInfo_ReplicaType_WITNESS;
constexpr int ReplicaInfo_ReplicaType_ReplicaType_ARRAYSIZE = ReplicaInfo_ReplicaType_ReplicaType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReplicaInfo_ReplicaType_descriptor();
template<typename T>
inline const std::string& ReplicaInfo_ReplicaType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReplicaInfo_ReplicaType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReplicaInfo_ReplicaType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReplicaInfo_ReplicaType_descriptor(), enum_t_value);
}
inline bool ReplicaInfo_ReplicaType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReplicaInfo_ReplicaType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReplicaInfo_ReplicaType>(
    ReplicaInfo_ReplicaType_descriptor(), name, value);
}
enum InstanceConfig_Type : int {
  InstanceConfig_Type_TYPE_UNSPECIFIED = 0,
  InstanceConfig_Type_GOOGLE_MANAGED = 1,
  InstanceConfig_Type_USER_MANAGED = 2,
  InstanceConfig_Type_InstanceConfig_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  InstanceConfig_Type_InstanceConfig_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool InstanceConfig_Type_IsValid(int value);
constexpr InstanceConfig_Type InstanceConfig_Type_Type_MIN = InstanceConfig_Type_TYPE_UNSPECIFIED;
constexpr InstanceConfig_Type InstanceConfig_Type_Type_MAX = InstanceConfig_Type_USER_MANAGED;
constexpr int InstanceConfig_Type_Type_ARRAYSIZE = InstanceConfig_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InstanceConfig_Type_descriptor();
template<typename T>
inline const std::string& InstanceConfig_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InstanceConfig_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InstanceConfig_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InstanceConfig_Type_descriptor(), enum_t_value);
}
inline bool InstanceConfig_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InstanceConfig_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InstanceConfig_Type>(
    InstanceConfig_Type_descriptor(), name, value);
}
enum InstanceConfig_State : int {
  InstanceConfig_State_STATE_UNSPECIFIED = 0,
  InstanceConfig_State_CREATING = 1,
  InstanceConfig_State_READY = 2,
  InstanceConfig_State_InstanceConfig_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  InstanceConfig_State_InstanceConfig_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool InstanceConfig_State_IsValid(int value);
constexpr InstanceConfig_State InstanceConfig_State_State_MIN = InstanceConfig_State_STATE_UNSPECIFIED;
constexpr InstanceConfig_State InstanceConfig_State_State_MAX = InstanceConfig_State_READY;
constexpr int InstanceConfig_State_State_ARRAYSIZE = InstanceConfig_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InstanceConfig_State_descriptor();
template<typename T>
inline const std::string& InstanceConfig_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InstanceConfig_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InstanceConfig_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InstanceConfig_State_descriptor(), enum_t_value);
}
inline bool InstanceConfig_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InstanceConfig_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InstanceConfig_State>(
    InstanceConfig_State_descriptor(), name, value);
}
enum Instance_State : int {
  Instance_State_STATE_UNSPECIFIED = 0,
  Instance_State_CREATING = 1,
  Instance_State_READY = 2,
  Instance_State_Instance_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Instance_State_Instance_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Instance_State_IsValid(int value);
constexpr Instance_State Instance_State_State_MIN = Instance_State_STATE_UNSPECIFIED;
constexpr Instance_State Instance_State_State_MAX = Instance_State_READY;
constexpr int Instance_State_State_ARRAYSIZE = Instance_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Instance_State_descriptor();
template<typename T>
inline const std::string& Instance_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Instance_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Instance_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Instance_State_descriptor(), enum_t_value);
}
inline bool Instance_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Instance_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Instance_State>(
    Instance_State_descriptor(), name, value);
}
// ===================================================================

class ReplicaInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.ReplicaInfo) */ {
 public:
  inline ReplicaInfo() : ReplicaInfo(nullptr) {}
  ~ReplicaInfo() override;
  explicit PROTOBUF_CONSTEXPR ReplicaInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplicaInfo(const ReplicaInfo& from);
  ReplicaInfo(ReplicaInfo&& from) noexcept
    : ReplicaInfo() {
    *this = ::std::move(from);
  }

  inline ReplicaInfo& operator=(const ReplicaInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicaInfo& operator=(ReplicaInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplicaInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplicaInfo* internal_default_instance() {
    return reinterpret_cast<const ReplicaInfo*>(
               &_ReplicaInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ReplicaInfo& a, ReplicaInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplicaInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplicaInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplicaInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplicaInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplicaInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReplicaInfo& from) {
    ReplicaInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplicaInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.ReplicaInfo";
  }
  protected:
  explicit ReplicaInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ReplicaInfo_ReplicaType ReplicaType;
  static constexpr ReplicaType TYPE_UNSPECIFIED =
    ReplicaInfo_ReplicaType_TYPE_UNSPECIFIED;
  static constexpr ReplicaType READ_WRITE =
    ReplicaInfo_ReplicaType_READ_WRITE;
  static constexpr ReplicaType READ_ONLY =
    ReplicaInfo_ReplicaType_READ_ONLY;
  static constexpr ReplicaType WITNESS =
    ReplicaInfo_ReplicaType_WITNESS;
  static inline bool ReplicaType_IsValid(int value) {
    return ReplicaInfo_ReplicaType_IsValid(value);
  }
  static constexpr ReplicaType ReplicaType_MIN =
    ReplicaInfo_ReplicaType_ReplicaType_MIN;
  static constexpr ReplicaType ReplicaType_MAX =
    ReplicaInfo_ReplicaType_ReplicaType_MAX;
  static constexpr int ReplicaType_ARRAYSIZE =
    ReplicaInfo_ReplicaType_ReplicaType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ReplicaType_descriptor() {
    return ReplicaInfo_ReplicaType_descriptor();
  }
  template<typename T>
  static inline const std::string& ReplicaType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ReplicaType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ReplicaType_Name.");
    return ReplicaInfo_ReplicaType_Name(enum_t_value);
  }
  static inline bool ReplicaType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ReplicaType* value) {
    return ReplicaInfo_ReplicaType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kTypeFieldNumber = 2,
    kDefaultLeaderLocationFieldNumber = 3,
  };
  // string location = 1;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // .google.spanner.admin.instance.v1.ReplicaInfo.ReplicaType type = 2;
  void clear_type();
  ::google::spanner::admin::instance::v1::ReplicaInfo_ReplicaType type() const;
  void set_type(::google::spanner::admin::instance::v1::ReplicaInfo_ReplicaType value);
  private:
  ::google::spanner::admin::instance::v1::ReplicaInfo_ReplicaType _internal_type() const;
  void _internal_set_type(::google::spanner::admin::instance::v1::ReplicaInfo_ReplicaType value);
  public:

  // bool default_leader_location = 3;
  void clear_default_leader_location();
  bool default_leader_location() const;
  void set_default_leader_location(bool value);
  private:
  bool _internal_default_leader_location() const;
  void _internal_set_default_leader_location(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.ReplicaInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    int type_;
    bool default_leader_location_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class InstanceConfig_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InstanceConfig_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InstanceConfig_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  InstanceConfig_LabelsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR InstanceConfig_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InstanceConfig_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InstanceConfig_LabelsEntry_DoNotUse& other);
  static const InstanceConfig_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InstanceConfig_LabelsEntry_DoNotUse*>(&_InstanceConfig_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.spanner.admin.instance.v1.InstanceConfig.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.spanner.admin.instance.v1.InstanceConfig.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};

// -------------------------------------------------------------------

class InstanceConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.InstanceConfig) */ {
 public:
  inline InstanceConfig() : InstanceConfig(nullptr) {}
  ~InstanceConfig() override;
  explicit PROTOBUF_CONSTEXPR InstanceConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstanceConfig(const InstanceConfig& from);
  InstanceConfig(InstanceConfig&& from) noexcept
    : InstanceConfig() {
    *this = ::std::move(from);
  }

  inline InstanceConfig& operator=(const InstanceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstanceConfig& operator=(InstanceConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstanceConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstanceConfig* internal_default_instance() {
    return reinterpret_cast<const InstanceConfig*>(
               &_InstanceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InstanceConfig& a, InstanceConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(InstanceConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstanceConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstanceConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstanceConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstanceConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstanceConfig& from) {
    InstanceConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstanceConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.InstanceConfig";
  }
  protected:
  explicit InstanceConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef InstanceConfig_Type Type;
  static constexpr Type TYPE_UNSPECIFIED =
    InstanceConfig_Type_TYPE_UNSPECIFIED;
  static constexpr Type GOOGLE_MANAGED =
    InstanceConfig_Type_GOOGLE_MANAGED;
  static constexpr Type USER_MANAGED =
    InstanceConfig_Type_USER_MANAGED;
  static inline bool Type_IsValid(int value) {
    return InstanceConfig_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    InstanceConfig_Type_Type_MIN;
  static constexpr Type Type_MAX =
    InstanceConfig_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    InstanceConfig_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return InstanceConfig_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return InstanceConfig_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return InstanceConfig_Type_Parse(name, value);
  }

  typedef InstanceConfig_State State;
  static constexpr State STATE_UNSPECIFIED =
    InstanceConfig_State_STATE_UNSPECIFIED;
  static constexpr State CREATING =
    InstanceConfig_State_CREATING;
  static constexpr State READY =
    InstanceConfig_State_READY;
  static inline bool State_IsValid(int value) {
    return InstanceConfig_State_IsValid(value);
  }
  static constexpr State State_MIN =
    InstanceConfig_State_State_MIN;
  static constexpr State State_MAX =
    InstanceConfig_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    InstanceConfig_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return InstanceConfig_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return InstanceConfig_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return InstanceConfig_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReplicasFieldNumber = 3,
    kLeaderOptionsFieldNumber = 4,
    kOptionalReplicasFieldNumber = 6,
    kLabelsFieldNumber = 8,
    kNameFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kBaseConfigFieldNumber = 7,
    kEtagFieldNumber = 9,
    kConfigTypeFieldNumber = 5,
    kReconcilingFieldNumber = 10,
    kStateFieldNumber = 11,
  };
  // repeated .google.spanner.admin.instance.v1.ReplicaInfo replicas = 3;
  int replicas_size() const;
  private:
  int _internal_replicas_size() const;
  public:
  void clear_replicas();
  ::google::spanner::admin::instance::v1::ReplicaInfo* mutable_replicas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::ReplicaInfo >*
      mutable_replicas();
  private:
  const ::google::spanner::admin::instance::v1::ReplicaInfo& _internal_replicas(int index) const;
  ::google::spanner::admin::instance::v1::ReplicaInfo* _internal_add_replicas();
  public:
  const ::google::spanner::admin::instance::v1::ReplicaInfo& replicas(int index) const;
  ::google::spanner::admin::instance::v1::ReplicaInfo* add_replicas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::ReplicaInfo >&
      replicas() const;

  // repeated string leader_options = 4;
  int leader_options_size() const;
  private:
  int _internal_leader_options_size() const;
  public:
  void clear_leader_options();
  const std::string& leader_options(int index) const;
  std::string* mutable_leader_options(int index);
  void set_leader_options(int index, const std::string& value);
  void set_leader_options(int index, std::string&& value);
  void set_leader_options(int index, const char* value);
  void set_leader_options(int index, const char* value, size_t size);
  std::string* add_leader_options();
  void add_leader_options(const std::string& value);
  void add_leader_options(std::string&& value);
  void add_leader_options(const char* value);
  void add_leader_options(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& leader_options() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_leader_options();
  private:
  const std::string& _internal_leader_options(int index) const;
  std::string* _internal_add_leader_options();
  public:

  // repeated .google.spanner.admin.instance.v1.ReplicaInfo optional_replicas = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
  int optional_replicas_size() const;
  private:
  int _internal_optional_replicas_size() const;
  public:
  void clear_optional_replicas();
  ::google::spanner::admin::instance::v1::ReplicaInfo* mutable_optional_replicas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::ReplicaInfo >*
      mutable_optional_replicas();
  private:
  const ::google::spanner::admin::instance::v1::ReplicaInfo& _internal_optional_replicas(int index) const;
  ::google::spanner::admin::instance::v1::ReplicaInfo* _internal_add_optional_replicas();
  public:
  const ::google::spanner::admin::instance::v1::ReplicaInfo& optional_replicas(int index) const;
  ::google::spanner::admin::instance::v1::ReplicaInfo* add_optional_replicas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::ReplicaInfo >&
      optional_replicas() const;

  // map<string, string> labels = 8;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string display_name = 2;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // string base_config = 7 [(.google.api.resource_reference) = {
  void clear_base_config();
  const std::string& base_config() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_config(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_config();
  PROTOBUF_NODISCARD std::string* release_base_config();
  void set_allocated_base_config(std::string* base_config);
  private:
  const std::string& _internal_base_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_config(const std::string& value);
  std::string* _internal_mutable_base_config();
  public:

  // string etag = 9;
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // .google.spanner.admin.instance.v1.InstanceConfig.Type config_type = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_config_type();
  ::google::spanner::admin::instance::v1::InstanceConfig_Type config_type() const;
  void set_config_type(::google::spanner::admin::instance::v1::InstanceConfig_Type value);
  private:
  ::google::spanner::admin::instance::v1::InstanceConfig_Type _internal_config_type() const;
  void _internal_set_config_type(::google::spanner::admin::instance::v1::InstanceConfig_Type value);
  public:

  // bool reconciling = 10 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_reconciling();
  bool reconciling() const;
  void set_reconciling(bool value);
  private:
  bool _internal_reconciling() const;
  void _internal_set_reconciling(bool value);
  public:

  // .google.spanner.admin.instance.v1.InstanceConfig.State state = 11 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_state();
  ::google::spanner::admin::instance::v1::InstanceConfig_State state() const;
  void set_state(::google::spanner::admin::instance::v1::InstanceConfig_State value);
  private:
  ::google::spanner::admin::instance::v1::InstanceConfig_State _internal_state() const;
  void _internal_set_state(::google::spanner::admin::instance::v1::InstanceConfig_State value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.InstanceConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::ReplicaInfo > replicas_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> leader_options_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::ReplicaInfo > optional_replicas_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        InstanceConfig_LabelsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
    int config_type_;
    bool reconciling_;
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class Instance_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Instance_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Instance_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Instance_LabelsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Instance_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Instance_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Instance_LabelsEntry_DoNotUse& other);
  static const Instance_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Instance_LabelsEntry_DoNotUse*>(&_Instance_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.spanner.admin.instance.v1.Instance.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.spanner.admin.instance.v1.Instance.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};

// -------------------------------------------------------------------

class Instance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.Instance) */ {
 public:
  inline Instance() : Instance(nullptr) {}
  ~Instance() override;
  explicit PROTOBUF_CONSTEXPR Instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Instance(const Instance& from);
  Instance(Instance&& from) noexcept
    : Instance() {
    *this = ::std::move(from);
  }

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instance& operator=(Instance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Instance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Instance* internal_default_instance() {
    return reinterpret_cast<const Instance*>(
               &_Instance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Instance& a, Instance& b) {
    a.Swap(&b);
  }
  inline void Swap(Instance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Instance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Instance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Instance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Instance& from) {
    Instance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.Instance";
  }
  protected:
  explicit Instance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef Instance_State State;
  static constexpr State STATE_UNSPECIFIED =
    Instance_State_STATE_UNSPECIFIED;
  static constexpr State CREATING =
    Instance_State_CREATING;
  static constexpr State READY =
    Instance_State_READY;
  static inline bool State_IsValid(int value) {
    return Instance_State_IsValid(value);
  }
  static constexpr State State_MIN =
    Instance_State_State_MIN;
  static constexpr State State_MAX =
    Instance_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    Instance_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return Instance_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return Instance_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return Instance_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 7,
    kEndpointUrisFieldNumber = 8,
    kNameFieldNumber = 1,
    kConfigFieldNumber = 2,
    kDisplayNameFieldNumber = 3,
    kCreateTimeFieldNumber = 11,
    kUpdateTimeFieldNumber = 12,
    kNodeCountFieldNumber = 5,
    kStateFieldNumber = 6,
    kProcessingUnitsFieldNumber = 9,
  };
  // map<string, string> labels = 7;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // repeated string endpoint_uris = 8;
  int endpoint_uris_size() const;
  private:
  int _internal_endpoint_uris_size() const;
  public:
  void clear_endpoint_uris();
  const std::string& endpoint_uris(int index) const;
  std::string* mutable_endpoint_uris(int index);
  void set_endpoint_uris(int index, const std::string& value);
  void set_endpoint_uris(int index, std::string&& value);
  void set_endpoint_uris(int index, const char* value);
  void set_endpoint_uris(int index, const char* value, size_t size);
  std::string* add_endpoint_uris();
  void add_endpoint_uris(const std::string& value);
  void add_endpoint_uris(std::string&& value);
  void add_endpoint_uris(const char* value);
  void add_endpoint_uris(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& endpoint_uris() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_endpoint_uris();
  private:
  const std::string& _internal_endpoint_uris(int index) const;
  std::string* _internal_add_endpoint_uris();
  public:

  // string name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string config = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_config();
  const std::string& config() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config();
  PROTOBUF_NODISCARD std::string* release_config();
  void set_allocated_config(std::string* config);
  private:
  const std::string& _internal_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config(const std::string& value);
  std::string* _internal_mutable_config();
  public:

  // string display_name = 3 [(.google.api.field_behavior) = REQUIRED];
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // .google.protobuf.Timestamp create_time = 11 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_time();
  void set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_time();
  public:
  void unsafe_arena_set_allocated_create_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_time();

  // .google.protobuf.Timestamp update_time = 12 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_update_time() const;
  private:
  bool _internal_has_update_time() const;
  public:
  void clear_update_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& update_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_update_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_update_time();
  void set_allocated_update_time(::PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_update_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_update_time();
  public:
  void unsafe_arena_set_allocated_update_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_update_time();

  // int32 node_count = 5;
  void clear_node_count();
  int32_t node_count() const;
  void set_node_count(int32_t value);
  private:
  int32_t _internal_node_count() const;
  void _internal_set_node_count(int32_t value);
  public:

  // .google.spanner.admin.instance.v1.Instance.State state = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_state();
  ::google::spanner::admin::instance::v1::Instance_State state() const;
  void set_state(::google::spanner::admin::instance::v1::Instance_State value);
  private:
  ::google::spanner::admin::instance::v1::Instance_State _internal_state() const;
  void _internal_set_state(::google::spanner::admin::instance::v1::Instance_State value);
  public:

  // int32 processing_units = 9;
  void clear_processing_units();
  int32_t processing_units() const;
  void set_processing_units(int32_t value);
  private:
  int32_t _internal_processing_units() const;
  void _internal_set_processing_units(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.Instance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Instance_LabelsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> endpoint_uris_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time_;
    int32_t node_count_;
    int state_;
    int32_t processing_units_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class ListInstanceConfigsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.ListInstanceConfigsRequest) */ {
 public:
  inline ListInstanceConfigsRequest() : ListInstanceConfigsRequest(nullptr) {}
  ~ListInstanceConfigsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListInstanceConfigsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListInstanceConfigsRequest(const ListInstanceConfigsRequest& from);
  ListInstanceConfigsRequest(ListInstanceConfigsRequest&& from) noexcept
    : ListInstanceConfigsRequest() {
    *this = ::std::move(from);
  }

  inline ListInstanceConfigsRequest& operator=(const ListInstanceConfigsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListInstanceConfigsRequest& operator=(ListInstanceConfigsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListInstanceConfigsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListInstanceConfigsRequest* internal_default_instance() {
    return reinterpret_cast<const ListInstanceConfigsRequest*>(
               &_ListInstanceConfigsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListInstanceConfigsRequest& a, ListInstanceConfigsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListInstanceConfigsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListInstanceConfigsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListInstanceConfigsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListInstanceConfigsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListInstanceConfigsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListInstanceConfigsRequest& from) {
    ListInstanceConfigsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListInstanceConfigsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.ListInstanceConfigsRequest";
  }
  protected:
  explicit ListInstanceConfigsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 3;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.ListInstanceConfigsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class ListInstanceConfigsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.ListInstanceConfigsResponse) */ {
 public:
  inline ListInstanceConfigsResponse() : ListInstanceConfigsResponse(nullptr) {}
  ~ListInstanceConfigsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListInstanceConfigsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListInstanceConfigsResponse(const ListInstanceConfigsResponse& from);
  ListInstanceConfigsResponse(ListInstanceConfigsResponse&& from) noexcept
    : ListInstanceConfigsResponse() {
    *this = ::std::move(from);
  }

  inline ListInstanceConfigsResponse& operator=(const ListInstanceConfigsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListInstanceConfigsResponse& operator=(ListInstanceConfigsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListInstanceConfigsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListInstanceConfigsResponse* internal_default_instance() {
    return reinterpret_cast<const ListInstanceConfigsResponse*>(
               &_ListInstanceConfigsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListInstanceConfigsResponse& a, ListInstanceConfigsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListInstanceConfigsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListInstanceConfigsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListInstanceConfigsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListInstanceConfigsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListInstanceConfigsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListInstanceConfigsResponse& from) {
    ListInstanceConfigsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListInstanceConfigsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.ListInstanceConfigsResponse";
  }
  protected:
  explicit ListInstanceConfigsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceConfigsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.spanner.admin.instance.v1.InstanceConfig instance_configs = 1;
  int instance_configs_size() const;
  private:
  int _internal_instance_configs_size() const;
  public:
  void clear_instance_configs();
  ::google::spanner::admin::instance::v1::InstanceConfig* mutable_instance_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::InstanceConfig >*
      mutable_instance_configs();
  private:
  const ::google::spanner::admin::instance::v1::InstanceConfig& _internal_instance_configs(int index) const;
  ::google::spanner::admin::instance::v1::InstanceConfig* _internal_add_instance_configs();
  public:
  const ::google::spanner::admin::instance::v1::InstanceConfig& instance_configs(int index) const;
  ::google::spanner::admin::instance::v1::InstanceConfig* add_instance_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::InstanceConfig >&
      instance_configs() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.ListInstanceConfigsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::InstanceConfig > instance_configs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class GetInstanceConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.GetInstanceConfigRequest) */ {
 public:
  inline GetInstanceConfigRequest() : GetInstanceConfigRequest(nullptr) {}
  ~GetInstanceConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR GetInstanceConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetInstanceConfigRequest(const GetInstanceConfigRequest& from);
  GetInstanceConfigRequest(GetInstanceConfigRequest&& from) noexcept
    : GetInstanceConfigRequest() {
    *this = ::std::move(from);
  }

  inline GetInstanceConfigRequest& operator=(const GetInstanceConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInstanceConfigRequest& operator=(GetInstanceConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetInstanceConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetInstanceConfigRequest* internal_default_instance() {
    return reinterpret_cast<const GetInstanceConfigRequest*>(
               &_GetInstanceConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetInstanceConfigRequest& a, GetInstanceConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInstanceConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInstanceConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetInstanceConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetInstanceConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetInstanceConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetInstanceConfigRequest& from) {
    GetInstanceConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInstanceConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.GetInstanceConfigRequest";
  }
  protected:
  explicit GetInstanceConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.GetInstanceConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class CreateInstanceConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.CreateInstanceConfigRequest) */ {
 public:
  inline CreateInstanceConfigRequest() : CreateInstanceConfigRequest(nullptr) {}
  ~CreateInstanceConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateInstanceConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateInstanceConfigRequest(const CreateInstanceConfigRequest& from);
  CreateInstanceConfigRequest(CreateInstanceConfigRequest&& from) noexcept
    : CreateInstanceConfigRequest() {
    *this = ::std::move(from);
  }

  inline CreateInstanceConfigRequest& operator=(const CreateInstanceConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInstanceConfigRequest& operator=(CreateInstanceConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInstanceConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateInstanceConfigRequest* internal_default_instance() {
    return reinterpret_cast<const CreateInstanceConfigRequest*>(
               &_CreateInstanceConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CreateInstanceConfigRequest& a, CreateInstanceConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInstanceConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInstanceConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateInstanceConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateInstanceConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateInstanceConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateInstanceConfigRequest& from) {
    CreateInstanceConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateInstanceConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.CreateInstanceConfigRequest";
  }
  protected:
  explicit CreateInstanceConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kInstanceConfigIdFieldNumber = 2,
    kInstanceConfigFieldNumber = 3,
    kValidateOnlyFieldNumber = 4,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string instance_config_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_instance_config_id();
  const std::string& instance_config_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_config_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_config_id();
  PROTOBUF_NODISCARD std::string* release_instance_config_id();
  void set_allocated_instance_config_id(std::string* instance_config_id);
  private:
  const std::string& _internal_instance_config_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_config_id(const std::string& value);
  std::string* _internal_mutable_instance_config_id();
  public:

  // .google.spanner.admin.instance.v1.InstanceConfig instance_config = 3 [(.google.api.field_behavior) = REQUIRED];
  bool has_instance_config() const;
  private:
  bool _internal_has_instance_config() const;
  public:
  void clear_instance_config();
  const ::google::spanner::admin::instance::v1::InstanceConfig& instance_config() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::instance::v1::InstanceConfig* release_instance_config();
  ::google::spanner::admin::instance::v1::InstanceConfig* mutable_instance_config();
  void set_allocated_instance_config(::google::spanner::admin::instance::v1::InstanceConfig* instance_config);
  private:
  const ::google::spanner::admin::instance::v1::InstanceConfig& _internal_instance_config() const;
  ::google::spanner::admin::instance::v1::InstanceConfig* _internal_mutable_instance_config();
  public:
  void unsafe_arena_set_allocated_instance_config(
      ::google::spanner::admin::instance::v1::InstanceConfig* instance_config);
  ::google::spanner::admin::instance::v1::InstanceConfig* unsafe_arena_release_instance_config();

  // bool validate_only = 4;
  void clear_validate_only();
  bool validate_only() const;
  void set_validate_only(bool value);
  private:
  bool _internal_validate_only() const;
  void _internal_set_validate_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.CreateInstanceConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_config_id_;
    ::google::spanner::admin::instance::v1::InstanceConfig* instance_config_;
    bool validate_only_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class UpdateInstanceConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.UpdateInstanceConfigRequest) */ {
 public:
  inline UpdateInstanceConfigRequest() : UpdateInstanceConfigRequest(nullptr) {}
  ~UpdateInstanceConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateInstanceConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateInstanceConfigRequest(const UpdateInstanceConfigRequest& from);
  UpdateInstanceConfigRequest(UpdateInstanceConfigRequest&& from) noexcept
    : UpdateInstanceConfigRequest() {
    *this = ::std::move(from);
  }

  inline UpdateInstanceConfigRequest& operator=(const UpdateInstanceConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateInstanceConfigRequest& operator=(UpdateInstanceConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateInstanceConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateInstanceConfigRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateInstanceConfigRequest*>(
               &_UpdateInstanceConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UpdateInstanceConfigRequest& a, UpdateInstanceConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateInstanceConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateInstanceConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateInstanceConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateInstanceConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateInstanceConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateInstanceConfigRequest& from) {
    UpdateInstanceConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateInstanceConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.UpdateInstanceConfigRequest";
  }
  protected:
  explicit UpdateInstanceConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceConfigFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
    kValidateOnlyFieldNumber = 3,
  };
  // .google.spanner.admin.instance.v1.InstanceConfig instance_config = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_instance_config() const;
  private:
  bool _internal_has_instance_config() const;
  public:
  void clear_instance_config();
  const ::google::spanner::admin::instance::v1::InstanceConfig& instance_config() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::instance::v1::InstanceConfig* release_instance_config();
  ::google::spanner::admin::instance::v1::InstanceConfig* mutable_instance_config();
  void set_allocated_instance_config(::google::spanner::admin::instance::v1::InstanceConfig* instance_config);
  private:
  const ::google::spanner::admin::instance::v1::InstanceConfig& _internal_instance_config() const;
  ::google::spanner::admin::instance::v1::InstanceConfig* _internal_mutable_instance_config();
  public:
  void unsafe_arena_set_allocated_instance_config(
      ::google::spanner::admin::instance::v1::InstanceConfig* instance_config);
  ::google::spanner::admin::instance::v1::InstanceConfig* unsafe_arena_release_instance_config();

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // bool validate_only = 3;
  void clear_validate_only();
  bool validate_only() const;
  void set_validate_only(bool value);
  private:
  bool _internal_validate_only() const;
  void _internal_set_validate_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.UpdateInstanceConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::spanner::admin::instance::v1::InstanceConfig* instance_config_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    bool validate_only_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class DeleteInstanceConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.DeleteInstanceConfigRequest) */ {
 public:
  inline DeleteInstanceConfigRequest() : DeleteInstanceConfigRequest(nullptr) {}
  ~DeleteInstanceConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteInstanceConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteInstanceConfigRequest(const DeleteInstanceConfigRequest& from);
  DeleteInstanceConfigRequest(DeleteInstanceConfigRequest&& from) noexcept
    : DeleteInstanceConfigRequest() {
    *this = ::std::move(from);
  }

  inline DeleteInstanceConfigRequest& operator=(const DeleteInstanceConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteInstanceConfigRequest& operator=(DeleteInstanceConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteInstanceConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteInstanceConfigRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteInstanceConfigRequest*>(
               &_DeleteInstanceConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeleteInstanceConfigRequest& a, DeleteInstanceConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteInstanceConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteInstanceConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteInstanceConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteInstanceConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteInstanceConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteInstanceConfigRequest& from) {
    DeleteInstanceConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteInstanceConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.DeleteInstanceConfigRequest";
  }
  protected:
  explicit DeleteInstanceConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kEtagFieldNumber = 2,
    kValidateOnlyFieldNumber = 3,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string etag = 2;
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // bool validate_only = 3;
  void clear_validate_only();
  bool validate_only() const;
  void set_validate_only(bool value);
  private:
  bool _internal_validate_only() const;
  void _internal_set_validate_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.DeleteInstanceConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
    bool validate_only_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class ListInstanceConfigOperationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest) */ {
 public:
  inline ListInstanceConfigOperationsRequest() : ListInstanceConfigOperationsRequest(nullptr) {}
  ~ListInstanceConfigOperationsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListInstanceConfigOperationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListInstanceConfigOperationsRequest(const ListInstanceConfigOperationsRequest& from);
  ListInstanceConfigOperationsRequest(ListInstanceConfigOperationsRequest&& from) noexcept
    : ListInstanceConfigOperationsRequest() {
    *this = ::std::move(from);
  }

  inline ListInstanceConfigOperationsRequest& operator=(const ListInstanceConfigOperationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListInstanceConfigOperationsRequest& operator=(ListInstanceConfigOperationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListInstanceConfigOperationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListInstanceConfigOperationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListInstanceConfigOperationsRequest*>(
               &_ListInstanceConfigOperationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ListInstanceConfigOperationsRequest& a, ListInstanceConfigOperationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListInstanceConfigOperationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListInstanceConfigOperationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListInstanceConfigOperationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListInstanceConfigOperationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListInstanceConfigOperationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListInstanceConfigOperationsRequest& from) {
    ListInstanceConfigOperationsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListInstanceConfigOperationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest";
  }
  protected:
  explicit ListInstanceConfigOperationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kFilterFieldNumber = 2,
    kPageTokenFieldNumber = 4,
    kPageSizeFieldNumber = 3,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string filter = 2;
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // string page_token = 4;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 3;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class ListInstanceConfigOperationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse) */ {
 public:
  inline ListInstanceConfigOperationsResponse() : ListInstanceConfigOperationsResponse(nullptr) {}
  ~ListInstanceConfigOperationsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListInstanceConfigOperationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListInstanceConfigOperationsResponse(const ListInstanceConfigOperationsResponse& from);
  ListInstanceConfigOperationsResponse(ListInstanceConfigOperationsResponse&& from) noexcept
    : ListInstanceConfigOperationsResponse() {
    *this = ::std::move(from);
  }

  inline ListInstanceConfigOperationsResponse& operator=(const ListInstanceConfigOperationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListInstanceConfigOperationsResponse& operator=(ListInstanceConfigOperationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListInstanceConfigOperationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListInstanceConfigOperationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListInstanceConfigOperationsResponse*>(
               &_ListInstanceConfigOperationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListInstanceConfigOperationsResponse& a, ListInstanceConfigOperationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListInstanceConfigOperationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListInstanceConfigOperationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListInstanceConfigOperationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListInstanceConfigOperationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListInstanceConfigOperationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListInstanceConfigOperationsResponse& from) {
    ListInstanceConfigOperationsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListInstanceConfigOperationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse";
  }
  protected:
  explicit ListInstanceConfigOperationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.longrunning.Operation operations = 1;
  int operations_size() const;
  private:
  int _internal_operations_size() const;
  public:
  void clear_operations();
  ::google::longrunning::Operation* mutable_operations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::longrunning::Operation >*
      mutable_operations();
  private:
  const ::google::longrunning::Operation& _internal_operations(int index) const;
  ::google::longrunning::Operation* _internal_add_operations();
  public:
  const ::google::longrunning::Operation& operations(int index) const;
  ::google::longrunning::Operation* add_operations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::longrunning::Operation >&
      operations() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::longrunning::Operation > operations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class GetInstanceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.GetInstanceRequest) */ {
 public:
  inline GetInstanceRequest() : GetInstanceRequest(nullptr) {}
  ~GetInstanceRequest() override;
  explicit PROTOBUF_CONSTEXPR GetInstanceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetInstanceRequest(const GetInstanceRequest& from);
  GetInstanceRequest(GetInstanceRequest&& from) noexcept
    : GetInstanceRequest() {
    *this = ::std::move(from);
  }

  inline GetInstanceRequest& operator=(const GetInstanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInstanceRequest& operator=(GetInstanceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetInstanceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetInstanceRequest* internal_default_instance() {
    return reinterpret_cast<const GetInstanceRequest*>(
               &_GetInstanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetInstanceRequest& a, GetInstanceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInstanceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInstanceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetInstanceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetInstanceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetInstanceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetInstanceRequest& from) {
    GetInstanceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInstanceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.GetInstanceRequest";
  }
  protected:
  explicit GetInstanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFieldMaskFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.FieldMask field_mask = 2;
  bool has_field_mask() const;
  private:
  bool _internal_has_field_mask() const;
  public:
  void clear_field_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& field_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_field_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_field_mask();
  void set_allocated_field_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* field_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_field_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_field_mask();
  public:
  void unsafe_arena_set_allocated_field_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* field_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_field_mask();

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.GetInstanceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* field_mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class CreateInstanceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.CreateInstanceRequest) */ {
 public:
  inline CreateInstanceRequest() : CreateInstanceRequest(nullptr) {}
  ~CreateInstanceRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateInstanceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateInstanceRequest(const CreateInstanceRequest& from);
  CreateInstanceRequest(CreateInstanceRequest&& from) noexcept
    : CreateInstanceRequest() {
    *this = ::std::move(from);
  }

  inline CreateInstanceRequest& operator=(const CreateInstanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInstanceRequest& operator=(CreateInstanceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInstanceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateInstanceRequest* internal_default_instance() {
    return reinterpret_cast<const CreateInstanceRequest*>(
               &_CreateInstanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CreateInstanceRequest& a, CreateInstanceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInstanceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInstanceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateInstanceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateInstanceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateInstanceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateInstanceRequest& from) {
    CreateInstanceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateInstanceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.CreateInstanceRequest";
  }
  protected:
  explicit CreateInstanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kInstanceIdFieldNumber = 2,
    kInstanceFieldNumber = 3,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string instance_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_instance_id();
  const std::string& instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_id();
  PROTOBUF_NODISCARD std::string* release_instance_id();
  void set_allocated_instance_id(std::string* instance_id);
  private:
  const std::string& _internal_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_id(const std::string& value);
  std::string* _internal_mutable_instance_id();
  public:

  // .google.spanner.admin.instance.v1.Instance instance = 3 [(.google.api.field_behavior) = REQUIRED];
  bool has_instance() const;
  private:
  bool _internal_has_instance() const;
  public:
  void clear_instance();
  const ::google::spanner::admin::instance::v1::Instance& instance() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::instance::v1::Instance* release_instance();
  ::google::spanner::admin::instance::v1::Instance* mutable_instance();
  void set_allocated_instance(::google::spanner::admin::instance::v1::Instance* instance);
  private:
  const ::google::spanner::admin::instance::v1::Instance& _internal_instance() const;
  ::google::spanner::admin::instance::v1::Instance* _internal_mutable_instance();
  public:
  void unsafe_arena_set_allocated_instance(
      ::google::spanner::admin::instance::v1::Instance* instance);
  ::google::spanner::admin::instance::v1::Instance* unsafe_arena_release_instance();

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.CreateInstanceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_;
    ::google::spanner::admin::instance::v1::Instance* instance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class ListInstancesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.ListInstancesRequest) */ {
 public:
  inline ListInstancesRequest() : ListInstancesRequest(nullptr) {}
  ~ListInstancesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListInstancesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListInstancesRequest(const ListInstancesRequest& from);
  ListInstancesRequest(ListInstancesRequest&& from) noexcept
    : ListInstancesRequest() {
    *this = ::std::move(from);
  }

  inline ListInstancesRequest& operator=(const ListInstancesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListInstancesRequest& operator=(ListInstancesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListInstancesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListInstancesRequest* internal_default_instance() {
    return reinterpret_cast<const ListInstancesRequest*>(
               &_ListInstancesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ListInstancesRequest& a, ListInstancesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListInstancesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListInstancesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListInstancesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListInstancesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListInstancesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListInstancesRequest& from) {
    ListInstancesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListInstancesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.ListInstancesRequest";
  }
  protected:
  explicit ListInstancesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kFilterFieldNumber = 4,
    kPageSizeFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 3;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // string filter = 4;
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // int32 page_size = 2;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.ListInstancesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class ListInstancesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.ListInstancesResponse) */ {
 public:
  inline ListInstancesResponse() : ListInstancesResponse(nullptr) {}
  ~ListInstancesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListInstancesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListInstancesResponse(const ListInstancesResponse& from);
  ListInstancesResponse(ListInstancesResponse&& from) noexcept
    : ListInstancesResponse() {
    *this = ::std::move(from);
  }

  inline ListInstancesResponse& operator=(const ListInstancesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListInstancesResponse& operator=(ListInstancesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListInstancesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListInstancesResponse* internal_default_instance() {
    return reinterpret_cast<const ListInstancesResponse*>(
               &_ListInstancesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ListInstancesResponse& a, ListInstancesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListInstancesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListInstancesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListInstancesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListInstancesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListInstancesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListInstancesResponse& from) {
    ListInstancesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListInstancesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.ListInstancesResponse";
  }
  protected:
  explicit ListInstancesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstancesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.spanner.admin.instance.v1.Instance instances = 1;
  int instances_size() const;
  private:
  int _internal_instances_size() const;
  public:
  void clear_instances();
  ::google::spanner::admin::instance::v1::Instance* mutable_instances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::Instance >*
      mutable_instances();
  private:
  const ::google::spanner::admin::instance::v1::Instance& _internal_instances(int index) const;
  ::google::spanner::admin::instance::v1::Instance* _internal_add_instances();
  public:
  const ::google::spanner::admin::instance::v1::Instance& instances(int index) const;
  ::google::spanner::admin::instance::v1::Instance* add_instances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::Instance >&
      instances() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.ListInstancesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::Instance > instances_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class UpdateInstanceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.UpdateInstanceRequest) */ {
 public:
  inline UpdateInstanceRequest() : UpdateInstanceRequest(nullptr) {}
  ~UpdateInstanceRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateInstanceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateInstanceRequest(const UpdateInstanceRequest& from);
  UpdateInstanceRequest(UpdateInstanceRequest&& from) noexcept
    : UpdateInstanceRequest() {
    *this = ::std::move(from);
  }

  inline UpdateInstanceRequest& operator=(const UpdateInstanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateInstanceRequest& operator=(UpdateInstanceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateInstanceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateInstanceRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateInstanceRequest*>(
               &_UpdateInstanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UpdateInstanceRequest& a, UpdateInstanceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateInstanceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateInstanceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateInstanceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateInstanceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateInstanceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateInstanceRequest& from) {
    UpdateInstanceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateInstanceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.UpdateInstanceRequest";
  }
  protected:
  explicit UpdateInstanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceFieldNumber = 1,
    kFieldMaskFieldNumber = 2,
  };
  // .google.spanner.admin.instance.v1.Instance instance = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_instance() const;
  private:
  bool _internal_has_instance() const;
  public:
  void clear_instance();
  const ::google::spanner::admin::instance::v1::Instance& instance() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::instance::v1::Instance* release_instance();
  ::google::spanner::admin::instance::v1::Instance* mutable_instance();
  void set_allocated_instance(::google::spanner::admin::instance::v1::Instance* instance);
  private:
  const ::google::spanner::admin::instance::v1::Instance& _internal_instance() const;
  ::google::spanner::admin::instance::v1::Instance* _internal_mutable_instance();
  public:
  void unsafe_arena_set_allocated_instance(
      ::google::spanner::admin::instance::v1::Instance* instance);
  ::google::spanner::admin::instance::v1::Instance* unsafe_arena_release_instance();

  // .google.protobuf.FieldMask field_mask = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_field_mask() const;
  private:
  bool _internal_has_field_mask() const;
  public:
  void clear_field_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& field_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_field_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_field_mask();
  void set_allocated_field_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* field_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_field_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_field_mask();
  public:
  void unsafe_arena_set_allocated_field_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* field_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_field_mask();

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.UpdateInstanceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::spanner::admin::instance::v1::Instance* instance_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* field_mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class DeleteInstanceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.DeleteInstanceRequest) */ {
 public:
  inline DeleteInstanceRequest() : DeleteInstanceRequest(nullptr) {}
  ~DeleteInstanceRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteInstanceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteInstanceRequest(const DeleteInstanceRequest& from);
  DeleteInstanceRequest(DeleteInstanceRequest&& from) noexcept
    : DeleteInstanceRequest() {
    *this = ::std::move(from);
  }

  inline DeleteInstanceRequest& operator=(const DeleteInstanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteInstanceRequest& operator=(DeleteInstanceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteInstanceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteInstanceRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteInstanceRequest*>(
               &_DeleteInstanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DeleteInstanceRequest& a, DeleteInstanceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteInstanceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteInstanceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteInstanceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteInstanceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteInstanceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteInstanceRequest& from) {
    DeleteInstanceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteInstanceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.DeleteInstanceRequest";
  }
  protected:
  explicit DeleteInstanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.DeleteInstanceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class CreateInstanceMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.CreateInstanceMetadata) */ {
 public:
  inline CreateInstanceMetadata() : CreateInstanceMetadata(nullptr) {}
  ~CreateInstanceMetadata() override;
  explicit PROTOBUF_CONSTEXPR CreateInstanceMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateInstanceMetadata(const CreateInstanceMetadata& from);
  CreateInstanceMetadata(CreateInstanceMetadata&& from) noexcept
    : CreateInstanceMetadata() {
    *this = ::std::move(from);
  }

  inline CreateInstanceMetadata& operator=(const CreateInstanceMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInstanceMetadata& operator=(CreateInstanceMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInstanceMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateInstanceMetadata* internal_default_instance() {
    return reinterpret_cast<const CreateInstanceMetadata*>(
               &_CreateInstanceMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CreateInstanceMetadata& a, CreateInstanceMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInstanceMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInstanceMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateInstanceMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateInstanceMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateInstanceMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateInstanceMetadata& from) {
    CreateInstanceMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateInstanceMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.CreateInstanceMetadata";
  }
  protected:
  explicit CreateInstanceMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceFieldNumber = 1,
    kStartTimeFieldNumber = 2,
    kCancelTimeFieldNumber = 3,
    kEndTimeFieldNumber = 4,
  };
  // .google.spanner.admin.instance.v1.Instance instance = 1;
  bool has_instance() const;
  private:
  bool _internal_has_instance() const;
  public:
  void clear_instance();
  const ::google::spanner::admin::instance::v1::Instance& instance() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::instance::v1::Instance* release_instance();
  ::google::spanner::admin::instance::v1::Instance* mutable_instance();
  void set_allocated_instance(::google::spanner::admin::instance::v1::Instance* instance);
  private:
  const ::google::spanner::admin::instance::v1::Instance& _internal_instance() const;
  ::google::spanner::admin::instance::v1::Instance* _internal_mutable_instance();
  public:
  void unsafe_arena_set_allocated_instance(
      ::google::spanner::admin::instance::v1::Instance* instance);
  ::google::spanner::admin::instance::v1::Instance* unsafe_arena_release_instance();

  // .google.protobuf.Timestamp start_time = 2;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp cancel_time = 3;
  bool has_cancel_time() const;
  private:
  bool _internal_has_cancel_time() const;
  public:
  void clear_cancel_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& cancel_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_cancel_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_cancel_time();
  void set_allocated_cancel_time(::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_cancel_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_cancel_time();
  public:
  void unsafe_arena_set_allocated_cancel_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_cancel_time();

  // .google.protobuf.Timestamp end_time = 4;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.CreateInstanceMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::spanner::admin::instance::v1::Instance* instance_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class UpdateInstanceMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.UpdateInstanceMetadata) */ {
 public:
  inline UpdateInstanceMetadata() : UpdateInstanceMetadata(nullptr) {}
  ~UpdateInstanceMetadata() override;
  explicit PROTOBUF_CONSTEXPR UpdateInstanceMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateInstanceMetadata(const UpdateInstanceMetadata& from);
  UpdateInstanceMetadata(UpdateInstanceMetadata&& from) noexcept
    : UpdateInstanceMetadata() {
    *this = ::std::move(from);
  }

  inline UpdateInstanceMetadata& operator=(const UpdateInstanceMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateInstanceMetadata& operator=(UpdateInstanceMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateInstanceMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateInstanceMetadata* internal_default_instance() {
    return reinterpret_cast<const UpdateInstanceMetadata*>(
               &_UpdateInstanceMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UpdateInstanceMetadata& a, UpdateInstanceMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateInstanceMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateInstanceMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateInstanceMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateInstanceMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateInstanceMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateInstanceMetadata& from) {
    UpdateInstanceMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateInstanceMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.UpdateInstanceMetadata";
  }
  protected:
  explicit UpdateInstanceMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceFieldNumber = 1,
    kStartTimeFieldNumber = 2,
    kCancelTimeFieldNumber = 3,
    kEndTimeFieldNumber = 4,
  };
  // .google.spanner.admin.instance.v1.Instance instance = 1;
  bool has_instance() const;
  private:
  bool _internal_has_instance() const;
  public:
  void clear_instance();
  const ::google::spanner::admin::instance::v1::Instance& instance() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::instance::v1::Instance* release_instance();
  ::google::spanner::admin::instance::v1::Instance* mutable_instance();
  void set_allocated_instance(::google::spanner::admin::instance::v1::Instance* instance);
  private:
  const ::google::spanner::admin::instance::v1::Instance& _internal_instance() const;
  ::google::spanner::admin::instance::v1::Instance* _internal_mutable_instance();
  public:
  void unsafe_arena_set_allocated_instance(
      ::google::spanner::admin::instance::v1::Instance* instance);
  ::google::spanner::admin::instance::v1::Instance* unsafe_arena_release_instance();

  // .google.protobuf.Timestamp start_time = 2;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp cancel_time = 3;
  bool has_cancel_time() const;
  private:
  bool _internal_has_cancel_time() const;
  public:
  void clear_cancel_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& cancel_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_cancel_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_cancel_time();
  void set_allocated_cancel_time(::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_cancel_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_cancel_time();
  public:
  void unsafe_arena_set_allocated_cancel_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_cancel_time();

  // .google.protobuf.Timestamp end_time = 4;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.UpdateInstanceMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::spanner::admin::instance::v1::Instance* instance_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class CreateInstanceConfigMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata) */ {
 public:
  inline CreateInstanceConfigMetadata() : CreateInstanceConfigMetadata(nullptr) {}
  ~CreateInstanceConfigMetadata() override;
  explicit PROTOBUF_CONSTEXPR CreateInstanceConfigMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateInstanceConfigMetadata(const CreateInstanceConfigMetadata& from);
  CreateInstanceConfigMetadata(CreateInstanceConfigMetadata&& from) noexcept
    : CreateInstanceConfigMetadata() {
    *this = ::std::move(from);
  }

  inline CreateInstanceConfigMetadata& operator=(const CreateInstanceConfigMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInstanceConfigMetadata& operator=(CreateInstanceConfigMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInstanceConfigMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateInstanceConfigMetadata* internal_default_instance() {
    return reinterpret_cast<const CreateInstanceConfigMetadata*>(
               &_CreateInstanceConfigMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CreateInstanceConfigMetadata& a, CreateInstanceConfigMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInstanceConfigMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInstanceConfigMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateInstanceConfigMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateInstanceConfigMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateInstanceConfigMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateInstanceConfigMetadata& from) {
    CreateInstanceConfigMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateInstanceConfigMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.CreateInstanceConfigMetadata";
  }
  protected:
  explicit CreateInstanceConfigMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceConfigFieldNumber = 1,
    kProgressFieldNumber = 2,
    kCancelTimeFieldNumber = 3,
  };
  // .google.spanner.admin.instance.v1.InstanceConfig instance_config = 1;
  bool has_instance_config() const;
  private:
  bool _internal_has_instance_config() const;
  public:
  void clear_instance_config();
  const ::google::spanner::admin::instance::v1::InstanceConfig& instance_config() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::instance::v1::InstanceConfig* release_instance_config();
  ::google::spanner::admin::instance::v1::InstanceConfig* mutable_instance_config();
  void set_allocated_instance_config(::google::spanner::admin::instance::v1::InstanceConfig* instance_config);
  private:
  const ::google::spanner::admin::instance::v1::InstanceConfig& _internal_instance_config() const;
  ::google::spanner::admin::instance::v1::InstanceConfig* _internal_mutable_instance_config();
  public:
  void unsafe_arena_set_allocated_instance_config(
      ::google::spanner::admin::instance::v1::InstanceConfig* instance_config);
  ::google::spanner::admin::instance::v1::InstanceConfig* unsafe_arena_release_instance_config();

  // .google.spanner.admin.instance.v1.OperationProgress progress = 2;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  const ::google::spanner::admin::instance::v1::OperationProgress& progress() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::instance::v1::OperationProgress* release_progress();
  ::google::spanner::admin::instance::v1::OperationProgress* mutable_progress();
  void set_allocated_progress(::google::spanner::admin::instance::v1::OperationProgress* progress);
  private:
  const ::google::spanner::admin::instance::v1::OperationProgress& _internal_progress() const;
  ::google::spanner::admin::instance::v1::OperationProgress* _internal_mutable_progress();
  public:
  void unsafe_arena_set_allocated_progress(
      ::google::spanner::admin::instance::v1::OperationProgress* progress);
  ::google::spanner::admin::instance::v1::OperationProgress* unsafe_arena_release_progress();

  // .google.protobuf.Timestamp cancel_time = 3;
  bool has_cancel_time() const;
  private:
  bool _internal_has_cancel_time() const;
  public:
  void clear_cancel_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& cancel_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_cancel_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_cancel_time();
  void set_allocated_cancel_time(::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_cancel_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_cancel_time();
  public:
  void unsafe_arena_set_allocated_cancel_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_cancel_time();

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::spanner::admin::instance::v1::InstanceConfig* instance_config_;
    ::google::spanner::admin::instance::v1::OperationProgress* progress_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// -------------------------------------------------------------------

class UpdateInstanceConfigMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata) */ {
 public:
  inline UpdateInstanceConfigMetadata() : UpdateInstanceConfigMetadata(nullptr) {}
  ~UpdateInstanceConfigMetadata() override;
  explicit PROTOBUF_CONSTEXPR UpdateInstanceConfigMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateInstanceConfigMetadata(const UpdateInstanceConfigMetadata& from);
  UpdateInstanceConfigMetadata(UpdateInstanceConfigMetadata&& from) noexcept
    : UpdateInstanceConfigMetadata() {
    *this = ::std::move(from);
  }

  inline UpdateInstanceConfigMetadata& operator=(const UpdateInstanceConfigMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateInstanceConfigMetadata& operator=(UpdateInstanceConfigMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateInstanceConfigMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateInstanceConfigMetadata* internal_default_instance() {
    return reinterpret_cast<const UpdateInstanceConfigMetadata*>(
               &_UpdateInstanceConfigMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(UpdateInstanceConfigMetadata& a, UpdateInstanceConfigMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateInstanceConfigMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateInstanceConfigMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateInstanceConfigMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateInstanceConfigMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateInstanceConfigMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateInstanceConfigMetadata& from) {
    UpdateInstanceConfigMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateInstanceConfigMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata";
  }
  protected:
  explicit UpdateInstanceConfigMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceConfigFieldNumber = 1,
    kProgressFieldNumber = 2,
    kCancelTimeFieldNumber = 3,
  };
  // .google.spanner.admin.instance.v1.InstanceConfig instance_config = 1;
  bool has_instance_config() const;
  private:
  bool _internal_has_instance_config() const;
  public:
  void clear_instance_config();
  const ::google::spanner::admin::instance::v1::InstanceConfig& instance_config() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::instance::v1::InstanceConfig* release_instance_config();
  ::google::spanner::admin::instance::v1::InstanceConfig* mutable_instance_config();
  void set_allocated_instance_config(::google::spanner::admin::instance::v1::InstanceConfig* instance_config);
  private:
  const ::google::spanner::admin::instance::v1::InstanceConfig& _internal_instance_config() const;
  ::google::spanner::admin::instance::v1::InstanceConfig* _internal_mutable_instance_config();
  public:
  void unsafe_arena_set_allocated_instance_config(
      ::google::spanner::admin::instance::v1::InstanceConfig* instance_config);
  ::google::spanner::admin::instance::v1::InstanceConfig* unsafe_arena_release_instance_config();

  // .google.spanner.admin.instance.v1.OperationProgress progress = 2;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  const ::google::spanner::admin::instance::v1::OperationProgress& progress() const;
  PROTOBUF_NODISCARD ::google::spanner::admin::instance::v1::OperationProgress* release_progress();
  ::google::spanner::admin::instance::v1::OperationProgress* mutable_progress();
  void set_allocated_progress(::google::spanner::admin::instance::v1::OperationProgress* progress);
  private:
  const ::google::spanner::admin::instance::v1::OperationProgress& _internal_progress() const;
  ::google::spanner::admin::instance::v1::OperationProgress* _internal_mutable_progress();
  public:
  void unsafe_arena_set_allocated_progress(
      ::google::spanner::admin::instance::v1::OperationProgress* progress);
  ::google::spanner::admin::instance::v1::OperationProgress* unsafe_arena_release_progress();

  // .google.protobuf.Timestamp cancel_time = 3;
  bool has_cancel_time() const;
  private:
  bool _internal_has_cancel_time() const;
  public:
  void clear_cancel_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& cancel_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_cancel_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_cancel_time();
  void set_allocated_cancel_time(::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_cancel_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_cancel_time();
  public:
  void unsafe_arena_set_allocated_cancel_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_cancel_time();

  // @@protoc_insertion_point(class_scope:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::spanner::admin::instance::v1::InstanceConfig* instance_config_;
    ::google::spanner::admin::instance::v1::OperationProgress* progress_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReplicaInfo

// string location = 1;
inline void ReplicaInfo::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& ReplicaInfo::location() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ReplicaInfo.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReplicaInfo::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ReplicaInfo.location)
}
inline std::string* ReplicaInfo::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.ReplicaInfo.location)
  return _s;
}
inline const std::string& ReplicaInfo::_internal_location() const {
  return _impl_.location_.Get();
}
inline void ReplicaInfo::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* ReplicaInfo::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* ReplicaInfo::release_location() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.ReplicaInfo.location)
  return _impl_.location_.Release();
}
inline void ReplicaInfo::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.ReplicaInfo.location)
}

// .google.spanner.admin.instance.v1.ReplicaInfo.ReplicaType type = 2;
inline void ReplicaInfo::clear_type() {
  _impl_.type_ = 0;
}
inline ::google::spanner::admin::instance::v1::ReplicaInfo_ReplicaType ReplicaInfo::_internal_type() const {
  return static_cast< ::google::spanner::admin::instance::v1::ReplicaInfo_ReplicaType >(_impl_.type_);
}
inline ::google::spanner::admin::instance::v1::ReplicaInfo_ReplicaType ReplicaInfo::type() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ReplicaInfo.type)
  return _internal_type();
}
inline void ReplicaInfo::_internal_set_type(::google::spanner::admin::instance::v1::ReplicaInfo_ReplicaType value) {
  
  _impl_.type_ = value;
}
inline void ReplicaInfo::set_type(::google::spanner::admin::instance::v1::ReplicaInfo_ReplicaType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ReplicaInfo.type)
}

// bool default_leader_location = 3;
inline void ReplicaInfo::clear_default_leader_location() {
  _impl_.default_leader_location_ = false;
}
inline bool ReplicaInfo::_internal_default_leader_location() const {
  return _impl_.default_leader_location_;
}
inline bool ReplicaInfo::default_leader_location() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ReplicaInfo.default_leader_location)
  return _internal_default_leader_location();
}
inline void ReplicaInfo::_internal_set_default_leader_location(bool value) {
  
  _impl_.default_leader_location_ = value;
}
inline void ReplicaInfo::set_default_leader_location(bool value) {
  _internal_set_default_leader_location(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ReplicaInfo.default_leader_location)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InstanceConfig

// string name = 1;
inline void InstanceConfig::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& InstanceConfig::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.InstanceConfig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceConfig::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.InstanceConfig.name)
}
inline std::string* InstanceConfig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.InstanceConfig.name)
  return _s;
}
inline const std::string& InstanceConfig::_internal_name() const {
  return _impl_.name_.Get();
}
inline void InstanceConfig::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* InstanceConfig::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* InstanceConfig::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.InstanceConfig.name)
  return _impl_.name_.Release();
}
inline void InstanceConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.InstanceConfig.name)
}

// string display_name = 2;
inline void InstanceConfig::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& InstanceConfig::display_name() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.InstanceConfig.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceConfig::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.InstanceConfig.display_name)
}
inline std::string* InstanceConfig::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.InstanceConfig.display_name)
  return _s;
}
inline const std::string& InstanceConfig::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void InstanceConfig::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InstanceConfig::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InstanceConfig::release_display_name() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.InstanceConfig.display_name)
  return _impl_.display_name_.Release();
}
inline void InstanceConfig::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.InstanceConfig.display_name)
}

// .google.spanner.admin.instance.v1.InstanceConfig.Type config_type = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void InstanceConfig::clear_config_type() {
  _impl_.config_type_ = 0;
}
inline ::google::spanner::admin::instance::v1::InstanceConfig_Type InstanceConfig::_internal_config_type() const {
  return static_cast< ::google::spanner::admin::instance::v1::InstanceConfig_Type >(_impl_.config_type_);
}
inline ::google::spanner::admin::instance::v1::InstanceConfig_Type InstanceConfig::config_type() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.InstanceConfig.config_type)
  return _internal_config_type();
}
inline void InstanceConfig::_internal_set_config_type(::google::spanner::admin::instance::v1::InstanceConfig_Type value) {
  
  _impl_.config_type_ = value;
}
inline void InstanceConfig::set_config_type(::google::spanner::admin::instance::v1::InstanceConfig_Type value) {
  _internal_set_config_type(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.InstanceConfig.config_type)
}

// repeated .google.spanner.admin.instance.v1.ReplicaInfo replicas = 3;
inline int InstanceConfig::_internal_replicas_size() const {
  return _impl_.replicas_.size();
}
inline int InstanceConfig::replicas_size() const {
  return _internal_replicas_size();
}
inline void InstanceConfig::clear_replicas() {
  _impl_.replicas_.Clear();
}
inline ::google::spanner::admin::instance::v1::ReplicaInfo* InstanceConfig::mutable_replicas(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.InstanceConfig.replicas)
  return _impl_.replicas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::ReplicaInfo >*
InstanceConfig::mutable_replicas() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.instance.v1.InstanceConfig.replicas)
  return &_impl_.replicas_;
}
inline const ::google::spanner::admin::instance::v1::ReplicaInfo& InstanceConfig::_internal_replicas(int index) const {
  return _impl_.replicas_.Get(index);
}
inline const ::google::spanner::admin::instance::v1::ReplicaInfo& InstanceConfig::replicas(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.InstanceConfig.replicas)
  return _internal_replicas(index);
}
inline ::google::spanner::admin::instance::v1::ReplicaInfo* InstanceConfig::_internal_add_replicas() {
  return _impl_.replicas_.Add();
}
inline ::google::spanner::admin::instance::v1::ReplicaInfo* InstanceConfig::add_replicas() {
  ::google::spanner::admin::instance::v1::ReplicaInfo* _add = _internal_add_replicas();
  // @@protoc_insertion_point(field_add:google.spanner.admin.instance.v1.InstanceConfig.replicas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::ReplicaInfo >&
InstanceConfig::replicas() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.instance.v1.InstanceConfig.replicas)
  return _impl_.replicas_;
}

// repeated .google.spanner.admin.instance.v1.ReplicaInfo optional_replicas = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline int InstanceConfig::_internal_optional_replicas_size() const {
  return _impl_.optional_replicas_.size();
}
inline int InstanceConfig::optional_replicas_size() const {
  return _internal_optional_replicas_size();
}
inline void InstanceConfig::clear_optional_replicas() {
  _impl_.optional_replicas_.Clear();
}
inline ::google::spanner::admin::instance::v1::ReplicaInfo* InstanceConfig::mutable_optional_replicas(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.InstanceConfig.optional_replicas)
  return _impl_.optional_replicas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::ReplicaInfo >*
InstanceConfig::mutable_optional_replicas() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.instance.v1.InstanceConfig.optional_replicas)
  return &_impl_.optional_replicas_;
}
inline const ::google::spanner::admin::instance::v1::ReplicaInfo& InstanceConfig::_internal_optional_replicas(int index) const {
  return _impl_.optional_replicas_.Get(index);
}
inline const ::google::spanner::admin::instance::v1::ReplicaInfo& InstanceConfig::optional_replicas(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.InstanceConfig.optional_replicas)
  return _internal_optional_replicas(index);
}
inline ::google::spanner::admin::instance::v1::ReplicaInfo* InstanceConfig::_internal_add_optional_replicas() {
  return _impl_.optional_replicas_.Add();
}
inline ::google::spanner::admin::instance::v1::ReplicaInfo* InstanceConfig::add_optional_replicas() {
  ::google::spanner::admin::instance::v1::ReplicaInfo* _add = _internal_add_optional_replicas();
  // @@protoc_insertion_point(field_add:google.spanner.admin.instance.v1.InstanceConfig.optional_replicas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::ReplicaInfo >&
InstanceConfig::optional_replicas() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.instance.v1.InstanceConfig.optional_replicas)
  return _impl_.optional_replicas_;
}

// string base_config = 7 [(.google.api.resource_reference) = {
inline void InstanceConfig::clear_base_config() {
  _impl_.base_config_.ClearToEmpty();
}
inline const std::string& InstanceConfig::base_config() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.InstanceConfig.base_config)
  return _internal_base_config();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceConfig::set_base_config(ArgT0&& arg0, ArgT... args) {
 
 _impl_.base_config_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.InstanceConfig.base_config)
}
inline std::string* InstanceConfig::mutable_base_config() {
  std::string* _s = _internal_mutable_base_config();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.InstanceConfig.base_config)
  return _s;
}
inline const std::string& InstanceConfig::_internal_base_config() const {
  return _impl_.base_config_.Get();
}
inline void InstanceConfig::_internal_set_base_config(const std::string& value) {
  
  _impl_.base_config_.Set(value, GetArenaForAllocation());
}
inline std::string* InstanceConfig::_internal_mutable_base_config() {
  
  return _impl_.base_config_.Mutable(GetArenaForAllocation());
}
inline std::string* InstanceConfig::release_base_config() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.InstanceConfig.base_config)
  return _impl_.base_config_.Release();
}
inline void InstanceConfig::set_allocated_base_config(std::string* base_config) {
  if (base_config != nullptr) {
    
  } else {
    
  }
  _impl_.base_config_.SetAllocated(base_config, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_config_.IsDefault()) {
    _impl_.base_config_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.InstanceConfig.base_config)
}

// map<string, string> labels = 8;
inline int InstanceConfig::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int InstanceConfig::labels_size() const {
  return _internal_labels_size();
}
inline void InstanceConfig::clear_labels() {
  _impl_.labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InstanceConfig::_internal_labels() const {
  return _impl_.labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InstanceConfig::labels() const {
  // @@protoc_insertion_point(field_map:google.spanner.admin.instance.v1.InstanceConfig.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InstanceConfig::_internal_mutable_labels() {
  return _impl_.labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InstanceConfig::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:google.spanner.admin.instance.v1.InstanceConfig.labels)
  return _internal_mutable_labels();
}

// string etag = 9;
inline void InstanceConfig::clear_etag() {
  _impl_.etag_.ClearToEmpty();
}
inline const std::string& InstanceConfig::etag() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.InstanceConfig.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceConfig::set_etag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.etag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.InstanceConfig.etag)
}
inline std::string* InstanceConfig::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.InstanceConfig.etag)
  return _s;
}
inline const std::string& InstanceConfig::_internal_etag() const {
  return _impl_.etag_.Get();
}
inline void InstanceConfig::_internal_set_etag(const std::string& value) {
  
  _impl_.etag_.Set(value, GetArenaForAllocation());
}
inline std::string* InstanceConfig::_internal_mutable_etag() {
  
  return _impl_.etag_.Mutable(GetArenaForAllocation());
}
inline std::string* InstanceConfig::release_etag() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.InstanceConfig.etag)
  return _impl_.etag_.Release();
}
inline void InstanceConfig::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    
  } else {
    
  }
  _impl_.etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.etag_.IsDefault()) {
    _impl_.etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.InstanceConfig.etag)
}

// repeated string leader_options = 4;
inline int InstanceConfig::_internal_leader_options_size() const {
  return _impl_.leader_options_.size();
}
inline int InstanceConfig::leader_options_size() const {
  return _internal_leader_options_size();
}
inline void InstanceConfig::clear_leader_options() {
  _impl_.leader_options_.Clear();
}
inline std::string* InstanceConfig::add_leader_options() {
  std::string* _s = _internal_add_leader_options();
  // @@protoc_insertion_point(field_add_mutable:google.spanner.admin.instance.v1.InstanceConfig.leader_options)
  return _s;
}
inline const std::string& InstanceConfig::_internal_leader_options(int index) const {
  return _impl_.leader_options_.Get(index);
}
inline const std::string& InstanceConfig::leader_options(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.InstanceConfig.leader_options)
  return _internal_leader_options(index);
}
inline std::string* InstanceConfig::mutable_leader_options(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.InstanceConfig.leader_options)
  return _impl_.leader_options_.Mutable(index);
}
inline void InstanceConfig::set_leader_options(int index, const std::string& value) {
  _impl_.leader_options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.InstanceConfig.leader_options)
}
inline void InstanceConfig::set_leader_options(int index, std::string&& value) {
  _impl_.leader_options_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.InstanceConfig.leader_options)
}
inline void InstanceConfig::set_leader_options(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.leader_options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.spanner.admin.instance.v1.InstanceConfig.leader_options)
}
inline void InstanceConfig::set_leader_options(int index, const char* value, size_t size) {
  _impl_.leader_options_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.spanner.admin.instance.v1.InstanceConfig.leader_options)
}
inline std::string* InstanceConfig::_internal_add_leader_options() {
  return _impl_.leader_options_.Add();
}
inline void InstanceConfig::add_leader_options(const std::string& value) {
  _impl_.leader_options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.spanner.admin.instance.v1.InstanceConfig.leader_options)
}
inline void InstanceConfig::add_leader_options(std::string&& value) {
  _impl_.leader_options_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.spanner.admin.instance.v1.InstanceConfig.leader_options)
}
inline void InstanceConfig::add_leader_options(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.leader_options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.spanner.admin.instance.v1.InstanceConfig.leader_options)
}
inline void InstanceConfig::add_leader_options(const char* value, size_t size) {
  _impl_.leader_options_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.spanner.admin.instance.v1.InstanceConfig.leader_options)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InstanceConfig::leader_options() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.instance.v1.InstanceConfig.leader_options)
  return _impl_.leader_options_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InstanceConfig::mutable_leader_options() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.instance.v1.InstanceConfig.leader_options)
  return &_impl_.leader_options_;
}

// bool reconciling = 10 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void InstanceConfig::clear_reconciling() {
  _impl_.reconciling_ = false;
}
inline bool InstanceConfig::_internal_reconciling() const {
  return _impl_.reconciling_;
}
inline bool InstanceConfig::reconciling() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.InstanceConfig.reconciling)
  return _internal_reconciling();
}
inline void InstanceConfig::_internal_set_reconciling(bool value) {
  
  _impl_.reconciling_ = value;
}
inline void InstanceConfig::set_reconciling(bool value) {
  _internal_set_reconciling(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.InstanceConfig.reconciling)
}

// .google.spanner.admin.instance.v1.InstanceConfig.State state = 11 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void InstanceConfig::clear_state() {
  _impl_.state_ = 0;
}
inline ::google::spanner::admin::instance::v1::InstanceConfig_State InstanceConfig::_internal_state() const {
  return static_cast< ::google::spanner::admin::instance::v1::InstanceConfig_State >(_impl_.state_);
}
inline ::google::spanner::admin::instance::v1::InstanceConfig_State InstanceConfig::state() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.InstanceConfig.state)
  return _internal_state();
}
inline void InstanceConfig::_internal_set_state(::google::spanner::admin::instance::v1::InstanceConfig_State value) {
  
  _impl_.state_ = value;
}
inline void InstanceConfig::set_state(::google::spanner::admin::instance::v1::InstanceConfig_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.InstanceConfig.state)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Instance

// string name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void Instance::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Instance::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.Instance.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Instance::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.Instance.name)
}
inline std::string* Instance::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.Instance.name)
  return _s;
}
inline const std::string& Instance::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Instance::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Instance::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Instance::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.Instance.name)
  return _impl_.name_.Release();
}
inline void Instance::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.Instance.name)
}

// string config = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void Instance::clear_config() {
  _impl_.config_.ClearToEmpty();
}
inline const std::string& Instance::config() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.Instance.config)
  return _internal_config();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Instance::set_config(ArgT0&& arg0, ArgT... args) {
 
 _impl_.config_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.Instance.config)
}
inline std::string* Instance::mutable_config() {
  std::string* _s = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.Instance.config)
  return _s;
}
inline const std::string& Instance::_internal_config() const {
  return _impl_.config_.Get();
}
inline void Instance::_internal_set_config(const std::string& value) {
  
  _impl_.config_.Set(value, GetArenaForAllocation());
}
inline std::string* Instance::_internal_mutable_config() {
  
  return _impl_.config_.Mutable(GetArenaForAllocation());
}
inline std::string* Instance::release_config() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.Instance.config)
  return _impl_.config_.Release();
}
inline void Instance::set_allocated_config(std::string* config) {
  if (config != nullptr) {
    
  } else {
    
  }
  _impl_.config_.SetAllocated(config, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.config_.IsDefault()) {
    _impl_.config_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.Instance.config)
}

// string display_name = 3 [(.google.api.field_behavior) = REQUIRED];
inline void Instance::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& Instance::display_name() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.Instance.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Instance::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.Instance.display_name)
}
inline std::string* Instance::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.Instance.display_name)
  return _s;
}
inline const std::string& Instance::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void Instance::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Instance::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Instance::release_display_name() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.Instance.display_name)
  return _impl_.display_name_.Release();
}
inline void Instance::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.Instance.display_name)
}

// int32 node_count = 5;
inline void Instance::clear_node_count() {
  _impl_.node_count_ = 0;
}
inline int32_t Instance::_internal_node_count() const {
  return _impl_.node_count_;
}
inline int32_t Instance::node_count() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.Instance.node_count)
  return _internal_node_count();
}
inline void Instance::_internal_set_node_count(int32_t value) {
  
  _impl_.node_count_ = value;
}
inline void Instance::set_node_count(int32_t value) {
  _internal_set_node_count(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.Instance.node_count)
}

// int32 processing_units = 9;
inline void Instance::clear_processing_units() {
  _impl_.processing_units_ = 0;
}
inline int32_t Instance::_internal_processing_units() const {
  return _impl_.processing_units_;
}
inline int32_t Instance::processing_units() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.Instance.processing_units)
  return _internal_processing_units();
}
inline void Instance::_internal_set_processing_units(int32_t value) {
  
  _impl_.processing_units_ = value;
}
inline void Instance::set_processing_units(int32_t value) {
  _internal_set_processing_units(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.Instance.processing_units)
}

// .google.spanner.admin.instance.v1.Instance.State state = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Instance::clear_state() {
  _impl_.state_ = 0;
}
inline ::google::spanner::admin::instance::v1::Instance_State Instance::_internal_state() const {
  return static_cast< ::google::spanner::admin::instance::v1::Instance_State >(_impl_.state_);
}
inline ::google::spanner::admin::instance::v1::Instance_State Instance::state() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.Instance.state)
  return _internal_state();
}
inline void Instance::_internal_set_state(::google::spanner::admin::instance::v1::Instance_State value) {
  
  _impl_.state_ = value;
}
inline void Instance::set_state(::google::spanner::admin::instance::v1::Instance_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.Instance.state)
}

// map<string, string> labels = 7;
inline int Instance::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int Instance::labels_size() const {
  return _internal_labels_size();
}
inline void Instance::clear_labels() {
  _impl_.labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Instance::_internal_labels() const {
  return _impl_.labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Instance::labels() const {
  // @@protoc_insertion_point(field_map:google.spanner.admin.instance.v1.Instance.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Instance::_internal_mutable_labels() {
  return _impl_.labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Instance::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:google.spanner.admin.instance.v1.Instance.labels)
  return _internal_mutable_labels();
}

// repeated string endpoint_uris = 8;
inline int Instance::_internal_endpoint_uris_size() const {
  return _impl_.endpoint_uris_.size();
}
inline int Instance::endpoint_uris_size() const {
  return _internal_endpoint_uris_size();
}
inline void Instance::clear_endpoint_uris() {
  _impl_.endpoint_uris_.Clear();
}
inline std::string* Instance::add_endpoint_uris() {
  std::string* _s = _internal_add_endpoint_uris();
  // @@protoc_insertion_point(field_add_mutable:google.spanner.admin.instance.v1.Instance.endpoint_uris)
  return _s;
}
inline const std::string& Instance::_internal_endpoint_uris(int index) const {
  return _impl_.endpoint_uris_.Get(index);
}
inline const std::string& Instance::endpoint_uris(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.Instance.endpoint_uris)
  return _internal_endpoint_uris(index);
}
inline std::string* Instance::mutable_endpoint_uris(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.Instance.endpoint_uris)
  return _impl_.endpoint_uris_.Mutable(index);
}
inline void Instance::set_endpoint_uris(int index, const std::string& value) {
  _impl_.endpoint_uris_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.Instance.endpoint_uris)
}
inline void Instance::set_endpoint_uris(int index, std::string&& value) {
  _impl_.endpoint_uris_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.Instance.endpoint_uris)
}
inline void Instance::set_endpoint_uris(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoint_uris_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.spanner.admin.instance.v1.Instance.endpoint_uris)
}
inline void Instance::set_endpoint_uris(int index, const char* value, size_t size) {
  _impl_.endpoint_uris_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.spanner.admin.instance.v1.Instance.endpoint_uris)
}
inline std::string* Instance::_internal_add_endpoint_uris() {
  return _impl_.endpoint_uris_.Add();
}
inline void Instance::add_endpoint_uris(const std::string& value) {
  _impl_.endpoint_uris_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.spanner.admin.instance.v1.Instance.endpoint_uris)
}
inline void Instance::add_endpoint_uris(std::string&& value) {
  _impl_.endpoint_uris_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.spanner.admin.instance.v1.Instance.endpoint_uris)
}
inline void Instance::add_endpoint_uris(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoint_uris_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.spanner.admin.instance.v1.Instance.endpoint_uris)
}
inline void Instance::add_endpoint_uris(const char* value, size_t size) {
  _impl_.endpoint_uris_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.spanner.admin.instance.v1.Instance.endpoint_uris)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Instance::endpoint_uris() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.instance.v1.Instance.endpoint_uris)
  return _impl_.endpoint_uris_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Instance::mutable_endpoint_uris() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.instance.v1.Instance.endpoint_uris)
  return &_impl_.endpoint_uris_;
}

// .google.protobuf.Timestamp create_time = 11 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Instance::_internal_has_create_time() const {
  return this != internal_default_instance() && _impl_.create_time_ != nullptr;
}
inline bool Instance::has_create_time() const {
  return _internal_has_create_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Instance::_internal_create_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.create_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Instance::create_time() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.Instance.create_time)
  return _internal_create_time();
}
inline void Instance::unsafe_arena_set_allocated_create_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  _impl_.create_time_ = create_time;
  if (create_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.Instance.create_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Instance::release_create_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Instance::unsafe_arena_release_create_time() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.Instance.create_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Instance::_internal_mutable_create_time() {
  
  if (_impl_.create_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.create_time_ = p;
  }
  return _impl_.create_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Instance::mutable_create_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.Instance.create_time)
  return _msg;
}
inline void Instance::set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  if (create_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time));
    if (message_arena != submessage_arena) {
      create_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.Instance.create_time)
}

// .google.protobuf.Timestamp update_time = 12 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Instance::_internal_has_update_time() const {
  return this != internal_default_instance() && _impl_.update_time_ != nullptr;
}
inline bool Instance::has_update_time() const {
  return _internal_has_update_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Instance::_internal_update_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.update_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Instance::update_time() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.Instance.update_time)
  return _internal_update_time();
}
inline void Instance::unsafe_arena_set_allocated_update_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_time_);
  }
  _impl_.update_time_ = update_time;
  if (update_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.Instance.update_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Instance::release_update_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.update_time_;
  _impl_.update_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Instance::unsafe_arena_release_update_time() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.Instance.update_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.update_time_;
  _impl_.update_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Instance::_internal_mutable_update_time() {
  
  if (_impl_.update_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.update_time_ = p;
  }
  return _impl_.update_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Instance::mutable_update_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_update_time();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.Instance.update_time)
  return _msg;
}
inline void Instance::set_allocated_update_time(::PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_time_);
  }
  if (update_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_time));
    if (message_arena != submessage_arena) {
      update_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_time_ = update_time;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.Instance.update_time)
}

// -------------------------------------------------------------------

// ListInstanceConfigsRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListInstanceConfigsRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListInstanceConfigsRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstanceConfigsRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListInstanceConfigsRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ListInstanceConfigsRequest.parent)
}
inline std::string* ListInstanceConfigsRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.ListInstanceConfigsRequest.parent)
  return _s;
}
inline const std::string& ListInstanceConfigsRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListInstanceConfigsRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListInstanceConfigsRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListInstanceConfigsRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.ListInstanceConfigsRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListInstanceConfigsRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.ListInstanceConfigsRequest.parent)
}

// int32 page_size = 2;
inline void ListInstanceConfigsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListInstanceConfigsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListInstanceConfigsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstanceConfigsRequest.page_size)
  return _internal_page_size();
}
inline void ListInstanceConfigsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListInstanceConfigsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ListInstanceConfigsRequest.page_size)
}

// string page_token = 3;
inline void ListInstanceConfigsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListInstanceConfigsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstanceConfigsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListInstanceConfigsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ListInstanceConfigsRequest.page_token)
}
inline std::string* ListInstanceConfigsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.ListInstanceConfigsRequest.page_token)
  return _s;
}
inline const std::string& ListInstanceConfigsRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListInstanceConfigsRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListInstanceConfigsRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListInstanceConfigsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.ListInstanceConfigsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListInstanceConfigsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.ListInstanceConfigsRequest.page_token)
}

// -------------------------------------------------------------------

// ListInstanceConfigsResponse

// repeated .google.spanner.admin.instance.v1.InstanceConfig instance_configs = 1;
inline int ListInstanceConfigsResponse::_internal_instance_configs_size() const {
  return _impl_.instance_configs_.size();
}
inline int ListInstanceConfigsResponse::instance_configs_size() const {
  return _internal_instance_configs_size();
}
inline void ListInstanceConfigsResponse::clear_instance_configs() {
  _impl_.instance_configs_.Clear();
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* ListInstanceConfigsResponse::mutable_instance_configs(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.ListInstanceConfigsResponse.instance_configs)
  return _impl_.instance_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::InstanceConfig >*
ListInstanceConfigsResponse::mutable_instance_configs() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.instance.v1.ListInstanceConfigsResponse.instance_configs)
  return &_impl_.instance_configs_;
}
inline const ::google::spanner::admin::instance::v1::InstanceConfig& ListInstanceConfigsResponse::_internal_instance_configs(int index) const {
  return _impl_.instance_configs_.Get(index);
}
inline const ::google::spanner::admin::instance::v1::InstanceConfig& ListInstanceConfigsResponse::instance_configs(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstanceConfigsResponse.instance_configs)
  return _internal_instance_configs(index);
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* ListInstanceConfigsResponse::_internal_add_instance_configs() {
  return _impl_.instance_configs_.Add();
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* ListInstanceConfigsResponse::add_instance_configs() {
  ::google::spanner::admin::instance::v1::InstanceConfig* _add = _internal_add_instance_configs();
  // @@protoc_insertion_point(field_add:google.spanner.admin.instance.v1.ListInstanceConfigsResponse.instance_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::InstanceConfig >&
ListInstanceConfigsResponse::instance_configs() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.instance.v1.ListInstanceConfigsResponse.instance_configs)
  return _impl_.instance_configs_;
}

// string next_page_token = 2;
inline void ListInstanceConfigsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListInstanceConfigsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstanceConfigsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListInstanceConfigsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ListInstanceConfigsResponse.next_page_token)
}
inline std::string* ListInstanceConfigsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.ListInstanceConfigsResponse.next_page_token)
  return _s;
}
inline const std::string& ListInstanceConfigsResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListInstanceConfigsResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListInstanceConfigsResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListInstanceConfigsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.ListInstanceConfigsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListInstanceConfigsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.ListInstanceConfigsResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetInstanceConfigRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetInstanceConfigRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetInstanceConfigRequest::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.GetInstanceConfigRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetInstanceConfigRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.GetInstanceConfigRequest.name)
}
inline std::string* GetInstanceConfigRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.GetInstanceConfigRequest.name)
  return _s;
}
inline const std::string& GetInstanceConfigRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetInstanceConfigRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetInstanceConfigRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetInstanceConfigRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.GetInstanceConfigRequest.name)
  return _impl_.name_.Release();
}
inline void GetInstanceConfigRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.GetInstanceConfigRequest.name)
}

// -------------------------------------------------------------------

// CreateInstanceConfigRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CreateInstanceConfigRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& CreateInstanceConfigRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInstanceConfigRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.parent)
}
inline std::string* CreateInstanceConfigRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.parent)
  return _s;
}
inline const std::string& CreateInstanceConfigRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void CreateInstanceConfigRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateInstanceConfigRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateInstanceConfigRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.parent)
  return _impl_.parent_.Release();
}
inline void CreateInstanceConfigRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.parent)
}

// string instance_config_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void CreateInstanceConfigRequest::clear_instance_config_id() {
  _impl_.instance_config_id_.ClearToEmpty();
}
inline const std::string& CreateInstanceConfigRequest::instance_config_id() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.instance_config_id)
  return _internal_instance_config_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInstanceConfigRequest::set_instance_config_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instance_config_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.instance_config_id)
}
inline std::string* CreateInstanceConfigRequest::mutable_instance_config_id() {
  std::string* _s = _internal_mutable_instance_config_id();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.instance_config_id)
  return _s;
}
inline const std::string& CreateInstanceConfigRequest::_internal_instance_config_id() const {
  return _impl_.instance_config_id_.Get();
}
inline void CreateInstanceConfigRequest::_internal_set_instance_config_id(const std::string& value) {
  
  _impl_.instance_config_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateInstanceConfigRequest::_internal_mutable_instance_config_id() {
  
  return _impl_.instance_config_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateInstanceConfigRequest::release_instance_config_id() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.instance_config_id)
  return _impl_.instance_config_id_.Release();
}
inline void CreateInstanceConfigRequest::set_allocated_instance_config_id(std::string* instance_config_id) {
  if (instance_config_id != nullptr) {
    
  } else {
    
  }
  _impl_.instance_config_id_.SetAllocated(instance_config_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_config_id_.IsDefault()) {
    _impl_.instance_config_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.instance_config_id)
}

// .google.spanner.admin.instance.v1.InstanceConfig instance_config = 3 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateInstanceConfigRequest::_internal_has_instance_config() const {
  return this != internal_default_instance() && _impl_.instance_config_ != nullptr;
}
inline bool CreateInstanceConfigRequest::has_instance_config() const {
  return _internal_has_instance_config();
}
inline void CreateInstanceConfigRequest::clear_instance_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.instance_config_ != nullptr) {
    delete _impl_.instance_config_;
  }
  _impl_.instance_config_ = nullptr;
}
inline const ::google::spanner::admin::instance::v1::InstanceConfig& CreateInstanceConfigRequest::_internal_instance_config() const {
  const ::google::spanner::admin::instance::v1::InstanceConfig* p = _impl_.instance_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::instance::v1::InstanceConfig&>(
      ::google::spanner::admin::instance::v1::_InstanceConfig_default_instance_);
}
inline const ::google::spanner::admin::instance::v1::InstanceConfig& CreateInstanceConfigRequest::instance_config() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.instance_config)
  return _internal_instance_config();
}
inline void CreateInstanceConfigRequest::unsafe_arena_set_allocated_instance_config(
    ::google::spanner::admin::instance::v1::InstanceConfig* instance_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instance_config_);
  }
  _impl_.instance_config_ = instance_config;
  if (instance_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.instance_config)
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* CreateInstanceConfigRequest::release_instance_config() {
  
  ::google::spanner::admin::instance::v1::InstanceConfig* temp = _impl_.instance_config_;
  _impl_.instance_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* CreateInstanceConfigRequest::unsafe_arena_release_instance_config() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.instance_config)
  
  ::google::spanner::admin::instance::v1::InstanceConfig* temp = _impl_.instance_config_;
  _impl_.instance_config_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* CreateInstanceConfigRequest::_internal_mutable_instance_config() {
  
  if (_impl_.instance_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::instance::v1::InstanceConfig>(GetArenaForAllocation());
    _impl_.instance_config_ = p;
  }
  return _impl_.instance_config_;
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* CreateInstanceConfigRequest::mutable_instance_config() {
  ::google::spanner::admin::instance::v1::InstanceConfig* _msg = _internal_mutable_instance_config();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.instance_config)
  return _msg;
}
inline void CreateInstanceConfigRequest::set_allocated_instance_config(::google::spanner::admin::instance::v1::InstanceConfig* instance_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instance_config_;
  }
  if (instance_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instance_config);
    if (message_arena != submessage_arena) {
      instance_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instance_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instance_config_ = instance_config;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.instance_config)
}

// bool validate_only = 4;
inline void CreateInstanceConfigRequest::clear_validate_only() {
  _impl_.validate_only_ = false;
}
inline bool CreateInstanceConfigRequest::_internal_validate_only() const {
  return _impl_.validate_only_;
}
inline bool CreateInstanceConfigRequest::validate_only() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.validate_only)
  return _internal_validate_only();
}
inline void CreateInstanceConfigRequest::_internal_set_validate_only(bool value) {
  
  _impl_.validate_only_ = value;
}
inline void CreateInstanceConfigRequest::set_validate_only(bool value) {
  _internal_set_validate_only(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.CreateInstanceConfigRequest.validate_only)
}

// -------------------------------------------------------------------

// UpdateInstanceConfigRequest

// .google.spanner.admin.instance.v1.InstanceConfig instance_config = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateInstanceConfigRequest::_internal_has_instance_config() const {
  return this != internal_default_instance() && _impl_.instance_config_ != nullptr;
}
inline bool UpdateInstanceConfigRequest::has_instance_config() const {
  return _internal_has_instance_config();
}
inline void UpdateInstanceConfigRequest::clear_instance_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.instance_config_ != nullptr) {
    delete _impl_.instance_config_;
  }
  _impl_.instance_config_ = nullptr;
}
inline const ::google::spanner::admin::instance::v1::InstanceConfig& UpdateInstanceConfigRequest::_internal_instance_config() const {
  const ::google::spanner::admin::instance::v1::InstanceConfig* p = _impl_.instance_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::instance::v1::InstanceConfig&>(
      ::google::spanner::admin::instance::v1::_InstanceConfig_default_instance_);
}
inline const ::google::spanner::admin::instance::v1::InstanceConfig& UpdateInstanceConfigRequest::instance_config() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.instance_config)
  return _internal_instance_config();
}
inline void UpdateInstanceConfigRequest::unsafe_arena_set_allocated_instance_config(
    ::google::spanner::admin::instance::v1::InstanceConfig* instance_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instance_config_);
  }
  _impl_.instance_config_ = instance_config;
  if (instance_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.instance_config)
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* UpdateInstanceConfigRequest::release_instance_config() {
  
  ::google::spanner::admin::instance::v1::InstanceConfig* temp = _impl_.instance_config_;
  _impl_.instance_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* UpdateInstanceConfigRequest::unsafe_arena_release_instance_config() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.instance_config)
  
  ::google::spanner::admin::instance::v1::InstanceConfig* temp = _impl_.instance_config_;
  _impl_.instance_config_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* UpdateInstanceConfigRequest::_internal_mutable_instance_config() {
  
  if (_impl_.instance_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::instance::v1::InstanceConfig>(GetArenaForAllocation());
    _impl_.instance_config_ = p;
  }
  return _impl_.instance_config_;
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* UpdateInstanceConfigRequest::mutable_instance_config() {
  ::google::spanner::admin::instance::v1::InstanceConfig* _msg = _internal_mutable_instance_config();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.instance_config)
  return _msg;
}
inline void UpdateInstanceConfigRequest::set_allocated_instance_config(::google::spanner::admin::instance::v1::InstanceConfig* instance_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instance_config_;
  }
  if (instance_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instance_config);
    if (message_arena != submessage_arena) {
      instance_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instance_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instance_config_ = instance_config;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.instance_config)
}

// .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateInstanceConfigRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateInstanceConfigRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateInstanceConfigRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateInstanceConfigRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateInstanceConfigRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateInstanceConfigRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateInstanceConfigRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateInstanceConfigRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateInstanceConfigRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.update_mask)
  return _msg;
}
inline void UpdateInstanceConfigRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.update_mask)
}

// bool validate_only = 3;
inline void UpdateInstanceConfigRequest::clear_validate_only() {
  _impl_.validate_only_ = false;
}
inline bool UpdateInstanceConfigRequest::_internal_validate_only() const {
  return _impl_.validate_only_;
}
inline bool UpdateInstanceConfigRequest::validate_only() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.validate_only)
  return _internal_validate_only();
}
inline void UpdateInstanceConfigRequest::_internal_set_validate_only(bool value) {
  
  _impl_.validate_only_ = value;
}
inline void UpdateInstanceConfigRequest::set_validate_only(bool value) {
  _internal_set_validate_only(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.UpdateInstanceConfigRequest.validate_only)
}

// -------------------------------------------------------------------

// DeleteInstanceConfigRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteInstanceConfigRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteInstanceConfigRequest::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.DeleteInstanceConfigRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteInstanceConfigRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.DeleteInstanceConfigRequest.name)
}
inline std::string* DeleteInstanceConfigRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.DeleteInstanceConfigRequest.name)
  return _s;
}
inline const std::string& DeleteInstanceConfigRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteInstanceConfigRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteInstanceConfigRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteInstanceConfigRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.DeleteInstanceConfigRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteInstanceConfigRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.DeleteInstanceConfigRequest.name)
}

// string etag = 2;
inline void DeleteInstanceConfigRequest::clear_etag() {
  _impl_.etag_.ClearToEmpty();
}
inline const std::string& DeleteInstanceConfigRequest::etag() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.DeleteInstanceConfigRequest.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteInstanceConfigRequest::set_etag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.etag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.DeleteInstanceConfigRequest.etag)
}
inline std::string* DeleteInstanceConfigRequest::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.DeleteInstanceConfigRequest.etag)
  return _s;
}
inline const std::string& DeleteInstanceConfigRequest::_internal_etag() const {
  return _impl_.etag_.Get();
}
inline void DeleteInstanceConfigRequest::_internal_set_etag(const std::string& value) {
  
  _impl_.etag_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteInstanceConfigRequest::_internal_mutable_etag() {
  
  return _impl_.etag_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteInstanceConfigRequest::release_etag() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.DeleteInstanceConfigRequest.etag)
  return _impl_.etag_.Release();
}
inline void DeleteInstanceConfigRequest::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    
  } else {
    
  }
  _impl_.etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.etag_.IsDefault()) {
    _impl_.etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.DeleteInstanceConfigRequest.etag)
}

// bool validate_only = 3;
inline void DeleteInstanceConfigRequest::clear_validate_only() {
  _impl_.validate_only_ = false;
}
inline bool DeleteInstanceConfigRequest::_internal_validate_only() const {
  return _impl_.validate_only_;
}
inline bool DeleteInstanceConfigRequest::validate_only() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.DeleteInstanceConfigRequest.validate_only)
  return _internal_validate_only();
}
inline void DeleteInstanceConfigRequest::_internal_set_validate_only(bool value) {
  
  _impl_.validate_only_ = value;
}
inline void DeleteInstanceConfigRequest::set_validate_only(bool value) {
  _internal_set_validate_only(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.DeleteInstanceConfigRequest.validate_only)
}

// -------------------------------------------------------------------

// ListInstanceConfigOperationsRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListInstanceConfigOperationsRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListInstanceConfigOperationsRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListInstanceConfigOperationsRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.parent)
}
inline std::string* ListInstanceConfigOperationsRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.parent)
  return _s;
}
inline const std::string& ListInstanceConfigOperationsRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListInstanceConfigOperationsRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListInstanceConfigOperationsRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListInstanceConfigOperationsRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListInstanceConfigOperationsRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.parent)
}

// string filter = 2;
inline void ListInstanceConfigOperationsRequest::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& ListInstanceConfigOperationsRequest::filter() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListInstanceConfigOperationsRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.filter)
}
inline std::string* ListInstanceConfigOperationsRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.filter)
  return _s;
}
inline const std::string& ListInstanceConfigOperationsRequest::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void ListInstanceConfigOperationsRequest::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* ListInstanceConfigOperationsRequest::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* ListInstanceConfigOperationsRequest::release_filter() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.filter)
  return _impl_.filter_.Release();
}
inline void ListInstanceConfigOperationsRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.filter)
}

// int32 page_size = 3;
inline void ListInstanceConfigOperationsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListInstanceConfigOperationsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListInstanceConfigOperationsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.page_size)
  return _internal_page_size();
}
inline void ListInstanceConfigOperationsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListInstanceConfigOperationsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.page_size)
}

// string page_token = 4;
inline void ListInstanceConfigOperationsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListInstanceConfigOperationsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListInstanceConfigOperationsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.page_token)
}
inline std::string* ListInstanceConfigOperationsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.page_token)
  return _s;
}
inline const std::string& ListInstanceConfigOperationsRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListInstanceConfigOperationsRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListInstanceConfigOperationsRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListInstanceConfigOperationsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListInstanceConfigOperationsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.ListInstanceConfigOperationsRequest.page_token)
}

// -------------------------------------------------------------------

// ListInstanceConfigOperationsResponse

// repeated .google.longrunning.Operation operations = 1;
inline int ListInstanceConfigOperationsResponse::_internal_operations_size() const {
  return _impl_.operations_.size();
}
inline int ListInstanceConfigOperationsResponse::operations_size() const {
  return _internal_operations_size();
}
inline ::google::longrunning::Operation* ListInstanceConfigOperationsResponse::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.operations)
  return _impl_.operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::longrunning::Operation >*
ListInstanceConfigOperationsResponse::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.operations)
  return &_impl_.operations_;
}
inline const ::google::longrunning::Operation& ListInstanceConfigOperationsResponse::_internal_operations(int index) const {
  return _impl_.operations_.Get(index);
}
inline const ::google::longrunning::Operation& ListInstanceConfigOperationsResponse::operations(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.operations)
  return _internal_operations(index);
}
inline ::google::longrunning::Operation* ListInstanceConfigOperationsResponse::_internal_add_operations() {
  return _impl_.operations_.Add();
}
inline ::google::longrunning::Operation* ListInstanceConfigOperationsResponse::add_operations() {
  ::google::longrunning::Operation* _add = _internal_add_operations();
  // @@protoc_insertion_point(field_add:google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.operations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::longrunning::Operation >&
ListInstanceConfigOperationsResponse::operations() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.operations)
  return _impl_.operations_;
}

// string next_page_token = 2;
inline void ListInstanceConfigOperationsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListInstanceConfigOperationsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListInstanceConfigOperationsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.next_page_token)
}
inline std::string* ListInstanceConfigOperationsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.next_page_token)
  return _s;
}
inline const std::string& ListInstanceConfigOperationsResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListInstanceConfigOperationsResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListInstanceConfigOperationsResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListInstanceConfigOperationsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListInstanceConfigOperationsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.ListInstanceConfigOperationsResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetInstanceRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetInstanceRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetInstanceRequest::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.GetInstanceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetInstanceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.GetInstanceRequest.name)
}
inline std::string* GetInstanceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.GetInstanceRequest.name)
  return _s;
}
inline const std::string& GetInstanceRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetInstanceRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetInstanceRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetInstanceRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.GetInstanceRequest.name)
  return _impl_.name_.Release();
}
inline void GetInstanceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.GetInstanceRequest.name)
}

// .google.protobuf.FieldMask field_mask = 2;
inline bool GetInstanceRequest::_internal_has_field_mask() const {
  return this != internal_default_instance() && _impl_.field_mask_ != nullptr;
}
inline bool GetInstanceRequest::has_field_mask() const {
  return _internal_has_field_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& GetInstanceRequest::_internal_field_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.field_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& GetInstanceRequest::field_mask() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.GetInstanceRequest.field_mask)
  return _internal_field_mask();
}
inline void GetInstanceRequest::unsafe_arena_set_allocated_field_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* field_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.field_mask_);
  }
  _impl_.field_mask_ = field_mask;
  if (field_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.GetInstanceRequest.field_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* GetInstanceRequest::release_field_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.field_mask_;
  _impl_.field_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* GetInstanceRequest::unsafe_arena_release_field_mask() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.GetInstanceRequest.field_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.field_mask_;
  _impl_.field_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* GetInstanceRequest::_internal_mutable_field_mask() {
  
  if (_impl_.field_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.field_mask_ = p;
  }
  return _impl_.field_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* GetInstanceRequest::mutable_field_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_field_mask();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.GetInstanceRequest.field_mask)
  return _msg;
}
inline void GetInstanceRequest::set_allocated_field_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* field_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.field_mask_);
  }
  if (field_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field_mask));
    if (message_arena != submessage_arena) {
      field_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.field_mask_ = field_mask;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.GetInstanceRequest.field_mask)
}

// -------------------------------------------------------------------

// CreateInstanceRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CreateInstanceRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& CreateInstanceRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.CreateInstanceRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInstanceRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.CreateInstanceRequest.parent)
}
inline std::string* CreateInstanceRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.CreateInstanceRequest.parent)
  return _s;
}
inline const std::string& CreateInstanceRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void CreateInstanceRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateInstanceRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateInstanceRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.CreateInstanceRequest.parent)
  return _impl_.parent_.Release();
}
inline void CreateInstanceRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.CreateInstanceRequest.parent)
}

// string instance_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void CreateInstanceRequest::clear_instance_id() {
  _impl_.instance_id_.ClearToEmpty();
}
inline const std::string& CreateInstanceRequest::instance_id() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.CreateInstanceRequest.instance_id)
  return _internal_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateInstanceRequest::set_instance_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.CreateInstanceRequest.instance_id)
}
inline std::string* CreateInstanceRequest::mutable_instance_id() {
  std::string* _s = _internal_mutable_instance_id();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.CreateInstanceRequest.instance_id)
  return _s;
}
inline const std::string& CreateInstanceRequest::_internal_instance_id() const {
  return _impl_.instance_id_.Get();
}
inline void CreateInstanceRequest::_internal_set_instance_id(const std::string& value) {
  
  _impl_.instance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateInstanceRequest::_internal_mutable_instance_id() {
  
  return _impl_.instance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateInstanceRequest::release_instance_id() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.CreateInstanceRequest.instance_id)
  return _impl_.instance_id_.Release();
}
inline void CreateInstanceRequest::set_allocated_instance_id(std::string* instance_id) {
  if (instance_id != nullptr) {
    
  } else {
    
  }
  _impl_.instance_id_.SetAllocated(instance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.CreateInstanceRequest.instance_id)
}

// .google.spanner.admin.instance.v1.Instance instance = 3 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateInstanceRequest::_internal_has_instance() const {
  return this != internal_default_instance() && _impl_.instance_ != nullptr;
}
inline bool CreateInstanceRequest::has_instance() const {
  return _internal_has_instance();
}
inline void CreateInstanceRequest::clear_instance() {
  if (GetArenaForAllocation() == nullptr && _impl_.instance_ != nullptr) {
    delete _impl_.instance_;
  }
  _impl_.instance_ = nullptr;
}
inline const ::google::spanner::admin::instance::v1::Instance& CreateInstanceRequest::_internal_instance() const {
  const ::google::spanner::admin::instance::v1::Instance* p = _impl_.instance_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::instance::v1::Instance&>(
      ::google::spanner::admin::instance::v1::_Instance_default_instance_);
}
inline const ::google::spanner::admin::instance::v1::Instance& CreateInstanceRequest::instance() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.CreateInstanceRequest.instance)
  return _internal_instance();
}
inline void CreateInstanceRequest::unsafe_arena_set_allocated_instance(
    ::google::spanner::admin::instance::v1::Instance* instance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instance_);
  }
  _impl_.instance_ = instance;
  if (instance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.CreateInstanceRequest.instance)
}
inline ::google::spanner::admin::instance::v1::Instance* CreateInstanceRequest::release_instance() {
  
  ::google::spanner::admin::instance::v1::Instance* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::instance::v1::Instance* CreateInstanceRequest::unsafe_arena_release_instance() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.CreateInstanceRequest.instance)
  
  ::google::spanner::admin::instance::v1::Instance* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::instance::v1::Instance* CreateInstanceRequest::_internal_mutable_instance() {
  
  if (_impl_.instance_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::instance::v1::Instance>(GetArenaForAllocation());
    _impl_.instance_ = p;
  }
  return _impl_.instance_;
}
inline ::google::spanner::admin::instance::v1::Instance* CreateInstanceRequest::mutable_instance() {
  ::google::spanner::admin::instance::v1::Instance* _msg = _internal_mutable_instance();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.CreateInstanceRequest.instance)
  return _msg;
}
inline void CreateInstanceRequest::set_allocated_instance(::google::spanner::admin::instance::v1::Instance* instance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instance_;
  }
  if (instance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instance);
    if (message_arena != submessage_arena) {
      instance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instance_ = instance;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.CreateInstanceRequest.instance)
}

// -------------------------------------------------------------------

// ListInstancesRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListInstancesRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListInstancesRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstancesRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListInstancesRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ListInstancesRequest.parent)
}
inline std::string* ListInstancesRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.ListInstancesRequest.parent)
  return _s;
}
inline const std::string& ListInstancesRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListInstancesRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListInstancesRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListInstancesRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.ListInstancesRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListInstancesRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.ListInstancesRequest.parent)
}

// int32 page_size = 2;
inline void ListInstancesRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListInstancesRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListInstancesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstancesRequest.page_size)
  return _internal_page_size();
}
inline void ListInstancesRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListInstancesRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ListInstancesRequest.page_size)
}

// string page_token = 3;
inline void ListInstancesRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListInstancesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstancesRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListInstancesRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ListInstancesRequest.page_token)
}
inline std::string* ListInstancesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.ListInstancesRequest.page_token)
  return _s;
}
inline const std::string& ListInstancesRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListInstancesRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListInstancesRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListInstancesRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.ListInstancesRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListInstancesRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.ListInstancesRequest.page_token)
}

// string filter = 4;
inline void ListInstancesRequest::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& ListInstancesRequest::filter() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstancesRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListInstancesRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ListInstancesRequest.filter)
}
inline std::string* ListInstancesRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.ListInstancesRequest.filter)
  return _s;
}
inline const std::string& ListInstancesRequest::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void ListInstancesRequest::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* ListInstancesRequest::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* ListInstancesRequest::release_filter() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.ListInstancesRequest.filter)
  return _impl_.filter_.Release();
}
inline void ListInstancesRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.ListInstancesRequest.filter)
}

// -------------------------------------------------------------------

// ListInstancesResponse

// repeated .google.spanner.admin.instance.v1.Instance instances = 1;
inline int ListInstancesResponse::_internal_instances_size() const {
  return _impl_.instances_.size();
}
inline int ListInstancesResponse::instances_size() const {
  return _internal_instances_size();
}
inline void ListInstancesResponse::clear_instances() {
  _impl_.instances_.Clear();
}
inline ::google::spanner::admin::instance::v1::Instance* ListInstancesResponse::mutable_instances(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.ListInstancesResponse.instances)
  return _impl_.instances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::Instance >*
ListInstancesResponse::mutable_instances() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.admin.instance.v1.ListInstancesResponse.instances)
  return &_impl_.instances_;
}
inline const ::google::spanner::admin::instance::v1::Instance& ListInstancesResponse::_internal_instances(int index) const {
  return _impl_.instances_.Get(index);
}
inline const ::google::spanner::admin::instance::v1::Instance& ListInstancesResponse::instances(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstancesResponse.instances)
  return _internal_instances(index);
}
inline ::google::spanner::admin::instance::v1::Instance* ListInstancesResponse::_internal_add_instances() {
  return _impl_.instances_.Add();
}
inline ::google::spanner::admin::instance::v1::Instance* ListInstancesResponse::add_instances() {
  ::google::spanner::admin::instance::v1::Instance* _add = _internal_add_instances();
  // @@protoc_insertion_point(field_add:google.spanner.admin.instance.v1.ListInstancesResponse.instances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::spanner::admin::instance::v1::Instance >&
ListInstancesResponse::instances() const {
  // @@protoc_insertion_point(field_list:google.spanner.admin.instance.v1.ListInstancesResponse.instances)
  return _impl_.instances_;
}

// string next_page_token = 2;
inline void ListInstancesResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListInstancesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.ListInstancesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListInstancesResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.ListInstancesResponse.next_page_token)
}
inline std::string* ListInstancesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.ListInstancesResponse.next_page_token)
  return _s;
}
inline const std::string& ListInstancesResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListInstancesResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListInstancesResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListInstancesResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.ListInstancesResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListInstancesResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.ListInstancesResponse.next_page_token)
}

// -------------------------------------------------------------------

// UpdateInstanceRequest

// .google.spanner.admin.instance.v1.Instance instance = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateInstanceRequest::_internal_has_instance() const {
  return this != internal_default_instance() && _impl_.instance_ != nullptr;
}
inline bool UpdateInstanceRequest::has_instance() const {
  return _internal_has_instance();
}
inline void UpdateInstanceRequest::clear_instance() {
  if (GetArenaForAllocation() == nullptr && _impl_.instance_ != nullptr) {
    delete _impl_.instance_;
  }
  _impl_.instance_ = nullptr;
}
inline const ::google::spanner::admin::instance::v1::Instance& UpdateInstanceRequest::_internal_instance() const {
  const ::google::spanner::admin::instance::v1::Instance* p = _impl_.instance_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::instance::v1::Instance&>(
      ::google::spanner::admin::instance::v1::_Instance_default_instance_);
}
inline const ::google::spanner::admin::instance::v1::Instance& UpdateInstanceRequest::instance() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.UpdateInstanceRequest.instance)
  return _internal_instance();
}
inline void UpdateInstanceRequest::unsafe_arena_set_allocated_instance(
    ::google::spanner::admin::instance::v1::Instance* instance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instance_);
  }
  _impl_.instance_ = instance;
  if (instance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceRequest.instance)
}
inline ::google::spanner::admin::instance::v1::Instance* UpdateInstanceRequest::release_instance() {
  
  ::google::spanner::admin::instance::v1::Instance* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::instance::v1::Instance* UpdateInstanceRequest::unsafe_arena_release_instance() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.UpdateInstanceRequest.instance)
  
  ::google::spanner::admin::instance::v1::Instance* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::instance::v1::Instance* UpdateInstanceRequest::_internal_mutable_instance() {
  
  if (_impl_.instance_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::instance::v1::Instance>(GetArenaForAllocation());
    _impl_.instance_ = p;
  }
  return _impl_.instance_;
}
inline ::google::spanner::admin::instance::v1::Instance* UpdateInstanceRequest::mutable_instance() {
  ::google::spanner::admin::instance::v1::Instance* _msg = _internal_mutable_instance();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.UpdateInstanceRequest.instance)
  return _msg;
}
inline void UpdateInstanceRequest::set_allocated_instance(::google::spanner::admin::instance::v1::Instance* instance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instance_;
  }
  if (instance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instance);
    if (message_arena != submessage_arena) {
      instance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instance_ = instance;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceRequest.instance)
}

// .google.protobuf.FieldMask field_mask = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateInstanceRequest::_internal_has_field_mask() const {
  return this != internal_default_instance() && _impl_.field_mask_ != nullptr;
}
inline bool UpdateInstanceRequest::has_field_mask() const {
  return _internal_has_field_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateInstanceRequest::_internal_field_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.field_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateInstanceRequest::field_mask() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.UpdateInstanceRequest.field_mask)
  return _internal_field_mask();
}
inline void UpdateInstanceRequest::unsafe_arena_set_allocated_field_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* field_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.field_mask_);
  }
  _impl_.field_mask_ = field_mask;
  if (field_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceRequest.field_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateInstanceRequest::release_field_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.field_mask_;
  _impl_.field_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateInstanceRequest::unsafe_arena_release_field_mask() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.UpdateInstanceRequest.field_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.field_mask_;
  _impl_.field_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateInstanceRequest::_internal_mutable_field_mask() {
  
  if (_impl_.field_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.field_mask_ = p;
  }
  return _impl_.field_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateInstanceRequest::mutable_field_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_field_mask();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.UpdateInstanceRequest.field_mask)
  return _msg;
}
inline void UpdateInstanceRequest::set_allocated_field_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* field_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.field_mask_);
  }
  if (field_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field_mask));
    if (message_arena != submessage_arena) {
      field_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.field_mask_ = field_mask;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceRequest.field_mask)
}

// -------------------------------------------------------------------

// DeleteInstanceRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteInstanceRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteInstanceRequest::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.DeleteInstanceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteInstanceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.spanner.admin.instance.v1.DeleteInstanceRequest.name)
}
inline std::string* DeleteInstanceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.DeleteInstanceRequest.name)
  return _s;
}
inline const std::string& DeleteInstanceRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteInstanceRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteInstanceRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteInstanceRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.DeleteInstanceRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteInstanceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.DeleteInstanceRequest.name)
}

// -------------------------------------------------------------------

// CreateInstanceMetadata

// .google.spanner.admin.instance.v1.Instance instance = 1;
inline bool CreateInstanceMetadata::_internal_has_instance() const {
  return this != internal_default_instance() && _impl_.instance_ != nullptr;
}
inline bool CreateInstanceMetadata::has_instance() const {
  return _internal_has_instance();
}
inline void CreateInstanceMetadata::clear_instance() {
  if (GetArenaForAllocation() == nullptr && _impl_.instance_ != nullptr) {
    delete _impl_.instance_;
  }
  _impl_.instance_ = nullptr;
}
inline const ::google::spanner::admin::instance::v1::Instance& CreateInstanceMetadata::_internal_instance() const {
  const ::google::spanner::admin::instance::v1::Instance* p = _impl_.instance_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::instance::v1::Instance&>(
      ::google::spanner::admin::instance::v1::_Instance_default_instance_);
}
inline const ::google::spanner::admin::instance::v1::Instance& CreateInstanceMetadata::instance() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.CreateInstanceMetadata.instance)
  return _internal_instance();
}
inline void CreateInstanceMetadata::unsafe_arena_set_allocated_instance(
    ::google::spanner::admin::instance::v1::Instance* instance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instance_);
  }
  _impl_.instance_ = instance;
  if (instance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.CreateInstanceMetadata.instance)
}
inline ::google::spanner::admin::instance::v1::Instance* CreateInstanceMetadata::release_instance() {
  
  ::google::spanner::admin::instance::v1::Instance* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::instance::v1::Instance* CreateInstanceMetadata::unsafe_arena_release_instance() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.CreateInstanceMetadata.instance)
  
  ::google::spanner::admin::instance::v1::Instance* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::instance::v1::Instance* CreateInstanceMetadata::_internal_mutable_instance() {
  
  if (_impl_.instance_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::instance::v1::Instance>(GetArenaForAllocation());
    _impl_.instance_ = p;
  }
  return _impl_.instance_;
}
inline ::google::spanner::admin::instance::v1::Instance* CreateInstanceMetadata::mutable_instance() {
  ::google::spanner::admin::instance::v1::Instance* _msg = _internal_mutable_instance();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.CreateInstanceMetadata.instance)
  return _msg;
}
inline void CreateInstanceMetadata::set_allocated_instance(::google::spanner::admin::instance::v1::Instance* instance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instance_;
  }
  if (instance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instance);
    if (message_arena != submessage_arena) {
      instance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instance_ = instance;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.CreateInstanceMetadata.instance)
}

// .google.protobuf.Timestamp start_time = 2;
inline bool CreateInstanceMetadata::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool CreateInstanceMetadata::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateInstanceMetadata::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateInstanceMetadata::start_time() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.CreateInstanceMetadata.start_time)
  return _internal_start_time();
}
inline void CreateInstanceMetadata::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.CreateInstanceMetadata.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceMetadata::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceMetadata::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.CreateInstanceMetadata.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceMetadata::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceMetadata::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.CreateInstanceMetadata.start_time)
  return _msg;
}
inline void CreateInstanceMetadata::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.CreateInstanceMetadata.start_time)
}

// .google.protobuf.Timestamp cancel_time = 3;
inline bool CreateInstanceMetadata::_internal_has_cancel_time() const {
  return this != internal_default_instance() && _impl_.cancel_time_ != nullptr;
}
inline bool CreateInstanceMetadata::has_cancel_time() const {
  return _internal_has_cancel_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateInstanceMetadata::_internal_cancel_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.cancel_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateInstanceMetadata::cancel_time() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.CreateInstanceMetadata.cancel_time)
  return _internal_cancel_time();
}
inline void CreateInstanceMetadata::unsafe_arena_set_allocated_cancel_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cancel_time_);
  }
  _impl_.cancel_time_ = cancel_time;
  if (cancel_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.CreateInstanceMetadata.cancel_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceMetadata::release_cancel_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.cancel_time_;
  _impl_.cancel_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceMetadata::unsafe_arena_release_cancel_time() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.CreateInstanceMetadata.cancel_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.cancel_time_;
  _impl_.cancel_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceMetadata::_internal_mutable_cancel_time() {
  
  if (_impl_.cancel_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.cancel_time_ = p;
  }
  return _impl_.cancel_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceMetadata::mutable_cancel_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_cancel_time();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.CreateInstanceMetadata.cancel_time)
  return _msg;
}
inline void CreateInstanceMetadata::set_allocated_cancel_time(::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cancel_time_);
  }
  if (cancel_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cancel_time));
    if (message_arena != submessage_arena) {
      cancel_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cancel_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cancel_time_ = cancel_time;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.CreateInstanceMetadata.cancel_time)
}

// .google.protobuf.Timestamp end_time = 4;
inline bool CreateInstanceMetadata::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool CreateInstanceMetadata::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateInstanceMetadata::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateInstanceMetadata::end_time() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.CreateInstanceMetadata.end_time)
  return _internal_end_time();
}
inline void CreateInstanceMetadata::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.CreateInstanceMetadata.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceMetadata::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceMetadata::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.CreateInstanceMetadata.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceMetadata::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceMetadata::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.CreateInstanceMetadata.end_time)
  return _msg;
}
inline void CreateInstanceMetadata::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.CreateInstanceMetadata.end_time)
}

// -------------------------------------------------------------------

// UpdateInstanceMetadata

// .google.spanner.admin.instance.v1.Instance instance = 1;
inline bool UpdateInstanceMetadata::_internal_has_instance() const {
  return this != internal_default_instance() && _impl_.instance_ != nullptr;
}
inline bool UpdateInstanceMetadata::has_instance() const {
  return _internal_has_instance();
}
inline void UpdateInstanceMetadata::clear_instance() {
  if (GetArenaForAllocation() == nullptr && _impl_.instance_ != nullptr) {
    delete _impl_.instance_;
  }
  _impl_.instance_ = nullptr;
}
inline const ::google::spanner::admin::instance::v1::Instance& UpdateInstanceMetadata::_internal_instance() const {
  const ::google::spanner::admin::instance::v1::Instance* p = _impl_.instance_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::instance::v1::Instance&>(
      ::google::spanner::admin::instance::v1::_Instance_default_instance_);
}
inline const ::google::spanner::admin::instance::v1::Instance& UpdateInstanceMetadata::instance() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.UpdateInstanceMetadata.instance)
  return _internal_instance();
}
inline void UpdateInstanceMetadata::unsafe_arena_set_allocated_instance(
    ::google::spanner::admin::instance::v1::Instance* instance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instance_);
  }
  _impl_.instance_ = instance;
  if (instance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceMetadata.instance)
}
inline ::google::spanner::admin::instance::v1::Instance* UpdateInstanceMetadata::release_instance() {
  
  ::google::spanner::admin::instance::v1::Instance* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::instance::v1::Instance* UpdateInstanceMetadata::unsafe_arena_release_instance() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.UpdateInstanceMetadata.instance)
  
  ::google::spanner::admin::instance::v1::Instance* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::instance::v1::Instance* UpdateInstanceMetadata::_internal_mutable_instance() {
  
  if (_impl_.instance_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::instance::v1::Instance>(GetArenaForAllocation());
    _impl_.instance_ = p;
  }
  return _impl_.instance_;
}
inline ::google::spanner::admin::instance::v1::Instance* UpdateInstanceMetadata::mutable_instance() {
  ::google::spanner::admin::instance::v1::Instance* _msg = _internal_mutable_instance();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.UpdateInstanceMetadata.instance)
  return _msg;
}
inline void UpdateInstanceMetadata::set_allocated_instance(::google::spanner::admin::instance::v1::Instance* instance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instance_;
  }
  if (instance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instance);
    if (message_arena != submessage_arena) {
      instance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instance_ = instance;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceMetadata.instance)
}

// .google.protobuf.Timestamp start_time = 2;
inline bool UpdateInstanceMetadata::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool UpdateInstanceMetadata::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateInstanceMetadata::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateInstanceMetadata::start_time() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.UpdateInstanceMetadata.start_time)
  return _internal_start_time();
}
inline void UpdateInstanceMetadata::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceMetadata.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceMetadata::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceMetadata::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.UpdateInstanceMetadata.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceMetadata::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceMetadata::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.UpdateInstanceMetadata.start_time)
  return _msg;
}
inline void UpdateInstanceMetadata::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceMetadata.start_time)
}

// .google.protobuf.Timestamp cancel_time = 3;
inline bool UpdateInstanceMetadata::_internal_has_cancel_time() const {
  return this != internal_default_instance() && _impl_.cancel_time_ != nullptr;
}
inline bool UpdateInstanceMetadata::has_cancel_time() const {
  return _internal_has_cancel_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateInstanceMetadata::_internal_cancel_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.cancel_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateInstanceMetadata::cancel_time() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.UpdateInstanceMetadata.cancel_time)
  return _internal_cancel_time();
}
inline void UpdateInstanceMetadata::unsafe_arena_set_allocated_cancel_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cancel_time_);
  }
  _impl_.cancel_time_ = cancel_time;
  if (cancel_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceMetadata.cancel_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceMetadata::release_cancel_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.cancel_time_;
  _impl_.cancel_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceMetadata::unsafe_arena_release_cancel_time() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.UpdateInstanceMetadata.cancel_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.cancel_time_;
  _impl_.cancel_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceMetadata::_internal_mutable_cancel_time() {
  
  if (_impl_.cancel_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.cancel_time_ = p;
  }
  return _impl_.cancel_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceMetadata::mutable_cancel_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_cancel_time();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.UpdateInstanceMetadata.cancel_time)
  return _msg;
}
inline void UpdateInstanceMetadata::set_allocated_cancel_time(::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cancel_time_);
  }
  if (cancel_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cancel_time));
    if (message_arena != submessage_arena) {
      cancel_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cancel_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cancel_time_ = cancel_time;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceMetadata.cancel_time)
}

// .google.protobuf.Timestamp end_time = 4;
inline bool UpdateInstanceMetadata::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool UpdateInstanceMetadata::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateInstanceMetadata::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateInstanceMetadata::end_time() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.UpdateInstanceMetadata.end_time)
  return _internal_end_time();
}
inline void UpdateInstanceMetadata::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceMetadata.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceMetadata::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceMetadata::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.UpdateInstanceMetadata.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceMetadata::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceMetadata::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.UpdateInstanceMetadata.end_time)
  return _msg;
}
inline void UpdateInstanceMetadata::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceMetadata.end_time)
}

// -------------------------------------------------------------------

// CreateInstanceConfigMetadata

// .google.spanner.admin.instance.v1.InstanceConfig instance_config = 1;
inline bool CreateInstanceConfigMetadata::_internal_has_instance_config() const {
  return this != internal_default_instance() && _impl_.instance_config_ != nullptr;
}
inline bool CreateInstanceConfigMetadata::has_instance_config() const {
  return _internal_has_instance_config();
}
inline void CreateInstanceConfigMetadata::clear_instance_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.instance_config_ != nullptr) {
    delete _impl_.instance_config_;
  }
  _impl_.instance_config_ = nullptr;
}
inline const ::google::spanner::admin::instance::v1::InstanceConfig& CreateInstanceConfigMetadata::_internal_instance_config() const {
  const ::google::spanner::admin::instance::v1::InstanceConfig* p = _impl_.instance_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::instance::v1::InstanceConfig&>(
      ::google::spanner::admin::instance::v1::_InstanceConfig_default_instance_);
}
inline const ::google::spanner::admin::instance::v1::InstanceConfig& CreateInstanceConfigMetadata::instance_config() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata.instance_config)
  return _internal_instance_config();
}
inline void CreateInstanceConfigMetadata::unsafe_arena_set_allocated_instance_config(
    ::google::spanner::admin::instance::v1::InstanceConfig* instance_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instance_config_);
  }
  _impl_.instance_config_ = instance_config;
  if (instance_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata.instance_config)
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* CreateInstanceConfigMetadata::release_instance_config() {
  
  ::google::spanner::admin::instance::v1::InstanceConfig* temp = _impl_.instance_config_;
  _impl_.instance_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* CreateInstanceConfigMetadata::unsafe_arena_release_instance_config() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata.instance_config)
  
  ::google::spanner::admin::instance::v1::InstanceConfig* temp = _impl_.instance_config_;
  _impl_.instance_config_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* CreateInstanceConfigMetadata::_internal_mutable_instance_config() {
  
  if (_impl_.instance_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::instance::v1::InstanceConfig>(GetArenaForAllocation());
    _impl_.instance_config_ = p;
  }
  return _impl_.instance_config_;
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* CreateInstanceConfigMetadata::mutable_instance_config() {
  ::google::spanner::admin::instance::v1::InstanceConfig* _msg = _internal_mutable_instance_config();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata.instance_config)
  return _msg;
}
inline void CreateInstanceConfigMetadata::set_allocated_instance_config(::google::spanner::admin::instance::v1::InstanceConfig* instance_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instance_config_;
  }
  if (instance_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instance_config);
    if (message_arena != submessage_arena) {
      instance_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instance_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instance_config_ = instance_config;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata.instance_config)
}

// .google.spanner.admin.instance.v1.OperationProgress progress = 2;
inline bool CreateInstanceConfigMetadata::_internal_has_progress() const {
  return this != internal_default_instance() && _impl_.progress_ != nullptr;
}
inline bool CreateInstanceConfigMetadata::has_progress() const {
  return _internal_has_progress();
}
inline const ::google::spanner::admin::instance::v1::OperationProgress& CreateInstanceConfigMetadata::_internal_progress() const {
  const ::google::spanner::admin::instance::v1::OperationProgress* p = _impl_.progress_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::instance::v1::OperationProgress&>(
      ::google::spanner::admin::instance::v1::_OperationProgress_default_instance_);
}
inline const ::google::spanner::admin::instance::v1::OperationProgress& CreateInstanceConfigMetadata::progress() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata.progress)
  return _internal_progress();
}
inline void CreateInstanceConfigMetadata::unsafe_arena_set_allocated_progress(
    ::google::spanner::admin::instance::v1::OperationProgress* progress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  _impl_.progress_ = progress;
  if (progress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata.progress)
}
inline ::google::spanner::admin::instance::v1::OperationProgress* CreateInstanceConfigMetadata::release_progress() {
  
  ::google::spanner::admin::instance::v1::OperationProgress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::instance::v1::OperationProgress* CreateInstanceConfigMetadata::unsafe_arena_release_progress() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata.progress)
  
  ::google::spanner::admin::instance::v1::OperationProgress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::instance::v1::OperationProgress* CreateInstanceConfigMetadata::_internal_mutable_progress() {
  
  if (_impl_.progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::instance::v1::OperationProgress>(GetArenaForAllocation());
    _impl_.progress_ = p;
  }
  return _impl_.progress_;
}
inline ::google::spanner::admin::instance::v1::OperationProgress* CreateInstanceConfigMetadata::mutable_progress() {
  ::google::spanner::admin::instance::v1::OperationProgress* _msg = _internal_mutable_progress();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata.progress)
  return _msg;
}
inline void CreateInstanceConfigMetadata::set_allocated_progress(::google::spanner::admin::instance::v1::OperationProgress* progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  if (progress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(progress));
    if (message_arena != submessage_arena) {
      progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, progress, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.progress_ = progress;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata.progress)
}

// .google.protobuf.Timestamp cancel_time = 3;
inline bool CreateInstanceConfigMetadata::_internal_has_cancel_time() const {
  return this != internal_default_instance() && _impl_.cancel_time_ != nullptr;
}
inline bool CreateInstanceConfigMetadata::has_cancel_time() const {
  return _internal_has_cancel_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateInstanceConfigMetadata::_internal_cancel_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.cancel_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateInstanceConfigMetadata::cancel_time() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata.cancel_time)
  return _internal_cancel_time();
}
inline void CreateInstanceConfigMetadata::unsafe_arena_set_allocated_cancel_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cancel_time_);
  }
  _impl_.cancel_time_ = cancel_time;
  if (cancel_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata.cancel_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceConfigMetadata::release_cancel_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.cancel_time_;
  _impl_.cancel_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceConfigMetadata::unsafe_arena_release_cancel_time() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata.cancel_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.cancel_time_;
  _impl_.cancel_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceConfigMetadata::_internal_mutable_cancel_time() {
  
  if (_impl_.cancel_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.cancel_time_ = p;
  }
  return _impl_.cancel_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateInstanceConfigMetadata::mutable_cancel_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_cancel_time();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata.cancel_time)
  return _msg;
}
inline void CreateInstanceConfigMetadata::set_allocated_cancel_time(::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cancel_time_);
  }
  if (cancel_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cancel_time));
    if (message_arena != submessage_arena) {
      cancel_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cancel_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cancel_time_ = cancel_time;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.CreateInstanceConfigMetadata.cancel_time)
}

// -------------------------------------------------------------------

// UpdateInstanceConfigMetadata

// .google.spanner.admin.instance.v1.InstanceConfig instance_config = 1;
inline bool UpdateInstanceConfigMetadata::_internal_has_instance_config() const {
  return this != internal_default_instance() && _impl_.instance_config_ != nullptr;
}
inline bool UpdateInstanceConfigMetadata::has_instance_config() const {
  return _internal_has_instance_config();
}
inline void UpdateInstanceConfigMetadata::clear_instance_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.instance_config_ != nullptr) {
    delete _impl_.instance_config_;
  }
  _impl_.instance_config_ = nullptr;
}
inline const ::google::spanner::admin::instance::v1::InstanceConfig& UpdateInstanceConfigMetadata::_internal_instance_config() const {
  const ::google::spanner::admin::instance::v1::InstanceConfig* p = _impl_.instance_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::instance::v1::InstanceConfig&>(
      ::google::spanner::admin::instance::v1::_InstanceConfig_default_instance_);
}
inline const ::google::spanner::admin::instance::v1::InstanceConfig& UpdateInstanceConfigMetadata::instance_config() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.instance_config)
  return _internal_instance_config();
}
inline void UpdateInstanceConfigMetadata::unsafe_arena_set_allocated_instance_config(
    ::google::spanner::admin::instance::v1::InstanceConfig* instance_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instance_config_);
  }
  _impl_.instance_config_ = instance_config;
  if (instance_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.instance_config)
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* UpdateInstanceConfigMetadata::release_instance_config() {
  
  ::google::spanner::admin::instance::v1::InstanceConfig* temp = _impl_.instance_config_;
  _impl_.instance_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* UpdateInstanceConfigMetadata::unsafe_arena_release_instance_config() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.instance_config)
  
  ::google::spanner::admin::instance::v1::InstanceConfig* temp = _impl_.instance_config_;
  _impl_.instance_config_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* UpdateInstanceConfigMetadata::_internal_mutable_instance_config() {
  
  if (_impl_.instance_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::instance::v1::InstanceConfig>(GetArenaForAllocation());
    _impl_.instance_config_ = p;
  }
  return _impl_.instance_config_;
}
inline ::google::spanner::admin::instance::v1::InstanceConfig* UpdateInstanceConfigMetadata::mutable_instance_config() {
  ::google::spanner::admin::instance::v1::InstanceConfig* _msg = _internal_mutable_instance_config();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.instance_config)
  return _msg;
}
inline void UpdateInstanceConfigMetadata::set_allocated_instance_config(::google::spanner::admin::instance::v1::InstanceConfig* instance_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instance_config_;
  }
  if (instance_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instance_config);
    if (message_arena != submessage_arena) {
      instance_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instance_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instance_config_ = instance_config;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.instance_config)
}

// .google.spanner.admin.instance.v1.OperationProgress progress = 2;
inline bool UpdateInstanceConfigMetadata::_internal_has_progress() const {
  return this != internal_default_instance() && _impl_.progress_ != nullptr;
}
inline bool UpdateInstanceConfigMetadata::has_progress() const {
  return _internal_has_progress();
}
inline const ::google::spanner::admin::instance::v1::OperationProgress& UpdateInstanceConfigMetadata::_internal_progress() const {
  const ::google::spanner::admin::instance::v1::OperationProgress* p = _impl_.progress_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::spanner::admin::instance::v1::OperationProgress&>(
      ::google::spanner::admin::instance::v1::_OperationProgress_default_instance_);
}
inline const ::google::spanner::admin::instance::v1::OperationProgress& UpdateInstanceConfigMetadata::progress() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.progress)
  return _internal_progress();
}
inline void UpdateInstanceConfigMetadata::unsafe_arena_set_allocated_progress(
    ::google::spanner::admin::instance::v1::OperationProgress* progress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  _impl_.progress_ = progress;
  if (progress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.progress)
}
inline ::google::spanner::admin::instance::v1::OperationProgress* UpdateInstanceConfigMetadata::release_progress() {
  
  ::google::spanner::admin::instance::v1::OperationProgress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::spanner::admin::instance::v1::OperationProgress* UpdateInstanceConfigMetadata::unsafe_arena_release_progress() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.progress)
  
  ::google::spanner::admin::instance::v1::OperationProgress* temp = _impl_.progress_;
  _impl_.progress_ = nullptr;
  return temp;
}
inline ::google::spanner::admin::instance::v1::OperationProgress* UpdateInstanceConfigMetadata::_internal_mutable_progress() {
  
  if (_impl_.progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::spanner::admin::instance::v1::OperationProgress>(GetArenaForAllocation());
    _impl_.progress_ = p;
  }
  return _impl_.progress_;
}
inline ::google::spanner::admin::instance::v1::OperationProgress* UpdateInstanceConfigMetadata::mutable_progress() {
  ::google::spanner::admin::instance::v1::OperationProgress* _msg = _internal_mutable_progress();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.progress)
  return _msg;
}
inline void UpdateInstanceConfigMetadata::set_allocated_progress(::google::spanner::admin::instance::v1::OperationProgress* progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_);
  }
  if (progress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(progress));
    if (message_arena != submessage_arena) {
      progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, progress, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.progress_ = progress;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.progress)
}

// .google.protobuf.Timestamp cancel_time = 3;
inline bool UpdateInstanceConfigMetadata::_internal_has_cancel_time() const {
  return this != internal_default_instance() && _impl_.cancel_time_ != nullptr;
}
inline bool UpdateInstanceConfigMetadata::has_cancel_time() const {
  return _internal_has_cancel_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateInstanceConfigMetadata::_internal_cancel_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.cancel_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateInstanceConfigMetadata::cancel_time() const {
  // @@protoc_insertion_point(field_get:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.cancel_time)
  return _internal_cancel_time();
}
inline void UpdateInstanceConfigMetadata::unsafe_arena_set_allocated_cancel_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cancel_time_);
  }
  _impl_.cancel_time_ = cancel_time;
  if (cancel_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.cancel_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceConfigMetadata::release_cancel_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.cancel_time_;
  _impl_.cancel_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceConfigMetadata::unsafe_arena_release_cancel_time() {
  // @@protoc_insertion_point(field_release:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.cancel_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.cancel_time_;
  _impl_.cancel_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceConfigMetadata::_internal_mutable_cancel_time() {
  
  if (_impl_.cancel_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.cancel_time_ = p;
  }
  return _impl_.cancel_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateInstanceConfigMetadata::mutable_cancel_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_cancel_time();
  // @@protoc_insertion_point(field_mutable:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.cancel_time)
  return _msg;
}
inline void UpdateInstanceConfigMetadata::set_allocated_cancel_time(::PROTOBUF_NAMESPACE_ID::Timestamp* cancel_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cancel_time_);
  }
  if (cancel_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cancel_time));
    if (message_arena != submessage_arena) {
      cancel_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cancel_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cancel_time_ = cancel_time;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.admin.instance.v1.UpdateInstanceConfigMetadata.cancel_time)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace instance
}  // namespace admin
}  // namespace spanner
}  // namespace google

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::google::spanner::admin::instance::v1::ReplicaInfo_ReplicaType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::spanner::admin::instance::v1::ReplicaInfo_ReplicaType>() {
  return ::google::spanner::admin::instance::v1::ReplicaInfo_ReplicaType_descriptor();
}
template <> struct is_proto_enum< ::google::spanner::admin::instance::v1::InstanceConfig_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::spanner::admin::instance::v1::InstanceConfig_Type>() {
  return ::google::spanner::admin::instance::v1::InstanceConfig_Type_descriptor();
}
template <> struct is_proto_enum< ::google::spanner::admin::instance::v1::InstanceConfig_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::spanner::admin::instance::v1::InstanceConfig_State>() {
  return ::google::spanner::admin::instance::v1::InstanceConfig_State_descriptor();
}
template <> struct is_proto_enum< ::google::spanner::admin::instance::v1::Instance_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::spanner::admin::instance::v1::Instance_State>() {
  return ::google::spanner::admin::instance::v1::Instance_State_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_google_2fspanner_2fadmin_2finstance_2fv1_2fspanner_5finstance_5fadmin_2eproto
