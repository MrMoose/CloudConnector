// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/bigtable/admin/v2/table.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/field_behavior.pb.h"
#include "google/api/resource.pb.h"
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "google/rpc/status.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto;
namespace google {
namespace bigtable {
namespace admin {
namespace v2 {
class Backup;
struct BackupDefaultTypeInternal;
extern BackupDefaultTypeInternal _Backup_default_instance_;
class BackupInfo;
struct BackupInfoDefaultTypeInternal;
extern BackupInfoDefaultTypeInternal _BackupInfo_default_instance_;
class ColumnFamily;
struct ColumnFamilyDefaultTypeInternal;
extern ColumnFamilyDefaultTypeInternal _ColumnFamily_default_instance_;
class EncryptionInfo;
struct EncryptionInfoDefaultTypeInternal;
extern EncryptionInfoDefaultTypeInternal _EncryptionInfo_default_instance_;
class GcRule;
struct GcRuleDefaultTypeInternal;
extern GcRuleDefaultTypeInternal _GcRule_default_instance_;
class GcRule_Intersection;
struct GcRule_IntersectionDefaultTypeInternal;
extern GcRule_IntersectionDefaultTypeInternal _GcRule_Intersection_default_instance_;
class GcRule_Union;
struct GcRule_UnionDefaultTypeInternal;
extern GcRule_UnionDefaultTypeInternal _GcRule_Union_default_instance_;
class RestoreInfo;
struct RestoreInfoDefaultTypeInternal;
extern RestoreInfoDefaultTypeInternal _RestoreInfo_default_instance_;
class Snapshot;
struct SnapshotDefaultTypeInternal;
extern SnapshotDefaultTypeInternal _Snapshot_default_instance_;
class Table;
struct TableDefaultTypeInternal;
extern TableDefaultTypeInternal _Table_default_instance_;
class Table_ClusterState;
struct Table_ClusterStateDefaultTypeInternal;
extern Table_ClusterStateDefaultTypeInternal _Table_ClusterState_default_instance_;
class Table_ClusterStatesEntry_DoNotUse;
struct Table_ClusterStatesEntry_DoNotUseDefaultTypeInternal;
extern Table_ClusterStatesEntry_DoNotUseDefaultTypeInternal _Table_ClusterStatesEntry_DoNotUse_default_instance_;
class Table_ColumnFamiliesEntry_DoNotUse;
struct Table_ColumnFamiliesEntry_DoNotUseDefaultTypeInternal;
extern Table_ColumnFamiliesEntry_DoNotUseDefaultTypeInternal _Table_ColumnFamiliesEntry_DoNotUse_default_instance_;
}  // namespace v2
}  // namespace admin
}  // namespace bigtable
}  // namespace google
PROTOBUF_NAMESPACE_OPEN
template<> ::google::bigtable::admin::v2::Backup* Arena::CreateMaybeMessage<::google::bigtable::admin::v2::Backup>(Arena*);
template<> ::google::bigtable::admin::v2::BackupInfo* Arena::CreateMaybeMessage<::google::bigtable::admin::v2::BackupInfo>(Arena*);
template<> ::google::bigtable::admin::v2::ColumnFamily* Arena::CreateMaybeMessage<::google::bigtable::admin::v2::ColumnFamily>(Arena*);
template<> ::google::bigtable::admin::v2::EncryptionInfo* Arena::CreateMaybeMessage<::google::bigtable::admin::v2::EncryptionInfo>(Arena*);
template<> ::google::bigtable::admin::v2::GcRule* Arena::CreateMaybeMessage<::google::bigtable::admin::v2::GcRule>(Arena*);
template<> ::google::bigtable::admin::v2::GcRule_Intersection* Arena::CreateMaybeMessage<::google::bigtable::admin::v2::GcRule_Intersection>(Arena*);
template<> ::google::bigtable::admin::v2::GcRule_Union* Arena::CreateMaybeMessage<::google::bigtable::admin::v2::GcRule_Union>(Arena*);
template<> ::google::bigtable::admin::v2::RestoreInfo* Arena::CreateMaybeMessage<::google::bigtable::admin::v2::RestoreInfo>(Arena*);
template<> ::google::bigtable::admin::v2::Snapshot* Arena::CreateMaybeMessage<::google::bigtable::admin::v2::Snapshot>(Arena*);
template<> ::google::bigtable::admin::v2::Table* Arena::CreateMaybeMessage<::google::bigtable::admin::v2::Table>(Arena*);
template<> ::google::bigtable::admin::v2::Table_ClusterState* Arena::CreateMaybeMessage<::google::bigtable::admin::v2::Table_ClusterState>(Arena*);
template<> ::google::bigtable::admin::v2::Table_ClusterStatesEntry_DoNotUse* Arena::CreateMaybeMessage<::google::bigtable::admin::v2::Table_ClusterStatesEntry_DoNotUse>(Arena*);
template<> ::google::bigtable::admin::v2::Table_ColumnFamiliesEntry_DoNotUse* Arena::CreateMaybeMessage<::google::bigtable::admin::v2::Table_ColumnFamiliesEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace google {
namespace bigtable {
namespace admin {
namespace v2 {

enum Table_ClusterState_ReplicationState : int {
  Table_ClusterState_ReplicationState_STATE_NOT_KNOWN = 0,
  Table_ClusterState_ReplicationState_INITIALIZING = 1,
  Table_ClusterState_ReplicationState_PLANNED_MAINTENANCE = 2,
  Table_ClusterState_ReplicationState_UNPLANNED_MAINTENANCE = 3,
  Table_ClusterState_ReplicationState_READY = 4,
  Table_ClusterState_ReplicationState_READY_OPTIMIZING = 5,
  Table_ClusterState_ReplicationState_Table_ClusterState_ReplicationState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Table_ClusterState_ReplicationState_Table_ClusterState_ReplicationState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Table_ClusterState_ReplicationState_IsValid(int value);
constexpr Table_ClusterState_ReplicationState Table_ClusterState_ReplicationState_ReplicationState_MIN = Table_ClusterState_ReplicationState_STATE_NOT_KNOWN;
constexpr Table_ClusterState_ReplicationState Table_ClusterState_ReplicationState_ReplicationState_MAX = Table_ClusterState_ReplicationState_READY_OPTIMIZING;
constexpr int Table_ClusterState_ReplicationState_ReplicationState_ARRAYSIZE = Table_ClusterState_ReplicationState_ReplicationState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Table_ClusterState_ReplicationState_descriptor();
template<typename T>
inline const std::string& Table_ClusterState_ReplicationState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Table_ClusterState_ReplicationState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Table_ClusterState_ReplicationState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Table_ClusterState_ReplicationState_descriptor(), enum_t_value);
}
inline bool Table_ClusterState_ReplicationState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Table_ClusterState_ReplicationState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Table_ClusterState_ReplicationState>(
    Table_ClusterState_ReplicationState_descriptor(), name, value);
}
enum Table_TimestampGranularity : int {
  Table_TimestampGranularity_TIMESTAMP_GRANULARITY_UNSPECIFIED = 0,
  Table_TimestampGranularity_MILLIS = 1,
  Table_TimestampGranularity_Table_TimestampGranularity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Table_TimestampGranularity_Table_TimestampGranularity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Table_TimestampGranularity_IsValid(int value);
constexpr Table_TimestampGranularity Table_TimestampGranularity_TimestampGranularity_MIN = Table_TimestampGranularity_TIMESTAMP_GRANULARITY_UNSPECIFIED;
constexpr Table_TimestampGranularity Table_TimestampGranularity_TimestampGranularity_MAX = Table_TimestampGranularity_MILLIS;
constexpr int Table_TimestampGranularity_TimestampGranularity_ARRAYSIZE = Table_TimestampGranularity_TimestampGranularity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Table_TimestampGranularity_descriptor();
template<typename T>
inline const std::string& Table_TimestampGranularity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Table_TimestampGranularity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Table_TimestampGranularity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Table_TimestampGranularity_descriptor(), enum_t_value);
}
inline bool Table_TimestampGranularity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Table_TimestampGranularity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Table_TimestampGranularity>(
    Table_TimestampGranularity_descriptor(), name, value);
}
enum Table_View : int {
  Table_View_VIEW_UNSPECIFIED = 0,
  Table_View_NAME_ONLY = 1,
  Table_View_SCHEMA_VIEW = 2,
  Table_View_REPLICATION_VIEW = 3,
  Table_View_ENCRYPTION_VIEW = 5,
  Table_View_FULL = 4,
  Table_View_Table_View_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Table_View_Table_View_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Table_View_IsValid(int value);
constexpr Table_View Table_View_View_MIN = Table_View_VIEW_UNSPECIFIED;
constexpr Table_View Table_View_View_MAX = Table_View_ENCRYPTION_VIEW;
constexpr int Table_View_View_ARRAYSIZE = Table_View_View_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Table_View_descriptor();
template<typename T>
inline const std::string& Table_View_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Table_View>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Table_View_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Table_View_descriptor(), enum_t_value);
}
inline bool Table_View_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Table_View* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Table_View>(
    Table_View_descriptor(), name, value);
}
enum EncryptionInfo_EncryptionType : int {
  EncryptionInfo_EncryptionType_ENCRYPTION_TYPE_UNSPECIFIED = 0,
  EncryptionInfo_EncryptionType_GOOGLE_DEFAULT_ENCRYPTION = 1,
  EncryptionInfo_EncryptionType_CUSTOMER_MANAGED_ENCRYPTION = 2,
  EncryptionInfo_EncryptionType_EncryptionInfo_EncryptionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EncryptionInfo_EncryptionType_EncryptionInfo_EncryptionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EncryptionInfo_EncryptionType_IsValid(int value);
constexpr EncryptionInfo_EncryptionType EncryptionInfo_EncryptionType_EncryptionType_MIN = EncryptionInfo_EncryptionType_ENCRYPTION_TYPE_UNSPECIFIED;
constexpr EncryptionInfo_EncryptionType EncryptionInfo_EncryptionType_EncryptionType_MAX = EncryptionInfo_EncryptionType_CUSTOMER_MANAGED_ENCRYPTION;
constexpr int EncryptionInfo_EncryptionType_EncryptionType_ARRAYSIZE = EncryptionInfo_EncryptionType_EncryptionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EncryptionInfo_EncryptionType_descriptor();
template<typename T>
inline const std::string& EncryptionInfo_EncryptionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EncryptionInfo_EncryptionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EncryptionInfo_EncryptionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EncryptionInfo_EncryptionType_descriptor(), enum_t_value);
}
inline bool EncryptionInfo_EncryptionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EncryptionInfo_EncryptionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EncryptionInfo_EncryptionType>(
    EncryptionInfo_EncryptionType_descriptor(), name, value);
}
enum Snapshot_State : int {
  Snapshot_State_STATE_NOT_KNOWN = 0,
  Snapshot_State_READY = 1,
  Snapshot_State_CREATING = 2,
  Snapshot_State_Snapshot_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Snapshot_State_Snapshot_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Snapshot_State_IsValid(int value);
constexpr Snapshot_State Snapshot_State_State_MIN = Snapshot_State_STATE_NOT_KNOWN;
constexpr Snapshot_State Snapshot_State_State_MAX = Snapshot_State_CREATING;
constexpr int Snapshot_State_State_ARRAYSIZE = Snapshot_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Snapshot_State_descriptor();
template<typename T>
inline const std::string& Snapshot_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Snapshot_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Snapshot_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Snapshot_State_descriptor(), enum_t_value);
}
inline bool Snapshot_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Snapshot_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Snapshot_State>(
    Snapshot_State_descriptor(), name, value);
}
enum Backup_State : int {
  Backup_State_STATE_UNSPECIFIED = 0,
  Backup_State_CREATING = 1,
  Backup_State_READY = 2,
  Backup_State_Backup_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Backup_State_Backup_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Backup_State_IsValid(int value);
constexpr Backup_State Backup_State_State_MIN = Backup_State_STATE_UNSPECIFIED;
constexpr Backup_State Backup_State_State_MAX = Backup_State_READY;
constexpr int Backup_State_State_ARRAYSIZE = Backup_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Backup_State_descriptor();
template<typename T>
inline const std::string& Backup_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Backup_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Backup_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Backup_State_descriptor(), enum_t_value);
}
inline bool Backup_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Backup_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Backup_State>(
    Backup_State_descriptor(), name, value);
}
enum RestoreSourceType : int {
  RESTORE_SOURCE_TYPE_UNSPECIFIED = 0,
  BACKUP = 1,
  RestoreSourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RestoreSourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RestoreSourceType_IsValid(int value);
constexpr RestoreSourceType RestoreSourceType_MIN = RESTORE_SOURCE_TYPE_UNSPECIFIED;
constexpr RestoreSourceType RestoreSourceType_MAX = BACKUP;
constexpr int RestoreSourceType_ARRAYSIZE = RestoreSourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RestoreSourceType_descriptor();
template<typename T>
inline const std::string& RestoreSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RestoreSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RestoreSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RestoreSourceType_descriptor(), enum_t_value);
}
inline bool RestoreSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RestoreSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RestoreSourceType>(
    RestoreSourceType_descriptor(), name, value);
}
// ===================================================================

class RestoreInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.bigtable.admin.v2.RestoreInfo) */ {
 public:
  inline RestoreInfo() : RestoreInfo(nullptr) {}
  ~RestoreInfo() override;
  explicit PROTOBUF_CONSTEXPR RestoreInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RestoreInfo(const RestoreInfo& from);
  RestoreInfo(RestoreInfo&& from) noexcept
    : RestoreInfo() {
    *this = ::std::move(from);
  }

  inline RestoreInfo& operator=(const RestoreInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestoreInfo& operator=(RestoreInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestoreInfo& default_instance() {
    return *internal_default_instance();
  }
  enum SourceInfoCase {
    kBackupInfo = 2,
    SOURCE_INFO_NOT_SET = 0,
  };

  static inline const RestoreInfo* internal_default_instance() {
    return reinterpret_cast<const RestoreInfo*>(
               &_RestoreInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RestoreInfo& a, RestoreInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RestoreInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestoreInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestoreInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RestoreInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RestoreInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RestoreInfo& from) {
    RestoreInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestoreInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.bigtable.admin.v2.RestoreInfo";
  }
  protected:
  explicit RestoreInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceTypeFieldNumber = 1,
    kBackupInfoFieldNumber = 2,
  };
  // .google.bigtable.admin.v2.RestoreSourceType source_type = 1;
  void clear_source_type();
  ::google::bigtable::admin::v2::RestoreSourceType source_type() const;
  void set_source_type(::google::bigtable::admin::v2::RestoreSourceType value);
  private:
  ::google::bigtable::admin::v2::RestoreSourceType _internal_source_type() const;
  void _internal_set_source_type(::google::bigtable::admin::v2::RestoreSourceType value);
  public:

  // .google.bigtable.admin.v2.BackupInfo backup_info = 2;
  bool has_backup_info() const;
  private:
  bool _internal_has_backup_info() const;
  public:
  void clear_backup_info();
  const ::google::bigtable::admin::v2::BackupInfo& backup_info() const;
  PROTOBUF_NODISCARD ::google::bigtable::admin::v2::BackupInfo* release_backup_info();
  ::google::bigtable::admin::v2::BackupInfo* mutable_backup_info();
  void set_allocated_backup_info(::google::bigtable::admin::v2::BackupInfo* backup_info);
  private:
  const ::google::bigtable::admin::v2::BackupInfo& _internal_backup_info() const;
  ::google::bigtable::admin::v2::BackupInfo* _internal_mutable_backup_info();
  public:
  void unsafe_arena_set_allocated_backup_info(
      ::google::bigtable::admin::v2::BackupInfo* backup_info);
  ::google::bigtable::admin::v2::BackupInfo* unsafe_arena_release_backup_info();

  void clear_source_info();
  SourceInfoCase source_info_case() const;
  // @@protoc_insertion_point(class_scope:google.bigtable.admin.v2.RestoreInfo)
 private:
  class _Internal;
  void set_has_backup_info();

  inline bool has_source_info() const;
  inline void clear_has_source_info();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int source_type_;
    union SourceInfoUnion {
      constexpr SourceInfoUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::google::bigtable::admin::v2::BackupInfo* backup_info_;
    } source_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Table_ClusterState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.bigtable.admin.v2.Table.ClusterState) */ {
 public:
  inline Table_ClusterState() : Table_ClusterState(nullptr) {}
  ~Table_ClusterState() override;
  explicit PROTOBUF_CONSTEXPR Table_ClusterState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Table_ClusterState(const Table_ClusterState& from);
  Table_ClusterState(Table_ClusterState&& from) noexcept
    : Table_ClusterState() {
    *this = ::std::move(from);
  }

  inline Table_ClusterState& operator=(const Table_ClusterState& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table_ClusterState& operator=(Table_ClusterState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Table_ClusterState& default_instance() {
    return *internal_default_instance();
  }
  static inline const Table_ClusterState* internal_default_instance() {
    return reinterpret_cast<const Table_ClusterState*>(
               &_Table_ClusterState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Table_ClusterState& a, Table_ClusterState& b) {
    a.Swap(&b);
  }
  inline void Swap(Table_ClusterState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table_ClusterState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Table_ClusterState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Table_ClusterState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Table_ClusterState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Table_ClusterState& from) {
    Table_ClusterState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Table_ClusterState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.bigtable.admin.v2.Table.ClusterState";
  }
  protected:
  explicit Table_ClusterState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Table_ClusterState_ReplicationState ReplicationState;
  static constexpr ReplicationState STATE_NOT_KNOWN =
    Table_ClusterState_ReplicationState_STATE_NOT_KNOWN;
  static constexpr ReplicationState INITIALIZING =
    Table_ClusterState_ReplicationState_INITIALIZING;
  static constexpr ReplicationState PLANNED_MAINTENANCE =
    Table_ClusterState_ReplicationState_PLANNED_MAINTENANCE;
  static constexpr ReplicationState UNPLANNED_MAINTENANCE =
    Table_ClusterState_ReplicationState_UNPLANNED_MAINTENANCE;
  static constexpr ReplicationState READY =
    Table_ClusterState_ReplicationState_READY;
  static constexpr ReplicationState READY_OPTIMIZING =
    Table_ClusterState_ReplicationState_READY_OPTIMIZING;
  static inline bool ReplicationState_IsValid(int value) {
    return Table_ClusterState_ReplicationState_IsValid(value);
  }
  static constexpr ReplicationState ReplicationState_MIN =
    Table_ClusterState_ReplicationState_ReplicationState_MIN;
  static constexpr ReplicationState ReplicationState_MAX =
    Table_ClusterState_ReplicationState_ReplicationState_MAX;
  static constexpr int ReplicationState_ARRAYSIZE =
    Table_ClusterState_ReplicationState_ReplicationState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ReplicationState_descriptor() {
    return Table_ClusterState_ReplicationState_descriptor();
  }
  template<typename T>
  static inline const std::string& ReplicationState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ReplicationState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ReplicationState_Name.");
    return Table_ClusterState_ReplicationState_Name(enum_t_value);
  }
  static inline bool ReplicationState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ReplicationState* value) {
    return Table_ClusterState_ReplicationState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEncryptionInfoFieldNumber = 2,
    kReplicationStateFieldNumber = 1,
  };
  // repeated .google.bigtable.admin.v2.EncryptionInfo encryption_info = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
  int encryption_info_size() const;
  private:
  int _internal_encryption_info_size() const;
  public:
  void clear_encryption_info();
  ::google::bigtable::admin::v2::EncryptionInfo* mutable_encryption_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::bigtable::admin::v2::EncryptionInfo >*
      mutable_encryption_info();
  private:
  const ::google::bigtable::admin::v2::EncryptionInfo& _internal_encryption_info(int index) const;
  ::google::bigtable::admin::v2::EncryptionInfo* _internal_add_encryption_info();
  public:
  const ::google::bigtable::admin::v2::EncryptionInfo& encryption_info(int index) const;
  ::google::bigtable::admin::v2::EncryptionInfo* add_encryption_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::bigtable::admin::v2::EncryptionInfo >&
      encryption_info() const;

  // .google.bigtable.admin.v2.Table.ClusterState.ReplicationState replication_state = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_replication_state();
  ::google::bigtable::admin::v2::Table_ClusterState_ReplicationState replication_state() const;
  void set_replication_state(::google::bigtable::admin::v2::Table_ClusterState_ReplicationState value);
  private:
  ::google::bigtable::admin::v2::Table_ClusterState_ReplicationState _internal_replication_state() const;
  void _internal_set_replication_state(::google::bigtable::admin::v2::Table_ClusterState_ReplicationState value);
  public:

  // @@protoc_insertion_point(class_scope:google.bigtable.admin.v2.Table.ClusterState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::bigtable::admin::v2::EncryptionInfo > encryption_info_;
    int replication_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Table_ClusterStatesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Table_ClusterStatesEntry_DoNotUse, 
    std::string, ::google::bigtable::admin::v2::Table_ClusterState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Table_ClusterStatesEntry_DoNotUse, 
    std::string, ::google::bigtable::admin::v2::Table_ClusterState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Table_ClusterStatesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Table_ClusterStatesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Table_ClusterStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Table_ClusterStatesEntry_DoNotUse& other);
  static const Table_ClusterStatesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Table_ClusterStatesEntry_DoNotUse*>(&_Table_ClusterStatesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.bigtable.admin.v2.Table.ClusterStatesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto;
};

// -------------------------------------------------------------------

class Table_ColumnFamiliesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Table_ColumnFamiliesEntry_DoNotUse, 
    std::string, ::google::bigtable::admin::v2::ColumnFamily,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Table_ColumnFamiliesEntry_DoNotUse, 
    std::string, ::google::bigtable::admin::v2::ColumnFamily,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Table_ColumnFamiliesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Table_ColumnFamiliesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Table_ColumnFamiliesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Table_ColumnFamiliesEntry_DoNotUse& other);
  static const Table_ColumnFamiliesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Table_ColumnFamiliesEntry_DoNotUse*>(&_Table_ColumnFamiliesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "google.bigtable.admin.v2.Table.ColumnFamiliesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto;
};

// -------------------------------------------------------------------

class Table final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.bigtable.admin.v2.Table) */ {
 public:
  inline Table() : Table(nullptr) {}
  ~Table() override;
  explicit PROTOBUF_CONSTEXPR Table(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Table(const Table& from);
  Table(Table&& from) noexcept
    : Table() {
    *this = ::std::move(from);
  }

  inline Table& operator=(const Table& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table& operator=(Table&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Table& default_instance() {
    return *internal_default_instance();
  }
  static inline const Table* internal_default_instance() {
    return reinterpret_cast<const Table*>(
               &_Table_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Table& a, Table& b) {
    a.Swap(&b);
  }
  inline void Swap(Table* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Table* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Table>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Table& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Table& from) {
    Table::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Table* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.bigtable.admin.v2.Table";
  }
  protected:
  explicit Table(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Table_ClusterState ClusterState;

  typedef Table_TimestampGranularity TimestampGranularity;
  static constexpr TimestampGranularity TIMESTAMP_GRANULARITY_UNSPECIFIED =
    Table_TimestampGranularity_TIMESTAMP_GRANULARITY_UNSPECIFIED;
  static constexpr TimestampGranularity MILLIS =
    Table_TimestampGranularity_MILLIS;
  static inline bool TimestampGranularity_IsValid(int value) {
    return Table_TimestampGranularity_IsValid(value);
  }
  static constexpr TimestampGranularity TimestampGranularity_MIN =
    Table_TimestampGranularity_TimestampGranularity_MIN;
  static constexpr TimestampGranularity TimestampGranularity_MAX =
    Table_TimestampGranularity_TimestampGranularity_MAX;
  static constexpr int TimestampGranularity_ARRAYSIZE =
    Table_TimestampGranularity_TimestampGranularity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TimestampGranularity_descriptor() {
    return Table_TimestampGranularity_descriptor();
  }
  template<typename T>
  static inline const std::string& TimestampGranularity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TimestampGranularity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TimestampGranularity_Name.");
    return Table_TimestampGranularity_Name(enum_t_value);
  }
  static inline bool TimestampGranularity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TimestampGranularity* value) {
    return Table_TimestampGranularity_Parse(name, value);
  }

  typedef Table_View View;
  static constexpr View VIEW_UNSPECIFIED =
    Table_View_VIEW_UNSPECIFIED;
  static constexpr View NAME_ONLY =
    Table_View_NAME_ONLY;
  static constexpr View SCHEMA_VIEW =
    Table_View_SCHEMA_VIEW;
  static constexpr View REPLICATION_VIEW =
    Table_View_REPLICATION_VIEW;
  static constexpr View ENCRYPTION_VIEW =
    Table_View_ENCRYPTION_VIEW;
  static constexpr View FULL =
    Table_View_FULL;
  static inline bool View_IsValid(int value) {
    return Table_View_IsValid(value);
  }
  static constexpr View View_MIN =
    Table_View_View_MIN;
  static constexpr View View_MAX =
    Table_View_View_MAX;
  static constexpr int View_ARRAYSIZE =
    Table_View_View_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  View_descriptor() {
    return Table_View_descriptor();
  }
  template<typename T>
  static inline const std::string& View_Name(T enum_t_value) {
    static_assert(::std::is_same<T, View>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function View_Name.");
    return Table_View_Name(enum_t_value);
  }
  static inline bool View_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      View* value) {
    return Table_View_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClusterStatesFieldNumber = 2,
    kColumnFamiliesFieldNumber = 3,
    kNameFieldNumber = 1,
    kRestoreInfoFieldNumber = 6,
    kGranularityFieldNumber = 4,
    kDeletionProtectionFieldNumber = 9,
  };
  // map<string, .google.bigtable.admin.v2.Table.ClusterState> cluster_states = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
  int cluster_states_size() const;
  private:
  int _internal_cluster_states_size() const;
  public:
  void clear_cluster_states();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::Table_ClusterState >&
      _internal_cluster_states() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::Table_ClusterState >*
      _internal_mutable_cluster_states();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::Table_ClusterState >&
      cluster_states() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::Table_ClusterState >*
      mutable_cluster_states();

  // map<string, .google.bigtable.admin.v2.ColumnFamily> column_families = 3;
  int column_families_size() const;
  private:
  int _internal_column_families_size() const;
  public:
  void clear_column_families();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::ColumnFamily >&
      _internal_column_families() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::ColumnFamily >*
      _internal_mutable_column_families();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::ColumnFamily >&
      column_families() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::ColumnFamily >*
      mutable_column_families();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.bigtable.admin.v2.RestoreInfo restore_info = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_restore_info() const;
  private:
  bool _internal_has_restore_info() const;
  public:
  void clear_restore_info();
  const ::google::bigtable::admin::v2::RestoreInfo& restore_info() const;
  PROTOBUF_NODISCARD ::google::bigtable::admin::v2::RestoreInfo* release_restore_info();
  ::google::bigtable::admin::v2::RestoreInfo* mutable_restore_info();
  void set_allocated_restore_info(::google::bigtable::admin::v2::RestoreInfo* restore_info);
  private:
  const ::google::bigtable::admin::v2::RestoreInfo& _internal_restore_info() const;
  ::google::bigtable::admin::v2::RestoreInfo* _internal_mutable_restore_info();
  public:
  void unsafe_arena_set_allocated_restore_info(
      ::google::bigtable::admin::v2::RestoreInfo* restore_info);
  ::google::bigtable::admin::v2::RestoreInfo* unsafe_arena_release_restore_info();

  // .google.bigtable.admin.v2.Table.TimestampGranularity granularity = 4 [(.google.api.field_behavior) = IMMUTABLE];
  void clear_granularity();
  ::google::bigtable::admin::v2::Table_TimestampGranularity granularity() const;
  void set_granularity(::google::bigtable::admin::v2::Table_TimestampGranularity value);
  private:
  ::google::bigtable::admin::v2::Table_TimestampGranularity _internal_granularity() const;
  void _internal_set_granularity(::google::bigtable::admin::v2::Table_TimestampGranularity value);
  public:

  // bool deletion_protection = 9;
  void clear_deletion_protection();
  bool deletion_protection() const;
  void set_deletion_protection(bool value);
  private:
  bool _internal_deletion_protection() const;
  void _internal_set_deletion_protection(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.bigtable.admin.v2.Table)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Table_ClusterStatesEntry_DoNotUse,
        std::string, ::google::bigtable::admin::v2::Table_ClusterState,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> cluster_states_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Table_ColumnFamiliesEntry_DoNotUse,
        std::string, ::google::bigtable::admin::v2::ColumnFamily,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> column_families_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::google::bigtable::admin::v2::RestoreInfo* restore_info_;
    int granularity_;
    bool deletion_protection_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ColumnFamily final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.bigtable.admin.v2.ColumnFamily) */ {
 public:
  inline ColumnFamily() : ColumnFamily(nullptr) {}
  ~ColumnFamily() override;
  explicit PROTOBUF_CONSTEXPR ColumnFamily(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnFamily(const ColumnFamily& from);
  ColumnFamily(ColumnFamily&& from) noexcept
    : ColumnFamily() {
    *this = ::std::move(from);
  }

  inline ColumnFamily& operator=(const ColumnFamily& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnFamily& operator=(ColumnFamily&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnFamily& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnFamily* internal_default_instance() {
    return reinterpret_cast<const ColumnFamily*>(
               &_ColumnFamily_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ColumnFamily& a, ColumnFamily& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnFamily* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnFamily* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnFamily* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnFamily>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnFamily& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnFamily& from) {
    ColumnFamily::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnFamily* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.bigtable.admin.v2.ColumnFamily";
  }
  protected:
  explicit ColumnFamily(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGcRuleFieldNumber = 1,
  };
  // .google.bigtable.admin.v2.GcRule gc_rule = 1;
  bool has_gc_rule() const;
  private:
  bool _internal_has_gc_rule() const;
  public:
  void clear_gc_rule();
  const ::google::bigtable::admin::v2::GcRule& gc_rule() const;
  PROTOBUF_NODISCARD ::google::bigtable::admin::v2::GcRule* release_gc_rule();
  ::google::bigtable::admin::v2::GcRule* mutable_gc_rule();
  void set_allocated_gc_rule(::google::bigtable::admin::v2::GcRule* gc_rule);
  private:
  const ::google::bigtable::admin::v2::GcRule& _internal_gc_rule() const;
  ::google::bigtable::admin::v2::GcRule* _internal_mutable_gc_rule();
  public:
  void unsafe_arena_set_allocated_gc_rule(
      ::google::bigtable::admin::v2::GcRule* gc_rule);
  ::google::bigtable::admin::v2::GcRule* unsafe_arena_release_gc_rule();

  // @@protoc_insertion_point(class_scope:google.bigtable.admin.v2.ColumnFamily)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::bigtable::admin::v2::GcRule* gc_rule_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto;
};
// -------------------------------------------------------------------

class GcRule_Intersection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.bigtable.admin.v2.GcRule.Intersection) */ {
 public:
  inline GcRule_Intersection() : GcRule_Intersection(nullptr) {}
  ~GcRule_Intersection() override;
  explicit PROTOBUF_CONSTEXPR GcRule_Intersection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GcRule_Intersection(const GcRule_Intersection& from);
  GcRule_Intersection(GcRule_Intersection&& from) noexcept
    : GcRule_Intersection() {
    *this = ::std::move(from);
  }

  inline GcRule_Intersection& operator=(const GcRule_Intersection& from) {
    CopyFrom(from);
    return *this;
  }
  inline GcRule_Intersection& operator=(GcRule_Intersection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GcRule_Intersection& default_instance() {
    return *internal_default_instance();
  }
  static inline const GcRule_Intersection* internal_default_instance() {
    return reinterpret_cast<const GcRule_Intersection*>(
               &_GcRule_Intersection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GcRule_Intersection& a, GcRule_Intersection& b) {
    a.Swap(&b);
  }
  inline void Swap(GcRule_Intersection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GcRule_Intersection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GcRule_Intersection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GcRule_Intersection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GcRule_Intersection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GcRule_Intersection& from) {
    GcRule_Intersection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GcRule_Intersection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.bigtable.admin.v2.GcRule.Intersection";
  }
  protected:
  explicit GcRule_Intersection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRulesFieldNumber = 1,
  };
  // repeated .google.bigtable.admin.v2.GcRule rules = 1;
  int rules_size() const;
  private:
  int _internal_rules_size() const;
  public:
  void clear_rules();
  ::google::bigtable::admin::v2::GcRule* mutable_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::bigtable::admin::v2::GcRule >*
      mutable_rules();
  private:
  const ::google::bigtable::admin::v2::GcRule& _internal_rules(int index) const;
  ::google::bigtable::admin::v2::GcRule* _internal_add_rules();
  public:
  const ::google::bigtable::admin::v2::GcRule& rules(int index) const;
  ::google::bigtable::admin::v2::GcRule* add_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::bigtable::admin::v2::GcRule >&
      rules() const;

  // @@protoc_insertion_point(class_scope:google.bigtable.admin.v2.GcRule.Intersection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::bigtable::admin::v2::GcRule > rules_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto;
};
// -------------------------------------------------------------------

class GcRule_Union final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.bigtable.admin.v2.GcRule.Union) */ {
 public:
  inline GcRule_Union() : GcRule_Union(nullptr) {}
  ~GcRule_Union() override;
  explicit PROTOBUF_CONSTEXPR GcRule_Union(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GcRule_Union(const GcRule_Union& from);
  GcRule_Union(GcRule_Union&& from) noexcept
    : GcRule_Union() {
    *this = ::std::move(from);
  }

  inline GcRule_Union& operator=(const GcRule_Union& from) {
    CopyFrom(from);
    return *this;
  }
  inline GcRule_Union& operator=(GcRule_Union&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GcRule_Union& default_instance() {
    return *internal_default_instance();
  }
  static inline const GcRule_Union* internal_default_instance() {
    return reinterpret_cast<const GcRule_Union*>(
               &_GcRule_Union_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GcRule_Union& a, GcRule_Union& b) {
    a.Swap(&b);
  }
  inline void Swap(GcRule_Union* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GcRule_Union* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GcRule_Union* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GcRule_Union>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GcRule_Union& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GcRule_Union& from) {
    GcRule_Union::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GcRule_Union* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.bigtable.admin.v2.GcRule.Union";
  }
  protected:
  explicit GcRule_Union(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRulesFieldNumber = 1,
  };
  // repeated .google.bigtable.admin.v2.GcRule rules = 1;
  int rules_size() const;
  private:
  int _internal_rules_size() const;
  public:
  void clear_rules();
  ::google::bigtable::admin::v2::GcRule* mutable_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::bigtable::admin::v2::GcRule >*
      mutable_rules();
  private:
  const ::google::bigtable::admin::v2::GcRule& _internal_rules(int index) const;
  ::google::bigtable::admin::v2::GcRule* _internal_add_rules();
  public:
  const ::google::bigtable::admin::v2::GcRule& rules(int index) const;
  ::google::bigtable::admin::v2::GcRule* add_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::bigtable::admin::v2::GcRule >&
      rules() const;

  // @@protoc_insertion_point(class_scope:google.bigtable.admin.v2.GcRule.Union)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::bigtable::admin::v2::GcRule > rules_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto;
};
// -------------------------------------------------------------------

class GcRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.bigtable.admin.v2.GcRule) */ {
 public:
  inline GcRule() : GcRule(nullptr) {}
  ~GcRule() override;
  explicit PROTOBUF_CONSTEXPR GcRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GcRule(const GcRule& from);
  GcRule(GcRule&& from) noexcept
    : GcRule() {
    *this = ::std::move(from);
  }

  inline GcRule& operator=(const GcRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline GcRule& operator=(GcRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GcRule& default_instance() {
    return *internal_default_instance();
  }
  enum RuleCase {
    kMaxNumVersions = 1,
    kMaxAge = 2,
    kIntersection = 3,
    kUnion = 4,
    RULE_NOT_SET = 0,
  };

  static inline const GcRule* internal_default_instance() {
    return reinterpret_cast<const GcRule*>(
               &_GcRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GcRule& a, GcRule& b) {
    a.Swap(&b);
  }
  inline void Swap(GcRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GcRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GcRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GcRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GcRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GcRule& from) {
    GcRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GcRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.bigtable.admin.v2.GcRule";
  }
  protected:
  explicit GcRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GcRule_Intersection Intersection;
  typedef GcRule_Union Union;

  // accessors -------------------------------------------------------

  enum : int {
    kMaxNumVersionsFieldNumber = 1,
    kMaxAgeFieldNumber = 2,
    kIntersectionFieldNumber = 3,
    kUnionFieldNumber = 4,
  };
  // int32 max_num_versions = 1;
  bool has_max_num_versions() const;
  private:
  bool _internal_has_max_num_versions() const;
  public:
  void clear_max_num_versions();
  int32_t max_num_versions() const;
  void set_max_num_versions(int32_t value);
  private:
  int32_t _internal_max_num_versions() const;
  void _internal_set_max_num_versions(int32_t value);
  public:

  // .google.protobuf.Duration max_age = 2;
  bool has_max_age() const;
  private:
  bool _internal_has_max_age() const;
  public:
  void clear_max_age();
  const ::PROTOBUF_NAMESPACE_ID::Duration& max_age() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_max_age();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_max_age();
  void set_allocated_max_age(::PROTOBUF_NAMESPACE_ID::Duration* max_age);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_max_age() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_max_age();
  public:
  void unsafe_arena_set_allocated_max_age(
      ::PROTOBUF_NAMESPACE_ID::Duration* max_age);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_max_age();

  // .google.bigtable.admin.v2.GcRule.Intersection intersection = 3;
  bool has_intersection() const;
  private:
  bool _internal_has_intersection() const;
  public:
  void clear_intersection();
  const ::google::bigtable::admin::v2::GcRule_Intersection& intersection() const;
  PROTOBUF_NODISCARD ::google::bigtable::admin::v2::GcRule_Intersection* release_intersection();
  ::google::bigtable::admin::v2::GcRule_Intersection* mutable_intersection();
  void set_allocated_intersection(::google::bigtable::admin::v2::GcRule_Intersection* intersection);
  private:
  const ::google::bigtable::admin::v2::GcRule_Intersection& _internal_intersection() const;
  ::google::bigtable::admin::v2::GcRule_Intersection* _internal_mutable_intersection();
  public:
  void unsafe_arena_set_allocated_intersection(
      ::google::bigtable::admin::v2::GcRule_Intersection* intersection);
  ::google::bigtable::admin::v2::GcRule_Intersection* unsafe_arena_release_intersection();

  // .google.bigtable.admin.v2.GcRule.Union union = 4;
  bool has_union_() const;
  private:
  bool _internal_has_union_() const;
  public:
  void clear_union_();
  const ::google::bigtable::admin::v2::GcRule_Union& union_() const;
  PROTOBUF_NODISCARD ::google::bigtable::admin::v2::GcRule_Union* release_union_();
  ::google::bigtable::admin::v2::GcRule_Union* mutable_union_();
  void set_allocated_union_(::google::bigtable::admin::v2::GcRule_Union* union_);
  private:
  const ::google::bigtable::admin::v2::GcRule_Union& _internal_union_() const;
  ::google::bigtable::admin::v2::GcRule_Union* _internal_mutable_union_();
  public:
  void unsafe_arena_set_allocated_union_(
      ::google::bigtable::admin::v2::GcRule_Union* union_);
  ::google::bigtable::admin::v2::GcRule_Union* unsafe_arena_release_union_();

  void clear_rule();
  RuleCase rule_case() const;
  // @@protoc_insertion_point(class_scope:google.bigtable.admin.v2.GcRule)
 private:
  class _Internal;
  void set_has_max_num_versions();
  void set_has_max_age();
  void set_has_intersection();
  void set_has_union_();

  inline bool has_rule() const;
  inline void clear_has_rule();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RuleUnion {
      constexpr RuleUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int32_t max_num_versions_;
      ::PROTOBUF_NAMESPACE_ID::Duration* max_age_;
      ::google::bigtable::admin::v2::GcRule_Intersection* intersection_;
      ::google::bigtable::admin::v2::GcRule_Union* union__;
    } rule_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto;
};
// -------------------------------------------------------------------

class EncryptionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.bigtable.admin.v2.EncryptionInfo) */ {
 public:
  inline EncryptionInfo() : EncryptionInfo(nullptr) {}
  ~EncryptionInfo() override;
  explicit PROTOBUF_CONSTEXPR EncryptionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EncryptionInfo(const EncryptionInfo& from);
  EncryptionInfo(EncryptionInfo&& from) noexcept
    : EncryptionInfo() {
    *this = ::std::move(from);
  }

  inline EncryptionInfo& operator=(const EncryptionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncryptionInfo& operator=(EncryptionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncryptionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncryptionInfo* internal_default_instance() {
    return reinterpret_cast<const EncryptionInfo*>(
               &_EncryptionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EncryptionInfo& a, EncryptionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(EncryptionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncryptionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncryptionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EncryptionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EncryptionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EncryptionInfo& from) {
    EncryptionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncryptionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.bigtable.admin.v2.EncryptionInfo";
  }
  protected:
  explicit EncryptionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EncryptionInfo_EncryptionType EncryptionType;
  static constexpr EncryptionType ENCRYPTION_TYPE_UNSPECIFIED =
    EncryptionInfo_EncryptionType_ENCRYPTION_TYPE_UNSPECIFIED;
  static constexpr EncryptionType GOOGLE_DEFAULT_ENCRYPTION =
    EncryptionInfo_EncryptionType_GOOGLE_DEFAULT_ENCRYPTION;
  static constexpr EncryptionType CUSTOMER_MANAGED_ENCRYPTION =
    EncryptionInfo_EncryptionType_CUSTOMER_MANAGED_ENCRYPTION;
  static inline bool EncryptionType_IsValid(int value) {
    return EncryptionInfo_EncryptionType_IsValid(value);
  }
  static constexpr EncryptionType EncryptionType_MIN =
    EncryptionInfo_EncryptionType_EncryptionType_MIN;
  static constexpr EncryptionType EncryptionType_MAX =
    EncryptionInfo_EncryptionType_EncryptionType_MAX;
  static constexpr int EncryptionType_ARRAYSIZE =
    EncryptionInfo_EncryptionType_EncryptionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EncryptionType_descriptor() {
    return EncryptionInfo_EncryptionType_descriptor();
  }
  template<typename T>
  static inline const std::string& EncryptionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EncryptionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EncryptionType_Name.");
    return EncryptionInfo_EncryptionType_Name(enum_t_value);
  }
  static inline bool EncryptionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EncryptionType* value) {
    return EncryptionInfo_EncryptionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKmsKeyVersionFieldNumber = 2,
    kEncryptionStatusFieldNumber = 4,
    kEncryptionTypeFieldNumber = 3,
  };
  // string kms_key_version = 2 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.resource_reference) = {
  void clear_kms_key_version();
  const std::string& kms_key_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kms_key_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kms_key_version();
  PROTOBUF_NODISCARD std::string* release_kms_key_version();
  void set_allocated_kms_key_version(std::string* kms_key_version);
  private:
  const std::string& _internal_kms_key_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kms_key_version(const std::string& value);
  std::string* _internal_mutable_kms_key_version();
  public:

  // .google.rpc.Status encryption_status = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_encryption_status() const;
  private:
  bool _internal_has_encryption_status() const;
  public:
  void clear_encryption_status();
  const ::google::rpc::Status& encryption_status() const;
  PROTOBUF_NODISCARD ::google::rpc::Status* release_encryption_status();
  ::google::rpc::Status* mutable_encryption_status();
  void set_allocated_encryption_status(::google::rpc::Status* encryption_status);
  private:
  const ::google::rpc::Status& _internal_encryption_status() const;
  ::google::rpc::Status* _internal_mutable_encryption_status();
  public:
  void unsafe_arena_set_allocated_encryption_status(
      ::google::rpc::Status* encryption_status);
  ::google::rpc::Status* unsafe_arena_release_encryption_status();

  // .google.bigtable.admin.v2.EncryptionInfo.EncryptionType encryption_type = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_encryption_type();
  ::google::bigtable::admin::v2::EncryptionInfo_EncryptionType encryption_type() const;
  void set_encryption_type(::google::bigtable::admin::v2::EncryptionInfo_EncryptionType value);
  private:
  ::google::bigtable::admin::v2::EncryptionInfo_EncryptionType _internal_encryption_type() const;
  void _internal_set_encryption_type(::google::bigtable::admin::v2::EncryptionInfo_EncryptionType value);
  public:

  // @@protoc_insertion_point(class_scope:google.bigtable.admin.v2.EncryptionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kms_key_version_;
    ::google::rpc::Status* encryption_status_;
    int encryption_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Snapshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.bigtable.admin.v2.Snapshot) */ {
 public:
  inline Snapshot() : Snapshot(nullptr) {}
  ~Snapshot() override;
  explicit PROTOBUF_CONSTEXPR Snapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Snapshot(const Snapshot& from);
  Snapshot(Snapshot&& from) noexcept
    : Snapshot() {
    *this = ::std::move(from);
  }

  inline Snapshot& operator=(const Snapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Snapshot& operator=(Snapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Snapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Snapshot* internal_default_instance() {
    return reinterpret_cast<const Snapshot*>(
               &_Snapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Snapshot& a, Snapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(Snapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Snapshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Snapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Snapshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Snapshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Snapshot& from) {
    Snapshot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Snapshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.bigtable.admin.v2.Snapshot";
  }
  protected:
  explicit Snapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Snapshot_State State;
  static constexpr State STATE_NOT_KNOWN =
    Snapshot_State_STATE_NOT_KNOWN;
  static constexpr State READY =
    Snapshot_State_READY;
  static constexpr State CREATING =
    Snapshot_State_CREATING;
  static inline bool State_IsValid(int value) {
    return Snapshot_State_IsValid(value);
  }
  static constexpr State State_MIN =
    Snapshot_State_State_MIN;
  static constexpr State State_MAX =
    Snapshot_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    Snapshot_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return Snapshot_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return Snapshot_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return Snapshot_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 7,
    kSourceTableFieldNumber = 2,
    kCreateTimeFieldNumber = 4,
    kDeleteTimeFieldNumber = 5,
    kDataSizeBytesFieldNumber = 3,
    kStateFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 7;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .google.bigtable.admin.v2.Table source_table = 2;
  bool has_source_table() const;
  private:
  bool _internal_has_source_table() const;
  public:
  void clear_source_table();
  const ::google::bigtable::admin::v2::Table& source_table() const;
  PROTOBUF_NODISCARD ::google::bigtable::admin::v2::Table* release_source_table();
  ::google::bigtable::admin::v2::Table* mutable_source_table();
  void set_allocated_source_table(::google::bigtable::admin::v2::Table* source_table);
  private:
  const ::google::bigtable::admin::v2::Table& _internal_source_table() const;
  ::google::bigtable::admin::v2::Table* _internal_mutable_source_table();
  public:
  void unsafe_arena_set_allocated_source_table(
      ::google::bigtable::admin::v2::Table* source_table);
  ::google::bigtable::admin::v2::Table* unsafe_arena_release_source_table();

  // .google.protobuf.Timestamp create_time = 4;
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_time();
  void set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_time();
  public:
  void unsafe_arena_set_allocated_create_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_time();

  // .google.protobuf.Timestamp delete_time = 5;
  bool has_delete_time() const;
  private:
  bool _internal_has_delete_time() const;
  public:
  void clear_delete_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& delete_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_delete_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_delete_time();
  void set_allocated_delete_time(::PROTOBUF_NAMESPACE_ID::Timestamp* delete_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_delete_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_delete_time();
  public:
  void unsafe_arena_set_allocated_delete_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* delete_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_delete_time();

  // int64 data_size_bytes = 3;
  void clear_data_size_bytes();
  int64_t data_size_bytes() const;
  void set_data_size_bytes(int64_t value);
  private:
  int64_t _internal_data_size_bytes() const;
  void _internal_set_data_size_bytes(int64_t value);
  public:

  // .google.bigtable.admin.v2.Snapshot.State state = 6;
  void clear_state();
  ::google::bigtable::admin::v2::Snapshot_State state() const;
  void set_state(::google::bigtable::admin::v2::Snapshot_State value);
  private:
  ::google::bigtable::admin::v2::Snapshot_State _internal_state() const;
  void _internal_set_state(::google::bigtable::admin::v2::Snapshot_State value);
  public:

  // @@protoc_insertion_point(class_scope:google.bigtable.admin.v2.Snapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::google::bigtable::admin::v2::Table* source_table_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* delete_time_;
    int64_t data_size_bytes_;
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Backup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.bigtable.admin.v2.Backup) */ {
 public:
  inline Backup() : Backup(nullptr) {}
  ~Backup() override;
  explicit PROTOBUF_CONSTEXPR Backup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Backup(const Backup& from);
  Backup(Backup&& from) noexcept
    : Backup() {
    *this = ::std::move(from);
  }

  inline Backup& operator=(const Backup& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backup& operator=(Backup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Backup& default_instance() {
    return *internal_default_instance();
  }
  static inline const Backup* internal_default_instance() {
    return reinterpret_cast<const Backup*>(
               &_Backup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Backup& a, Backup& b) {
    a.Swap(&b);
  }
  inline void Swap(Backup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Backup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Backup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Backup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Backup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Backup& from) {
    Backup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.bigtable.admin.v2.Backup";
  }
  protected:
  explicit Backup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Backup_State State;
  static constexpr State STATE_UNSPECIFIED =
    Backup_State_STATE_UNSPECIFIED;
  static constexpr State CREATING =
    Backup_State_CREATING;
  static constexpr State READY =
    Backup_State_READY;
  static inline bool State_IsValid(int value) {
    return Backup_State_IsValid(value);
  }
  static constexpr State State_MIN =
    Backup_State_State_MIN;
  static constexpr State State_MAX =
    Backup_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    Backup_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return Backup_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return Backup_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return Backup_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSourceTableFieldNumber = 2,
    kExpireTimeFieldNumber = 3,
    kStartTimeFieldNumber = 4,
    kEndTimeFieldNumber = 5,
    kEncryptionInfoFieldNumber = 9,
    kSizeBytesFieldNumber = 6,
    kStateFieldNumber = 7,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string source_table = 2 [(.google.api.field_behavior) = IMMUTABLE, (.google.api.field_behavior) = REQUIRED];
  void clear_source_table();
  const std::string& source_table() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_table(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_table();
  PROTOBUF_NODISCARD std::string* release_source_table();
  void set_allocated_source_table(std::string* source_table);
  private:
  const std::string& _internal_source_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_table(const std::string& value);
  std::string* _internal_mutable_source_table();
  public:

  // .google.protobuf.Timestamp expire_time = 3 [(.google.api.field_behavior) = REQUIRED];
  bool has_expire_time() const;
  private:
  bool _internal_has_expire_time() const;
  public:
  void clear_expire_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& expire_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_expire_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_expire_time();
  void set_allocated_expire_time(::PROTOBUF_NAMESPACE_ID::Timestamp* expire_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_expire_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_expire_time();
  public:
  void unsafe_arena_set_allocated_expire_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* expire_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_expire_time();

  // .google.protobuf.Timestamp start_time = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // .google.bigtable.admin.v2.EncryptionInfo encryption_info = 9 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_encryption_info() const;
  private:
  bool _internal_has_encryption_info() const;
  public:
  void clear_encryption_info();
  const ::google::bigtable::admin::v2::EncryptionInfo& encryption_info() const;
  PROTOBUF_NODISCARD ::google::bigtable::admin::v2::EncryptionInfo* release_encryption_info();
  ::google::bigtable::admin::v2::EncryptionInfo* mutable_encryption_info();
  void set_allocated_encryption_info(::google::bigtable::admin::v2::EncryptionInfo* encryption_info);
  private:
  const ::google::bigtable::admin::v2::EncryptionInfo& _internal_encryption_info() const;
  ::google::bigtable::admin::v2::EncryptionInfo* _internal_mutable_encryption_info();
  public:
  void unsafe_arena_set_allocated_encryption_info(
      ::google::bigtable::admin::v2::EncryptionInfo* encryption_info);
  ::google::bigtable::admin::v2::EncryptionInfo* unsafe_arena_release_encryption_info();

  // int64 size_bytes = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_size_bytes();
  int64_t size_bytes() const;
  void set_size_bytes(int64_t value);
  private:
  int64_t _internal_size_bytes() const;
  void _internal_set_size_bytes(int64_t value);
  public:

  // .google.bigtable.admin.v2.Backup.State state = 7 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_state();
  ::google::bigtable::admin::v2::Backup_State state() const;
  void set_state(::google::bigtable::admin::v2::Backup_State value);
  private:
  ::google::bigtable::admin::v2::Backup_State _internal_state() const;
  void _internal_set_state(::google::bigtable::admin::v2::Backup_State value);
  public:

  // @@protoc_insertion_point(class_scope:google.bigtable.admin.v2.Backup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_table_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expire_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    ::google::bigtable::admin::v2::EncryptionInfo* encryption_info_;
    int64_t size_bytes_;
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto;
};
// -------------------------------------------------------------------

class BackupInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.bigtable.admin.v2.BackupInfo) */ {
 public:
  inline BackupInfo() : BackupInfo(nullptr) {}
  ~BackupInfo() override;
  explicit PROTOBUF_CONSTEXPR BackupInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BackupInfo(const BackupInfo& from);
  BackupInfo(BackupInfo&& from) noexcept
    : BackupInfo() {
    *this = ::std::move(from);
  }

  inline BackupInfo& operator=(const BackupInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackupInfo& operator=(BackupInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BackupInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BackupInfo* internal_default_instance() {
    return reinterpret_cast<const BackupInfo*>(
               &_BackupInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BackupInfo& a, BackupInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BackupInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackupInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BackupInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BackupInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BackupInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BackupInfo& from) {
    BackupInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BackupInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.bigtable.admin.v2.BackupInfo";
  }
  protected:
  explicit BackupInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBackupFieldNumber = 1,
    kSourceTableFieldNumber = 4,
    kStartTimeFieldNumber = 2,
    kEndTimeFieldNumber = 3,
  };
  // string backup = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_backup();
  const std::string& backup() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backup(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backup();
  PROTOBUF_NODISCARD std::string* release_backup();
  void set_allocated_backup(std::string* backup);
  private:
  const std::string& _internal_backup() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backup(const std::string& value);
  std::string* _internal_mutable_backup();
  public:

  // string source_table = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_source_table();
  const std::string& source_table() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_table(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_table();
  PROTOBUF_NODISCARD std::string* release_source_table();
  void set_allocated_source_table(std::string* source_table);
  private:
  const std::string& _internal_source_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_table(const std::string& value);
  std::string* _internal_mutable_source_table();
  public:

  // .google.protobuf.Timestamp start_time = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // @@protoc_insertion_point(class_scope:google.bigtable.admin.v2.BackupInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backup_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_table_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RestoreInfo

// .google.bigtable.admin.v2.RestoreSourceType source_type = 1;
inline void RestoreInfo::clear_source_type() {
  _impl_.source_type_ = 0;
}
inline ::google::bigtable::admin::v2::RestoreSourceType RestoreInfo::_internal_source_type() const {
  return static_cast< ::google::bigtable::admin::v2::RestoreSourceType >(_impl_.source_type_);
}
inline ::google::bigtable::admin::v2::RestoreSourceType RestoreInfo::source_type() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.RestoreInfo.source_type)
  return _internal_source_type();
}
inline void RestoreInfo::_internal_set_source_type(::google::bigtable::admin::v2::RestoreSourceType value) {
  
  _impl_.source_type_ = value;
}
inline void RestoreInfo::set_source_type(::google::bigtable::admin::v2::RestoreSourceType value) {
  _internal_set_source_type(value);
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.RestoreInfo.source_type)
}

// .google.bigtable.admin.v2.BackupInfo backup_info = 2;
inline bool RestoreInfo::_internal_has_backup_info() const {
  return source_info_case() == kBackupInfo;
}
inline bool RestoreInfo::has_backup_info() const {
  return _internal_has_backup_info();
}
inline void RestoreInfo::set_has_backup_info() {
  _impl_._oneof_case_[0] = kBackupInfo;
}
inline void RestoreInfo::clear_backup_info() {
  if (_internal_has_backup_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.source_info_.backup_info_;
    }
    clear_has_source_info();
  }
}
inline ::google::bigtable::admin::v2::BackupInfo* RestoreInfo::release_backup_info() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.RestoreInfo.backup_info)
  if (_internal_has_backup_info()) {
    clear_has_source_info();
    ::google::bigtable::admin::v2::BackupInfo* temp = _impl_.source_info_.backup_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.source_info_.backup_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::bigtable::admin::v2::BackupInfo& RestoreInfo::_internal_backup_info() const {
  return _internal_has_backup_info()
      ? *_impl_.source_info_.backup_info_
      : reinterpret_cast< ::google::bigtable::admin::v2::BackupInfo&>(::google::bigtable::admin::v2::_BackupInfo_default_instance_);
}
inline const ::google::bigtable::admin::v2::BackupInfo& RestoreInfo::backup_info() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.RestoreInfo.backup_info)
  return _internal_backup_info();
}
inline ::google::bigtable::admin::v2::BackupInfo* RestoreInfo::unsafe_arena_release_backup_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.bigtable.admin.v2.RestoreInfo.backup_info)
  if (_internal_has_backup_info()) {
    clear_has_source_info();
    ::google::bigtable::admin::v2::BackupInfo* temp = _impl_.source_info_.backup_info_;
    _impl_.source_info_.backup_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RestoreInfo::unsafe_arena_set_allocated_backup_info(::google::bigtable::admin::v2::BackupInfo* backup_info) {
  clear_source_info();
  if (backup_info) {
    set_has_backup_info();
    _impl_.source_info_.backup_info_ = backup_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.RestoreInfo.backup_info)
}
inline ::google::bigtable::admin::v2::BackupInfo* RestoreInfo::_internal_mutable_backup_info() {
  if (!_internal_has_backup_info()) {
    clear_source_info();
    set_has_backup_info();
    _impl_.source_info_.backup_info_ = CreateMaybeMessage< ::google::bigtable::admin::v2::BackupInfo >(GetArenaForAllocation());
  }
  return _impl_.source_info_.backup_info_;
}
inline ::google::bigtable::admin::v2::BackupInfo* RestoreInfo::mutable_backup_info() {
  ::google::bigtable::admin::v2::BackupInfo* _msg = _internal_mutable_backup_info();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.RestoreInfo.backup_info)
  return _msg;
}

inline bool RestoreInfo::has_source_info() const {
  return source_info_case() != SOURCE_INFO_NOT_SET;
}
inline void RestoreInfo::clear_has_source_info() {
  _impl_._oneof_case_[0] = SOURCE_INFO_NOT_SET;
}
inline RestoreInfo::SourceInfoCase RestoreInfo::source_info_case() const {
  return RestoreInfo::SourceInfoCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Table_ClusterState

// .google.bigtable.admin.v2.Table.ClusterState.ReplicationState replication_state = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Table_ClusterState::clear_replication_state() {
  _impl_.replication_state_ = 0;
}
inline ::google::bigtable::admin::v2::Table_ClusterState_ReplicationState Table_ClusterState::_internal_replication_state() const {
  return static_cast< ::google::bigtable::admin::v2::Table_ClusterState_ReplicationState >(_impl_.replication_state_);
}
inline ::google::bigtable::admin::v2::Table_ClusterState_ReplicationState Table_ClusterState::replication_state() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Table.ClusterState.replication_state)
  return _internal_replication_state();
}
inline void Table_ClusterState::_internal_set_replication_state(::google::bigtable::admin::v2::Table_ClusterState_ReplicationState value) {
  
  _impl_.replication_state_ = value;
}
inline void Table_ClusterState::set_replication_state(::google::bigtable::admin::v2::Table_ClusterState_ReplicationState value) {
  _internal_set_replication_state(value);
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.Table.ClusterState.replication_state)
}

// repeated .google.bigtable.admin.v2.EncryptionInfo encryption_info = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline int Table_ClusterState::_internal_encryption_info_size() const {
  return _impl_.encryption_info_.size();
}
inline int Table_ClusterState::encryption_info_size() const {
  return _internal_encryption_info_size();
}
inline void Table_ClusterState::clear_encryption_info() {
  _impl_.encryption_info_.Clear();
}
inline ::google::bigtable::admin::v2::EncryptionInfo* Table_ClusterState::mutable_encryption_info(int index) {
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.Table.ClusterState.encryption_info)
  return _impl_.encryption_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::bigtable::admin::v2::EncryptionInfo >*
Table_ClusterState::mutable_encryption_info() {
  // @@protoc_insertion_point(field_mutable_list:google.bigtable.admin.v2.Table.ClusterState.encryption_info)
  return &_impl_.encryption_info_;
}
inline const ::google::bigtable::admin::v2::EncryptionInfo& Table_ClusterState::_internal_encryption_info(int index) const {
  return _impl_.encryption_info_.Get(index);
}
inline const ::google::bigtable::admin::v2::EncryptionInfo& Table_ClusterState::encryption_info(int index) const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Table.ClusterState.encryption_info)
  return _internal_encryption_info(index);
}
inline ::google::bigtable::admin::v2::EncryptionInfo* Table_ClusterState::_internal_add_encryption_info() {
  return _impl_.encryption_info_.Add();
}
inline ::google::bigtable::admin::v2::EncryptionInfo* Table_ClusterState::add_encryption_info() {
  ::google::bigtable::admin::v2::EncryptionInfo* _add = _internal_add_encryption_info();
  // @@protoc_insertion_point(field_add:google.bigtable.admin.v2.Table.ClusterState.encryption_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::bigtable::admin::v2::EncryptionInfo >&
Table_ClusterState::encryption_info() const {
  // @@protoc_insertion_point(field_list:google.bigtable.admin.v2.Table.ClusterState.encryption_info)
  return _impl_.encryption_info_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Table

// string name = 1;
inline void Table::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Table::name() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Table.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Table::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.Table.name)
}
inline std::string* Table::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.Table.name)
  return _s;
}
inline const std::string& Table::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Table::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Table::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Table::release_name() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.Table.name)
  return _impl_.name_.Release();
}
inline void Table::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.Table.name)
}

// map<string, .google.bigtable.admin.v2.Table.ClusterState> cluster_states = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline int Table::_internal_cluster_states_size() const {
  return _impl_.cluster_states_.size();
}
inline int Table::cluster_states_size() const {
  return _internal_cluster_states_size();
}
inline void Table::clear_cluster_states() {
  _impl_.cluster_states_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::Table_ClusterState >&
Table::_internal_cluster_states() const {
  return _impl_.cluster_states_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::Table_ClusterState >&
Table::cluster_states() const {
  // @@protoc_insertion_point(field_map:google.bigtable.admin.v2.Table.cluster_states)
  return _internal_cluster_states();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::Table_ClusterState >*
Table::_internal_mutable_cluster_states() {
  return _impl_.cluster_states_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::Table_ClusterState >*
Table::mutable_cluster_states() {
  // @@protoc_insertion_point(field_mutable_map:google.bigtable.admin.v2.Table.cluster_states)
  return _internal_mutable_cluster_states();
}

// map<string, .google.bigtable.admin.v2.ColumnFamily> column_families = 3;
inline int Table::_internal_column_families_size() const {
  return _impl_.column_families_.size();
}
inline int Table::column_families_size() const {
  return _internal_column_families_size();
}
inline void Table::clear_column_families() {
  _impl_.column_families_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::ColumnFamily >&
Table::_internal_column_families() const {
  return _impl_.column_families_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::ColumnFamily >&
Table::column_families() const {
  // @@protoc_insertion_point(field_map:google.bigtable.admin.v2.Table.column_families)
  return _internal_column_families();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::ColumnFamily >*
Table::_internal_mutable_column_families() {
  return _impl_.column_families_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::google::bigtable::admin::v2::ColumnFamily >*
Table::mutable_column_families() {
  // @@protoc_insertion_point(field_mutable_map:google.bigtable.admin.v2.Table.column_families)
  return _internal_mutable_column_families();
}

// .google.bigtable.admin.v2.Table.TimestampGranularity granularity = 4 [(.google.api.field_behavior) = IMMUTABLE];
inline void Table::clear_granularity() {
  _impl_.granularity_ = 0;
}
inline ::google::bigtable::admin::v2::Table_TimestampGranularity Table::_internal_granularity() const {
  return static_cast< ::google::bigtable::admin::v2::Table_TimestampGranularity >(_impl_.granularity_);
}
inline ::google::bigtable::admin::v2::Table_TimestampGranularity Table::granularity() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Table.granularity)
  return _internal_granularity();
}
inline void Table::_internal_set_granularity(::google::bigtable::admin::v2::Table_TimestampGranularity value) {
  
  _impl_.granularity_ = value;
}
inline void Table::set_granularity(::google::bigtable::admin::v2::Table_TimestampGranularity value) {
  _internal_set_granularity(value);
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.Table.granularity)
}

// .google.bigtable.admin.v2.RestoreInfo restore_info = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Table::_internal_has_restore_info() const {
  return this != internal_default_instance() && _impl_.restore_info_ != nullptr;
}
inline bool Table::has_restore_info() const {
  return _internal_has_restore_info();
}
inline void Table::clear_restore_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.restore_info_ != nullptr) {
    delete _impl_.restore_info_;
  }
  _impl_.restore_info_ = nullptr;
}
inline const ::google::bigtable::admin::v2::RestoreInfo& Table::_internal_restore_info() const {
  const ::google::bigtable::admin::v2::RestoreInfo* p = _impl_.restore_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::bigtable::admin::v2::RestoreInfo&>(
      ::google::bigtable::admin::v2::_RestoreInfo_default_instance_);
}
inline const ::google::bigtable::admin::v2::RestoreInfo& Table::restore_info() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Table.restore_info)
  return _internal_restore_info();
}
inline void Table::unsafe_arena_set_allocated_restore_info(
    ::google::bigtable::admin::v2::RestoreInfo* restore_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.restore_info_);
  }
  _impl_.restore_info_ = restore_info;
  if (restore_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.Table.restore_info)
}
inline ::google::bigtable::admin::v2::RestoreInfo* Table::release_restore_info() {
  
  ::google::bigtable::admin::v2::RestoreInfo* temp = _impl_.restore_info_;
  _impl_.restore_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::bigtable::admin::v2::RestoreInfo* Table::unsafe_arena_release_restore_info() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.Table.restore_info)
  
  ::google::bigtable::admin::v2::RestoreInfo* temp = _impl_.restore_info_;
  _impl_.restore_info_ = nullptr;
  return temp;
}
inline ::google::bigtable::admin::v2::RestoreInfo* Table::_internal_mutable_restore_info() {
  
  if (_impl_.restore_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::bigtable::admin::v2::RestoreInfo>(GetArenaForAllocation());
    _impl_.restore_info_ = p;
  }
  return _impl_.restore_info_;
}
inline ::google::bigtable::admin::v2::RestoreInfo* Table::mutable_restore_info() {
  ::google::bigtable::admin::v2::RestoreInfo* _msg = _internal_mutable_restore_info();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.Table.restore_info)
  return _msg;
}
inline void Table::set_allocated_restore_info(::google::bigtable::admin::v2::RestoreInfo* restore_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.restore_info_;
  }
  if (restore_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(restore_info);
    if (message_arena != submessage_arena) {
      restore_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, restore_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.restore_info_ = restore_info;
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.Table.restore_info)
}

// bool deletion_protection = 9;
inline void Table::clear_deletion_protection() {
  _impl_.deletion_protection_ = false;
}
inline bool Table::_internal_deletion_protection() const {
  return _impl_.deletion_protection_;
}
inline bool Table::deletion_protection() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Table.deletion_protection)
  return _internal_deletion_protection();
}
inline void Table::_internal_set_deletion_protection(bool value) {
  
  _impl_.deletion_protection_ = value;
}
inline void Table::set_deletion_protection(bool value) {
  _internal_set_deletion_protection(value);
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.Table.deletion_protection)
}

// -------------------------------------------------------------------

// ColumnFamily

// .google.bigtable.admin.v2.GcRule gc_rule = 1;
inline bool ColumnFamily::_internal_has_gc_rule() const {
  return this != internal_default_instance() && _impl_.gc_rule_ != nullptr;
}
inline bool ColumnFamily::has_gc_rule() const {
  return _internal_has_gc_rule();
}
inline void ColumnFamily::clear_gc_rule() {
  if (GetArenaForAllocation() == nullptr && _impl_.gc_rule_ != nullptr) {
    delete _impl_.gc_rule_;
  }
  _impl_.gc_rule_ = nullptr;
}
inline const ::google::bigtable::admin::v2::GcRule& ColumnFamily::_internal_gc_rule() const {
  const ::google::bigtable::admin::v2::GcRule* p = _impl_.gc_rule_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::bigtable::admin::v2::GcRule&>(
      ::google::bigtable::admin::v2::_GcRule_default_instance_);
}
inline const ::google::bigtable::admin::v2::GcRule& ColumnFamily::gc_rule() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.ColumnFamily.gc_rule)
  return _internal_gc_rule();
}
inline void ColumnFamily::unsafe_arena_set_allocated_gc_rule(
    ::google::bigtable::admin::v2::GcRule* gc_rule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gc_rule_);
  }
  _impl_.gc_rule_ = gc_rule;
  if (gc_rule) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.ColumnFamily.gc_rule)
}
inline ::google::bigtable::admin::v2::GcRule* ColumnFamily::release_gc_rule() {
  
  ::google::bigtable::admin::v2::GcRule* temp = _impl_.gc_rule_;
  _impl_.gc_rule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::bigtable::admin::v2::GcRule* ColumnFamily::unsafe_arena_release_gc_rule() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.ColumnFamily.gc_rule)
  
  ::google::bigtable::admin::v2::GcRule* temp = _impl_.gc_rule_;
  _impl_.gc_rule_ = nullptr;
  return temp;
}
inline ::google::bigtable::admin::v2::GcRule* ColumnFamily::_internal_mutable_gc_rule() {
  
  if (_impl_.gc_rule_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::bigtable::admin::v2::GcRule>(GetArenaForAllocation());
    _impl_.gc_rule_ = p;
  }
  return _impl_.gc_rule_;
}
inline ::google::bigtable::admin::v2::GcRule* ColumnFamily::mutable_gc_rule() {
  ::google::bigtable::admin::v2::GcRule* _msg = _internal_mutable_gc_rule();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.ColumnFamily.gc_rule)
  return _msg;
}
inline void ColumnFamily::set_allocated_gc_rule(::google::bigtable::admin::v2::GcRule* gc_rule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gc_rule_;
  }
  if (gc_rule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gc_rule);
    if (message_arena != submessage_arena) {
      gc_rule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gc_rule, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.gc_rule_ = gc_rule;
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.ColumnFamily.gc_rule)
}

// -------------------------------------------------------------------

// GcRule_Intersection

// repeated .google.bigtable.admin.v2.GcRule rules = 1;
inline int GcRule_Intersection::_internal_rules_size() const {
  return _impl_.rules_.size();
}
inline int GcRule_Intersection::rules_size() const {
  return _internal_rules_size();
}
inline void GcRule_Intersection::clear_rules() {
  _impl_.rules_.Clear();
}
inline ::google::bigtable::admin::v2::GcRule* GcRule_Intersection::mutable_rules(int index) {
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.GcRule.Intersection.rules)
  return _impl_.rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::bigtable::admin::v2::GcRule >*
GcRule_Intersection::mutable_rules() {
  // @@protoc_insertion_point(field_mutable_list:google.bigtable.admin.v2.GcRule.Intersection.rules)
  return &_impl_.rules_;
}
inline const ::google::bigtable::admin::v2::GcRule& GcRule_Intersection::_internal_rules(int index) const {
  return _impl_.rules_.Get(index);
}
inline const ::google::bigtable::admin::v2::GcRule& GcRule_Intersection::rules(int index) const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.GcRule.Intersection.rules)
  return _internal_rules(index);
}
inline ::google::bigtable::admin::v2::GcRule* GcRule_Intersection::_internal_add_rules() {
  return _impl_.rules_.Add();
}
inline ::google::bigtable::admin::v2::GcRule* GcRule_Intersection::add_rules() {
  ::google::bigtable::admin::v2::GcRule* _add = _internal_add_rules();
  // @@protoc_insertion_point(field_add:google.bigtable.admin.v2.GcRule.Intersection.rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::bigtable::admin::v2::GcRule >&
GcRule_Intersection::rules() const {
  // @@protoc_insertion_point(field_list:google.bigtable.admin.v2.GcRule.Intersection.rules)
  return _impl_.rules_;
}

// -------------------------------------------------------------------

// GcRule_Union

// repeated .google.bigtable.admin.v2.GcRule rules = 1;
inline int GcRule_Union::_internal_rules_size() const {
  return _impl_.rules_.size();
}
inline int GcRule_Union::rules_size() const {
  return _internal_rules_size();
}
inline void GcRule_Union::clear_rules() {
  _impl_.rules_.Clear();
}
inline ::google::bigtable::admin::v2::GcRule* GcRule_Union::mutable_rules(int index) {
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.GcRule.Union.rules)
  return _impl_.rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::bigtable::admin::v2::GcRule >*
GcRule_Union::mutable_rules() {
  // @@protoc_insertion_point(field_mutable_list:google.bigtable.admin.v2.GcRule.Union.rules)
  return &_impl_.rules_;
}
inline const ::google::bigtable::admin::v2::GcRule& GcRule_Union::_internal_rules(int index) const {
  return _impl_.rules_.Get(index);
}
inline const ::google::bigtable::admin::v2::GcRule& GcRule_Union::rules(int index) const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.GcRule.Union.rules)
  return _internal_rules(index);
}
inline ::google::bigtable::admin::v2::GcRule* GcRule_Union::_internal_add_rules() {
  return _impl_.rules_.Add();
}
inline ::google::bigtable::admin::v2::GcRule* GcRule_Union::add_rules() {
  ::google::bigtable::admin::v2::GcRule* _add = _internal_add_rules();
  // @@protoc_insertion_point(field_add:google.bigtable.admin.v2.GcRule.Union.rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::bigtable::admin::v2::GcRule >&
GcRule_Union::rules() const {
  // @@protoc_insertion_point(field_list:google.bigtable.admin.v2.GcRule.Union.rules)
  return _impl_.rules_;
}

// -------------------------------------------------------------------

// GcRule

// int32 max_num_versions = 1;
inline bool GcRule::_internal_has_max_num_versions() const {
  return rule_case() == kMaxNumVersions;
}
inline bool GcRule::has_max_num_versions() const {
  return _internal_has_max_num_versions();
}
inline void GcRule::set_has_max_num_versions() {
  _impl_._oneof_case_[0] = kMaxNumVersions;
}
inline void GcRule::clear_max_num_versions() {
  if (_internal_has_max_num_versions()) {
    _impl_.rule_.max_num_versions_ = 0;
    clear_has_rule();
  }
}
inline int32_t GcRule::_internal_max_num_versions() const {
  if (_internal_has_max_num_versions()) {
    return _impl_.rule_.max_num_versions_;
  }
  return 0;
}
inline void GcRule::_internal_set_max_num_versions(int32_t value) {
  if (!_internal_has_max_num_versions()) {
    clear_rule();
    set_has_max_num_versions();
  }
  _impl_.rule_.max_num_versions_ = value;
}
inline int32_t GcRule::max_num_versions() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.GcRule.max_num_versions)
  return _internal_max_num_versions();
}
inline void GcRule::set_max_num_versions(int32_t value) {
  _internal_set_max_num_versions(value);
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.GcRule.max_num_versions)
}

// .google.protobuf.Duration max_age = 2;
inline bool GcRule::_internal_has_max_age() const {
  return rule_case() == kMaxAge;
}
inline bool GcRule::has_max_age() const {
  return _internal_has_max_age();
}
inline void GcRule::set_has_max_age() {
  _impl_._oneof_case_[0] = kMaxAge;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* GcRule::release_max_age() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.GcRule.max_age)
  if (_internal_has_max_age()) {
    clear_has_rule();
    ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.rule_.max_age_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rule_.max_age_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& GcRule::_internal_max_age() const {
  return _internal_has_max_age()
      ? *_impl_.rule_.max_age_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Duration&>(::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& GcRule::max_age() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.GcRule.max_age)
  return _internal_max_age();
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* GcRule::unsafe_arena_release_max_age() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.bigtable.admin.v2.GcRule.max_age)
  if (_internal_has_max_age()) {
    clear_has_rule();
    ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.rule_.max_age_;
    _impl_.rule_.max_age_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GcRule::unsafe_arena_set_allocated_max_age(::PROTOBUF_NAMESPACE_ID::Duration* max_age) {
  clear_rule();
  if (max_age) {
    set_has_max_age();
    _impl_.rule_.max_age_ = max_age;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.GcRule.max_age)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* GcRule::_internal_mutable_max_age() {
  if (!_internal_has_max_age()) {
    clear_rule();
    set_has_max_age();
    _impl_.rule_.max_age_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Duration >(GetArenaForAllocation());
  }
  return _impl_.rule_.max_age_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* GcRule::mutable_max_age() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_max_age();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.GcRule.max_age)
  return _msg;
}

// .google.bigtable.admin.v2.GcRule.Intersection intersection = 3;
inline bool GcRule::_internal_has_intersection() const {
  return rule_case() == kIntersection;
}
inline bool GcRule::has_intersection() const {
  return _internal_has_intersection();
}
inline void GcRule::set_has_intersection() {
  _impl_._oneof_case_[0] = kIntersection;
}
inline void GcRule::clear_intersection() {
  if (_internal_has_intersection()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.rule_.intersection_;
    }
    clear_has_rule();
  }
}
inline ::google::bigtable::admin::v2::GcRule_Intersection* GcRule::release_intersection() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.GcRule.intersection)
  if (_internal_has_intersection()) {
    clear_has_rule();
    ::google::bigtable::admin::v2::GcRule_Intersection* temp = _impl_.rule_.intersection_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rule_.intersection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::bigtable::admin::v2::GcRule_Intersection& GcRule::_internal_intersection() const {
  return _internal_has_intersection()
      ? *_impl_.rule_.intersection_
      : reinterpret_cast< ::google::bigtable::admin::v2::GcRule_Intersection&>(::google::bigtable::admin::v2::_GcRule_Intersection_default_instance_);
}
inline const ::google::bigtable::admin::v2::GcRule_Intersection& GcRule::intersection() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.GcRule.intersection)
  return _internal_intersection();
}
inline ::google::bigtable::admin::v2::GcRule_Intersection* GcRule::unsafe_arena_release_intersection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.bigtable.admin.v2.GcRule.intersection)
  if (_internal_has_intersection()) {
    clear_has_rule();
    ::google::bigtable::admin::v2::GcRule_Intersection* temp = _impl_.rule_.intersection_;
    _impl_.rule_.intersection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GcRule::unsafe_arena_set_allocated_intersection(::google::bigtable::admin::v2::GcRule_Intersection* intersection) {
  clear_rule();
  if (intersection) {
    set_has_intersection();
    _impl_.rule_.intersection_ = intersection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.GcRule.intersection)
}
inline ::google::bigtable::admin::v2::GcRule_Intersection* GcRule::_internal_mutable_intersection() {
  if (!_internal_has_intersection()) {
    clear_rule();
    set_has_intersection();
    _impl_.rule_.intersection_ = CreateMaybeMessage< ::google::bigtable::admin::v2::GcRule_Intersection >(GetArenaForAllocation());
  }
  return _impl_.rule_.intersection_;
}
inline ::google::bigtable::admin::v2::GcRule_Intersection* GcRule::mutable_intersection() {
  ::google::bigtable::admin::v2::GcRule_Intersection* _msg = _internal_mutable_intersection();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.GcRule.intersection)
  return _msg;
}

// .google.bigtable.admin.v2.GcRule.Union union = 4;
inline bool GcRule::_internal_has_union_() const {
  return rule_case() == kUnion;
}
inline bool GcRule::has_union_() const {
  return _internal_has_union_();
}
inline void GcRule::set_has_union_() {
  _impl_._oneof_case_[0] = kUnion;
}
inline void GcRule::clear_union_() {
  if (_internal_has_union_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.rule_.union__;
    }
    clear_has_rule();
  }
}
inline ::google::bigtable::admin::v2::GcRule_Union* GcRule::release_union_() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.GcRule.union)
  if (_internal_has_union_()) {
    clear_has_rule();
    ::google::bigtable::admin::v2::GcRule_Union* temp = _impl_.rule_.union__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rule_.union__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::bigtable::admin::v2::GcRule_Union& GcRule::_internal_union_() const {
  return _internal_has_union_()
      ? *_impl_.rule_.union__
      : reinterpret_cast< ::google::bigtable::admin::v2::GcRule_Union&>(::google::bigtable::admin::v2::_GcRule_Union_default_instance_);
}
inline const ::google::bigtable::admin::v2::GcRule_Union& GcRule::union_() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.GcRule.union)
  return _internal_union_();
}
inline ::google::bigtable::admin::v2::GcRule_Union* GcRule::unsafe_arena_release_union_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.bigtable.admin.v2.GcRule.union)
  if (_internal_has_union_()) {
    clear_has_rule();
    ::google::bigtable::admin::v2::GcRule_Union* temp = _impl_.rule_.union__;
    _impl_.rule_.union__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GcRule::unsafe_arena_set_allocated_union_(::google::bigtable::admin::v2::GcRule_Union* union_) {
  clear_rule();
  if (union_) {
    set_has_union_();
    _impl_.rule_.union__ = union_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.GcRule.union)
}
inline ::google::bigtable::admin::v2::GcRule_Union* GcRule::_internal_mutable_union_() {
  if (!_internal_has_union_()) {
    clear_rule();
    set_has_union_();
    _impl_.rule_.union__ = CreateMaybeMessage< ::google::bigtable::admin::v2::GcRule_Union >(GetArenaForAllocation());
  }
  return _impl_.rule_.union__;
}
inline ::google::bigtable::admin::v2::GcRule_Union* GcRule::mutable_union_() {
  ::google::bigtable::admin::v2::GcRule_Union* _msg = _internal_mutable_union_();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.GcRule.union)
  return _msg;
}

inline bool GcRule::has_rule() const {
  return rule_case() != RULE_NOT_SET;
}
inline void GcRule::clear_has_rule() {
  _impl_._oneof_case_[0] = RULE_NOT_SET;
}
inline GcRule::RuleCase GcRule::rule_case() const {
  return GcRule::RuleCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EncryptionInfo

// .google.bigtable.admin.v2.EncryptionInfo.EncryptionType encryption_type = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void EncryptionInfo::clear_encryption_type() {
  _impl_.encryption_type_ = 0;
}
inline ::google::bigtable::admin::v2::EncryptionInfo_EncryptionType EncryptionInfo::_internal_encryption_type() const {
  return static_cast< ::google::bigtable::admin::v2::EncryptionInfo_EncryptionType >(_impl_.encryption_type_);
}
inline ::google::bigtable::admin::v2::EncryptionInfo_EncryptionType EncryptionInfo::encryption_type() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.EncryptionInfo.encryption_type)
  return _internal_encryption_type();
}
inline void EncryptionInfo::_internal_set_encryption_type(::google::bigtable::admin::v2::EncryptionInfo_EncryptionType value) {
  
  _impl_.encryption_type_ = value;
}
inline void EncryptionInfo::set_encryption_type(::google::bigtable::admin::v2::EncryptionInfo_EncryptionType value) {
  _internal_set_encryption_type(value);
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.EncryptionInfo.encryption_type)
}

// .google.rpc.Status encryption_status = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool EncryptionInfo::_internal_has_encryption_status() const {
  return this != internal_default_instance() && _impl_.encryption_status_ != nullptr;
}
inline bool EncryptionInfo::has_encryption_status() const {
  return _internal_has_encryption_status();
}
inline const ::google::rpc::Status& EncryptionInfo::_internal_encryption_status() const {
  const ::google::rpc::Status* p = _impl_.encryption_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::rpc::Status&>(
      ::google::rpc::_Status_default_instance_);
}
inline const ::google::rpc::Status& EncryptionInfo::encryption_status() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.EncryptionInfo.encryption_status)
  return _internal_encryption_status();
}
inline void EncryptionInfo::unsafe_arena_set_allocated_encryption_status(
    ::google::rpc::Status* encryption_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encryption_status_);
  }
  _impl_.encryption_status_ = encryption_status;
  if (encryption_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.EncryptionInfo.encryption_status)
}
inline ::google::rpc::Status* EncryptionInfo::release_encryption_status() {
  
  ::google::rpc::Status* temp = _impl_.encryption_status_;
  _impl_.encryption_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::rpc::Status* EncryptionInfo::unsafe_arena_release_encryption_status() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.EncryptionInfo.encryption_status)
  
  ::google::rpc::Status* temp = _impl_.encryption_status_;
  _impl_.encryption_status_ = nullptr;
  return temp;
}
inline ::google::rpc::Status* EncryptionInfo::_internal_mutable_encryption_status() {
  
  if (_impl_.encryption_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::rpc::Status>(GetArenaForAllocation());
    _impl_.encryption_status_ = p;
  }
  return _impl_.encryption_status_;
}
inline ::google::rpc::Status* EncryptionInfo::mutable_encryption_status() {
  ::google::rpc::Status* _msg = _internal_mutable_encryption_status();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.EncryptionInfo.encryption_status)
  return _msg;
}
inline void EncryptionInfo::set_allocated_encryption_status(::google::rpc::Status* encryption_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encryption_status_);
  }
  if (encryption_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encryption_status));
    if (message_arena != submessage_arena) {
      encryption_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encryption_status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.encryption_status_ = encryption_status;
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.EncryptionInfo.encryption_status)
}

// string kms_key_version = 2 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.resource_reference) = {
inline void EncryptionInfo::clear_kms_key_version() {
  _impl_.kms_key_version_.ClearToEmpty();
}
inline const std::string& EncryptionInfo::kms_key_version() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.EncryptionInfo.kms_key_version)
  return _internal_kms_key_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EncryptionInfo::set_kms_key_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.kms_key_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.EncryptionInfo.kms_key_version)
}
inline std::string* EncryptionInfo::mutable_kms_key_version() {
  std::string* _s = _internal_mutable_kms_key_version();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.EncryptionInfo.kms_key_version)
  return _s;
}
inline const std::string& EncryptionInfo::_internal_kms_key_version() const {
  return _impl_.kms_key_version_.Get();
}
inline void EncryptionInfo::_internal_set_kms_key_version(const std::string& value) {
  
  _impl_.kms_key_version_.Set(value, GetArenaForAllocation());
}
inline std::string* EncryptionInfo::_internal_mutable_kms_key_version() {
  
  return _impl_.kms_key_version_.Mutable(GetArenaForAllocation());
}
inline std::string* EncryptionInfo::release_kms_key_version() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.EncryptionInfo.kms_key_version)
  return _impl_.kms_key_version_.Release();
}
inline void EncryptionInfo::set_allocated_kms_key_version(std::string* kms_key_version) {
  if (kms_key_version != nullptr) {
    
  } else {
    
  }
  _impl_.kms_key_version_.SetAllocated(kms_key_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kms_key_version_.IsDefault()) {
    _impl_.kms_key_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.EncryptionInfo.kms_key_version)
}

// -------------------------------------------------------------------

// Snapshot

// string name = 1;
inline void Snapshot::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Snapshot::name() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Snapshot.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Snapshot::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.Snapshot.name)
}
inline std::string* Snapshot::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.Snapshot.name)
  return _s;
}
inline const std::string& Snapshot::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Snapshot::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Snapshot::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Snapshot::release_name() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.Snapshot.name)
  return _impl_.name_.Release();
}
inline void Snapshot::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.Snapshot.name)
}

// .google.bigtable.admin.v2.Table source_table = 2;
inline bool Snapshot::_internal_has_source_table() const {
  return this != internal_default_instance() && _impl_.source_table_ != nullptr;
}
inline bool Snapshot::has_source_table() const {
  return _internal_has_source_table();
}
inline void Snapshot::clear_source_table() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_table_ != nullptr) {
    delete _impl_.source_table_;
  }
  _impl_.source_table_ = nullptr;
}
inline const ::google::bigtable::admin::v2::Table& Snapshot::_internal_source_table() const {
  const ::google::bigtable::admin::v2::Table* p = _impl_.source_table_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::bigtable::admin::v2::Table&>(
      ::google::bigtable::admin::v2::_Table_default_instance_);
}
inline const ::google::bigtable::admin::v2::Table& Snapshot::source_table() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Snapshot.source_table)
  return _internal_source_table();
}
inline void Snapshot::unsafe_arena_set_allocated_source_table(
    ::google::bigtable::admin::v2::Table* source_table) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_table_);
  }
  _impl_.source_table_ = source_table;
  if (source_table) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.Snapshot.source_table)
}
inline ::google::bigtable::admin::v2::Table* Snapshot::release_source_table() {
  
  ::google::bigtable::admin::v2::Table* temp = _impl_.source_table_;
  _impl_.source_table_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::bigtable::admin::v2::Table* Snapshot::unsafe_arena_release_source_table() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.Snapshot.source_table)
  
  ::google::bigtable::admin::v2::Table* temp = _impl_.source_table_;
  _impl_.source_table_ = nullptr;
  return temp;
}
inline ::google::bigtable::admin::v2::Table* Snapshot::_internal_mutable_source_table() {
  
  if (_impl_.source_table_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::bigtable::admin::v2::Table>(GetArenaForAllocation());
    _impl_.source_table_ = p;
  }
  return _impl_.source_table_;
}
inline ::google::bigtable::admin::v2::Table* Snapshot::mutable_source_table() {
  ::google::bigtable::admin::v2::Table* _msg = _internal_mutable_source_table();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.Snapshot.source_table)
  return _msg;
}
inline void Snapshot::set_allocated_source_table(::google::bigtable::admin::v2::Table* source_table) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_table_;
  }
  if (source_table) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_table);
    if (message_arena != submessage_arena) {
      source_table = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_table, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_table_ = source_table;
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.Snapshot.source_table)
}

// int64 data_size_bytes = 3;
inline void Snapshot::clear_data_size_bytes() {
  _impl_.data_size_bytes_ = int64_t{0};
}
inline int64_t Snapshot::_internal_data_size_bytes() const {
  return _impl_.data_size_bytes_;
}
inline int64_t Snapshot::data_size_bytes() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Snapshot.data_size_bytes)
  return _internal_data_size_bytes();
}
inline void Snapshot::_internal_set_data_size_bytes(int64_t value) {
  
  _impl_.data_size_bytes_ = value;
}
inline void Snapshot::set_data_size_bytes(int64_t value) {
  _internal_set_data_size_bytes(value);
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.Snapshot.data_size_bytes)
}

// .google.protobuf.Timestamp create_time = 4;
inline bool Snapshot::_internal_has_create_time() const {
  return this != internal_default_instance() && _impl_.create_time_ != nullptr;
}
inline bool Snapshot::has_create_time() const {
  return _internal_has_create_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Snapshot::_internal_create_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.create_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Snapshot::create_time() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Snapshot.create_time)
  return _internal_create_time();
}
inline void Snapshot::unsafe_arena_set_allocated_create_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  _impl_.create_time_ = create_time;
  if (create_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.Snapshot.create_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Snapshot::release_create_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Snapshot::unsafe_arena_release_create_time() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.Snapshot.create_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Snapshot::_internal_mutable_create_time() {
  
  if (_impl_.create_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.create_time_ = p;
  }
  return _impl_.create_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Snapshot::mutable_create_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.Snapshot.create_time)
  return _msg;
}
inline void Snapshot::set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  if (create_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time));
    if (message_arena != submessage_arena) {
      create_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.Snapshot.create_time)
}

// .google.protobuf.Timestamp delete_time = 5;
inline bool Snapshot::_internal_has_delete_time() const {
  return this != internal_default_instance() && _impl_.delete_time_ != nullptr;
}
inline bool Snapshot::has_delete_time() const {
  return _internal_has_delete_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Snapshot::_internal_delete_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.delete_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Snapshot::delete_time() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Snapshot.delete_time)
  return _internal_delete_time();
}
inline void Snapshot::unsafe_arena_set_allocated_delete_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* delete_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delete_time_);
  }
  _impl_.delete_time_ = delete_time;
  if (delete_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.Snapshot.delete_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Snapshot::release_delete_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.delete_time_;
  _impl_.delete_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Snapshot::unsafe_arena_release_delete_time() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.Snapshot.delete_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.delete_time_;
  _impl_.delete_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Snapshot::_internal_mutable_delete_time() {
  
  if (_impl_.delete_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.delete_time_ = p;
  }
  return _impl_.delete_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Snapshot::mutable_delete_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_delete_time();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.Snapshot.delete_time)
  return _msg;
}
inline void Snapshot::set_allocated_delete_time(::PROTOBUF_NAMESPACE_ID::Timestamp* delete_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delete_time_);
  }
  if (delete_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(delete_time));
    if (message_arena != submessage_arena) {
      delete_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delete_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.delete_time_ = delete_time;
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.Snapshot.delete_time)
}

// .google.bigtable.admin.v2.Snapshot.State state = 6;
inline void Snapshot::clear_state() {
  _impl_.state_ = 0;
}
inline ::google::bigtable::admin::v2::Snapshot_State Snapshot::_internal_state() const {
  return static_cast< ::google::bigtable::admin::v2::Snapshot_State >(_impl_.state_);
}
inline ::google::bigtable::admin::v2::Snapshot_State Snapshot::state() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Snapshot.state)
  return _internal_state();
}
inline void Snapshot::_internal_set_state(::google::bigtable::admin::v2::Snapshot_State value) {
  
  _impl_.state_ = value;
}
inline void Snapshot::set_state(::google::bigtable::admin::v2::Snapshot_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.Snapshot.state)
}

// string description = 7;
inline void Snapshot::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Snapshot::description() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Snapshot.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Snapshot::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.Snapshot.description)
}
inline std::string* Snapshot::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.Snapshot.description)
  return _s;
}
inline const std::string& Snapshot::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Snapshot::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Snapshot::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Snapshot::release_description() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.Snapshot.description)
  return _impl_.description_.Release();
}
inline void Snapshot::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.Snapshot.description)
}

// -------------------------------------------------------------------

// Backup

// string name = 1;
inline void Backup::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Backup::name() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Backup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.Backup.name)
}
inline std::string* Backup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.Backup.name)
  return _s;
}
inline const std::string& Backup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Backup::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Backup::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Backup::release_name() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.Backup.name)
  return _impl_.name_.Release();
}
inline void Backup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.Backup.name)
}

// string source_table = 2 [(.google.api.field_behavior) = IMMUTABLE, (.google.api.field_behavior) = REQUIRED];
inline void Backup::clear_source_table() {
  _impl_.source_table_.ClearToEmpty();
}
inline const std::string& Backup::source_table() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Backup.source_table)
  return _internal_source_table();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Backup::set_source_table(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_table_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.Backup.source_table)
}
inline std::string* Backup::mutable_source_table() {
  std::string* _s = _internal_mutable_source_table();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.Backup.source_table)
  return _s;
}
inline const std::string& Backup::_internal_source_table() const {
  return _impl_.source_table_.Get();
}
inline void Backup::_internal_set_source_table(const std::string& value) {
  
  _impl_.source_table_.Set(value, GetArenaForAllocation());
}
inline std::string* Backup::_internal_mutable_source_table() {
  
  return _impl_.source_table_.Mutable(GetArenaForAllocation());
}
inline std::string* Backup::release_source_table() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.Backup.source_table)
  return _impl_.source_table_.Release();
}
inline void Backup::set_allocated_source_table(std::string* source_table) {
  if (source_table != nullptr) {
    
  } else {
    
  }
  _impl_.source_table_.SetAllocated(source_table, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_table_.IsDefault()) {
    _impl_.source_table_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.Backup.source_table)
}

// .google.protobuf.Timestamp expire_time = 3 [(.google.api.field_behavior) = REQUIRED];
inline bool Backup::_internal_has_expire_time() const {
  return this != internal_default_instance() && _impl_.expire_time_ != nullptr;
}
inline bool Backup::has_expire_time() const {
  return _internal_has_expire_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Backup::_internal_expire_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.expire_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Backup::expire_time() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Backup.expire_time)
  return _internal_expire_time();
}
inline void Backup::unsafe_arena_set_allocated_expire_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expire_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expire_time_);
  }
  _impl_.expire_time_ = expire_time;
  if (expire_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.Backup.expire_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backup::release_expire_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expire_time_;
  _impl_.expire_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backup::unsafe_arena_release_expire_time() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.Backup.expire_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expire_time_;
  _impl_.expire_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backup::_internal_mutable_expire_time() {
  
  if (_impl_.expire_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.expire_time_ = p;
  }
  return _impl_.expire_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backup::mutable_expire_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_expire_time();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.Backup.expire_time)
  return _msg;
}
inline void Backup::set_allocated_expire_time(::PROTOBUF_NAMESPACE_ID::Timestamp* expire_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expire_time_);
  }
  if (expire_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expire_time));
    if (message_arena != submessage_arena) {
      expire_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expire_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expire_time_ = expire_time;
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.Backup.expire_time)
}

// .google.protobuf.Timestamp start_time = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Backup::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool Backup::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Backup::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Backup::start_time() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Backup.start_time)
  return _internal_start_time();
}
inline void Backup::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.Backup.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backup::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backup::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.Backup.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backup::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backup::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.Backup.start_time)
  return _msg;
}
inline void Backup::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.Backup.start_time)
}

// .google.protobuf.Timestamp end_time = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Backup::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool Backup::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Backup::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Backup::end_time() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Backup.end_time)
  return _internal_end_time();
}
inline void Backup::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.Backup.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backup::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backup::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.Backup.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backup::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Backup::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.Backup.end_time)
  return _msg;
}
inline void Backup::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.Backup.end_time)
}

// int64 size_bytes = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Backup::clear_size_bytes() {
  _impl_.size_bytes_ = int64_t{0};
}
inline int64_t Backup::_internal_size_bytes() const {
  return _impl_.size_bytes_;
}
inline int64_t Backup::size_bytes() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Backup.size_bytes)
  return _internal_size_bytes();
}
inline void Backup::_internal_set_size_bytes(int64_t value) {
  
  _impl_.size_bytes_ = value;
}
inline void Backup::set_size_bytes(int64_t value) {
  _internal_set_size_bytes(value);
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.Backup.size_bytes)
}

// .google.bigtable.admin.v2.Backup.State state = 7 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Backup::clear_state() {
  _impl_.state_ = 0;
}
inline ::google::bigtable::admin::v2::Backup_State Backup::_internal_state() const {
  return static_cast< ::google::bigtable::admin::v2::Backup_State >(_impl_.state_);
}
inline ::google::bigtable::admin::v2::Backup_State Backup::state() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Backup.state)
  return _internal_state();
}
inline void Backup::_internal_set_state(::google::bigtable::admin::v2::Backup_State value) {
  
  _impl_.state_ = value;
}
inline void Backup::set_state(::google::bigtable::admin::v2::Backup_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.Backup.state)
}

// .google.bigtable.admin.v2.EncryptionInfo encryption_info = 9 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Backup::_internal_has_encryption_info() const {
  return this != internal_default_instance() && _impl_.encryption_info_ != nullptr;
}
inline bool Backup::has_encryption_info() const {
  return _internal_has_encryption_info();
}
inline void Backup::clear_encryption_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.encryption_info_ != nullptr) {
    delete _impl_.encryption_info_;
  }
  _impl_.encryption_info_ = nullptr;
}
inline const ::google::bigtable::admin::v2::EncryptionInfo& Backup::_internal_encryption_info() const {
  const ::google::bigtable::admin::v2::EncryptionInfo* p = _impl_.encryption_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::bigtable::admin::v2::EncryptionInfo&>(
      ::google::bigtable::admin::v2::_EncryptionInfo_default_instance_);
}
inline const ::google::bigtable::admin::v2::EncryptionInfo& Backup::encryption_info() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.Backup.encryption_info)
  return _internal_encryption_info();
}
inline void Backup::unsafe_arena_set_allocated_encryption_info(
    ::google::bigtable::admin::v2::EncryptionInfo* encryption_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encryption_info_);
  }
  _impl_.encryption_info_ = encryption_info;
  if (encryption_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.Backup.encryption_info)
}
inline ::google::bigtable::admin::v2::EncryptionInfo* Backup::release_encryption_info() {
  
  ::google::bigtable::admin::v2::EncryptionInfo* temp = _impl_.encryption_info_;
  _impl_.encryption_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::bigtable::admin::v2::EncryptionInfo* Backup::unsafe_arena_release_encryption_info() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.Backup.encryption_info)
  
  ::google::bigtable::admin::v2::EncryptionInfo* temp = _impl_.encryption_info_;
  _impl_.encryption_info_ = nullptr;
  return temp;
}
inline ::google::bigtable::admin::v2::EncryptionInfo* Backup::_internal_mutable_encryption_info() {
  
  if (_impl_.encryption_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::bigtable::admin::v2::EncryptionInfo>(GetArenaForAllocation());
    _impl_.encryption_info_ = p;
  }
  return _impl_.encryption_info_;
}
inline ::google::bigtable::admin::v2::EncryptionInfo* Backup::mutable_encryption_info() {
  ::google::bigtable::admin::v2::EncryptionInfo* _msg = _internal_mutable_encryption_info();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.Backup.encryption_info)
  return _msg;
}
inline void Backup::set_allocated_encryption_info(::google::bigtable::admin::v2::EncryptionInfo* encryption_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.encryption_info_;
  }
  if (encryption_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(encryption_info);
    if (message_arena != submessage_arena) {
      encryption_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encryption_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.encryption_info_ = encryption_info;
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.Backup.encryption_info)
}

// -------------------------------------------------------------------

// BackupInfo

// string backup = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void BackupInfo::clear_backup() {
  _impl_.backup_.ClearToEmpty();
}
inline const std::string& BackupInfo::backup() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.BackupInfo.backup)
  return _internal_backup();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BackupInfo::set_backup(ArgT0&& arg0, ArgT... args) {
 
 _impl_.backup_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.BackupInfo.backup)
}
inline std::string* BackupInfo::mutable_backup() {
  std::string* _s = _internal_mutable_backup();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.BackupInfo.backup)
  return _s;
}
inline const std::string& BackupInfo::_internal_backup() const {
  return _impl_.backup_.Get();
}
inline void BackupInfo::_internal_set_backup(const std::string& value) {
  
  _impl_.backup_.Set(value, GetArenaForAllocation());
}
inline std::string* BackupInfo::_internal_mutable_backup() {
  
  return _impl_.backup_.Mutable(GetArenaForAllocation());
}
inline std::string* BackupInfo::release_backup() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.BackupInfo.backup)
  return _impl_.backup_.Release();
}
inline void BackupInfo::set_allocated_backup(std::string* backup) {
  if (backup != nullptr) {
    
  } else {
    
  }
  _impl_.backup_.SetAllocated(backup, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backup_.IsDefault()) {
    _impl_.backup_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.BackupInfo.backup)
}

// .google.protobuf.Timestamp start_time = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool BackupInfo::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool BackupInfo::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BackupInfo::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BackupInfo::start_time() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.BackupInfo.start_time)
  return _internal_start_time();
}
inline void BackupInfo::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.BackupInfo.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BackupInfo::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BackupInfo::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.BackupInfo.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BackupInfo::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BackupInfo::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.BackupInfo.start_time)
  return _msg;
}
inline void BackupInfo::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.BackupInfo.start_time)
}

// .google.protobuf.Timestamp end_time = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool BackupInfo::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool BackupInfo::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BackupInfo::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BackupInfo::end_time() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.BackupInfo.end_time)
  return _internal_end_time();
}
inline void BackupInfo::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.bigtable.admin.v2.BackupInfo.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BackupInfo::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BackupInfo::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.BackupInfo.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BackupInfo::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BackupInfo::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.BackupInfo.end_time)
  return _msg;
}
inline void BackupInfo::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.BackupInfo.end_time)
}

// string source_table = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void BackupInfo::clear_source_table() {
  _impl_.source_table_.ClearToEmpty();
}
inline const std::string& BackupInfo::source_table() const {
  // @@protoc_insertion_point(field_get:google.bigtable.admin.v2.BackupInfo.source_table)
  return _internal_source_table();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BackupInfo::set_source_table(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_table_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.bigtable.admin.v2.BackupInfo.source_table)
}
inline std::string* BackupInfo::mutable_source_table() {
  std::string* _s = _internal_mutable_source_table();
  // @@protoc_insertion_point(field_mutable:google.bigtable.admin.v2.BackupInfo.source_table)
  return _s;
}
inline const std::string& BackupInfo::_internal_source_table() const {
  return _impl_.source_table_.Get();
}
inline void BackupInfo::_internal_set_source_table(const std::string& value) {
  
  _impl_.source_table_.Set(value, GetArenaForAllocation());
}
inline std::string* BackupInfo::_internal_mutable_source_table() {
  
  return _impl_.source_table_.Mutable(GetArenaForAllocation());
}
inline std::string* BackupInfo::release_source_table() {
  // @@protoc_insertion_point(field_release:google.bigtable.admin.v2.BackupInfo.source_table)
  return _impl_.source_table_.Release();
}
inline void BackupInfo::set_allocated_source_table(std::string* source_table) {
  if (source_table != nullptr) {
    
  } else {
    
  }
  _impl_.source_table_.SetAllocated(source_table, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_table_.IsDefault()) {
    _impl_.source_table_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.bigtable.admin.v2.BackupInfo.source_table)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace admin
}  // namespace bigtable
}  // namespace google

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::google::bigtable::admin::v2::Table_ClusterState_ReplicationState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::bigtable::admin::v2::Table_ClusterState_ReplicationState>() {
  return ::google::bigtable::admin::v2::Table_ClusterState_ReplicationState_descriptor();
}
template <> struct is_proto_enum< ::google::bigtable::admin::v2::Table_TimestampGranularity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::bigtable::admin::v2::Table_TimestampGranularity>() {
  return ::google::bigtable::admin::v2::Table_TimestampGranularity_descriptor();
}
template <> struct is_proto_enum< ::google::bigtable::admin::v2::Table_View> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::bigtable::admin::v2::Table_View>() {
  return ::google::bigtable::admin::v2::Table_View_descriptor();
}
template <> struct is_proto_enum< ::google::bigtable::admin::v2::EncryptionInfo_EncryptionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::bigtable::admin::v2::EncryptionInfo_EncryptionType>() {
  return ::google::bigtable::admin::v2::EncryptionInfo_EncryptionType_descriptor();
}
template <> struct is_proto_enum< ::google::bigtable::admin::v2::Snapshot_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::bigtable::admin::v2::Snapshot_State>() {
  return ::google::bigtable::admin::v2::Snapshot_State_descriptor();
}
template <> struct is_proto_enum< ::google::bigtable::admin::v2::Backup_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::bigtable::admin::v2::Backup_State>() {
  return ::google::bigtable::admin::v2::Backup_State_descriptor();
}
template <> struct is_proto_enum< ::google::bigtable::admin::v2::RestoreSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::bigtable::admin::v2::RestoreSourceType>() {
  return ::google::bigtable::admin::v2::RestoreSourceType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_google_2fbigtable_2fadmin_2fv2_2ftable_2eproto
