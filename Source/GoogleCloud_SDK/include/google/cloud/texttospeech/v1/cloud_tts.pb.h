// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/texttospeech/v1/cloud_tts.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_google_2fcloud_2ftexttospeech_2fv1_2fcloud_5ftts_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_google_2fcloud_2ftexttospeech_2fv1_2fcloud_5ftts_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/api/client.pb.h"
#include "google/api/field_behavior.pb.h"
#include "google/api/resource.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_google_2fcloud_2ftexttospeech_2fv1_2fcloud_5ftts_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_google_2fcloud_2ftexttospeech_2fv1_2fcloud_5ftts_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_google_2fcloud_2ftexttospeech_2fv1_2fcloud_5ftts_2eproto;
namespace google {
namespace cloud {
namespace texttospeech {
namespace v1 {
class AudioConfig;
struct AudioConfigDefaultTypeInternal;
extern AudioConfigDefaultTypeInternal _AudioConfig_default_instance_;
class CustomVoiceParams;
struct CustomVoiceParamsDefaultTypeInternal;
extern CustomVoiceParamsDefaultTypeInternal _CustomVoiceParams_default_instance_;
class ListVoicesRequest;
struct ListVoicesRequestDefaultTypeInternal;
extern ListVoicesRequestDefaultTypeInternal _ListVoicesRequest_default_instance_;
class ListVoicesResponse;
struct ListVoicesResponseDefaultTypeInternal;
extern ListVoicesResponseDefaultTypeInternal _ListVoicesResponse_default_instance_;
class SynthesisInput;
struct SynthesisInputDefaultTypeInternal;
extern SynthesisInputDefaultTypeInternal _SynthesisInput_default_instance_;
class SynthesizeSpeechRequest;
struct SynthesizeSpeechRequestDefaultTypeInternal;
extern SynthesizeSpeechRequestDefaultTypeInternal _SynthesizeSpeechRequest_default_instance_;
class SynthesizeSpeechResponse;
struct SynthesizeSpeechResponseDefaultTypeInternal;
extern SynthesizeSpeechResponseDefaultTypeInternal _SynthesizeSpeechResponse_default_instance_;
class Voice;
struct VoiceDefaultTypeInternal;
extern VoiceDefaultTypeInternal _Voice_default_instance_;
class VoiceSelectionParams;
struct VoiceSelectionParamsDefaultTypeInternal;
extern VoiceSelectionParamsDefaultTypeInternal _VoiceSelectionParams_default_instance_;
}  // namespace v1
}  // namespace texttospeech
}  // namespace cloud
}  // namespace google
PROTOBUF_NAMESPACE_OPEN
template<> ::google::cloud::texttospeech::v1::AudioConfig* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1::AudioConfig>(Arena*);
template<> ::google::cloud::texttospeech::v1::CustomVoiceParams* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1::CustomVoiceParams>(Arena*);
template<> ::google::cloud::texttospeech::v1::ListVoicesRequest* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1::ListVoicesRequest>(Arena*);
template<> ::google::cloud::texttospeech::v1::ListVoicesResponse* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1::ListVoicesResponse>(Arena*);
template<> ::google::cloud::texttospeech::v1::SynthesisInput* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1::SynthesisInput>(Arena*);
template<> ::google::cloud::texttospeech::v1::SynthesizeSpeechRequest* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1::SynthesizeSpeechRequest>(Arena*);
template<> ::google::cloud::texttospeech::v1::SynthesizeSpeechResponse* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1::SynthesizeSpeechResponse>(Arena*);
template<> ::google::cloud::texttospeech::v1::Voice* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1::Voice>(Arena*);
template<> ::google::cloud::texttospeech::v1::VoiceSelectionParams* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1::VoiceSelectionParams>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace google {
namespace cloud {
namespace texttospeech {
namespace v1 {

enum CustomVoiceParams_ReportedUsage : int {
  CustomVoiceParams_ReportedUsage_REPORTED_USAGE_UNSPECIFIED = 0,
  CustomVoiceParams_ReportedUsage_REALTIME = 1,
  CustomVoiceParams_ReportedUsage_OFFLINE = 2,
  CustomVoiceParams_ReportedUsage_CustomVoiceParams_ReportedUsage_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CustomVoiceParams_ReportedUsage_CustomVoiceParams_ReportedUsage_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CustomVoiceParams_ReportedUsage_IsValid(int value);
constexpr CustomVoiceParams_ReportedUsage CustomVoiceParams_ReportedUsage_ReportedUsage_MIN = CustomVoiceParams_ReportedUsage_REPORTED_USAGE_UNSPECIFIED;
constexpr CustomVoiceParams_ReportedUsage CustomVoiceParams_ReportedUsage_ReportedUsage_MAX = CustomVoiceParams_ReportedUsage_OFFLINE;
constexpr int CustomVoiceParams_ReportedUsage_ReportedUsage_ARRAYSIZE = CustomVoiceParams_ReportedUsage_ReportedUsage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CustomVoiceParams_ReportedUsage_descriptor();
template<typename T>
inline const std::string& CustomVoiceParams_ReportedUsage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CustomVoiceParams_ReportedUsage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CustomVoiceParams_ReportedUsage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CustomVoiceParams_ReportedUsage_descriptor(), enum_t_value);
}
inline bool CustomVoiceParams_ReportedUsage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CustomVoiceParams_ReportedUsage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CustomVoiceParams_ReportedUsage>(
    CustomVoiceParams_ReportedUsage_descriptor(), name, value);
}
enum SsmlVoiceGender : int {
  SSML_VOICE_GENDER_UNSPECIFIED = 0,
  MALE = 1,
  FEMALE = 2,
  NEUTRAL = 3,
  SsmlVoiceGender_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SsmlVoiceGender_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SsmlVoiceGender_IsValid(int value);
constexpr SsmlVoiceGender SsmlVoiceGender_MIN = SSML_VOICE_GENDER_UNSPECIFIED;
constexpr SsmlVoiceGender SsmlVoiceGender_MAX = NEUTRAL;
constexpr int SsmlVoiceGender_ARRAYSIZE = SsmlVoiceGender_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SsmlVoiceGender_descriptor();
template<typename T>
inline const std::string& SsmlVoiceGender_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SsmlVoiceGender>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SsmlVoiceGender_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SsmlVoiceGender_descriptor(), enum_t_value);
}
inline bool SsmlVoiceGender_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SsmlVoiceGender* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SsmlVoiceGender>(
    SsmlVoiceGender_descriptor(), name, value);
}
enum AudioEncoding : int {
  AUDIO_ENCODING_UNSPECIFIED = 0,
  LINEAR16 = 1,
  MP3 = 2,
  OGG_OPUS = 3,
  MULAW = 5,
  ALAW = 6,
  AudioEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AudioEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AudioEncoding_IsValid(int value);
constexpr AudioEncoding AudioEncoding_MIN = AUDIO_ENCODING_UNSPECIFIED;
constexpr AudioEncoding AudioEncoding_MAX = ALAW;
constexpr int AudioEncoding_ARRAYSIZE = AudioEncoding_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioEncoding_descriptor();
template<typename T>
inline const std::string& AudioEncoding_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioEncoding>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioEncoding_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioEncoding_descriptor(), enum_t_value);
}
inline bool AudioEncoding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioEncoding* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioEncoding>(
    AudioEncoding_descriptor(), name, value);
}
// ===================================================================

class ListVoicesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1.ListVoicesRequest) */ {
 public:
  inline ListVoicesRequest() : ListVoicesRequest(nullptr) {}
  ~ListVoicesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListVoicesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListVoicesRequest(const ListVoicesRequest& from);
  ListVoicesRequest(ListVoicesRequest&& from) noexcept
    : ListVoicesRequest() {
    *this = ::std::move(from);
  }

  inline ListVoicesRequest& operator=(const ListVoicesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListVoicesRequest& operator=(ListVoicesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListVoicesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListVoicesRequest* internal_default_instance() {
    return reinterpret_cast<const ListVoicesRequest*>(
               &_ListVoicesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ListVoicesRequest& a, ListVoicesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListVoicesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListVoicesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListVoicesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListVoicesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListVoicesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListVoicesRequest& from) {
    ListVoicesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListVoicesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.cloud.texttospeech.v1.ListVoicesRequest";
  }
  protected:
  explicit ListVoicesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageCodeFieldNumber = 1,
  };
  // string language_code = 1 [(.google.api.field_behavior) = OPTIONAL];
  void clear_language_code();
  const std::string& language_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language_code();
  PROTOBUF_NODISCARD std::string* release_language_code();
  void set_allocated_language_code(std::string* language_code);
  private:
  const std::string& _internal_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_code(const std::string& value);
  std::string* _internal_mutable_language_code();
  public:

  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1.ListVoicesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fcloud_2ftexttospeech_2fv1_2fcloud_5ftts_2eproto;
};
// -------------------------------------------------------------------

class ListVoicesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1.ListVoicesResponse) */ {
 public:
  inline ListVoicesResponse() : ListVoicesResponse(nullptr) {}
  ~ListVoicesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListVoicesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListVoicesResponse(const ListVoicesResponse& from);
  ListVoicesResponse(ListVoicesResponse&& from) noexcept
    : ListVoicesResponse() {
    *this = ::std::move(from);
  }

  inline ListVoicesResponse& operator=(const ListVoicesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListVoicesResponse& operator=(ListVoicesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListVoicesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListVoicesResponse* internal_default_instance() {
    return reinterpret_cast<const ListVoicesResponse*>(
               &_ListVoicesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ListVoicesResponse& a, ListVoicesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListVoicesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListVoicesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListVoicesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListVoicesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListVoicesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListVoicesResponse& from) {
    ListVoicesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListVoicesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.cloud.texttospeech.v1.ListVoicesResponse";
  }
  protected:
  explicit ListVoicesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoicesFieldNumber = 1,
  };
  // repeated .google.cloud.texttospeech.v1.Voice voices = 1;
  int voices_size() const;
  private:
  int _internal_voices_size() const;
  public:
  void clear_voices();
  ::google::cloud::texttospeech::v1::Voice* mutable_voices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::cloud::texttospeech::v1::Voice >*
      mutable_voices();
  private:
  const ::google::cloud::texttospeech::v1::Voice& _internal_voices(int index) const;
  ::google::cloud::texttospeech::v1::Voice* _internal_add_voices();
  public:
  const ::google::cloud::texttospeech::v1::Voice& voices(int index) const;
  ::google::cloud::texttospeech::v1::Voice* add_voices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::cloud::texttospeech::v1::Voice >&
      voices() const;

  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1.ListVoicesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::cloud::texttospeech::v1::Voice > voices_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fcloud_2ftexttospeech_2fv1_2fcloud_5ftts_2eproto;
};
// -------------------------------------------------------------------

class Voice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1.Voice) */ {
 public:
  inline Voice() : Voice(nullptr) {}
  ~Voice() override;
  explicit PROTOBUF_CONSTEXPR Voice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Voice(const Voice& from);
  Voice(Voice&& from) noexcept
    : Voice() {
    *this = ::std::move(from);
  }

  inline Voice& operator=(const Voice& from) {
    CopyFrom(from);
    return *this;
  }
  inline Voice& operator=(Voice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Voice& default_instance() {
    return *internal_default_instance();
  }
  static inline const Voice* internal_default_instance() {
    return reinterpret_cast<const Voice*>(
               &_Voice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Voice& a, Voice& b) {
    a.Swap(&b);
  }
  inline void Swap(Voice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Voice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Voice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Voice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Voice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Voice& from) {
    Voice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Voice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.cloud.texttospeech.v1.Voice";
  }
  protected:
  explicit Voice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageCodesFieldNumber = 1,
    kNameFieldNumber = 2,
    kSsmlGenderFieldNumber = 3,
    kNaturalSampleRateHertzFieldNumber = 4,
  };
  // repeated string language_codes = 1;
  int language_codes_size() const;
  private:
  int _internal_language_codes_size() const;
  public:
  void clear_language_codes();
  const std::string& language_codes(int index) const;
  std::string* mutable_language_codes(int index);
  void set_language_codes(int index, const std::string& value);
  void set_language_codes(int index, std::string&& value);
  void set_language_codes(int index, const char* value);
  void set_language_codes(int index, const char* value, size_t size);
  std::string* add_language_codes();
  void add_language_codes(const std::string& value);
  void add_language_codes(std::string&& value);
  void add_language_codes(const char* value);
  void add_language_codes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& language_codes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_language_codes();
  private:
  const std::string& _internal_language_codes(int index) const;
  std::string* _internal_add_language_codes();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.cloud.texttospeech.v1.SsmlVoiceGender ssml_gender = 3;
  void clear_ssml_gender();
  ::google::cloud::texttospeech::v1::SsmlVoiceGender ssml_gender() const;
  void set_ssml_gender(::google::cloud::texttospeech::v1::SsmlVoiceGender value);
  private:
  ::google::cloud::texttospeech::v1::SsmlVoiceGender _internal_ssml_gender() const;
  void _internal_set_ssml_gender(::google::cloud::texttospeech::v1::SsmlVoiceGender value);
  public:

  // int32 natural_sample_rate_hertz = 4;
  void clear_natural_sample_rate_hertz();
  int32_t natural_sample_rate_hertz() const;
  void set_natural_sample_rate_hertz(int32_t value);
  private:
  int32_t _internal_natural_sample_rate_hertz() const;
  void _internal_set_natural_sample_rate_hertz(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1.Voice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> language_codes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int ssml_gender_;
    int32_t natural_sample_rate_hertz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fcloud_2ftexttospeech_2fv1_2fcloud_5ftts_2eproto;
};
// -------------------------------------------------------------------

class SynthesizeSpeechRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1.SynthesizeSpeechRequest) */ {
 public:
  inline SynthesizeSpeechRequest() : SynthesizeSpeechRequest(nullptr) {}
  ~SynthesizeSpeechRequest() override;
  explicit PROTOBUF_CONSTEXPR SynthesizeSpeechRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SynthesizeSpeechRequest(const SynthesizeSpeechRequest& from);
  SynthesizeSpeechRequest(SynthesizeSpeechRequest&& from) noexcept
    : SynthesizeSpeechRequest() {
    *this = ::std::move(from);
  }

  inline SynthesizeSpeechRequest& operator=(const SynthesizeSpeechRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SynthesizeSpeechRequest& operator=(SynthesizeSpeechRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SynthesizeSpeechRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SynthesizeSpeechRequest* internal_default_instance() {
    return reinterpret_cast<const SynthesizeSpeechRequest*>(
               &_SynthesizeSpeechRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SynthesizeSpeechRequest& a, SynthesizeSpeechRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SynthesizeSpeechRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SynthesizeSpeechRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SynthesizeSpeechRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SynthesizeSpeechRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SynthesizeSpeechRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SynthesizeSpeechRequest& from) {
    SynthesizeSpeechRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SynthesizeSpeechRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.cloud.texttospeech.v1.SynthesizeSpeechRequest";
  }
  protected:
  explicit SynthesizeSpeechRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 1,
    kVoiceFieldNumber = 2,
    kAudioConfigFieldNumber = 3,
  };
  // .google.cloud.texttospeech.v1.SynthesisInput input = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::google::cloud::texttospeech::v1::SynthesisInput& input() const;
  PROTOBUF_NODISCARD ::google::cloud::texttospeech::v1::SynthesisInput* release_input();
  ::google::cloud::texttospeech::v1::SynthesisInput* mutable_input();
  void set_allocated_input(::google::cloud::texttospeech::v1::SynthesisInput* input);
  private:
  const ::google::cloud::texttospeech::v1::SynthesisInput& _internal_input() const;
  ::google::cloud::texttospeech::v1::SynthesisInput* _internal_mutable_input();
  public:
  void unsafe_arena_set_allocated_input(
      ::google::cloud::texttospeech::v1::SynthesisInput* input);
  ::google::cloud::texttospeech::v1::SynthesisInput* unsafe_arena_release_input();

  // .google.cloud.texttospeech.v1.VoiceSelectionParams voice = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_voice() const;
  private:
  bool _internal_has_voice() const;
  public:
  void clear_voice();
  const ::google::cloud::texttospeech::v1::VoiceSelectionParams& voice() const;
  PROTOBUF_NODISCARD ::google::cloud::texttospeech::v1::VoiceSelectionParams* release_voice();
  ::google::cloud::texttospeech::v1::VoiceSelectionParams* mutable_voice();
  void set_allocated_voice(::google::cloud::texttospeech::v1::VoiceSelectionParams* voice);
  private:
  const ::google::cloud::texttospeech::v1::VoiceSelectionParams& _internal_voice() const;
  ::google::cloud::texttospeech::v1::VoiceSelectionParams* _internal_mutable_voice();
  public:
  void unsafe_arena_set_allocated_voice(
      ::google::cloud::texttospeech::v1::VoiceSelectionParams* voice);
  ::google::cloud::texttospeech::v1::VoiceSelectionParams* unsafe_arena_release_voice();

  // .google.cloud.texttospeech.v1.AudioConfig audio_config = 3 [(.google.api.field_behavior) = REQUIRED];
  bool has_audio_config() const;
  private:
  bool _internal_has_audio_config() const;
  public:
  void clear_audio_config();
  const ::google::cloud::texttospeech::v1::AudioConfig& audio_config() const;
  PROTOBUF_NODISCARD ::google::cloud::texttospeech::v1::AudioConfig* release_audio_config();
  ::google::cloud::texttospeech::v1::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::google::cloud::texttospeech::v1::AudioConfig* audio_config);
  private:
  const ::google::cloud::texttospeech::v1::AudioConfig& _internal_audio_config() const;
  ::google::cloud::texttospeech::v1::AudioConfig* _internal_mutable_audio_config();
  public:
  void unsafe_arena_set_allocated_audio_config(
      ::google::cloud::texttospeech::v1::AudioConfig* audio_config);
  ::google::cloud::texttospeech::v1::AudioConfig* unsafe_arena_release_audio_config();

  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1.SynthesizeSpeechRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::cloud::texttospeech::v1::SynthesisInput* input_;
    ::google::cloud::texttospeech::v1::VoiceSelectionParams* voice_;
    ::google::cloud::texttospeech::v1::AudioConfig* audio_config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fcloud_2ftexttospeech_2fv1_2fcloud_5ftts_2eproto;
};
// -------------------------------------------------------------------

class SynthesisInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1.SynthesisInput) */ {
 public:
  inline SynthesisInput() : SynthesisInput(nullptr) {}
  ~SynthesisInput() override;
  explicit PROTOBUF_CONSTEXPR SynthesisInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SynthesisInput(const SynthesisInput& from);
  SynthesisInput(SynthesisInput&& from) noexcept
    : SynthesisInput() {
    *this = ::std::move(from);
  }

  inline SynthesisInput& operator=(const SynthesisInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SynthesisInput& operator=(SynthesisInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SynthesisInput& default_instance() {
    return *internal_default_instance();
  }
  enum InputSourceCase {
    kText = 1,
    kSsml = 2,
    INPUT_SOURCE_NOT_SET = 0,
  };

  static inline const SynthesisInput* internal_default_instance() {
    return reinterpret_cast<const SynthesisInput*>(
               &_SynthesisInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SynthesisInput& a, SynthesisInput& b) {
    a.Swap(&b);
  }
  inline void Swap(SynthesisInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SynthesisInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SynthesisInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SynthesisInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SynthesisInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SynthesisInput& from) {
    SynthesisInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SynthesisInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.cloud.texttospeech.v1.SynthesisInput";
  }
  protected:
  explicit SynthesisInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kSsmlFieldNumber = 2,
  };
  // string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string ssml = 2;
  bool has_ssml() const;
  private:
  bool _internal_has_ssml() const;
  public:
  void clear_ssml();
  const std::string& ssml() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ssml(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ssml();
  PROTOBUF_NODISCARD std::string* release_ssml();
  void set_allocated_ssml(std::string* ssml);
  private:
  const std::string& _internal_ssml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ssml(const std::string& value);
  std::string* _internal_mutable_ssml();
  public:

  void clear_input_source();
  InputSourceCase input_source_case() const;
  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1.SynthesisInput)
 private:
  class _Internal;
  void set_has_text();
  void set_has_ssml();

  inline bool has_input_source() const;
  inline void clear_has_input_source();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union InputSourceUnion {
      constexpr InputSourceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ssml_;
    } input_source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fcloud_2ftexttospeech_2fv1_2fcloud_5ftts_2eproto;
};
// -------------------------------------------------------------------

class VoiceSelectionParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1.VoiceSelectionParams) */ {
 public:
  inline VoiceSelectionParams() : VoiceSelectionParams(nullptr) {}
  ~VoiceSelectionParams() override;
  explicit PROTOBUF_CONSTEXPR VoiceSelectionParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoiceSelectionParams(const VoiceSelectionParams& from);
  VoiceSelectionParams(VoiceSelectionParams&& from) noexcept
    : VoiceSelectionParams() {
    *this = ::std::move(from);
  }

  inline VoiceSelectionParams& operator=(const VoiceSelectionParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoiceSelectionParams& operator=(VoiceSelectionParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoiceSelectionParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoiceSelectionParams* internal_default_instance() {
    return reinterpret_cast<const VoiceSelectionParams*>(
               &_VoiceSelectionParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VoiceSelectionParams& a, VoiceSelectionParams& b) {
    a.Swap(&b);
  }
  inline void Swap(VoiceSelectionParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoiceSelectionParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoiceSelectionParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoiceSelectionParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoiceSelectionParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoiceSelectionParams& from) {
    VoiceSelectionParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoiceSelectionParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.cloud.texttospeech.v1.VoiceSelectionParams";
  }
  protected:
  explicit VoiceSelectionParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageCodeFieldNumber = 1,
    kNameFieldNumber = 2,
    kCustomVoiceFieldNumber = 4,
    kSsmlGenderFieldNumber = 3,
  };
  // string language_code = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_language_code();
  const std::string& language_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language_code();
  PROTOBUF_NODISCARD std::string* release_language_code();
  void set_allocated_language_code(std::string* language_code);
  private:
  const std::string& _internal_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_code(const std::string& value);
  std::string* _internal_mutable_language_code();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.cloud.texttospeech.v1.CustomVoiceParams custom_voice = 4;
  bool has_custom_voice() const;
  private:
  bool _internal_has_custom_voice() const;
  public:
  void clear_custom_voice();
  const ::google::cloud::texttospeech::v1::CustomVoiceParams& custom_voice() const;
  PROTOBUF_NODISCARD ::google::cloud::texttospeech::v1::CustomVoiceParams* release_custom_voice();
  ::google::cloud::texttospeech::v1::CustomVoiceParams* mutable_custom_voice();
  void set_allocated_custom_voice(::google::cloud::texttospeech::v1::CustomVoiceParams* custom_voice);
  private:
  const ::google::cloud::texttospeech::v1::CustomVoiceParams& _internal_custom_voice() const;
  ::google::cloud::texttospeech::v1::CustomVoiceParams* _internal_mutable_custom_voice();
  public:
  void unsafe_arena_set_allocated_custom_voice(
      ::google::cloud::texttospeech::v1::CustomVoiceParams* custom_voice);
  ::google::cloud::texttospeech::v1::CustomVoiceParams* unsafe_arena_release_custom_voice();

  // .google.cloud.texttospeech.v1.SsmlVoiceGender ssml_gender = 3;
  void clear_ssml_gender();
  ::google::cloud::texttospeech::v1::SsmlVoiceGender ssml_gender() const;
  void set_ssml_gender(::google::cloud::texttospeech::v1::SsmlVoiceGender value);
  private:
  ::google::cloud::texttospeech::v1::SsmlVoiceGender _internal_ssml_gender() const;
  void _internal_set_ssml_gender(::google::cloud::texttospeech::v1::SsmlVoiceGender value);
  public:

  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1.VoiceSelectionParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::google::cloud::texttospeech::v1::CustomVoiceParams* custom_voice_;
    int ssml_gender_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fcloud_2ftexttospeech_2fv1_2fcloud_5ftts_2eproto;
};
// -------------------------------------------------------------------

class AudioConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1.AudioConfig) */ {
 public:
  inline AudioConfig() : AudioConfig(nullptr) {}
  ~AudioConfig() override;
  explicit PROTOBUF_CONSTEXPR AudioConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioConfig(const AudioConfig& from);
  AudioConfig(AudioConfig&& from) noexcept
    : AudioConfig() {
    *this = ::std::move(from);
  }

  inline AudioConfig& operator=(const AudioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioConfig& operator=(AudioConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioConfig* internal_default_instance() {
    return reinterpret_cast<const AudioConfig*>(
               &_AudioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AudioConfig& a, AudioConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioConfig& from) {
    AudioConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.cloud.texttospeech.v1.AudioConfig";
  }
  protected:
  explicit AudioConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEffectsProfileIdFieldNumber = 6,
    kSpeakingRateFieldNumber = 2,
    kPitchFieldNumber = 3,
    kAudioEncodingFieldNumber = 1,
    kSampleRateHertzFieldNumber = 5,
    kVolumeGainDbFieldNumber = 4,
  };
  // repeated string effects_profile_id = 6 [(.google.api.field_behavior) = INPUT_ONLY, (.google.api.field_behavior) = OPTIONAL];
  int effects_profile_id_size() const;
  private:
  int _internal_effects_profile_id_size() const;
  public:
  void clear_effects_profile_id();
  const std::string& effects_profile_id(int index) const;
  std::string* mutable_effects_profile_id(int index);
  void set_effects_profile_id(int index, const std::string& value);
  void set_effects_profile_id(int index, std::string&& value);
  void set_effects_profile_id(int index, const char* value);
  void set_effects_profile_id(int index, const char* value, size_t size);
  std::string* add_effects_profile_id();
  void add_effects_profile_id(const std::string& value);
  void add_effects_profile_id(std::string&& value);
  void add_effects_profile_id(const char* value);
  void add_effects_profile_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& effects_profile_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_effects_profile_id();
  private:
  const std::string& _internal_effects_profile_id(int index) const;
  std::string* _internal_add_effects_profile_id();
  public:

  // double speaking_rate = 2 [(.google.api.field_behavior) = INPUT_ONLY, (.google.api.field_behavior) = OPTIONAL];
  void clear_speaking_rate();
  double speaking_rate() const;
  void set_speaking_rate(double value);
  private:
  double _internal_speaking_rate() const;
  void _internal_set_speaking_rate(double value);
  public:

  // double pitch = 3 [(.google.api.field_behavior) = INPUT_ONLY, (.google.api.field_behavior) = OPTIONAL];
  void clear_pitch();
  double pitch() const;
  void set_pitch(double value);
  private:
  double _internal_pitch() const;
  void _internal_set_pitch(double value);
  public:

  // .google.cloud.texttospeech.v1.AudioEncoding audio_encoding = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_audio_encoding();
  ::google::cloud::texttospeech::v1::AudioEncoding audio_encoding() const;
  void set_audio_encoding(::google::cloud::texttospeech::v1::AudioEncoding value);
  private:
  ::google::cloud::texttospeech::v1::AudioEncoding _internal_audio_encoding() const;
  void _internal_set_audio_encoding(::google::cloud::texttospeech::v1::AudioEncoding value);
  public:

  // int32 sample_rate_hertz = 5 [(.google.api.field_behavior) = OPTIONAL];
  void clear_sample_rate_hertz();
  int32_t sample_rate_hertz() const;
  void set_sample_rate_hertz(int32_t value);
  private:
  int32_t _internal_sample_rate_hertz() const;
  void _internal_set_sample_rate_hertz(int32_t value);
  public:

  // double volume_gain_db = 4 [(.google.api.field_behavior) = INPUT_ONLY, (.google.api.field_behavior) = OPTIONAL];
  void clear_volume_gain_db();
  double volume_gain_db() const;
  void set_volume_gain_db(double value);
  private:
  double _internal_volume_gain_db() const;
  void _internal_set_volume_gain_db(double value);
  public:

  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1.AudioConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> effects_profile_id_;
    double speaking_rate_;
    double pitch_;
    int audio_encoding_;
    int32_t sample_rate_hertz_;
    double volume_gain_db_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fcloud_2ftexttospeech_2fv1_2fcloud_5ftts_2eproto;
};
// -------------------------------------------------------------------

class CustomVoiceParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1.CustomVoiceParams) */ {
 public:
  inline CustomVoiceParams() : CustomVoiceParams(nullptr) {}
  ~CustomVoiceParams() override;
  explicit PROTOBUF_CONSTEXPR CustomVoiceParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomVoiceParams(const CustomVoiceParams& from);
  CustomVoiceParams(CustomVoiceParams&& from) noexcept
    : CustomVoiceParams() {
    *this = ::std::move(from);
  }

  inline CustomVoiceParams& operator=(const CustomVoiceParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomVoiceParams& operator=(CustomVoiceParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomVoiceParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomVoiceParams* internal_default_instance() {
    return reinterpret_cast<const CustomVoiceParams*>(
               &_CustomVoiceParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CustomVoiceParams& a, CustomVoiceParams& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomVoiceParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomVoiceParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomVoiceParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomVoiceParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomVoiceParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomVoiceParams& from) {
    CustomVoiceParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomVoiceParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.cloud.texttospeech.v1.CustomVoiceParams";
  }
  protected:
  explicit CustomVoiceParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CustomVoiceParams_ReportedUsage ReportedUsage;
  static constexpr ReportedUsage REPORTED_USAGE_UNSPECIFIED =
    CustomVoiceParams_ReportedUsage_REPORTED_USAGE_UNSPECIFIED;
  static constexpr ReportedUsage REALTIME =
    CustomVoiceParams_ReportedUsage_REALTIME;
  static constexpr ReportedUsage OFFLINE =
    CustomVoiceParams_ReportedUsage_OFFLINE;
  static inline bool ReportedUsage_IsValid(int value) {
    return CustomVoiceParams_ReportedUsage_IsValid(value);
  }
  static constexpr ReportedUsage ReportedUsage_MIN =
    CustomVoiceParams_ReportedUsage_ReportedUsage_MIN;
  static constexpr ReportedUsage ReportedUsage_MAX =
    CustomVoiceParams_ReportedUsage_ReportedUsage_MAX;
  static constexpr int ReportedUsage_ARRAYSIZE =
    CustomVoiceParams_ReportedUsage_ReportedUsage_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ReportedUsage_descriptor() {
    return CustomVoiceParams_ReportedUsage_descriptor();
  }
  template<typename T>
  static inline const std::string& ReportedUsage_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ReportedUsage>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ReportedUsage_Name.");
    return CustomVoiceParams_ReportedUsage_Name(enum_t_value);
  }
  static inline bool ReportedUsage_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ReportedUsage* value) {
    return CustomVoiceParams_ReportedUsage_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModelFieldNumber = 1,
    kReportedUsageFieldNumber = 3,
  };
  // string model = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // .google.cloud.texttospeech.v1.CustomVoiceParams.ReportedUsage reported_usage = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_reported_usage();
  ::google::cloud::texttospeech::v1::CustomVoiceParams_ReportedUsage reported_usage() const;
  void set_reported_usage(::google::cloud::texttospeech::v1::CustomVoiceParams_ReportedUsage value);
  private:
  ::google::cloud::texttospeech::v1::CustomVoiceParams_ReportedUsage _internal_reported_usage() const;
  void _internal_set_reported_usage(::google::cloud::texttospeech::v1::CustomVoiceParams_ReportedUsage value);
  public:

  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1.CustomVoiceParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    int reported_usage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fcloud_2ftexttospeech_2fv1_2fcloud_5ftts_2eproto;
};
// -------------------------------------------------------------------

class SynthesizeSpeechResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1.SynthesizeSpeechResponse) */ {
 public:
  inline SynthesizeSpeechResponse() : SynthesizeSpeechResponse(nullptr) {}
  ~SynthesizeSpeechResponse() override;
  explicit PROTOBUF_CONSTEXPR SynthesizeSpeechResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SynthesizeSpeechResponse(const SynthesizeSpeechResponse& from);
  SynthesizeSpeechResponse(SynthesizeSpeechResponse&& from) noexcept
    : SynthesizeSpeechResponse() {
    *this = ::std::move(from);
  }

  inline SynthesizeSpeechResponse& operator=(const SynthesizeSpeechResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SynthesizeSpeechResponse& operator=(SynthesizeSpeechResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SynthesizeSpeechResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SynthesizeSpeechResponse* internal_default_instance() {
    return reinterpret_cast<const SynthesizeSpeechResponse*>(
               &_SynthesizeSpeechResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SynthesizeSpeechResponse& a, SynthesizeSpeechResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SynthesizeSpeechResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SynthesizeSpeechResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SynthesizeSpeechResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SynthesizeSpeechResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SynthesizeSpeechResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SynthesizeSpeechResponse& from) {
    SynthesizeSpeechResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SynthesizeSpeechResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.cloud.texttospeech.v1.SynthesizeSpeechResponse";
  }
  protected:
  explicit SynthesizeSpeechResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioContentFieldNumber = 1,
  };
  // bytes audio_content = 1;
  void clear_audio_content();
  const std::string& audio_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_content();
  PROTOBUF_NODISCARD std::string* release_audio_content();
  void set_allocated_audio_content(std::string* audio_content);
  private:
  const std::string& _internal_audio_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_content(const std::string& value);
  std::string* _internal_mutable_audio_content();
  public:

  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1.SynthesizeSpeechResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_content_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2fcloud_2ftexttospeech_2fv1_2fcloud_5ftts_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ListVoicesRequest

// string language_code = 1 [(.google.api.field_behavior) = OPTIONAL];
inline void ListVoicesRequest::clear_language_code() {
  _impl_.language_code_.ClearToEmpty();
}
inline const std::string& ListVoicesRequest::language_code() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.ListVoicesRequest.language_code)
  return _internal_language_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListVoicesRequest::set_language_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.ListVoicesRequest.language_code)
}
inline std::string* ListVoicesRequest::mutable_language_code() {
  std::string* _s = _internal_mutable_language_code();
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1.ListVoicesRequest.language_code)
  return _s;
}
inline const std::string& ListVoicesRequest::_internal_language_code() const {
  return _impl_.language_code_.Get();
}
inline void ListVoicesRequest::_internal_set_language_code(const std::string& value) {
  
  _impl_.language_code_.Set(value, GetArenaForAllocation());
}
inline std::string* ListVoicesRequest::_internal_mutable_language_code() {
  
  return _impl_.language_code_.Mutable(GetArenaForAllocation());
}
inline std::string* ListVoicesRequest::release_language_code() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1.ListVoicesRequest.language_code)
  return _impl_.language_code_.Release();
}
inline void ListVoicesRequest::set_allocated_language_code(std::string* language_code) {
  if (language_code != nullptr) {
    
  } else {
    
  }
  _impl_.language_code_.SetAllocated(language_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_code_.IsDefault()) {
    _impl_.language_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1.ListVoicesRequest.language_code)
}

// -------------------------------------------------------------------

// ListVoicesResponse

// repeated .google.cloud.texttospeech.v1.Voice voices = 1;
inline int ListVoicesResponse::_internal_voices_size() const {
  return _impl_.voices_.size();
}
inline int ListVoicesResponse::voices_size() const {
  return _internal_voices_size();
}
inline void ListVoicesResponse::clear_voices() {
  _impl_.voices_.Clear();
}
inline ::google::cloud::texttospeech::v1::Voice* ListVoicesResponse::mutable_voices(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1.ListVoicesResponse.voices)
  return _impl_.voices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::cloud::texttospeech::v1::Voice >*
ListVoicesResponse::mutable_voices() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.texttospeech.v1.ListVoicesResponse.voices)
  return &_impl_.voices_;
}
inline const ::google::cloud::texttospeech::v1::Voice& ListVoicesResponse::_internal_voices(int index) const {
  return _impl_.voices_.Get(index);
}
inline const ::google::cloud::texttospeech::v1::Voice& ListVoicesResponse::voices(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.ListVoicesResponse.voices)
  return _internal_voices(index);
}
inline ::google::cloud::texttospeech::v1::Voice* ListVoicesResponse::_internal_add_voices() {
  return _impl_.voices_.Add();
}
inline ::google::cloud::texttospeech::v1::Voice* ListVoicesResponse::add_voices() {
  ::google::cloud::texttospeech::v1::Voice* _add = _internal_add_voices();
  // @@protoc_insertion_point(field_add:google.cloud.texttospeech.v1.ListVoicesResponse.voices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::cloud::texttospeech::v1::Voice >&
ListVoicesResponse::voices() const {
  // @@protoc_insertion_point(field_list:google.cloud.texttospeech.v1.ListVoicesResponse.voices)
  return _impl_.voices_;
}

// -------------------------------------------------------------------

// Voice

// repeated string language_codes = 1;
inline int Voice::_internal_language_codes_size() const {
  return _impl_.language_codes_.size();
}
inline int Voice::language_codes_size() const {
  return _internal_language_codes_size();
}
inline void Voice::clear_language_codes() {
  _impl_.language_codes_.Clear();
}
inline std::string* Voice::add_language_codes() {
  std::string* _s = _internal_add_language_codes();
  // @@protoc_insertion_point(field_add_mutable:google.cloud.texttospeech.v1.Voice.language_codes)
  return _s;
}
inline const std::string& Voice::_internal_language_codes(int index) const {
  return _impl_.language_codes_.Get(index);
}
inline const std::string& Voice::language_codes(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.Voice.language_codes)
  return _internal_language_codes(index);
}
inline std::string* Voice::mutable_language_codes(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1.Voice.language_codes)
  return _impl_.language_codes_.Mutable(index);
}
inline void Voice::set_language_codes(int index, const std::string& value) {
  _impl_.language_codes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.Voice.language_codes)
}
inline void Voice::set_language_codes(int index, std::string&& value) {
  _impl_.language_codes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.Voice.language_codes)
}
inline void Voice::set_language_codes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.language_codes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.cloud.texttospeech.v1.Voice.language_codes)
}
inline void Voice::set_language_codes(int index, const char* value, size_t size) {
  _impl_.language_codes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.cloud.texttospeech.v1.Voice.language_codes)
}
inline std::string* Voice::_internal_add_language_codes() {
  return _impl_.language_codes_.Add();
}
inline void Voice::add_language_codes(const std::string& value) {
  _impl_.language_codes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.cloud.texttospeech.v1.Voice.language_codes)
}
inline void Voice::add_language_codes(std::string&& value) {
  _impl_.language_codes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.cloud.texttospeech.v1.Voice.language_codes)
}
inline void Voice::add_language_codes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.language_codes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.cloud.texttospeech.v1.Voice.language_codes)
}
inline void Voice::add_language_codes(const char* value, size_t size) {
  _impl_.language_codes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.cloud.texttospeech.v1.Voice.language_codes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Voice::language_codes() const {
  // @@protoc_insertion_point(field_list:google.cloud.texttospeech.v1.Voice.language_codes)
  return _impl_.language_codes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Voice::mutable_language_codes() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.texttospeech.v1.Voice.language_codes)
  return &_impl_.language_codes_;
}

// string name = 2;
inline void Voice::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Voice::name() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.Voice.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Voice::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.Voice.name)
}
inline std::string* Voice::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1.Voice.name)
  return _s;
}
inline const std::string& Voice::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Voice::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Voice::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Voice::release_name() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1.Voice.name)
  return _impl_.name_.Release();
}
inline void Voice::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1.Voice.name)
}

// .google.cloud.texttospeech.v1.SsmlVoiceGender ssml_gender = 3;
inline void Voice::clear_ssml_gender() {
  _impl_.ssml_gender_ = 0;
}
inline ::google::cloud::texttospeech::v1::SsmlVoiceGender Voice::_internal_ssml_gender() const {
  return static_cast< ::google::cloud::texttospeech::v1::SsmlVoiceGender >(_impl_.ssml_gender_);
}
inline ::google::cloud::texttospeech::v1::SsmlVoiceGender Voice::ssml_gender() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.Voice.ssml_gender)
  return _internal_ssml_gender();
}
inline void Voice::_internal_set_ssml_gender(::google::cloud::texttospeech::v1::SsmlVoiceGender value) {
  
  _impl_.ssml_gender_ = value;
}
inline void Voice::set_ssml_gender(::google::cloud::texttospeech::v1::SsmlVoiceGender value) {
  _internal_set_ssml_gender(value);
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.Voice.ssml_gender)
}

// int32 natural_sample_rate_hertz = 4;
inline void Voice::clear_natural_sample_rate_hertz() {
  _impl_.natural_sample_rate_hertz_ = 0;
}
inline int32_t Voice::_internal_natural_sample_rate_hertz() const {
  return _impl_.natural_sample_rate_hertz_;
}
inline int32_t Voice::natural_sample_rate_hertz() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.Voice.natural_sample_rate_hertz)
  return _internal_natural_sample_rate_hertz();
}
inline void Voice::_internal_set_natural_sample_rate_hertz(int32_t value) {
  
  _impl_.natural_sample_rate_hertz_ = value;
}
inline void Voice::set_natural_sample_rate_hertz(int32_t value) {
  _internal_set_natural_sample_rate_hertz(value);
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.Voice.natural_sample_rate_hertz)
}

// -------------------------------------------------------------------

// SynthesizeSpeechRequest

// .google.cloud.texttospeech.v1.SynthesisInput input = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool SynthesizeSpeechRequest::_internal_has_input() const {
  return this != internal_default_instance() && _impl_.input_ != nullptr;
}
inline bool SynthesizeSpeechRequest::has_input() const {
  return _internal_has_input();
}
inline void SynthesizeSpeechRequest::clear_input() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_ != nullptr) {
    delete _impl_.input_;
  }
  _impl_.input_ = nullptr;
}
inline const ::google::cloud::texttospeech::v1::SynthesisInput& SynthesizeSpeechRequest::_internal_input() const {
  const ::google::cloud::texttospeech::v1::SynthesisInput* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::cloud::texttospeech::v1::SynthesisInput&>(
      ::google::cloud::texttospeech::v1::_SynthesisInput_default_instance_);
}
inline const ::google::cloud::texttospeech::v1::SynthesisInput& SynthesizeSpeechRequest::input() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.SynthesizeSpeechRequest.input)
  return _internal_input();
}
inline void SynthesizeSpeechRequest::unsafe_arena_set_allocated_input(
    ::google::cloud::texttospeech::v1::SynthesisInput* input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = input;
  if (input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.cloud.texttospeech.v1.SynthesizeSpeechRequest.input)
}
inline ::google::cloud::texttospeech::v1::SynthesisInput* SynthesizeSpeechRequest::release_input() {
  
  ::google::cloud::texttospeech::v1::SynthesisInput* temp = _impl_.input_;
  _impl_.input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::cloud::texttospeech::v1::SynthesisInput* SynthesizeSpeechRequest::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1.SynthesizeSpeechRequest.input)
  
  ::google::cloud::texttospeech::v1::SynthesisInput* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::google::cloud::texttospeech::v1::SynthesisInput* SynthesizeSpeechRequest::_internal_mutable_input() {
  
  if (_impl_.input_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::cloud::texttospeech::v1::SynthesisInput>(GetArenaForAllocation());
    _impl_.input_ = p;
  }
  return _impl_.input_;
}
inline ::google::cloud::texttospeech::v1::SynthesisInput* SynthesizeSpeechRequest::mutable_input() {
  ::google::cloud::texttospeech::v1::SynthesisInput* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1.SynthesizeSpeechRequest.input)
  return _msg;
}
inline void SynthesizeSpeechRequest::set_allocated_input(::google::cloud::texttospeech::v1::SynthesisInput* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(input);
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_ = input;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1.SynthesizeSpeechRequest.input)
}

// .google.cloud.texttospeech.v1.VoiceSelectionParams voice = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool SynthesizeSpeechRequest::_internal_has_voice() const {
  return this != internal_default_instance() && _impl_.voice_ != nullptr;
}
inline bool SynthesizeSpeechRequest::has_voice() const {
  return _internal_has_voice();
}
inline void SynthesizeSpeechRequest::clear_voice() {
  if (GetArenaForAllocation() == nullptr && _impl_.voice_ != nullptr) {
    delete _impl_.voice_;
  }
  _impl_.voice_ = nullptr;
}
inline const ::google::cloud::texttospeech::v1::VoiceSelectionParams& SynthesizeSpeechRequest::_internal_voice() const {
  const ::google::cloud::texttospeech::v1::VoiceSelectionParams* p = _impl_.voice_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::cloud::texttospeech::v1::VoiceSelectionParams&>(
      ::google::cloud::texttospeech::v1::_VoiceSelectionParams_default_instance_);
}
inline const ::google::cloud::texttospeech::v1::VoiceSelectionParams& SynthesizeSpeechRequest::voice() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.SynthesizeSpeechRequest.voice)
  return _internal_voice();
}
inline void SynthesizeSpeechRequest::unsafe_arena_set_allocated_voice(
    ::google::cloud::texttospeech::v1::VoiceSelectionParams* voice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voice_);
  }
  _impl_.voice_ = voice;
  if (voice) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.cloud.texttospeech.v1.SynthesizeSpeechRequest.voice)
}
inline ::google::cloud::texttospeech::v1::VoiceSelectionParams* SynthesizeSpeechRequest::release_voice() {
  
  ::google::cloud::texttospeech::v1::VoiceSelectionParams* temp = _impl_.voice_;
  _impl_.voice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::cloud::texttospeech::v1::VoiceSelectionParams* SynthesizeSpeechRequest::unsafe_arena_release_voice() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1.SynthesizeSpeechRequest.voice)
  
  ::google::cloud::texttospeech::v1::VoiceSelectionParams* temp = _impl_.voice_;
  _impl_.voice_ = nullptr;
  return temp;
}
inline ::google::cloud::texttospeech::v1::VoiceSelectionParams* SynthesizeSpeechRequest::_internal_mutable_voice() {
  
  if (_impl_.voice_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::cloud::texttospeech::v1::VoiceSelectionParams>(GetArenaForAllocation());
    _impl_.voice_ = p;
  }
  return _impl_.voice_;
}
inline ::google::cloud::texttospeech::v1::VoiceSelectionParams* SynthesizeSpeechRequest::mutable_voice() {
  ::google::cloud::texttospeech::v1::VoiceSelectionParams* _msg = _internal_mutable_voice();
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1.SynthesizeSpeechRequest.voice)
  return _msg;
}
inline void SynthesizeSpeechRequest::set_allocated_voice(::google::cloud::texttospeech::v1::VoiceSelectionParams* voice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.voice_;
  }
  if (voice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(voice);
    if (message_arena != submessage_arena) {
      voice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voice, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.voice_ = voice;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1.SynthesizeSpeechRequest.voice)
}

// .google.cloud.texttospeech.v1.AudioConfig audio_config = 3 [(.google.api.field_behavior) = REQUIRED];
inline bool SynthesizeSpeechRequest::_internal_has_audio_config() const {
  return this != internal_default_instance() && _impl_.audio_config_ != nullptr;
}
inline bool SynthesizeSpeechRequest::has_audio_config() const {
  return _internal_has_audio_config();
}
inline void SynthesizeSpeechRequest::clear_audio_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_config_ != nullptr) {
    delete _impl_.audio_config_;
  }
  _impl_.audio_config_ = nullptr;
}
inline const ::google::cloud::texttospeech::v1::AudioConfig& SynthesizeSpeechRequest::_internal_audio_config() const {
  const ::google::cloud::texttospeech::v1::AudioConfig* p = _impl_.audio_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::cloud::texttospeech::v1::AudioConfig&>(
      ::google::cloud::texttospeech::v1::_AudioConfig_default_instance_);
}
inline const ::google::cloud::texttospeech::v1::AudioConfig& SynthesizeSpeechRequest::audio_config() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.SynthesizeSpeechRequest.audio_config)
  return _internal_audio_config();
}
inline void SynthesizeSpeechRequest::unsafe_arena_set_allocated_audio_config(
    ::google::cloud::texttospeech::v1::AudioConfig* audio_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_config_);
  }
  _impl_.audio_config_ = audio_config;
  if (audio_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.cloud.texttospeech.v1.SynthesizeSpeechRequest.audio_config)
}
inline ::google::cloud::texttospeech::v1::AudioConfig* SynthesizeSpeechRequest::release_audio_config() {
  
  ::google::cloud::texttospeech::v1::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::cloud::texttospeech::v1::AudioConfig* SynthesizeSpeechRequest::unsafe_arena_release_audio_config() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1.SynthesizeSpeechRequest.audio_config)
  
  ::google::cloud::texttospeech::v1::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
  return temp;
}
inline ::google::cloud::texttospeech::v1::AudioConfig* SynthesizeSpeechRequest::_internal_mutable_audio_config() {
  
  if (_impl_.audio_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::cloud::texttospeech::v1::AudioConfig>(GetArenaForAllocation());
    _impl_.audio_config_ = p;
  }
  return _impl_.audio_config_;
}
inline ::google::cloud::texttospeech::v1::AudioConfig* SynthesizeSpeechRequest::mutable_audio_config() {
  ::google::cloud::texttospeech::v1::AudioConfig* _msg = _internal_mutable_audio_config();
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1.SynthesizeSpeechRequest.audio_config)
  return _msg;
}
inline void SynthesizeSpeechRequest::set_allocated_audio_config(::google::cloud::texttospeech::v1::AudioConfig* audio_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_config_;
  }
  if (audio_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_config);
    if (message_arena != submessage_arena) {
      audio_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_config_ = audio_config;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1.SynthesizeSpeechRequest.audio_config)
}

// -------------------------------------------------------------------

// SynthesisInput

// string text = 1;
inline bool SynthesisInput::_internal_has_text() const {
  return input_source_case() == kText;
}
inline bool SynthesisInput::has_text() const {
  return _internal_has_text();
}
inline void SynthesisInput::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void SynthesisInput::clear_text() {
  if (_internal_has_text()) {
    _impl_.input_source_.text_.Destroy();
    clear_has_input_source();
  }
}
inline const std::string& SynthesisInput::text() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.SynthesisInput.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline void SynthesisInput::set_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text()) {
    clear_input_source();
    set_has_text();
    _impl_.input_source_.text_.InitDefault();
  }
  _impl_.input_source_.text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.SynthesisInput.text)
}
inline std::string* SynthesisInput::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1.SynthesisInput.text)
  return _s;
}
inline const std::string& SynthesisInput::_internal_text() const {
  if (_internal_has_text()) {
    return _impl_.input_source_.text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SynthesisInput::_internal_set_text(const std::string& value) {
  if (!_internal_has_text()) {
    clear_input_source();
    set_has_text();
    _impl_.input_source_.text_.InitDefault();
  }
  _impl_.input_source_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesisInput::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_input_source();
    set_has_text();
    _impl_.input_source_.text_.InitDefault();
  }
  return _impl_.input_source_.text_.Mutable(      GetArenaForAllocation());
}
inline std::string* SynthesisInput::release_text() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1.SynthesisInput.text)
  if (_internal_has_text()) {
    clear_has_input_source();
    return _impl_.input_source_.text_.Release();
  } else {
    return nullptr;
  }
}
inline void SynthesisInput::set_allocated_text(std::string* text) {
  if (has_input_source()) {
    clear_input_source();
  }
  if (text != nullptr) {
    set_has_text();
    _impl_.input_source_.text_.InitAllocated(text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1.SynthesisInput.text)
}

// string ssml = 2;
inline bool SynthesisInput::_internal_has_ssml() const {
  return input_source_case() == kSsml;
}
inline bool SynthesisInput::has_ssml() const {
  return _internal_has_ssml();
}
inline void SynthesisInput::set_has_ssml() {
  _impl_._oneof_case_[0] = kSsml;
}
inline void SynthesisInput::clear_ssml() {
  if (_internal_has_ssml()) {
    _impl_.input_source_.ssml_.Destroy();
    clear_has_input_source();
  }
}
inline const std::string& SynthesisInput::ssml() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.SynthesisInput.ssml)
  return _internal_ssml();
}
template <typename ArgT0, typename... ArgT>
inline void SynthesisInput::set_ssml(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_ssml()) {
    clear_input_source();
    set_has_ssml();
    _impl_.input_source_.ssml_.InitDefault();
  }
  _impl_.input_source_.ssml_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.SynthesisInput.ssml)
}
inline std::string* SynthesisInput::mutable_ssml() {
  std::string* _s = _internal_mutable_ssml();
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1.SynthesisInput.ssml)
  return _s;
}
inline const std::string& SynthesisInput::_internal_ssml() const {
  if (_internal_has_ssml()) {
    return _impl_.input_source_.ssml_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SynthesisInput::_internal_set_ssml(const std::string& value) {
  if (!_internal_has_ssml()) {
    clear_input_source();
    set_has_ssml();
    _impl_.input_source_.ssml_.InitDefault();
  }
  _impl_.input_source_.ssml_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesisInput::_internal_mutable_ssml() {
  if (!_internal_has_ssml()) {
    clear_input_source();
    set_has_ssml();
    _impl_.input_source_.ssml_.InitDefault();
  }
  return _impl_.input_source_.ssml_.Mutable(      GetArenaForAllocation());
}
inline std::string* SynthesisInput::release_ssml() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1.SynthesisInput.ssml)
  if (_internal_has_ssml()) {
    clear_has_input_source();
    return _impl_.input_source_.ssml_.Release();
  } else {
    return nullptr;
  }
}
inline void SynthesisInput::set_allocated_ssml(std::string* ssml) {
  if (has_input_source()) {
    clear_input_source();
  }
  if (ssml != nullptr) {
    set_has_ssml();
    _impl_.input_source_.ssml_.InitAllocated(ssml, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1.SynthesisInput.ssml)
}

inline bool SynthesisInput::has_input_source() const {
  return input_source_case() != INPUT_SOURCE_NOT_SET;
}
inline void SynthesisInput::clear_has_input_source() {
  _impl_._oneof_case_[0] = INPUT_SOURCE_NOT_SET;
}
inline SynthesisInput::InputSourceCase SynthesisInput::input_source_case() const {
  return SynthesisInput::InputSourceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VoiceSelectionParams

// string language_code = 1 [(.google.api.field_behavior) = REQUIRED];
inline void VoiceSelectionParams::clear_language_code() {
  _impl_.language_code_.ClearToEmpty();
}
inline const std::string& VoiceSelectionParams::language_code() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.VoiceSelectionParams.language_code)
  return _internal_language_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoiceSelectionParams::set_language_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.VoiceSelectionParams.language_code)
}
inline std::string* VoiceSelectionParams::mutable_language_code() {
  std::string* _s = _internal_mutable_language_code();
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1.VoiceSelectionParams.language_code)
  return _s;
}
inline const std::string& VoiceSelectionParams::_internal_language_code() const {
  return _impl_.language_code_.Get();
}
inline void VoiceSelectionParams::_internal_set_language_code(const std::string& value) {
  
  _impl_.language_code_.Set(value, GetArenaForAllocation());
}
inline std::string* VoiceSelectionParams::_internal_mutable_language_code() {
  
  return _impl_.language_code_.Mutable(GetArenaForAllocation());
}
inline std::string* VoiceSelectionParams::release_language_code() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1.VoiceSelectionParams.language_code)
  return _impl_.language_code_.Release();
}
inline void VoiceSelectionParams::set_allocated_language_code(std::string* language_code) {
  if (language_code != nullptr) {
    
  } else {
    
  }
  _impl_.language_code_.SetAllocated(language_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_code_.IsDefault()) {
    _impl_.language_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1.VoiceSelectionParams.language_code)
}

// string name = 2;
inline void VoiceSelectionParams::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& VoiceSelectionParams::name() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.VoiceSelectionParams.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoiceSelectionParams::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.VoiceSelectionParams.name)
}
inline std::string* VoiceSelectionParams::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1.VoiceSelectionParams.name)
  return _s;
}
inline const std::string& VoiceSelectionParams::_internal_name() const {
  return _impl_.name_.Get();
}
inline void VoiceSelectionParams::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* VoiceSelectionParams::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* VoiceSelectionParams::release_name() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1.VoiceSelectionParams.name)
  return _impl_.name_.Release();
}
inline void VoiceSelectionParams::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1.VoiceSelectionParams.name)
}

// .google.cloud.texttospeech.v1.SsmlVoiceGender ssml_gender = 3;
inline void VoiceSelectionParams::clear_ssml_gender() {
  _impl_.ssml_gender_ = 0;
}
inline ::google::cloud::texttospeech::v1::SsmlVoiceGender VoiceSelectionParams::_internal_ssml_gender() const {
  return static_cast< ::google::cloud::texttospeech::v1::SsmlVoiceGender >(_impl_.ssml_gender_);
}
inline ::google::cloud::texttospeech::v1::SsmlVoiceGender VoiceSelectionParams::ssml_gender() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.VoiceSelectionParams.ssml_gender)
  return _internal_ssml_gender();
}
inline void VoiceSelectionParams::_internal_set_ssml_gender(::google::cloud::texttospeech::v1::SsmlVoiceGender value) {
  
  _impl_.ssml_gender_ = value;
}
inline void VoiceSelectionParams::set_ssml_gender(::google::cloud::texttospeech::v1::SsmlVoiceGender value) {
  _internal_set_ssml_gender(value);
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.VoiceSelectionParams.ssml_gender)
}

// .google.cloud.texttospeech.v1.CustomVoiceParams custom_voice = 4;
inline bool VoiceSelectionParams::_internal_has_custom_voice() const {
  return this != internal_default_instance() && _impl_.custom_voice_ != nullptr;
}
inline bool VoiceSelectionParams::has_custom_voice() const {
  return _internal_has_custom_voice();
}
inline void VoiceSelectionParams::clear_custom_voice() {
  if (GetArenaForAllocation() == nullptr && _impl_.custom_voice_ != nullptr) {
    delete _impl_.custom_voice_;
  }
  _impl_.custom_voice_ = nullptr;
}
inline const ::google::cloud::texttospeech::v1::CustomVoiceParams& VoiceSelectionParams::_internal_custom_voice() const {
  const ::google::cloud::texttospeech::v1::CustomVoiceParams* p = _impl_.custom_voice_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::cloud::texttospeech::v1::CustomVoiceParams&>(
      ::google::cloud::texttospeech::v1::_CustomVoiceParams_default_instance_);
}
inline const ::google::cloud::texttospeech::v1::CustomVoiceParams& VoiceSelectionParams::custom_voice() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.VoiceSelectionParams.custom_voice)
  return _internal_custom_voice();
}
inline void VoiceSelectionParams::unsafe_arena_set_allocated_custom_voice(
    ::google::cloud::texttospeech::v1::CustomVoiceParams* custom_voice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.custom_voice_);
  }
  _impl_.custom_voice_ = custom_voice;
  if (custom_voice) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.cloud.texttospeech.v1.VoiceSelectionParams.custom_voice)
}
inline ::google::cloud::texttospeech::v1::CustomVoiceParams* VoiceSelectionParams::release_custom_voice() {
  
  ::google::cloud::texttospeech::v1::CustomVoiceParams* temp = _impl_.custom_voice_;
  _impl_.custom_voice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::cloud::texttospeech::v1::CustomVoiceParams* VoiceSelectionParams::unsafe_arena_release_custom_voice() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1.VoiceSelectionParams.custom_voice)
  
  ::google::cloud::texttospeech::v1::CustomVoiceParams* temp = _impl_.custom_voice_;
  _impl_.custom_voice_ = nullptr;
  return temp;
}
inline ::google::cloud::texttospeech::v1::CustomVoiceParams* VoiceSelectionParams::_internal_mutable_custom_voice() {
  
  if (_impl_.custom_voice_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::cloud::texttospeech::v1::CustomVoiceParams>(GetArenaForAllocation());
    _impl_.custom_voice_ = p;
  }
  return _impl_.custom_voice_;
}
inline ::google::cloud::texttospeech::v1::CustomVoiceParams* VoiceSelectionParams::mutable_custom_voice() {
  ::google::cloud::texttospeech::v1::CustomVoiceParams* _msg = _internal_mutable_custom_voice();
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1.VoiceSelectionParams.custom_voice)
  return _msg;
}
inline void VoiceSelectionParams::set_allocated_custom_voice(::google::cloud::texttospeech::v1::CustomVoiceParams* custom_voice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.custom_voice_;
  }
  if (custom_voice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(custom_voice);
    if (message_arena != submessage_arena) {
      custom_voice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, custom_voice, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.custom_voice_ = custom_voice;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1.VoiceSelectionParams.custom_voice)
}

// -------------------------------------------------------------------

// AudioConfig

// .google.cloud.texttospeech.v1.AudioEncoding audio_encoding = 1 [(.google.api.field_behavior) = REQUIRED];
inline void AudioConfig::clear_audio_encoding() {
  _impl_.audio_encoding_ = 0;
}
inline ::google::cloud::texttospeech::v1::AudioEncoding AudioConfig::_internal_audio_encoding() const {
  return static_cast< ::google::cloud::texttospeech::v1::AudioEncoding >(_impl_.audio_encoding_);
}
inline ::google::cloud::texttospeech::v1::AudioEncoding AudioConfig::audio_encoding() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.AudioConfig.audio_encoding)
  return _internal_audio_encoding();
}
inline void AudioConfig::_internal_set_audio_encoding(::google::cloud::texttospeech::v1::AudioEncoding value) {
  
  _impl_.audio_encoding_ = value;
}
inline void AudioConfig::set_audio_encoding(::google::cloud::texttospeech::v1::AudioEncoding value) {
  _internal_set_audio_encoding(value);
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.AudioConfig.audio_encoding)
}

// double speaking_rate = 2 [(.google.api.field_behavior) = INPUT_ONLY, (.google.api.field_behavior) = OPTIONAL];
inline void AudioConfig::clear_speaking_rate() {
  _impl_.speaking_rate_ = 0;
}
inline double AudioConfig::_internal_speaking_rate() const {
  return _impl_.speaking_rate_;
}
inline double AudioConfig::speaking_rate() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.AudioConfig.speaking_rate)
  return _internal_speaking_rate();
}
inline void AudioConfig::_internal_set_speaking_rate(double value) {
  
  _impl_.speaking_rate_ = value;
}
inline void AudioConfig::set_speaking_rate(double value) {
  _internal_set_speaking_rate(value);
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.AudioConfig.speaking_rate)
}

// double pitch = 3 [(.google.api.field_behavior) = INPUT_ONLY, (.google.api.field_behavior) = OPTIONAL];
inline void AudioConfig::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline double AudioConfig::_internal_pitch() const {
  return _impl_.pitch_;
}
inline double AudioConfig::pitch() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.AudioConfig.pitch)
  return _internal_pitch();
}
inline void AudioConfig::_internal_set_pitch(double value) {
  
  _impl_.pitch_ = value;
}
inline void AudioConfig::set_pitch(double value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.AudioConfig.pitch)
}

// double volume_gain_db = 4 [(.google.api.field_behavior) = INPUT_ONLY, (.google.api.field_behavior) = OPTIONAL];
inline void AudioConfig::clear_volume_gain_db() {
  _impl_.volume_gain_db_ = 0;
}
inline double AudioConfig::_internal_volume_gain_db() const {
  return _impl_.volume_gain_db_;
}
inline double AudioConfig::volume_gain_db() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.AudioConfig.volume_gain_db)
  return _internal_volume_gain_db();
}
inline void AudioConfig::_internal_set_volume_gain_db(double value) {
  
  _impl_.volume_gain_db_ = value;
}
inline void AudioConfig::set_volume_gain_db(double value) {
  _internal_set_volume_gain_db(value);
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.AudioConfig.volume_gain_db)
}

// int32 sample_rate_hertz = 5 [(.google.api.field_behavior) = OPTIONAL];
inline void AudioConfig::clear_sample_rate_hertz() {
  _impl_.sample_rate_hertz_ = 0;
}
inline int32_t AudioConfig::_internal_sample_rate_hertz() const {
  return _impl_.sample_rate_hertz_;
}
inline int32_t AudioConfig::sample_rate_hertz() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.AudioConfig.sample_rate_hertz)
  return _internal_sample_rate_hertz();
}
inline void AudioConfig::_internal_set_sample_rate_hertz(int32_t value) {
  
  _impl_.sample_rate_hertz_ = value;
}
inline void AudioConfig::set_sample_rate_hertz(int32_t value) {
  _internal_set_sample_rate_hertz(value);
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.AudioConfig.sample_rate_hertz)
}

// repeated string effects_profile_id = 6 [(.google.api.field_behavior) = INPUT_ONLY, (.google.api.field_behavior) = OPTIONAL];
inline int AudioConfig::_internal_effects_profile_id_size() const {
  return _impl_.effects_profile_id_.size();
}
inline int AudioConfig::effects_profile_id_size() const {
  return _internal_effects_profile_id_size();
}
inline void AudioConfig::clear_effects_profile_id() {
  _impl_.effects_profile_id_.Clear();
}
inline std::string* AudioConfig::add_effects_profile_id() {
  std::string* _s = _internal_add_effects_profile_id();
  // @@protoc_insertion_point(field_add_mutable:google.cloud.texttospeech.v1.AudioConfig.effects_profile_id)
  return _s;
}
inline const std::string& AudioConfig::_internal_effects_profile_id(int index) const {
  return _impl_.effects_profile_id_.Get(index);
}
inline const std::string& AudioConfig::effects_profile_id(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.AudioConfig.effects_profile_id)
  return _internal_effects_profile_id(index);
}
inline std::string* AudioConfig::mutable_effects_profile_id(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1.AudioConfig.effects_profile_id)
  return _impl_.effects_profile_id_.Mutable(index);
}
inline void AudioConfig::set_effects_profile_id(int index, const std::string& value) {
  _impl_.effects_profile_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.AudioConfig.effects_profile_id)
}
inline void AudioConfig::set_effects_profile_id(int index, std::string&& value) {
  _impl_.effects_profile_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.AudioConfig.effects_profile_id)
}
inline void AudioConfig::set_effects_profile_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.effects_profile_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.cloud.texttospeech.v1.AudioConfig.effects_profile_id)
}
inline void AudioConfig::set_effects_profile_id(int index, const char* value, size_t size) {
  _impl_.effects_profile_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.cloud.texttospeech.v1.AudioConfig.effects_profile_id)
}
inline std::string* AudioConfig::_internal_add_effects_profile_id() {
  return _impl_.effects_profile_id_.Add();
}
inline void AudioConfig::add_effects_profile_id(const std::string& value) {
  _impl_.effects_profile_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.cloud.texttospeech.v1.AudioConfig.effects_profile_id)
}
inline void AudioConfig::add_effects_profile_id(std::string&& value) {
  _impl_.effects_profile_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.cloud.texttospeech.v1.AudioConfig.effects_profile_id)
}
inline void AudioConfig::add_effects_profile_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.effects_profile_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.cloud.texttospeech.v1.AudioConfig.effects_profile_id)
}
inline void AudioConfig::add_effects_profile_id(const char* value, size_t size) {
  _impl_.effects_profile_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.cloud.texttospeech.v1.AudioConfig.effects_profile_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AudioConfig::effects_profile_id() const {
  // @@protoc_insertion_point(field_list:google.cloud.texttospeech.v1.AudioConfig.effects_profile_id)
  return _impl_.effects_profile_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AudioConfig::mutable_effects_profile_id() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.texttospeech.v1.AudioConfig.effects_profile_id)
  return &_impl_.effects_profile_id_;
}

// -------------------------------------------------------------------

// CustomVoiceParams

// string model = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CustomVoiceParams::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& CustomVoiceParams::model() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.CustomVoiceParams.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomVoiceParams::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.CustomVoiceParams.model)
}
inline std::string* CustomVoiceParams::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1.CustomVoiceParams.model)
  return _s;
}
inline const std::string& CustomVoiceParams::_internal_model() const {
  return _impl_.model_.Get();
}
inline void CustomVoiceParams::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomVoiceParams::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomVoiceParams::release_model() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1.CustomVoiceParams.model)
  return _impl_.model_.Release();
}
inline void CustomVoiceParams::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1.CustomVoiceParams.model)
}

// .google.cloud.texttospeech.v1.CustomVoiceParams.ReportedUsage reported_usage = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void CustomVoiceParams::clear_reported_usage() {
  _impl_.reported_usage_ = 0;
}
inline ::google::cloud::texttospeech::v1::CustomVoiceParams_ReportedUsage CustomVoiceParams::_internal_reported_usage() const {
  return static_cast< ::google::cloud::texttospeech::v1::CustomVoiceParams_ReportedUsage >(_impl_.reported_usage_);
}
inline ::google::cloud::texttospeech::v1::CustomVoiceParams_ReportedUsage CustomVoiceParams::reported_usage() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.CustomVoiceParams.reported_usage)
  return _internal_reported_usage();
}
inline void CustomVoiceParams::_internal_set_reported_usage(::google::cloud::texttospeech::v1::CustomVoiceParams_ReportedUsage value) {
  
  _impl_.reported_usage_ = value;
}
inline void CustomVoiceParams::set_reported_usage(::google::cloud::texttospeech::v1::CustomVoiceParams_ReportedUsage value) {
  _internal_set_reported_usage(value);
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.CustomVoiceParams.reported_usage)
}

// -------------------------------------------------------------------

// SynthesizeSpeechResponse

// bytes audio_content = 1;
inline void SynthesizeSpeechResponse::clear_audio_content() {
  _impl_.audio_content_.ClearToEmpty();
}
inline const std::string& SynthesizeSpeechResponse::audio_content() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1.SynthesizeSpeechResponse.audio_content)
  return _internal_audio_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SynthesizeSpeechResponse::set_audio_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.audio_content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1.SynthesizeSpeechResponse.audio_content)
}
inline std::string* SynthesizeSpeechResponse::mutable_audio_content() {
  std::string* _s = _internal_mutable_audio_content();
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1.SynthesizeSpeechResponse.audio_content)
  return _s;
}
inline const std::string& SynthesizeSpeechResponse::_internal_audio_content() const {
  return _impl_.audio_content_.Get();
}
inline void SynthesizeSpeechResponse::_internal_set_audio_content(const std::string& value) {
  
  _impl_.audio_content_.Set(value, GetArenaForAllocation());
}
inline std::string* SynthesizeSpeechResponse::_internal_mutable_audio_content() {
  
  return _impl_.audio_content_.Mutable(GetArenaForAllocation());
}
inline std::string* SynthesizeSpeechResponse::release_audio_content() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1.SynthesizeSpeechResponse.audio_content)
  return _impl_.audio_content_.Release();
}
inline void SynthesizeSpeechResponse::set_allocated_audio_content(std::string* audio_content) {
  if (audio_content != nullptr) {
    
  } else {
    
  }
  _impl_.audio_content_.SetAllocated(audio_content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_content_.IsDefault()) {
    _impl_.audio_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1.SynthesizeSpeechResponse.audio_content)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace texttospeech
}  // namespace cloud
}  // namespace google

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::google::cloud::texttospeech::v1::CustomVoiceParams_ReportedUsage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::texttospeech::v1::CustomVoiceParams_ReportedUsage>() {
  return ::google::cloud::texttospeech::v1::CustomVoiceParams_ReportedUsage_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::texttospeech::v1::SsmlVoiceGender> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::texttospeech::v1::SsmlVoiceGender>() {
  return ::google::cloud::texttospeech::v1::SsmlVoiceGender_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::texttospeech::v1::AudioEncoding> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::texttospeech::v1::AudioEncoding>() {
  return ::google::cloud::texttospeech::v1::AudioEncoding_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_google_2fcloud_2ftexttospeech_2fv1_2fcloud_5ftts_2eproto
