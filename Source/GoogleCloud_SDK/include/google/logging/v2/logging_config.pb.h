// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/logging/v2/logging_config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_google_2flogging_2fv2_2flogging_5fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_google_2flogging_2fv2_2flogging_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/api/client.pb.h"
#include "google/api/field_behavior.pb.h"
#include "google/api/resource.pb.h"
#include "google/longrunning/operations.pb.h"
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/field_mask.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_google_2flogging_2fv2_2flogging_5fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
namespace google {
namespace logging {
namespace v2 {
class BigQueryOptions;
struct BigQueryOptionsDefaultTypeInternal;
extern BigQueryOptionsDefaultTypeInternal _BigQueryOptions_default_instance_;
class CmekSettings;
struct CmekSettingsDefaultTypeInternal;
extern CmekSettingsDefaultTypeInternal _CmekSettings_default_instance_;
class CopyLogEntriesMetadata;
struct CopyLogEntriesMetadataDefaultTypeInternal;
extern CopyLogEntriesMetadataDefaultTypeInternal _CopyLogEntriesMetadata_default_instance_;
class CopyLogEntriesRequest;
struct CopyLogEntriesRequestDefaultTypeInternal;
extern CopyLogEntriesRequestDefaultTypeInternal _CopyLogEntriesRequest_default_instance_;
class CopyLogEntriesResponse;
struct CopyLogEntriesResponseDefaultTypeInternal;
extern CopyLogEntriesResponseDefaultTypeInternal _CopyLogEntriesResponse_default_instance_;
class CreateBucketRequest;
struct CreateBucketRequestDefaultTypeInternal;
extern CreateBucketRequestDefaultTypeInternal _CreateBucketRequest_default_instance_;
class CreateExclusionRequest;
struct CreateExclusionRequestDefaultTypeInternal;
extern CreateExclusionRequestDefaultTypeInternal _CreateExclusionRequest_default_instance_;
class CreateSinkRequest;
struct CreateSinkRequestDefaultTypeInternal;
extern CreateSinkRequestDefaultTypeInternal _CreateSinkRequest_default_instance_;
class CreateViewRequest;
struct CreateViewRequestDefaultTypeInternal;
extern CreateViewRequestDefaultTypeInternal _CreateViewRequest_default_instance_;
class DeleteBucketRequest;
struct DeleteBucketRequestDefaultTypeInternal;
extern DeleteBucketRequestDefaultTypeInternal _DeleteBucketRequest_default_instance_;
class DeleteExclusionRequest;
struct DeleteExclusionRequestDefaultTypeInternal;
extern DeleteExclusionRequestDefaultTypeInternal _DeleteExclusionRequest_default_instance_;
class DeleteSinkRequest;
struct DeleteSinkRequestDefaultTypeInternal;
extern DeleteSinkRequestDefaultTypeInternal _DeleteSinkRequest_default_instance_;
class DeleteViewRequest;
struct DeleteViewRequestDefaultTypeInternal;
extern DeleteViewRequestDefaultTypeInternal _DeleteViewRequest_default_instance_;
class GetBucketRequest;
struct GetBucketRequestDefaultTypeInternal;
extern GetBucketRequestDefaultTypeInternal _GetBucketRequest_default_instance_;
class GetCmekSettingsRequest;
struct GetCmekSettingsRequestDefaultTypeInternal;
extern GetCmekSettingsRequestDefaultTypeInternal _GetCmekSettingsRequest_default_instance_;
class GetExclusionRequest;
struct GetExclusionRequestDefaultTypeInternal;
extern GetExclusionRequestDefaultTypeInternal _GetExclusionRequest_default_instance_;
class GetSettingsRequest;
struct GetSettingsRequestDefaultTypeInternal;
extern GetSettingsRequestDefaultTypeInternal _GetSettingsRequest_default_instance_;
class GetSinkRequest;
struct GetSinkRequestDefaultTypeInternal;
extern GetSinkRequestDefaultTypeInternal _GetSinkRequest_default_instance_;
class GetViewRequest;
struct GetViewRequestDefaultTypeInternal;
extern GetViewRequestDefaultTypeInternal _GetViewRequest_default_instance_;
class ListBucketsRequest;
struct ListBucketsRequestDefaultTypeInternal;
extern ListBucketsRequestDefaultTypeInternal _ListBucketsRequest_default_instance_;
class ListBucketsResponse;
struct ListBucketsResponseDefaultTypeInternal;
extern ListBucketsResponseDefaultTypeInternal _ListBucketsResponse_default_instance_;
class ListExclusionsRequest;
struct ListExclusionsRequestDefaultTypeInternal;
extern ListExclusionsRequestDefaultTypeInternal _ListExclusionsRequest_default_instance_;
class ListExclusionsResponse;
struct ListExclusionsResponseDefaultTypeInternal;
extern ListExclusionsResponseDefaultTypeInternal _ListExclusionsResponse_default_instance_;
class ListSinksRequest;
struct ListSinksRequestDefaultTypeInternal;
extern ListSinksRequestDefaultTypeInternal _ListSinksRequest_default_instance_;
class ListSinksResponse;
struct ListSinksResponseDefaultTypeInternal;
extern ListSinksResponseDefaultTypeInternal _ListSinksResponse_default_instance_;
class ListViewsRequest;
struct ListViewsRequestDefaultTypeInternal;
extern ListViewsRequestDefaultTypeInternal _ListViewsRequest_default_instance_;
class ListViewsResponse;
struct ListViewsResponseDefaultTypeInternal;
extern ListViewsResponseDefaultTypeInternal _ListViewsResponse_default_instance_;
class LogBucket;
struct LogBucketDefaultTypeInternal;
extern LogBucketDefaultTypeInternal _LogBucket_default_instance_;
class LogExclusion;
struct LogExclusionDefaultTypeInternal;
extern LogExclusionDefaultTypeInternal _LogExclusion_default_instance_;
class LogSink;
struct LogSinkDefaultTypeInternal;
extern LogSinkDefaultTypeInternal _LogSink_default_instance_;
class LogView;
struct LogViewDefaultTypeInternal;
extern LogViewDefaultTypeInternal _LogView_default_instance_;
class Settings;
struct SettingsDefaultTypeInternal;
extern SettingsDefaultTypeInternal _Settings_default_instance_;
class UndeleteBucketRequest;
struct UndeleteBucketRequestDefaultTypeInternal;
extern UndeleteBucketRequestDefaultTypeInternal _UndeleteBucketRequest_default_instance_;
class UpdateBucketRequest;
struct UpdateBucketRequestDefaultTypeInternal;
extern UpdateBucketRequestDefaultTypeInternal _UpdateBucketRequest_default_instance_;
class UpdateCmekSettingsRequest;
struct UpdateCmekSettingsRequestDefaultTypeInternal;
extern UpdateCmekSettingsRequestDefaultTypeInternal _UpdateCmekSettingsRequest_default_instance_;
class UpdateExclusionRequest;
struct UpdateExclusionRequestDefaultTypeInternal;
extern UpdateExclusionRequestDefaultTypeInternal _UpdateExclusionRequest_default_instance_;
class UpdateSettingsRequest;
struct UpdateSettingsRequestDefaultTypeInternal;
extern UpdateSettingsRequestDefaultTypeInternal _UpdateSettingsRequest_default_instance_;
class UpdateSinkRequest;
struct UpdateSinkRequestDefaultTypeInternal;
extern UpdateSinkRequestDefaultTypeInternal _UpdateSinkRequest_default_instance_;
class UpdateViewRequest;
struct UpdateViewRequestDefaultTypeInternal;
extern UpdateViewRequestDefaultTypeInternal _UpdateViewRequest_default_instance_;
}  // namespace v2
}  // namespace logging
}  // namespace google
PROTOBUF_NAMESPACE_OPEN
template<> ::google::logging::v2::BigQueryOptions* Arena::CreateMaybeMessage<::google::logging::v2::BigQueryOptions>(Arena*);
template<> ::google::logging::v2::CmekSettings* Arena::CreateMaybeMessage<::google::logging::v2::CmekSettings>(Arena*);
template<> ::google::logging::v2::CopyLogEntriesMetadata* Arena::CreateMaybeMessage<::google::logging::v2::CopyLogEntriesMetadata>(Arena*);
template<> ::google::logging::v2::CopyLogEntriesRequest* Arena::CreateMaybeMessage<::google::logging::v2::CopyLogEntriesRequest>(Arena*);
template<> ::google::logging::v2::CopyLogEntriesResponse* Arena::CreateMaybeMessage<::google::logging::v2::CopyLogEntriesResponse>(Arena*);
template<> ::google::logging::v2::CreateBucketRequest* Arena::CreateMaybeMessage<::google::logging::v2::CreateBucketRequest>(Arena*);
template<> ::google::logging::v2::CreateExclusionRequest* Arena::CreateMaybeMessage<::google::logging::v2::CreateExclusionRequest>(Arena*);
template<> ::google::logging::v2::CreateSinkRequest* Arena::CreateMaybeMessage<::google::logging::v2::CreateSinkRequest>(Arena*);
template<> ::google::logging::v2::CreateViewRequest* Arena::CreateMaybeMessage<::google::logging::v2::CreateViewRequest>(Arena*);
template<> ::google::logging::v2::DeleteBucketRequest* Arena::CreateMaybeMessage<::google::logging::v2::DeleteBucketRequest>(Arena*);
template<> ::google::logging::v2::DeleteExclusionRequest* Arena::CreateMaybeMessage<::google::logging::v2::DeleteExclusionRequest>(Arena*);
template<> ::google::logging::v2::DeleteSinkRequest* Arena::CreateMaybeMessage<::google::logging::v2::DeleteSinkRequest>(Arena*);
template<> ::google::logging::v2::DeleteViewRequest* Arena::CreateMaybeMessage<::google::logging::v2::DeleteViewRequest>(Arena*);
template<> ::google::logging::v2::GetBucketRequest* Arena::CreateMaybeMessage<::google::logging::v2::GetBucketRequest>(Arena*);
template<> ::google::logging::v2::GetCmekSettingsRequest* Arena::CreateMaybeMessage<::google::logging::v2::GetCmekSettingsRequest>(Arena*);
template<> ::google::logging::v2::GetExclusionRequest* Arena::CreateMaybeMessage<::google::logging::v2::GetExclusionRequest>(Arena*);
template<> ::google::logging::v2::GetSettingsRequest* Arena::CreateMaybeMessage<::google::logging::v2::GetSettingsRequest>(Arena*);
template<> ::google::logging::v2::GetSinkRequest* Arena::CreateMaybeMessage<::google::logging::v2::GetSinkRequest>(Arena*);
template<> ::google::logging::v2::GetViewRequest* Arena::CreateMaybeMessage<::google::logging::v2::GetViewRequest>(Arena*);
template<> ::google::logging::v2::ListBucketsRequest* Arena::CreateMaybeMessage<::google::logging::v2::ListBucketsRequest>(Arena*);
template<> ::google::logging::v2::ListBucketsResponse* Arena::CreateMaybeMessage<::google::logging::v2::ListBucketsResponse>(Arena*);
template<> ::google::logging::v2::ListExclusionsRequest* Arena::CreateMaybeMessage<::google::logging::v2::ListExclusionsRequest>(Arena*);
template<> ::google::logging::v2::ListExclusionsResponse* Arena::CreateMaybeMessage<::google::logging::v2::ListExclusionsResponse>(Arena*);
template<> ::google::logging::v2::ListSinksRequest* Arena::CreateMaybeMessage<::google::logging::v2::ListSinksRequest>(Arena*);
template<> ::google::logging::v2::ListSinksResponse* Arena::CreateMaybeMessage<::google::logging::v2::ListSinksResponse>(Arena*);
template<> ::google::logging::v2::ListViewsRequest* Arena::CreateMaybeMessage<::google::logging::v2::ListViewsRequest>(Arena*);
template<> ::google::logging::v2::ListViewsResponse* Arena::CreateMaybeMessage<::google::logging::v2::ListViewsResponse>(Arena*);
template<> ::google::logging::v2::LogBucket* Arena::CreateMaybeMessage<::google::logging::v2::LogBucket>(Arena*);
template<> ::google::logging::v2::LogExclusion* Arena::CreateMaybeMessage<::google::logging::v2::LogExclusion>(Arena*);
template<> ::google::logging::v2::LogSink* Arena::CreateMaybeMessage<::google::logging::v2::LogSink>(Arena*);
template<> ::google::logging::v2::LogView* Arena::CreateMaybeMessage<::google::logging::v2::LogView>(Arena*);
template<> ::google::logging::v2::Settings* Arena::CreateMaybeMessage<::google::logging::v2::Settings>(Arena*);
template<> ::google::logging::v2::UndeleteBucketRequest* Arena::CreateMaybeMessage<::google::logging::v2::UndeleteBucketRequest>(Arena*);
template<> ::google::logging::v2::UpdateBucketRequest* Arena::CreateMaybeMessage<::google::logging::v2::UpdateBucketRequest>(Arena*);
template<> ::google::logging::v2::UpdateCmekSettingsRequest* Arena::CreateMaybeMessage<::google::logging::v2::UpdateCmekSettingsRequest>(Arena*);
template<> ::google::logging::v2::UpdateExclusionRequest* Arena::CreateMaybeMessage<::google::logging::v2::UpdateExclusionRequest>(Arena*);
template<> ::google::logging::v2::UpdateSettingsRequest* Arena::CreateMaybeMessage<::google::logging::v2::UpdateSettingsRequest>(Arena*);
template<> ::google::logging::v2::UpdateSinkRequest* Arena::CreateMaybeMessage<::google::logging::v2::UpdateSinkRequest>(Arena*);
template<> ::google::logging::v2::UpdateViewRequest* Arena::CreateMaybeMessage<::google::logging::v2::UpdateViewRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace google {
namespace logging {
namespace v2 {

enum LogSink_VersionFormat : int {
  LogSink_VersionFormat_VERSION_FORMAT_UNSPECIFIED = 0,
  LogSink_VersionFormat_V2 = 1,
  LogSink_VersionFormat_V1 = 2,
  LogSink_VersionFormat_LogSink_VersionFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LogSink_VersionFormat_LogSink_VersionFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LogSink_VersionFormat_IsValid(int value);
constexpr LogSink_VersionFormat LogSink_VersionFormat_VersionFormat_MIN = LogSink_VersionFormat_VERSION_FORMAT_UNSPECIFIED;
constexpr LogSink_VersionFormat LogSink_VersionFormat_VersionFormat_MAX = LogSink_VersionFormat_V1;
constexpr int LogSink_VersionFormat_VersionFormat_ARRAYSIZE = LogSink_VersionFormat_VersionFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogSink_VersionFormat_descriptor();
template<typename T>
inline const std::string& LogSink_VersionFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogSink_VersionFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogSink_VersionFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogSink_VersionFormat_descriptor(), enum_t_value);
}
inline bool LogSink_VersionFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogSink_VersionFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogSink_VersionFormat>(
    LogSink_VersionFormat_descriptor(), name, value);
}
enum LifecycleState : int {
  LIFECYCLE_STATE_UNSPECIFIED = 0,
  ACTIVE = 1,
  DELETE_REQUESTED = 2,
  LifecycleState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LifecycleState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LifecycleState_IsValid(int value);
constexpr LifecycleState LifecycleState_MIN = LIFECYCLE_STATE_UNSPECIFIED;
constexpr LifecycleState LifecycleState_MAX = DELETE_REQUESTED;
constexpr int LifecycleState_ARRAYSIZE = LifecycleState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LifecycleState_descriptor();
template<typename T>
inline const std::string& LifecycleState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LifecycleState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LifecycleState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LifecycleState_descriptor(), enum_t_value);
}
inline bool LifecycleState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LifecycleState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LifecycleState>(
    LifecycleState_descriptor(), name, value);
}
enum OperationState : int {
  OPERATION_STATE_UNSPECIFIED = 0,
  OPERATION_STATE_SCHEDULED = 1,
  OPERATION_STATE_WAITING_FOR_PERMISSIONS = 2,
  OPERATION_STATE_RUNNING = 3,
  OPERATION_STATE_SUCCEEDED = 4,
  OPERATION_STATE_FAILED = 5,
  OPERATION_STATE_CANCELLED = 6,
  OperationState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OperationState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OperationState_IsValid(int value);
constexpr OperationState OperationState_MIN = OPERATION_STATE_UNSPECIFIED;
constexpr OperationState OperationState_MAX = OPERATION_STATE_CANCELLED;
constexpr int OperationState_ARRAYSIZE = OperationState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OperationState_descriptor();
template<typename T>
inline const std::string& OperationState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OperationState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OperationState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OperationState_descriptor(), enum_t_value);
}
inline bool OperationState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OperationState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OperationState>(
    OperationState_descriptor(), name, value);
}
// ===================================================================

class LogBucket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.LogBucket) */ {
 public:
  inline LogBucket() : LogBucket(nullptr) {}
  ~LogBucket() override;
  explicit PROTOBUF_CONSTEXPR LogBucket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogBucket(const LogBucket& from);
  LogBucket(LogBucket&& from) noexcept
    : LogBucket() {
    *this = ::std::move(from);
  }

  inline LogBucket& operator=(const LogBucket& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogBucket& operator=(LogBucket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogBucket& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogBucket* internal_default_instance() {
    return reinterpret_cast<const LogBucket*>(
               &_LogBucket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LogBucket& a, LogBucket& b) {
    a.Swap(&b);
  }
  inline void Swap(LogBucket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogBucket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogBucket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogBucket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogBucket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogBucket& from) {
    LogBucket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogBucket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.LogBucket";
  }
  protected:
  explicit LogBucket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRestrictedFieldsFieldNumber = 15,
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 3,
    kCreateTimeFieldNumber = 4,
    kUpdateTimeFieldNumber = 5,
    kCmekSettingsFieldNumber = 19,
    kLockedFieldNumber = 9,
    kRetentionDaysFieldNumber = 11,
    kLifecycleStateFieldNumber = 12,
  };
  // repeated string restricted_fields = 15;
  int restricted_fields_size() const;
  private:
  int _internal_restricted_fields_size() const;
  public:
  void clear_restricted_fields();
  const std::string& restricted_fields(int index) const;
  std::string* mutable_restricted_fields(int index);
  void set_restricted_fields(int index, const std::string& value);
  void set_restricted_fields(int index, std::string&& value);
  void set_restricted_fields(int index, const char* value);
  void set_restricted_fields(int index, const char* value, size_t size);
  std::string* add_restricted_fields();
  void add_restricted_fields(const std::string& value);
  void add_restricted_fields(std::string&& value);
  void add_restricted_fields(const char* value);
  void add_restricted_fields(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& restricted_fields() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_restricted_fields();
  private:
  const std::string& _internal_restricted_fields(int index) const;
  std::string* _internal_add_restricted_fields();
  public:

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .google.protobuf.Timestamp create_time = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_time();
  void set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_time();
  public:
  void unsafe_arena_set_allocated_create_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_time();

  // .google.protobuf.Timestamp update_time = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_update_time() const;
  private:
  bool _internal_has_update_time() const;
  public:
  void clear_update_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& update_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_update_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_update_time();
  void set_allocated_update_time(::PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_update_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_update_time();
  public:
  void unsafe_arena_set_allocated_update_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_update_time();

  // .google.logging.v2.CmekSettings cmek_settings = 19;
  bool has_cmek_settings() const;
  private:
  bool _internal_has_cmek_settings() const;
  public:
  void clear_cmek_settings();
  const ::google::logging::v2::CmekSettings& cmek_settings() const;
  PROTOBUF_NODISCARD ::google::logging::v2::CmekSettings* release_cmek_settings();
  ::google::logging::v2::CmekSettings* mutable_cmek_settings();
  void set_allocated_cmek_settings(::google::logging::v2::CmekSettings* cmek_settings);
  private:
  const ::google::logging::v2::CmekSettings& _internal_cmek_settings() const;
  ::google::logging::v2::CmekSettings* _internal_mutable_cmek_settings();
  public:
  void unsafe_arena_set_allocated_cmek_settings(
      ::google::logging::v2::CmekSettings* cmek_settings);
  ::google::logging::v2::CmekSettings* unsafe_arena_release_cmek_settings();

  // bool locked = 9;
  void clear_locked();
  bool locked() const;
  void set_locked(bool value);
  private:
  bool _internal_locked() const;
  void _internal_set_locked(bool value);
  public:

  // int32 retention_days = 11;
  void clear_retention_days();
  int32_t retention_days() const;
  void set_retention_days(int32_t value);
  private:
  int32_t _internal_retention_days() const;
  void _internal_set_retention_days(int32_t value);
  public:

  // .google.logging.v2.LifecycleState lifecycle_state = 12 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_lifecycle_state();
  ::google::logging::v2::LifecycleState lifecycle_state() const;
  void set_lifecycle_state(::google::logging::v2::LifecycleState value);
  private:
  ::google::logging::v2::LifecycleState _internal_lifecycle_state() const;
  void _internal_set_lifecycle_state(::google::logging::v2::LifecycleState value);
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.LogBucket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> restricted_fields_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time_;
    ::google::logging::v2::CmekSettings* cmek_settings_;
    bool locked_;
    int32_t retention_days_;
    int lifecycle_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class LogView final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.LogView) */ {
 public:
  inline LogView() : LogView(nullptr) {}
  ~LogView() override;
  explicit PROTOBUF_CONSTEXPR LogView(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogView(const LogView& from);
  LogView(LogView&& from) noexcept
    : LogView() {
    *this = ::std::move(from);
  }

  inline LogView& operator=(const LogView& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogView& operator=(LogView&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogView& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogView* internal_default_instance() {
    return reinterpret_cast<const LogView*>(
               &_LogView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LogView& a, LogView& b) {
    a.Swap(&b);
  }
  inline void Swap(LogView* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogView* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogView* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogView>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogView& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogView& from) {
    LogView::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogView* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.LogView";
  }
  protected:
  explicit LogView(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 3,
    kFilterFieldNumber = 7,
    kCreateTimeFieldNumber = 4,
    kUpdateTimeFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string filter = 7;
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // .google.protobuf.Timestamp create_time = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_time();
  void set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_time();
  public:
  void unsafe_arena_set_allocated_create_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_time();

  // .google.protobuf.Timestamp update_time = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_update_time() const;
  private:
  bool _internal_has_update_time() const;
  public:
  void clear_update_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& update_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_update_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_update_time();
  void set_allocated_update_time(::PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_update_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_update_time();
  public:
  void unsafe_arena_set_allocated_update_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_update_time();

  // @@protoc_insertion_point(class_scope:google.logging.v2.LogView)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class LogSink final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.LogSink) */ {
 public:
  inline LogSink() : LogSink(nullptr) {}
  ~LogSink() override;
  explicit PROTOBUF_CONSTEXPR LogSink(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogSink(const LogSink& from);
  LogSink(LogSink&& from) noexcept
    : LogSink() {
    *this = ::std::move(from);
  }

  inline LogSink& operator=(const LogSink& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogSink& operator=(LogSink&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogSink& default_instance() {
    return *internal_default_instance();
  }
  enum OptionsCase {
    kBigqueryOptions = 12,
    OPTIONS_NOT_SET = 0,
  };

  static inline const LogSink* internal_default_instance() {
    return reinterpret_cast<const LogSink*>(
               &_LogSink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LogSink& a, LogSink& b) {
    a.Swap(&b);
  }
  inline void Swap(LogSink* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogSink* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogSink* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogSink>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogSink& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogSink& from) {
    LogSink::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogSink* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.LogSink";
  }
  protected:
  explicit LogSink(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LogSink_VersionFormat VersionFormat;
  static constexpr VersionFormat VERSION_FORMAT_UNSPECIFIED =
    LogSink_VersionFormat_VERSION_FORMAT_UNSPECIFIED;
  static constexpr VersionFormat V2 =
    LogSink_VersionFormat_V2;
  static constexpr VersionFormat V1 =
    LogSink_VersionFormat_V1;
  static inline bool VersionFormat_IsValid(int value) {
    return LogSink_VersionFormat_IsValid(value);
  }
  static constexpr VersionFormat VersionFormat_MIN =
    LogSink_VersionFormat_VersionFormat_MIN;
  static constexpr VersionFormat VersionFormat_MAX =
    LogSink_VersionFormat_VersionFormat_MAX;
  static constexpr int VersionFormat_ARRAYSIZE =
    LogSink_VersionFormat_VersionFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VersionFormat_descriptor() {
    return LogSink_VersionFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& VersionFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VersionFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VersionFormat_Name.");
    return LogSink_VersionFormat_Name(enum_t_value);
  }
  static inline bool VersionFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      VersionFormat* value) {
    return LogSink_VersionFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExclusionsFieldNumber = 16,
    kNameFieldNumber = 1,
    kDestinationFieldNumber = 3,
    kFilterFieldNumber = 5,
    kWriterIdentityFieldNumber = 8,
    kDescriptionFieldNumber = 18,
    kCreateTimeFieldNumber = 13,
    kUpdateTimeFieldNumber = 14,
    kOutputVersionFormatFieldNumber = 6,
    kDisabledFieldNumber = 19,
    kIncludeChildrenFieldNumber = 9,
    kBigqueryOptionsFieldNumber = 12,
  };
  // repeated .google.logging.v2.LogExclusion exclusions = 16 [(.google.api.field_behavior) = OPTIONAL];
  int exclusions_size() const;
  private:
  int _internal_exclusions_size() const;
  public:
  void clear_exclusions();
  ::google::logging::v2::LogExclusion* mutable_exclusions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogExclusion >*
      mutable_exclusions();
  private:
  const ::google::logging::v2::LogExclusion& _internal_exclusions(int index) const;
  ::google::logging::v2::LogExclusion* _internal_add_exclusions();
  public:
  const ::google::logging::v2::LogExclusion& exclusions(int index) const;
  ::google::logging::v2::LogExclusion* add_exclusions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogExclusion >&
      exclusions() const;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string destination = 3 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_destination();
  const std::string& destination() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* destination);
  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(const std::string& value);
  std::string* _internal_mutable_destination();
  public:

  // string filter = 5 [(.google.api.field_behavior) = OPTIONAL];
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // string writer_identity = 8 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_writer_identity();
  const std::string& writer_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_writer_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_writer_identity();
  PROTOBUF_NODISCARD std::string* release_writer_identity();
  void set_allocated_writer_identity(std::string* writer_identity);
  private:
  const std::string& _internal_writer_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_writer_identity(const std::string& value);
  std::string* _internal_mutable_writer_identity();
  public:

  // string description = 18 [(.google.api.field_behavior) = OPTIONAL];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .google.protobuf.Timestamp create_time = 13 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_time();
  void set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_time();
  public:
  void unsafe_arena_set_allocated_create_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_time();

  // .google.protobuf.Timestamp update_time = 14 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_update_time() const;
  private:
  bool _internal_has_update_time() const;
  public:
  void clear_update_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& update_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_update_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_update_time();
  void set_allocated_update_time(::PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_update_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_update_time();
  public:
  void unsafe_arena_set_allocated_update_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_update_time();

  // .google.logging.v2.LogSink.VersionFormat output_version_format = 6 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_output_version_format();
  PROTOBUF_DEPRECATED ::google::logging::v2::LogSink_VersionFormat output_version_format() const;
  PROTOBUF_DEPRECATED void set_output_version_format(::google::logging::v2::LogSink_VersionFormat value);
  private:
  ::google::logging::v2::LogSink_VersionFormat _internal_output_version_format() const;
  void _internal_set_output_version_format(::google::logging::v2::LogSink_VersionFormat value);
  public:

  // bool disabled = 19 [(.google.api.field_behavior) = OPTIONAL];
  void clear_disabled();
  bool disabled() const;
  void set_disabled(bool value);
  private:
  bool _internal_disabled() const;
  void _internal_set_disabled(bool value);
  public:

  // bool include_children = 9 [(.google.api.field_behavior) = OPTIONAL];
  void clear_include_children();
  bool include_children() const;
  void set_include_children(bool value);
  private:
  bool _internal_include_children() const;
  void _internal_set_include_children(bool value);
  public:

  // .google.logging.v2.BigQueryOptions bigquery_options = 12 [(.google.api.field_behavior) = OPTIONAL];
  bool has_bigquery_options() const;
  private:
  bool _internal_has_bigquery_options() const;
  public:
  void clear_bigquery_options();
  const ::google::logging::v2::BigQueryOptions& bigquery_options() const;
  PROTOBUF_NODISCARD ::google::logging::v2::BigQueryOptions* release_bigquery_options();
  ::google::logging::v2::BigQueryOptions* mutable_bigquery_options();
  void set_allocated_bigquery_options(::google::logging::v2::BigQueryOptions* bigquery_options);
  private:
  const ::google::logging::v2::BigQueryOptions& _internal_bigquery_options() const;
  ::google::logging::v2::BigQueryOptions* _internal_mutable_bigquery_options();
  public:
  void unsafe_arena_set_allocated_bigquery_options(
      ::google::logging::v2::BigQueryOptions* bigquery_options);
  ::google::logging::v2::BigQueryOptions* unsafe_arena_release_bigquery_options();

  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:google.logging.v2.LogSink)
 private:
  class _Internal;
  void set_has_bigquery_options();

  inline bool has_options() const;
  inline void clear_has_options();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogExclusion > exclusions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr writer_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time_;
    int output_version_format_;
    bool disabled_;
    bool include_children_;
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::google::logging::v2::BigQueryOptions* bigquery_options_;
    } options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class BigQueryOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.BigQueryOptions) */ {
 public:
  inline BigQueryOptions() : BigQueryOptions(nullptr) {}
  ~BigQueryOptions() override;
  explicit PROTOBUF_CONSTEXPR BigQueryOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BigQueryOptions(const BigQueryOptions& from);
  BigQueryOptions(BigQueryOptions&& from) noexcept
    : BigQueryOptions() {
    *this = ::std::move(from);
  }

  inline BigQueryOptions& operator=(const BigQueryOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline BigQueryOptions& operator=(BigQueryOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BigQueryOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const BigQueryOptions* internal_default_instance() {
    return reinterpret_cast<const BigQueryOptions*>(
               &_BigQueryOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BigQueryOptions& a, BigQueryOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(BigQueryOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BigQueryOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BigQueryOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BigQueryOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BigQueryOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BigQueryOptions& from) {
    BigQueryOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigQueryOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.BigQueryOptions";
  }
  protected:
  explicit BigQueryOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsePartitionedTablesFieldNumber = 1,
    kUsesTimestampColumnPartitioningFieldNumber = 3,
  };
  // bool use_partitioned_tables = 1 [(.google.api.field_behavior) = OPTIONAL];
  void clear_use_partitioned_tables();
  bool use_partitioned_tables() const;
  void set_use_partitioned_tables(bool value);
  private:
  bool _internal_use_partitioned_tables() const;
  void _internal_set_use_partitioned_tables(bool value);
  public:

  // bool uses_timestamp_column_partitioning = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_uses_timestamp_column_partitioning();
  bool uses_timestamp_column_partitioning() const;
  void set_uses_timestamp_column_partitioning(bool value);
  private:
  bool _internal_uses_timestamp_column_partitioning() const;
  void _internal_set_uses_timestamp_column_partitioning(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.BigQueryOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool use_partitioned_tables_;
    bool uses_timestamp_column_partitioning_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ListBucketsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.ListBucketsRequest) */ {
 public:
  inline ListBucketsRequest() : ListBucketsRequest(nullptr) {}
  ~ListBucketsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListBucketsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListBucketsRequest(const ListBucketsRequest& from);
  ListBucketsRequest(ListBucketsRequest&& from) noexcept
    : ListBucketsRequest() {
    *this = ::std::move(from);
  }

  inline ListBucketsRequest& operator=(const ListBucketsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListBucketsRequest& operator=(ListBucketsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListBucketsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListBucketsRequest* internal_default_instance() {
    return reinterpret_cast<const ListBucketsRequest*>(
               &_ListBucketsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ListBucketsRequest& a, ListBucketsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListBucketsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListBucketsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListBucketsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListBucketsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListBucketsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListBucketsRequest& from) {
    ListBucketsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListBucketsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.ListBucketsRequest";
  }
  protected:
  explicit ListBucketsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 3,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.ListBucketsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ListBucketsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.ListBucketsResponse) */ {
 public:
  inline ListBucketsResponse() : ListBucketsResponse(nullptr) {}
  ~ListBucketsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListBucketsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListBucketsResponse(const ListBucketsResponse& from);
  ListBucketsResponse(ListBucketsResponse&& from) noexcept
    : ListBucketsResponse() {
    *this = ::std::move(from);
  }

  inline ListBucketsResponse& operator=(const ListBucketsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListBucketsResponse& operator=(ListBucketsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListBucketsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListBucketsResponse* internal_default_instance() {
    return reinterpret_cast<const ListBucketsResponse*>(
               &_ListBucketsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListBucketsResponse& a, ListBucketsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListBucketsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListBucketsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListBucketsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListBucketsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListBucketsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListBucketsResponse& from) {
    ListBucketsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListBucketsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.ListBucketsResponse";
  }
  protected:
  explicit ListBucketsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.logging.v2.LogBucket buckets = 1;
  int buckets_size() const;
  private:
  int _internal_buckets_size() const;
  public:
  void clear_buckets();
  ::google::logging::v2::LogBucket* mutable_buckets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogBucket >*
      mutable_buckets();
  private:
  const ::google::logging::v2::LogBucket& _internal_buckets(int index) const;
  ::google::logging::v2::LogBucket* _internal_add_buckets();
  public:
  const ::google::logging::v2::LogBucket& buckets(int index) const;
  ::google::logging::v2::LogBucket* add_buckets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogBucket >&
      buckets() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.ListBucketsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogBucket > buckets_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CreateBucketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.CreateBucketRequest) */ {
 public:
  inline CreateBucketRequest() : CreateBucketRequest(nullptr) {}
  ~CreateBucketRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateBucketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateBucketRequest(const CreateBucketRequest& from);
  CreateBucketRequest(CreateBucketRequest&& from) noexcept
    : CreateBucketRequest() {
    *this = ::std::move(from);
  }

  inline CreateBucketRequest& operator=(const CreateBucketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateBucketRequest& operator=(CreateBucketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateBucketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateBucketRequest* internal_default_instance() {
    return reinterpret_cast<const CreateBucketRequest*>(
               &_CreateBucketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CreateBucketRequest& a, CreateBucketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateBucketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateBucketRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateBucketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateBucketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateBucketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateBucketRequest& from) {
    CreateBucketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateBucketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.CreateBucketRequest";
  }
  protected:
  explicit CreateBucketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kBucketIdFieldNumber = 2,
    kBucketFieldNumber = 3,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string bucket_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_bucket_id();
  const std::string& bucket_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bucket_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bucket_id();
  PROTOBUF_NODISCARD std::string* release_bucket_id();
  void set_allocated_bucket_id(std::string* bucket_id);
  private:
  const std::string& _internal_bucket_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bucket_id(const std::string& value);
  std::string* _internal_mutable_bucket_id();
  public:

  // .google.logging.v2.LogBucket bucket = 3 [(.google.api.field_behavior) = REQUIRED];
  bool has_bucket() const;
  private:
  bool _internal_has_bucket() const;
  public:
  void clear_bucket();
  const ::google::logging::v2::LogBucket& bucket() const;
  PROTOBUF_NODISCARD ::google::logging::v2::LogBucket* release_bucket();
  ::google::logging::v2::LogBucket* mutable_bucket();
  void set_allocated_bucket(::google::logging::v2::LogBucket* bucket);
  private:
  const ::google::logging::v2::LogBucket& _internal_bucket() const;
  ::google::logging::v2::LogBucket* _internal_mutable_bucket();
  public:
  void unsafe_arena_set_allocated_bucket(
      ::google::logging::v2::LogBucket* bucket);
  ::google::logging::v2::LogBucket* unsafe_arena_release_bucket();

  // @@protoc_insertion_point(class_scope:google.logging.v2.CreateBucketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bucket_id_;
    ::google::logging::v2::LogBucket* bucket_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class UpdateBucketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.UpdateBucketRequest) */ {
 public:
  inline UpdateBucketRequest() : UpdateBucketRequest(nullptr) {}
  ~UpdateBucketRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateBucketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateBucketRequest(const UpdateBucketRequest& from);
  UpdateBucketRequest(UpdateBucketRequest&& from) noexcept
    : UpdateBucketRequest() {
    *this = ::std::move(from);
  }

  inline UpdateBucketRequest& operator=(const UpdateBucketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateBucketRequest& operator=(UpdateBucketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateBucketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateBucketRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateBucketRequest*>(
               &_UpdateBucketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UpdateBucketRequest& a, UpdateBucketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateBucketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateBucketRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateBucketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateBucketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateBucketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateBucketRequest& from) {
    UpdateBucketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateBucketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.UpdateBucketRequest";
  }
  protected:
  explicit UpdateBucketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kBucketFieldNumber = 2,
    kUpdateMaskFieldNumber = 4,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.logging.v2.LogBucket bucket = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_bucket() const;
  private:
  bool _internal_has_bucket() const;
  public:
  void clear_bucket();
  const ::google::logging::v2::LogBucket& bucket() const;
  PROTOBUF_NODISCARD ::google::logging::v2::LogBucket* release_bucket();
  ::google::logging::v2::LogBucket* mutable_bucket();
  void set_allocated_bucket(::google::logging::v2::LogBucket* bucket);
  private:
  const ::google::logging::v2::LogBucket& _internal_bucket() const;
  ::google::logging::v2::LogBucket* _internal_mutable_bucket();
  public:
  void unsafe_arena_set_allocated_bucket(
      ::google::logging::v2::LogBucket* bucket);
  ::google::logging::v2::LogBucket* unsafe_arena_release_bucket();

  // .google.protobuf.FieldMask update_mask = 4 [(.google.api.field_behavior) = REQUIRED];
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // @@protoc_insertion_point(class_scope:google.logging.v2.UpdateBucketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::google::logging::v2::LogBucket* bucket_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class GetBucketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.GetBucketRequest) */ {
 public:
  inline GetBucketRequest() : GetBucketRequest(nullptr) {}
  ~GetBucketRequest() override;
  explicit PROTOBUF_CONSTEXPR GetBucketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBucketRequest(const GetBucketRequest& from);
  GetBucketRequest(GetBucketRequest&& from) noexcept
    : GetBucketRequest() {
    *this = ::std::move(from);
  }

  inline GetBucketRequest& operator=(const GetBucketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBucketRequest& operator=(GetBucketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBucketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBucketRequest* internal_default_instance() {
    return reinterpret_cast<const GetBucketRequest*>(
               &_GetBucketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetBucketRequest& a, GetBucketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBucketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBucketRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBucketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBucketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBucketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBucketRequest& from) {
    GetBucketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBucketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.GetBucketRequest";
  }
  protected:
  explicit GetBucketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.GetBucketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class DeleteBucketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.DeleteBucketRequest) */ {
 public:
  inline DeleteBucketRequest() : DeleteBucketRequest(nullptr) {}
  ~DeleteBucketRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteBucketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteBucketRequest(const DeleteBucketRequest& from);
  DeleteBucketRequest(DeleteBucketRequest&& from) noexcept
    : DeleteBucketRequest() {
    *this = ::std::move(from);
  }

  inline DeleteBucketRequest& operator=(const DeleteBucketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteBucketRequest& operator=(DeleteBucketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteBucketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteBucketRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteBucketRequest*>(
               &_DeleteBucketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DeleteBucketRequest& a, DeleteBucketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteBucketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteBucketRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteBucketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteBucketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteBucketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteBucketRequest& from) {
    DeleteBucketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteBucketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.DeleteBucketRequest";
  }
  protected:
  explicit DeleteBucketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.DeleteBucketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class UndeleteBucketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.UndeleteBucketRequest) */ {
 public:
  inline UndeleteBucketRequest() : UndeleteBucketRequest(nullptr) {}
  ~UndeleteBucketRequest() override;
  explicit PROTOBUF_CONSTEXPR UndeleteBucketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UndeleteBucketRequest(const UndeleteBucketRequest& from);
  UndeleteBucketRequest(UndeleteBucketRequest&& from) noexcept
    : UndeleteBucketRequest() {
    *this = ::std::move(from);
  }

  inline UndeleteBucketRequest& operator=(const UndeleteBucketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UndeleteBucketRequest& operator=(UndeleteBucketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UndeleteBucketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UndeleteBucketRequest* internal_default_instance() {
    return reinterpret_cast<const UndeleteBucketRequest*>(
               &_UndeleteBucketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UndeleteBucketRequest& a, UndeleteBucketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UndeleteBucketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UndeleteBucketRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UndeleteBucketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UndeleteBucketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UndeleteBucketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UndeleteBucketRequest& from) {
    UndeleteBucketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UndeleteBucketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.UndeleteBucketRequest";
  }
  protected:
  explicit UndeleteBucketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.UndeleteBucketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ListViewsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.ListViewsRequest) */ {
 public:
  inline ListViewsRequest() : ListViewsRequest(nullptr) {}
  ~ListViewsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListViewsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListViewsRequest(const ListViewsRequest& from);
  ListViewsRequest(ListViewsRequest&& from) noexcept
    : ListViewsRequest() {
    *this = ::std::move(from);
  }

  inline ListViewsRequest& operator=(const ListViewsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListViewsRequest& operator=(ListViewsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListViewsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListViewsRequest* internal_default_instance() {
    return reinterpret_cast<const ListViewsRequest*>(
               &_ListViewsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ListViewsRequest& a, ListViewsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListViewsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListViewsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListViewsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListViewsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListViewsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListViewsRequest& from) {
    ListViewsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListViewsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.ListViewsRequest";
  }
  protected:
  explicit ListViewsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 3,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.ListViewsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ListViewsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.ListViewsResponse) */ {
 public:
  inline ListViewsResponse() : ListViewsResponse(nullptr) {}
  ~ListViewsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListViewsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListViewsResponse(const ListViewsResponse& from);
  ListViewsResponse(ListViewsResponse&& from) noexcept
    : ListViewsResponse() {
    *this = ::std::move(from);
  }

  inline ListViewsResponse& operator=(const ListViewsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListViewsResponse& operator=(ListViewsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListViewsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListViewsResponse* internal_default_instance() {
    return reinterpret_cast<const ListViewsResponse*>(
               &_ListViewsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListViewsResponse& a, ListViewsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListViewsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListViewsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListViewsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListViewsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListViewsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListViewsResponse& from) {
    ListViewsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListViewsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.ListViewsResponse";
  }
  protected:
  explicit ListViewsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.logging.v2.LogView views = 1;
  int views_size() const;
  private:
  int _internal_views_size() const;
  public:
  void clear_views();
  ::google::logging::v2::LogView* mutable_views(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogView >*
      mutable_views();
  private:
  const ::google::logging::v2::LogView& _internal_views(int index) const;
  ::google::logging::v2::LogView* _internal_add_views();
  public:
  const ::google::logging::v2::LogView& views(int index) const;
  ::google::logging::v2::LogView* add_views();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogView >&
      views() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.ListViewsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogView > views_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CreateViewRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.CreateViewRequest) */ {
 public:
  inline CreateViewRequest() : CreateViewRequest(nullptr) {}
  ~CreateViewRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateViewRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateViewRequest(const CreateViewRequest& from);
  CreateViewRequest(CreateViewRequest&& from) noexcept
    : CreateViewRequest() {
    *this = ::std::move(from);
  }

  inline CreateViewRequest& operator=(const CreateViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateViewRequest& operator=(CreateViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateViewRequest* internal_default_instance() {
    return reinterpret_cast<const CreateViewRequest*>(
               &_CreateViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CreateViewRequest& a, CreateViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateViewRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateViewRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateViewRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateViewRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateViewRequest& from) {
    CreateViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateViewRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.CreateViewRequest";
  }
  protected:
  explicit CreateViewRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kViewIdFieldNumber = 2,
    kViewFieldNumber = 3,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string view_id = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_view_id();
  const std::string& view_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_id();
  PROTOBUF_NODISCARD std::string* release_view_id();
  void set_allocated_view_id(std::string* view_id);
  private:
  const std::string& _internal_view_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_id(const std::string& value);
  std::string* _internal_mutable_view_id();
  public:

  // .google.logging.v2.LogView view = 3 [(.google.api.field_behavior) = REQUIRED];
  bool has_view() const;
  private:
  bool _internal_has_view() const;
  public:
  void clear_view();
  const ::google::logging::v2::LogView& view() const;
  PROTOBUF_NODISCARD ::google::logging::v2::LogView* release_view();
  ::google::logging::v2::LogView* mutable_view();
  void set_allocated_view(::google::logging::v2::LogView* view);
  private:
  const ::google::logging::v2::LogView& _internal_view() const;
  ::google::logging::v2::LogView* _internal_mutable_view();
  public:
  void unsafe_arena_set_allocated_view(
      ::google::logging::v2::LogView* view);
  ::google::logging::v2::LogView* unsafe_arena_release_view();

  // @@protoc_insertion_point(class_scope:google.logging.v2.CreateViewRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_id_;
    ::google::logging::v2::LogView* view_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class UpdateViewRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.UpdateViewRequest) */ {
 public:
  inline UpdateViewRequest() : UpdateViewRequest(nullptr) {}
  ~UpdateViewRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateViewRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateViewRequest(const UpdateViewRequest& from);
  UpdateViewRequest(UpdateViewRequest&& from) noexcept
    : UpdateViewRequest() {
    *this = ::std::move(from);
  }

  inline UpdateViewRequest& operator=(const UpdateViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateViewRequest& operator=(UpdateViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateViewRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateViewRequest*>(
               &_UpdateViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UpdateViewRequest& a, UpdateViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateViewRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateViewRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateViewRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateViewRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateViewRequest& from) {
    UpdateViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateViewRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.UpdateViewRequest";
  }
  protected:
  explicit UpdateViewRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kViewFieldNumber = 2,
    kUpdateMaskFieldNumber = 4,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.logging.v2.LogView view = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_view() const;
  private:
  bool _internal_has_view() const;
  public:
  void clear_view();
  const ::google::logging::v2::LogView& view() const;
  PROTOBUF_NODISCARD ::google::logging::v2::LogView* release_view();
  ::google::logging::v2::LogView* mutable_view();
  void set_allocated_view(::google::logging::v2::LogView* view);
  private:
  const ::google::logging::v2::LogView& _internal_view() const;
  ::google::logging::v2::LogView* _internal_mutable_view();
  public:
  void unsafe_arena_set_allocated_view(
      ::google::logging::v2::LogView* view);
  ::google::logging::v2::LogView* unsafe_arena_release_view();

  // .google.protobuf.FieldMask update_mask = 4 [(.google.api.field_behavior) = OPTIONAL];
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // @@protoc_insertion_point(class_scope:google.logging.v2.UpdateViewRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::google::logging::v2::LogView* view_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class GetViewRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.GetViewRequest) */ {
 public:
  inline GetViewRequest() : GetViewRequest(nullptr) {}
  ~GetViewRequest() override;
  explicit PROTOBUF_CONSTEXPR GetViewRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetViewRequest(const GetViewRequest& from);
  GetViewRequest(GetViewRequest&& from) noexcept
    : GetViewRequest() {
    *this = ::std::move(from);
  }

  inline GetViewRequest& operator=(const GetViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetViewRequest& operator=(GetViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetViewRequest* internal_default_instance() {
    return reinterpret_cast<const GetViewRequest*>(
               &_GetViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetViewRequest& a, GetViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetViewRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetViewRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetViewRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetViewRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetViewRequest& from) {
    GetViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetViewRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.GetViewRequest";
  }
  protected:
  explicit GetViewRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.GetViewRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class DeleteViewRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.DeleteViewRequest) */ {
 public:
  inline DeleteViewRequest() : DeleteViewRequest(nullptr) {}
  ~DeleteViewRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteViewRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteViewRequest(const DeleteViewRequest& from);
  DeleteViewRequest(DeleteViewRequest&& from) noexcept
    : DeleteViewRequest() {
    *this = ::std::move(from);
  }

  inline DeleteViewRequest& operator=(const DeleteViewRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteViewRequest& operator=(DeleteViewRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteViewRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteViewRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteViewRequest*>(
               &_DeleteViewRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DeleteViewRequest& a, DeleteViewRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteViewRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteViewRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteViewRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteViewRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteViewRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteViewRequest& from) {
    DeleteViewRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteViewRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.DeleteViewRequest";
  }
  protected:
  explicit DeleteViewRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.DeleteViewRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ListSinksRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.ListSinksRequest) */ {
 public:
  inline ListSinksRequest() : ListSinksRequest(nullptr) {}
  ~ListSinksRequest() override;
  explicit PROTOBUF_CONSTEXPR ListSinksRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListSinksRequest(const ListSinksRequest& from);
  ListSinksRequest(ListSinksRequest&& from) noexcept
    : ListSinksRequest() {
    *this = ::std::move(from);
  }

  inline ListSinksRequest& operator=(const ListSinksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSinksRequest& operator=(ListSinksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSinksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSinksRequest* internal_default_instance() {
    return reinterpret_cast<const ListSinksRequest*>(
               &_ListSinksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ListSinksRequest& a, ListSinksRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSinksRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSinksRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSinksRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListSinksRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListSinksRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListSinksRequest& from) {
    ListSinksRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListSinksRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.ListSinksRequest";
  }
  protected:
  explicit ListSinksRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 3,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.ListSinksRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ListSinksResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.ListSinksResponse) */ {
 public:
  inline ListSinksResponse() : ListSinksResponse(nullptr) {}
  ~ListSinksResponse() override;
  explicit PROTOBUF_CONSTEXPR ListSinksResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListSinksResponse(const ListSinksResponse& from);
  ListSinksResponse(ListSinksResponse&& from) noexcept
    : ListSinksResponse() {
    *this = ::std::move(from);
  }

  inline ListSinksResponse& operator=(const ListSinksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSinksResponse& operator=(ListSinksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSinksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSinksResponse* internal_default_instance() {
    return reinterpret_cast<const ListSinksResponse*>(
               &_ListSinksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ListSinksResponse& a, ListSinksResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSinksResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSinksResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSinksResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListSinksResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListSinksResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListSinksResponse& from) {
    ListSinksResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListSinksResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.ListSinksResponse";
  }
  protected:
  explicit ListSinksResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSinksFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.logging.v2.LogSink sinks = 1;
  int sinks_size() const;
  private:
  int _internal_sinks_size() const;
  public:
  void clear_sinks();
  ::google::logging::v2::LogSink* mutable_sinks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogSink >*
      mutable_sinks();
  private:
  const ::google::logging::v2::LogSink& _internal_sinks(int index) const;
  ::google::logging::v2::LogSink* _internal_add_sinks();
  public:
  const ::google::logging::v2::LogSink& sinks(int index) const;
  ::google::logging::v2::LogSink* add_sinks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogSink >&
      sinks() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.ListSinksResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogSink > sinks_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class GetSinkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.GetSinkRequest) */ {
 public:
  inline GetSinkRequest() : GetSinkRequest(nullptr) {}
  ~GetSinkRequest() override;
  explicit PROTOBUF_CONSTEXPR GetSinkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSinkRequest(const GetSinkRequest& from);
  GetSinkRequest(GetSinkRequest&& from) noexcept
    : GetSinkRequest() {
    *this = ::std::move(from);
  }

  inline GetSinkRequest& operator=(const GetSinkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSinkRequest& operator=(GetSinkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSinkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSinkRequest* internal_default_instance() {
    return reinterpret_cast<const GetSinkRequest*>(
               &_GetSinkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetSinkRequest& a, GetSinkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSinkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSinkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSinkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSinkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSinkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSinkRequest& from) {
    GetSinkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSinkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.GetSinkRequest";
  }
  protected:
  explicit GetSinkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSinkNameFieldNumber = 1,
  };
  // string sink_name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_sink_name();
  const std::string& sink_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sink_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sink_name();
  PROTOBUF_NODISCARD std::string* release_sink_name();
  void set_allocated_sink_name(std::string* sink_name);
  private:
  const std::string& _internal_sink_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sink_name(const std::string& value);
  std::string* _internal_mutable_sink_name();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.GetSinkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sink_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CreateSinkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.CreateSinkRequest) */ {
 public:
  inline CreateSinkRequest() : CreateSinkRequest(nullptr) {}
  ~CreateSinkRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateSinkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSinkRequest(const CreateSinkRequest& from);
  CreateSinkRequest(CreateSinkRequest&& from) noexcept
    : CreateSinkRequest() {
    *this = ::std::move(from);
  }

  inline CreateSinkRequest& operator=(const CreateSinkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSinkRequest& operator=(CreateSinkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSinkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSinkRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSinkRequest*>(
               &_CreateSinkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CreateSinkRequest& a, CreateSinkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSinkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSinkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSinkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSinkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSinkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateSinkRequest& from) {
    CreateSinkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSinkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.CreateSinkRequest";
  }
  protected:
  explicit CreateSinkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kSinkFieldNumber = 2,
    kUniqueWriterIdentityFieldNumber = 3,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // .google.logging.v2.LogSink sink = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_sink() const;
  private:
  bool _internal_has_sink() const;
  public:
  void clear_sink();
  const ::google::logging::v2::LogSink& sink() const;
  PROTOBUF_NODISCARD ::google::logging::v2::LogSink* release_sink();
  ::google::logging::v2::LogSink* mutable_sink();
  void set_allocated_sink(::google::logging::v2::LogSink* sink);
  private:
  const ::google::logging::v2::LogSink& _internal_sink() const;
  ::google::logging::v2::LogSink* _internal_mutable_sink();
  public:
  void unsafe_arena_set_allocated_sink(
      ::google::logging::v2::LogSink* sink);
  ::google::logging::v2::LogSink* unsafe_arena_release_sink();

  // bool unique_writer_identity = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_unique_writer_identity();
  bool unique_writer_identity() const;
  void set_unique_writer_identity(bool value);
  private:
  bool _internal_unique_writer_identity() const;
  void _internal_set_unique_writer_identity(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.CreateSinkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::google::logging::v2::LogSink* sink_;
    bool unique_writer_identity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class UpdateSinkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.UpdateSinkRequest) */ {
 public:
  inline UpdateSinkRequest() : UpdateSinkRequest(nullptr) {}
  ~UpdateSinkRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateSinkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSinkRequest(const UpdateSinkRequest& from);
  UpdateSinkRequest(UpdateSinkRequest&& from) noexcept
    : UpdateSinkRequest() {
    *this = ::std::move(from);
  }

  inline UpdateSinkRequest& operator=(const UpdateSinkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSinkRequest& operator=(UpdateSinkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSinkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSinkRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateSinkRequest*>(
               &_UpdateSinkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(UpdateSinkRequest& a, UpdateSinkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSinkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSinkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSinkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateSinkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateSinkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateSinkRequest& from) {
    UpdateSinkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSinkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.UpdateSinkRequest";
  }
  protected:
  explicit UpdateSinkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSinkNameFieldNumber = 1,
    kSinkFieldNumber = 2,
    kUpdateMaskFieldNumber = 4,
    kUniqueWriterIdentityFieldNumber = 3,
  };
  // string sink_name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_sink_name();
  const std::string& sink_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sink_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sink_name();
  PROTOBUF_NODISCARD std::string* release_sink_name();
  void set_allocated_sink_name(std::string* sink_name);
  private:
  const std::string& _internal_sink_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sink_name(const std::string& value);
  std::string* _internal_mutable_sink_name();
  public:

  // .google.logging.v2.LogSink sink = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_sink() const;
  private:
  bool _internal_has_sink() const;
  public:
  void clear_sink();
  const ::google::logging::v2::LogSink& sink() const;
  PROTOBUF_NODISCARD ::google::logging::v2::LogSink* release_sink();
  ::google::logging::v2::LogSink* mutable_sink();
  void set_allocated_sink(::google::logging::v2::LogSink* sink);
  private:
  const ::google::logging::v2::LogSink& _internal_sink() const;
  ::google::logging::v2::LogSink* _internal_mutable_sink();
  public:
  void unsafe_arena_set_allocated_sink(
      ::google::logging::v2::LogSink* sink);
  ::google::logging::v2::LogSink* unsafe_arena_release_sink();

  // .google.protobuf.FieldMask update_mask = 4 [(.google.api.field_behavior) = OPTIONAL];
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // bool unique_writer_identity = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_unique_writer_identity();
  bool unique_writer_identity() const;
  void set_unique_writer_identity(bool value);
  private:
  bool _internal_unique_writer_identity() const;
  void _internal_set_unique_writer_identity(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.UpdateSinkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sink_name_;
    ::google::logging::v2::LogSink* sink_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    bool unique_writer_identity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class DeleteSinkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.DeleteSinkRequest) */ {
 public:
  inline DeleteSinkRequest() : DeleteSinkRequest(nullptr) {}
  ~DeleteSinkRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteSinkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSinkRequest(const DeleteSinkRequest& from);
  DeleteSinkRequest(DeleteSinkRequest&& from) noexcept
    : DeleteSinkRequest() {
    *this = ::std::move(from);
  }

  inline DeleteSinkRequest& operator=(const DeleteSinkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSinkRequest& operator=(DeleteSinkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSinkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSinkRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteSinkRequest*>(
               &_DeleteSinkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DeleteSinkRequest& a, DeleteSinkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSinkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSinkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSinkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSinkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteSinkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteSinkRequest& from) {
    DeleteSinkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSinkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.DeleteSinkRequest";
  }
  protected:
  explicit DeleteSinkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSinkNameFieldNumber = 1,
  };
  // string sink_name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_sink_name();
  const std::string& sink_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sink_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sink_name();
  PROTOBUF_NODISCARD std::string* release_sink_name();
  void set_allocated_sink_name(std::string* sink_name);
  private:
  const std::string& _internal_sink_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sink_name(const std::string& value);
  std::string* _internal_mutable_sink_name();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.DeleteSinkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sink_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class LogExclusion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.LogExclusion) */ {
 public:
  inline LogExclusion() : LogExclusion(nullptr) {}
  ~LogExclusion() override;
  explicit PROTOBUF_CONSTEXPR LogExclusion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogExclusion(const LogExclusion& from);
  LogExclusion(LogExclusion&& from) noexcept
    : LogExclusion() {
    *this = ::std::move(from);
  }

  inline LogExclusion& operator=(const LogExclusion& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogExclusion& operator=(LogExclusion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogExclusion& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogExclusion* internal_default_instance() {
    return reinterpret_cast<const LogExclusion*>(
               &_LogExclusion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(LogExclusion& a, LogExclusion& b) {
    a.Swap(&b);
  }
  inline void Swap(LogExclusion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogExclusion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogExclusion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogExclusion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogExclusion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogExclusion& from) {
    LogExclusion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogExclusion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.LogExclusion";
  }
  protected:
  explicit LogExclusion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kFilterFieldNumber = 3,
    kCreateTimeFieldNumber = 5,
    kUpdateTimeFieldNumber = 6,
    kDisabledFieldNumber = 4,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string filter = 3 [(.google.api.field_behavior) = REQUIRED];
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // .google.protobuf.Timestamp create_time = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& create_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_create_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_create_time();
  void set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_create_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_create_time();
  public:
  void unsafe_arena_set_allocated_create_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_create_time();

  // .google.protobuf.Timestamp update_time = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_update_time() const;
  private:
  bool _internal_has_update_time() const;
  public:
  void clear_update_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& update_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_update_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_update_time();
  void set_allocated_update_time(::PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_update_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_update_time();
  public:
  void unsafe_arena_set_allocated_update_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_update_time();

  // bool disabled = 4 [(.google.api.field_behavior) = OPTIONAL];
  void clear_disabled();
  bool disabled() const;
  void set_disabled(bool value);
  private:
  bool _internal_disabled() const;
  void _internal_set_disabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.LogExclusion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time_;
    bool disabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ListExclusionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.ListExclusionsRequest) */ {
 public:
  inline ListExclusionsRequest() : ListExclusionsRequest(nullptr) {}
  ~ListExclusionsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListExclusionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListExclusionsRequest(const ListExclusionsRequest& from);
  ListExclusionsRequest(ListExclusionsRequest&& from) noexcept
    : ListExclusionsRequest() {
    *this = ::std::move(from);
  }

  inline ListExclusionsRequest& operator=(const ListExclusionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListExclusionsRequest& operator=(ListExclusionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListExclusionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListExclusionsRequest* internal_default_instance() {
    return reinterpret_cast<const ListExclusionsRequest*>(
               &_ListExclusionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ListExclusionsRequest& a, ListExclusionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListExclusionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListExclusionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListExclusionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListExclusionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListExclusionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListExclusionsRequest& from) {
    ListExclusionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListExclusionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.ListExclusionsRequest";
  }
  protected:
  explicit ListExclusionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 3,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.ListExclusionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ListExclusionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.ListExclusionsResponse) */ {
 public:
  inline ListExclusionsResponse() : ListExclusionsResponse(nullptr) {}
  ~ListExclusionsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListExclusionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListExclusionsResponse(const ListExclusionsResponse& from);
  ListExclusionsResponse(ListExclusionsResponse&& from) noexcept
    : ListExclusionsResponse() {
    *this = ::std::move(from);
  }

  inline ListExclusionsResponse& operator=(const ListExclusionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListExclusionsResponse& operator=(ListExclusionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListExclusionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListExclusionsResponse* internal_default_instance() {
    return reinterpret_cast<const ListExclusionsResponse*>(
               &_ListExclusionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ListExclusionsResponse& a, ListExclusionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListExclusionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListExclusionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListExclusionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListExclusionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListExclusionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListExclusionsResponse& from) {
    ListExclusionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListExclusionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.ListExclusionsResponse";
  }
  protected:
  explicit ListExclusionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExclusionsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .google.logging.v2.LogExclusion exclusions = 1;
  int exclusions_size() const;
  private:
  int _internal_exclusions_size() const;
  public:
  void clear_exclusions();
  ::google::logging::v2::LogExclusion* mutable_exclusions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogExclusion >*
      mutable_exclusions();
  private:
  const ::google::logging::v2::LogExclusion& _internal_exclusions(int index) const;
  ::google::logging::v2::LogExclusion* _internal_add_exclusions();
  public:
  const ::google::logging::v2::LogExclusion& exclusions(int index) const;
  ::google::logging::v2::LogExclusion* add_exclusions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogExclusion >&
      exclusions() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.ListExclusionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogExclusion > exclusions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class GetExclusionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.GetExclusionRequest) */ {
 public:
  inline GetExclusionRequest() : GetExclusionRequest(nullptr) {}
  ~GetExclusionRequest() override;
  explicit PROTOBUF_CONSTEXPR GetExclusionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetExclusionRequest(const GetExclusionRequest& from);
  GetExclusionRequest(GetExclusionRequest&& from) noexcept
    : GetExclusionRequest() {
    *this = ::std::move(from);
  }

  inline GetExclusionRequest& operator=(const GetExclusionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetExclusionRequest& operator=(GetExclusionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetExclusionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetExclusionRequest* internal_default_instance() {
    return reinterpret_cast<const GetExclusionRequest*>(
               &_GetExclusionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetExclusionRequest& a, GetExclusionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetExclusionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetExclusionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetExclusionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetExclusionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetExclusionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetExclusionRequest& from) {
    GetExclusionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetExclusionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.GetExclusionRequest";
  }
  protected:
  explicit GetExclusionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.GetExclusionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CreateExclusionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.CreateExclusionRequest) */ {
 public:
  inline CreateExclusionRequest() : CreateExclusionRequest(nullptr) {}
  ~CreateExclusionRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateExclusionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateExclusionRequest(const CreateExclusionRequest& from);
  CreateExclusionRequest(CreateExclusionRequest&& from) noexcept
    : CreateExclusionRequest() {
    *this = ::std::move(from);
  }

  inline CreateExclusionRequest& operator=(const CreateExclusionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateExclusionRequest& operator=(CreateExclusionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateExclusionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateExclusionRequest* internal_default_instance() {
    return reinterpret_cast<const CreateExclusionRequest*>(
               &_CreateExclusionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CreateExclusionRequest& a, CreateExclusionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateExclusionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateExclusionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateExclusionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateExclusionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateExclusionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateExclusionRequest& from) {
    CreateExclusionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateExclusionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.CreateExclusionRequest";
  }
  protected:
  explicit CreateExclusionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kExclusionFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // .google.logging.v2.LogExclusion exclusion = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_exclusion() const;
  private:
  bool _internal_has_exclusion() const;
  public:
  void clear_exclusion();
  const ::google::logging::v2::LogExclusion& exclusion() const;
  PROTOBUF_NODISCARD ::google::logging::v2::LogExclusion* release_exclusion();
  ::google::logging::v2::LogExclusion* mutable_exclusion();
  void set_allocated_exclusion(::google::logging::v2::LogExclusion* exclusion);
  private:
  const ::google::logging::v2::LogExclusion& _internal_exclusion() const;
  ::google::logging::v2::LogExclusion* _internal_mutable_exclusion();
  public:
  void unsafe_arena_set_allocated_exclusion(
      ::google::logging::v2::LogExclusion* exclusion);
  ::google::logging::v2::LogExclusion* unsafe_arena_release_exclusion();

  // @@protoc_insertion_point(class_scope:google.logging.v2.CreateExclusionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::google::logging::v2::LogExclusion* exclusion_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class UpdateExclusionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.UpdateExclusionRequest) */ {
 public:
  inline UpdateExclusionRequest() : UpdateExclusionRequest(nullptr) {}
  ~UpdateExclusionRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateExclusionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateExclusionRequest(const UpdateExclusionRequest& from);
  UpdateExclusionRequest(UpdateExclusionRequest&& from) noexcept
    : UpdateExclusionRequest() {
    *this = ::std::move(from);
  }

  inline UpdateExclusionRequest& operator=(const UpdateExclusionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateExclusionRequest& operator=(UpdateExclusionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateExclusionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateExclusionRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateExclusionRequest*>(
               &_UpdateExclusionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(UpdateExclusionRequest& a, UpdateExclusionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateExclusionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateExclusionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateExclusionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateExclusionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateExclusionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateExclusionRequest& from) {
    UpdateExclusionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateExclusionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.UpdateExclusionRequest";
  }
  protected:
  explicit UpdateExclusionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kExclusionFieldNumber = 2,
    kUpdateMaskFieldNumber = 3,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.logging.v2.LogExclusion exclusion = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_exclusion() const;
  private:
  bool _internal_has_exclusion() const;
  public:
  void clear_exclusion();
  const ::google::logging::v2::LogExclusion& exclusion() const;
  PROTOBUF_NODISCARD ::google::logging::v2::LogExclusion* release_exclusion();
  ::google::logging::v2::LogExclusion* mutable_exclusion();
  void set_allocated_exclusion(::google::logging::v2::LogExclusion* exclusion);
  private:
  const ::google::logging::v2::LogExclusion& _internal_exclusion() const;
  ::google::logging::v2::LogExclusion* _internal_mutable_exclusion();
  public:
  void unsafe_arena_set_allocated_exclusion(
      ::google::logging::v2::LogExclusion* exclusion);
  ::google::logging::v2::LogExclusion* unsafe_arena_release_exclusion();

  // .google.protobuf.FieldMask update_mask = 3 [(.google.api.field_behavior) = REQUIRED];
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // @@protoc_insertion_point(class_scope:google.logging.v2.UpdateExclusionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::google::logging::v2::LogExclusion* exclusion_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class DeleteExclusionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.DeleteExclusionRequest) */ {
 public:
  inline DeleteExclusionRequest() : DeleteExclusionRequest(nullptr) {}
  ~DeleteExclusionRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteExclusionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteExclusionRequest(const DeleteExclusionRequest& from);
  DeleteExclusionRequest(DeleteExclusionRequest&& from) noexcept
    : DeleteExclusionRequest() {
    *this = ::std::move(from);
  }

  inline DeleteExclusionRequest& operator=(const DeleteExclusionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteExclusionRequest& operator=(DeleteExclusionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteExclusionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteExclusionRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteExclusionRequest*>(
               &_DeleteExclusionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(DeleteExclusionRequest& a, DeleteExclusionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteExclusionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteExclusionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteExclusionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteExclusionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteExclusionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteExclusionRequest& from) {
    DeleteExclusionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteExclusionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.DeleteExclusionRequest";
  }
  protected:
  explicit DeleteExclusionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.DeleteExclusionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class GetCmekSettingsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.GetCmekSettingsRequest) */ {
 public:
  inline GetCmekSettingsRequest() : GetCmekSettingsRequest(nullptr) {}
  ~GetCmekSettingsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetCmekSettingsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCmekSettingsRequest(const GetCmekSettingsRequest& from);
  GetCmekSettingsRequest(GetCmekSettingsRequest&& from) noexcept
    : GetCmekSettingsRequest() {
    *this = ::std::move(from);
  }

  inline GetCmekSettingsRequest& operator=(const GetCmekSettingsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCmekSettingsRequest& operator=(GetCmekSettingsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCmekSettingsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCmekSettingsRequest* internal_default_instance() {
    return reinterpret_cast<const GetCmekSettingsRequest*>(
               &_GetCmekSettingsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetCmekSettingsRequest& a, GetCmekSettingsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCmekSettingsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCmekSettingsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCmekSettingsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCmekSettingsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCmekSettingsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetCmekSettingsRequest& from) {
    GetCmekSettingsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCmekSettingsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.GetCmekSettingsRequest";
  }
  protected:
  explicit GetCmekSettingsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.GetCmekSettingsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class UpdateCmekSettingsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.UpdateCmekSettingsRequest) */ {
 public:
  inline UpdateCmekSettingsRequest() : UpdateCmekSettingsRequest(nullptr) {}
  ~UpdateCmekSettingsRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateCmekSettingsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateCmekSettingsRequest(const UpdateCmekSettingsRequest& from);
  UpdateCmekSettingsRequest(UpdateCmekSettingsRequest&& from) noexcept
    : UpdateCmekSettingsRequest() {
    *this = ::std::move(from);
  }

  inline UpdateCmekSettingsRequest& operator=(const UpdateCmekSettingsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCmekSettingsRequest& operator=(UpdateCmekSettingsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCmekSettingsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateCmekSettingsRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateCmekSettingsRequest*>(
               &_UpdateCmekSettingsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(UpdateCmekSettingsRequest& a, UpdateCmekSettingsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateCmekSettingsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCmekSettingsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCmekSettingsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateCmekSettingsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateCmekSettingsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateCmekSettingsRequest& from) {
    UpdateCmekSettingsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateCmekSettingsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.UpdateCmekSettingsRequest";
  }
  protected:
  explicit UpdateCmekSettingsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCmekSettingsFieldNumber = 2,
    kUpdateMaskFieldNumber = 3,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.logging.v2.CmekSettings cmek_settings = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_cmek_settings() const;
  private:
  bool _internal_has_cmek_settings() const;
  public:
  void clear_cmek_settings();
  const ::google::logging::v2::CmekSettings& cmek_settings() const;
  PROTOBUF_NODISCARD ::google::logging::v2::CmekSettings* release_cmek_settings();
  ::google::logging::v2::CmekSettings* mutable_cmek_settings();
  void set_allocated_cmek_settings(::google::logging::v2::CmekSettings* cmek_settings);
  private:
  const ::google::logging::v2::CmekSettings& _internal_cmek_settings() const;
  ::google::logging::v2::CmekSettings* _internal_mutable_cmek_settings();
  public:
  void unsafe_arena_set_allocated_cmek_settings(
      ::google::logging::v2::CmekSettings* cmek_settings);
  ::google::logging::v2::CmekSettings* unsafe_arena_release_cmek_settings();

  // .google.protobuf.FieldMask update_mask = 3 [(.google.api.field_behavior) = OPTIONAL];
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // @@protoc_insertion_point(class_scope:google.logging.v2.UpdateCmekSettingsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::google::logging::v2::CmekSettings* cmek_settings_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CmekSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.CmekSettings) */ {
 public:
  inline CmekSettings() : CmekSettings(nullptr) {}
  ~CmekSettings() override;
  explicit PROTOBUF_CONSTEXPR CmekSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CmekSettings(const CmekSettings& from);
  CmekSettings(CmekSettings&& from) noexcept
    : CmekSettings() {
    *this = ::std::move(from);
  }

  inline CmekSettings& operator=(const CmekSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline CmekSettings& operator=(CmekSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CmekSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const CmekSettings* internal_default_instance() {
    return reinterpret_cast<const CmekSettings*>(
               &_CmekSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CmekSettings& a, CmekSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(CmekSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CmekSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CmekSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CmekSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CmekSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CmekSettings& from) {
    CmekSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CmekSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.CmekSettings";
  }
  protected:
  explicit CmekSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kKmsKeyNameFieldNumber = 2,
    kServiceAccountIdFieldNumber = 3,
  };
  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string kms_key_name = 2;
  void clear_kms_key_name();
  const std::string& kms_key_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kms_key_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kms_key_name();
  PROTOBUF_NODISCARD std::string* release_kms_key_name();
  void set_allocated_kms_key_name(std::string* kms_key_name);
  private:
  const std::string& _internal_kms_key_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kms_key_name(const std::string& value);
  std::string* _internal_mutable_kms_key_name();
  public:

  // string service_account_id = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_service_account_id();
  const std::string& service_account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_account_id();
  PROTOBUF_NODISCARD std::string* release_service_account_id();
  void set_allocated_service_account_id(std::string* service_account_id);
  private:
  const std::string& _internal_service_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_account_id(const std::string& value);
  std::string* _internal_mutable_service_account_id();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.CmekSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kms_key_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_account_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class GetSettingsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.GetSettingsRequest) */ {
 public:
  inline GetSettingsRequest() : GetSettingsRequest(nullptr) {}
  ~GetSettingsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetSettingsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSettingsRequest(const GetSettingsRequest& from);
  GetSettingsRequest(GetSettingsRequest&& from) noexcept
    : GetSettingsRequest() {
    *this = ::std::move(from);
  }

  inline GetSettingsRequest& operator=(const GetSettingsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSettingsRequest& operator=(GetSettingsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSettingsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSettingsRequest* internal_default_instance() {
    return reinterpret_cast<const GetSettingsRequest*>(
               &_GetSettingsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetSettingsRequest& a, GetSettingsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSettingsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSettingsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSettingsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSettingsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSettingsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSettingsRequest& from) {
    GetSettingsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSettingsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.GetSettingsRequest";
  }
  protected:
  explicit GetSettingsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.GetSettingsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class UpdateSettingsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.UpdateSettingsRequest) */ {
 public:
  inline UpdateSettingsRequest() : UpdateSettingsRequest(nullptr) {}
  ~UpdateSettingsRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateSettingsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSettingsRequest(const UpdateSettingsRequest& from);
  UpdateSettingsRequest(UpdateSettingsRequest&& from) noexcept
    : UpdateSettingsRequest() {
    *this = ::std::move(from);
  }

  inline UpdateSettingsRequest& operator=(const UpdateSettingsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSettingsRequest& operator=(UpdateSettingsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSettingsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSettingsRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateSettingsRequest*>(
               &_UpdateSettingsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(UpdateSettingsRequest& a, UpdateSettingsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSettingsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSettingsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSettingsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateSettingsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateSettingsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateSettingsRequest& from) {
    UpdateSettingsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSettingsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.UpdateSettingsRequest";
  }
  protected:
  explicit UpdateSettingsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSettingsFieldNumber = 2,
    kUpdateMaskFieldNumber = 3,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.logging.v2.Settings settings = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::google::logging::v2::Settings& settings() const;
  PROTOBUF_NODISCARD ::google::logging::v2::Settings* release_settings();
  ::google::logging::v2::Settings* mutable_settings();
  void set_allocated_settings(::google::logging::v2::Settings* settings);
  private:
  const ::google::logging::v2::Settings& _internal_settings() const;
  ::google::logging::v2::Settings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::google::logging::v2::Settings* settings);
  ::google::logging::v2::Settings* unsafe_arena_release_settings();

  // .google.protobuf.FieldMask update_mask = 3 [(.google.api.field_behavior) = OPTIONAL];
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // @@protoc_insertion_point(class_scope:google.logging.v2.UpdateSettingsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::google::logging::v2::Settings* settings_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class Settings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.Settings) */ {
 public:
  inline Settings() : Settings(nullptr) {}
  ~Settings() override;
  explicit PROTOBUF_CONSTEXPR Settings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Settings(const Settings& from);
  Settings(Settings&& from) noexcept
    : Settings() {
    *this = ::std::move(from);
  }

  inline Settings& operator=(const Settings& from) {
    CopyFrom(from);
    return *this;
  }
  inline Settings& operator=(Settings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Settings& default_instance() {
    return *internal_default_instance();
  }
  static inline const Settings* internal_default_instance() {
    return reinterpret_cast<const Settings*>(
               &_Settings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Settings& a, Settings& b) {
    a.Swap(&b);
  }
  inline void Swap(Settings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Settings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Settings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Settings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Settings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Settings& from) {
    Settings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Settings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.Settings";
  }
  protected:
  explicit Settings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kKmsKeyNameFieldNumber = 2,
    kKmsServiceAccountIdFieldNumber = 3,
    kStorageLocationFieldNumber = 4,
    kDisableDefaultSinkFieldNumber = 5,
  };
  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string kms_key_name = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_kms_key_name();
  const std::string& kms_key_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kms_key_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kms_key_name();
  PROTOBUF_NODISCARD std::string* release_kms_key_name();
  void set_allocated_kms_key_name(std::string* kms_key_name);
  private:
  const std::string& _internal_kms_key_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kms_key_name(const std::string& value);
  std::string* _internal_mutable_kms_key_name();
  public:

  // string kms_service_account_id = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_kms_service_account_id();
  const std::string& kms_service_account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kms_service_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kms_service_account_id();
  PROTOBUF_NODISCARD std::string* release_kms_service_account_id();
  void set_allocated_kms_service_account_id(std::string* kms_service_account_id);
  private:
  const std::string& _internal_kms_service_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kms_service_account_id(const std::string& value);
  std::string* _internal_mutable_kms_service_account_id();
  public:

  // string storage_location = 4 [(.google.api.field_behavior) = OPTIONAL];
  void clear_storage_location();
  const std::string& storage_location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_storage_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_storage_location();
  PROTOBUF_NODISCARD std::string* release_storage_location();
  void set_allocated_storage_location(std::string* storage_location);
  private:
  const std::string& _internal_storage_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_storage_location(const std::string& value);
  std::string* _internal_mutable_storage_location();
  public:

  // bool disable_default_sink = 5 [(.google.api.field_behavior) = OPTIONAL];
  void clear_disable_default_sink();
  bool disable_default_sink() const;
  void set_disable_default_sink(bool value);
  private:
  bool _internal_disable_default_sink() const;
  void _internal_set_disable_default_sink(bool value);
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.Settings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kms_key_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kms_service_account_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr storage_location_;
    bool disable_default_sink_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CopyLogEntriesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.CopyLogEntriesRequest) */ {
 public:
  inline CopyLogEntriesRequest() : CopyLogEntriesRequest(nullptr) {}
  ~CopyLogEntriesRequest() override;
  explicit PROTOBUF_CONSTEXPR CopyLogEntriesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CopyLogEntriesRequest(const CopyLogEntriesRequest& from);
  CopyLogEntriesRequest(CopyLogEntriesRequest&& from) noexcept
    : CopyLogEntriesRequest() {
    *this = ::std::move(from);
  }

  inline CopyLogEntriesRequest& operator=(const CopyLogEntriesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CopyLogEntriesRequest& operator=(CopyLogEntriesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CopyLogEntriesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CopyLogEntriesRequest* internal_default_instance() {
    return reinterpret_cast<const CopyLogEntriesRequest*>(
               &_CopyLogEntriesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CopyLogEntriesRequest& a, CopyLogEntriesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CopyLogEntriesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CopyLogEntriesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CopyLogEntriesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CopyLogEntriesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CopyLogEntriesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CopyLogEntriesRequest& from) {
    CopyLogEntriesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CopyLogEntriesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.CopyLogEntriesRequest";
  }
  protected:
  explicit CopyLogEntriesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFilterFieldNumber = 3,
    kDestinationFieldNumber = 4,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string filter = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // string destination = 4 [(.google.api.field_behavior) = REQUIRED];
  void clear_destination();
  const std::string& destination() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* destination);
  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(const std::string& value);
  std::string* _internal_mutable_destination();
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.CopyLogEntriesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CopyLogEntriesMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.CopyLogEntriesMetadata) */ {
 public:
  inline CopyLogEntriesMetadata() : CopyLogEntriesMetadata(nullptr) {}
  ~CopyLogEntriesMetadata() override;
  explicit PROTOBUF_CONSTEXPR CopyLogEntriesMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CopyLogEntriesMetadata(const CopyLogEntriesMetadata& from);
  CopyLogEntriesMetadata(CopyLogEntriesMetadata&& from) noexcept
    : CopyLogEntriesMetadata() {
    *this = ::std::move(from);
  }

  inline CopyLogEntriesMetadata& operator=(const CopyLogEntriesMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline CopyLogEntriesMetadata& operator=(CopyLogEntriesMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CopyLogEntriesMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const CopyLogEntriesMetadata* internal_default_instance() {
    return reinterpret_cast<const CopyLogEntriesMetadata*>(
               &_CopyLogEntriesMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(CopyLogEntriesMetadata& a, CopyLogEntriesMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(CopyLogEntriesMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CopyLogEntriesMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CopyLogEntriesMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CopyLogEntriesMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CopyLogEntriesMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CopyLogEntriesMetadata& from) {
    CopyLogEntriesMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CopyLogEntriesMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.CopyLogEntriesMetadata";
  }
  protected:
  explicit CopyLogEntriesMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWriterIdentityFieldNumber = 7,
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
    kRequestFieldNumber = 5,
    kStateFieldNumber = 3,
    kCancellationRequestedFieldNumber = 4,
    kProgressFieldNumber = 6,
  };
  // string writer_identity = 7;
  void clear_writer_identity();
  const std::string& writer_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_writer_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_writer_identity();
  PROTOBUF_NODISCARD std::string* release_writer_identity();
  void set_allocated_writer_identity(std::string* writer_identity);
  private:
  const std::string& _internal_writer_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_writer_identity(const std::string& value);
  std::string* _internal_mutable_writer_identity();
  public:

  // .google.protobuf.Timestamp start_time = 1;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 2;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // .google.logging.v2.CopyLogEntriesRequest request = 5;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::google::logging::v2::CopyLogEntriesRequest& request() const;
  PROTOBUF_NODISCARD ::google::logging::v2::CopyLogEntriesRequest* release_request();
  ::google::logging::v2::CopyLogEntriesRequest* mutable_request();
  void set_allocated_request(::google::logging::v2::CopyLogEntriesRequest* request);
  private:
  const ::google::logging::v2::CopyLogEntriesRequest& _internal_request() const;
  ::google::logging::v2::CopyLogEntriesRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::google::logging::v2::CopyLogEntriesRequest* request);
  ::google::logging::v2::CopyLogEntriesRequest* unsafe_arena_release_request();

  // .google.logging.v2.OperationState state = 3;
  void clear_state();
  ::google::logging::v2::OperationState state() const;
  void set_state(::google::logging::v2::OperationState value);
  private:
  ::google::logging::v2::OperationState _internal_state() const;
  void _internal_set_state(::google::logging::v2::OperationState value);
  public:

  // bool cancellation_requested = 4;
  void clear_cancellation_requested();
  bool cancellation_requested() const;
  void set_cancellation_requested(bool value);
  private:
  bool _internal_cancellation_requested() const;
  void _internal_set_cancellation_requested(bool value);
  public:

  // int32 progress = 6;
  void clear_progress();
  int32_t progress() const;
  void set_progress(int32_t value);
  private:
  int32_t _internal_progress() const;
  void _internal_set_progress(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.CopyLogEntriesMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr writer_identity_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    ::google::logging::v2::CopyLogEntriesRequest* request_;
    int state_;
    bool cancellation_requested_;
    int32_t progress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CopyLogEntriesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:google.logging.v2.CopyLogEntriesResponse) */ {
 public:
  inline CopyLogEntriesResponse() : CopyLogEntriesResponse(nullptr) {}
  ~CopyLogEntriesResponse() override;
  explicit PROTOBUF_CONSTEXPR CopyLogEntriesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CopyLogEntriesResponse(const CopyLogEntriesResponse& from);
  CopyLogEntriesResponse(CopyLogEntriesResponse&& from) noexcept
    : CopyLogEntriesResponse() {
    *this = ::std::move(from);
  }

  inline CopyLogEntriesResponse& operator=(const CopyLogEntriesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CopyLogEntriesResponse& operator=(CopyLogEntriesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CopyLogEntriesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CopyLogEntriesResponse* internal_default_instance() {
    return reinterpret_cast<const CopyLogEntriesResponse*>(
               &_CopyLogEntriesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(CopyLogEntriesResponse& a, CopyLogEntriesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CopyLogEntriesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CopyLogEntriesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CopyLogEntriesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CopyLogEntriesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CopyLogEntriesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CopyLogEntriesResponse& from) {
    CopyLogEntriesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CopyLogEntriesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "google.logging.v2.CopyLogEntriesResponse";
  }
  protected:
  explicit CopyLogEntriesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogEntriesCopiedCountFieldNumber = 1,
  };
  // int64 log_entries_copied_count = 1;
  void clear_log_entries_copied_count();
  int64_t log_entries_copied_count() const;
  void set_log_entries_copied_count(int64_t value);
  private:
  int64_t _internal_log_entries_copied_count() const;
  void _internal_set_log_entries_copied_count(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:google.logging.v2.CopyLogEntriesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t log_entries_copied_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_google_2flogging_2fv2_2flogging_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LogBucket

// string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void LogBucket::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LogBucket::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogBucket.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogBucket::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.LogBucket.name)
}
inline std::string* LogBucket::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogBucket.name)
  return _s;
}
inline const std::string& LogBucket::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LogBucket::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LogBucket::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LogBucket::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogBucket.name)
  return _impl_.name_.Release();
}
inline void LogBucket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogBucket.name)
}

// string description = 3;
inline void LogBucket::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& LogBucket::description() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogBucket.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogBucket::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.LogBucket.description)
}
inline std::string* LogBucket::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogBucket.description)
  return _s;
}
inline const std::string& LogBucket::_internal_description() const {
  return _impl_.description_.Get();
}
inline void LogBucket::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* LogBucket::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* LogBucket::release_description() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogBucket.description)
  return _impl_.description_.Release();
}
inline void LogBucket::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogBucket.description)
}

// .google.protobuf.Timestamp create_time = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool LogBucket::_internal_has_create_time() const {
  return this != internal_default_instance() && _impl_.create_time_ != nullptr;
}
inline bool LogBucket::has_create_time() const {
  return _internal_has_create_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogBucket::_internal_create_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.create_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogBucket::create_time() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogBucket.create_time)
  return _internal_create_time();
}
inline void LogBucket::unsafe_arena_set_allocated_create_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  _impl_.create_time_ = create_time;
  if (create_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.LogBucket.create_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogBucket::release_create_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogBucket::unsafe_arena_release_create_time() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogBucket.create_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogBucket::_internal_mutable_create_time() {
  
  if (_impl_.create_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.create_time_ = p;
  }
  return _impl_.create_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogBucket::mutable_create_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogBucket.create_time)
  return _msg;
}
inline void LogBucket::set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  if (create_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time));
    if (message_arena != submessage_arena) {
      create_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogBucket.create_time)
}

// .google.protobuf.Timestamp update_time = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool LogBucket::_internal_has_update_time() const {
  return this != internal_default_instance() && _impl_.update_time_ != nullptr;
}
inline bool LogBucket::has_update_time() const {
  return _internal_has_update_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogBucket::_internal_update_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.update_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogBucket::update_time() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogBucket.update_time)
  return _internal_update_time();
}
inline void LogBucket::unsafe_arena_set_allocated_update_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_time_);
  }
  _impl_.update_time_ = update_time;
  if (update_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.LogBucket.update_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogBucket::release_update_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.update_time_;
  _impl_.update_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogBucket::unsafe_arena_release_update_time() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogBucket.update_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.update_time_;
  _impl_.update_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogBucket::_internal_mutable_update_time() {
  
  if (_impl_.update_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.update_time_ = p;
  }
  return _impl_.update_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogBucket::mutable_update_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_update_time();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogBucket.update_time)
  return _msg;
}
inline void LogBucket::set_allocated_update_time(::PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_time_);
  }
  if (update_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_time));
    if (message_arena != submessage_arena) {
      update_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_time_ = update_time;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogBucket.update_time)
}

// int32 retention_days = 11;
inline void LogBucket::clear_retention_days() {
  _impl_.retention_days_ = 0;
}
inline int32_t LogBucket::_internal_retention_days() const {
  return _impl_.retention_days_;
}
inline int32_t LogBucket::retention_days() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogBucket.retention_days)
  return _internal_retention_days();
}
inline void LogBucket::_internal_set_retention_days(int32_t value) {
  
  _impl_.retention_days_ = value;
}
inline void LogBucket::set_retention_days(int32_t value) {
  _internal_set_retention_days(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.LogBucket.retention_days)
}

// bool locked = 9;
inline void LogBucket::clear_locked() {
  _impl_.locked_ = false;
}
inline bool LogBucket::_internal_locked() const {
  return _impl_.locked_;
}
inline bool LogBucket::locked() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogBucket.locked)
  return _internal_locked();
}
inline void LogBucket::_internal_set_locked(bool value) {
  
  _impl_.locked_ = value;
}
inline void LogBucket::set_locked(bool value) {
  _internal_set_locked(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.LogBucket.locked)
}

// .google.logging.v2.LifecycleState lifecycle_state = 12 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void LogBucket::clear_lifecycle_state() {
  _impl_.lifecycle_state_ = 0;
}
inline ::google::logging::v2::LifecycleState LogBucket::_internal_lifecycle_state() const {
  return static_cast< ::google::logging::v2::LifecycleState >(_impl_.lifecycle_state_);
}
inline ::google::logging::v2::LifecycleState LogBucket::lifecycle_state() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogBucket.lifecycle_state)
  return _internal_lifecycle_state();
}
inline void LogBucket::_internal_set_lifecycle_state(::google::logging::v2::LifecycleState value) {
  
  _impl_.lifecycle_state_ = value;
}
inline void LogBucket::set_lifecycle_state(::google::logging::v2::LifecycleState value) {
  _internal_set_lifecycle_state(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.LogBucket.lifecycle_state)
}

// repeated string restricted_fields = 15;
inline int LogBucket::_internal_restricted_fields_size() const {
  return _impl_.restricted_fields_.size();
}
inline int LogBucket::restricted_fields_size() const {
  return _internal_restricted_fields_size();
}
inline void LogBucket::clear_restricted_fields() {
  _impl_.restricted_fields_.Clear();
}
inline std::string* LogBucket::add_restricted_fields() {
  std::string* _s = _internal_add_restricted_fields();
  // @@protoc_insertion_point(field_add_mutable:google.logging.v2.LogBucket.restricted_fields)
  return _s;
}
inline const std::string& LogBucket::_internal_restricted_fields(int index) const {
  return _impl_.restricted_fields_.Get(index);
}
inline const std::string& LogBucket::restricted_fields(int index) const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogBucket.restricted_fields)
  return _internal_restricted_fields(index);
}
inline std::string* LogBucket::mutable_restricted_fields(int index) {
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogBucket.restricted_fields)
  return _impl_.restricted_fields_.Mutable(index);
}
inline void LogBucket::set_restricted_fields(int index, const std::string& value) {
  _impl_.restricted_fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.LogBucket.restricted_fields)
}
inline void LogBucket::set_restricted_fields(int index, std::string&& value) {
  _impl_.restricted_fields_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:google.logging.v2.LogBucket.restricted_fields)
}
inline void LogBucket::set_restricted_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.restricted_fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.logging.v2.LogBucket.restricted_fields)
}
inline void LogBucket::set_restricted_fields(int index, const char* value, size_t size) {
  _impl_.restricted_fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.logging.v2.LogBucket.restricted_fields)
}
inline std::string* LogBucket::_internal_add_restricted_fields() {
  return _impl_.restricted_fields_.Add();
}
inline void LogBucket::add_restricted_fields(const std::string& value) {
  _impl_.restricted_fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.logging.v2.LogBucket.restricted_fields)
}
inline void LogBucket::add_restricted_fields(std::string&& value) {
  _impl_.restricted_fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.logging.v2.LogBucket.restricted_fields)
}
inline void LogBucket::add_restricted_fields(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.restricted_fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.logging.v2.LogBucket.restricted_fields)
}
inline void LogBucket::add_restricted_fields(const char* value, size_t size) {
  _impl_.restricted_fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.logging.v2.LogBucket.restricted_fields)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LogBucket::restricted_fields() const {
  // @@protoc_insertion_point(field_list:google.logging.v2.LogBucket.restricted_fields)
  return _impl_.restricted_fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LogBucket::mutable_restricted_fields() {
  // @@protoc_insertion_point(field_mutable_list:google.logging.v2.LogBucket.restricted_fields)
  return &_impl_.restricted_fields_;
}

// .google.logging.v2.CmekSettings cmek_settings = 19;
inline bool LogBucket::_internal_has_cmek_settings() const {
  return this != internal_default_instance() && _impl_.cmek_settings_ != nullptr;
}
inline bool LogBucket::has_cmek_settings() const {
  return _internal_has_cmek_settings();
}
inline void LogBucket::clear_cmek_settings() {
  if (GetArenaForAllocation() == nullptr && _impl_.cmek_settings_ != nullptr) {
    delete _impl_.cmek_settings_;
  }
  _impl_.cmek_settings_ = nullptr;
}
inline const ::google::logging::v2::CmekSettings& LogBucket::_internal_cmek_settings() const {
  const ::google::logging::v2::CmekSettings* p = _impl_.cmek_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::logging::v2::CmekSettings&>(
      ::google::logging::v2::_CmekSettings_default_instance_);
}
inline const ::google::logging::v2::CmekSettings& LogBucket::cmek_settings() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogBucket.cmek_settings)
  return _internal_cmek_settings();
}
inline void LogBucket::unsafe_arena_set_allocated_cmek_settings(
    ::google::logging::v2::CmekSettings* cmek_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cmek_settings_);
  }
  _impl_.cmek_settings_ = cmek_settings;
  if (cmek_settings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.LogBucket.cmek_settings)
}
inline ::google::logging::v2::CmekSettings* LogBucket::release_cmek_settings() {
  
  ::google::logging::v2::CmekSettings* temp = _impl_.cmek_settings_;
  _impl_.cmek_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::logging::v2::CmekSettings* LogBucket::unsafe_arena_release_cmek_settings() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogBucket.cmek_settings)
  
  ::google::logging::v2::CmekSettings* temp = _impl_.cmek_settings_;
  _impl_.cmek_settings_ = nullptr;
  return temp;
}
inline ::google::logging::v2::CmekSettings* LogBucket::_internal_mutable_cmek_settings() {
  
  if (_impl_.cmek_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::logging::v2::CmekSettings>(GetArenaForAllocation());
    _impl_.cmek_settings_ = p;
  }
  return _impl_.cmek_settings_;
}
inline ::google::logging::v2::CmekSettings* LogBucket::mutable_cmek_settings() {
  ::google::logging::v2::CmekSettings* _msg = _internal_mutable_cmek_settings();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogBucket.cmek_settings)
  return _msg;
}
inline void LogBucket::set_allocated_cmek_settings(::google::logging::v2::CmekSettings* cmek_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cmek_settings_;
  }
  if (cmek_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cmek_settings);
    if (message_arena != submessage_arena) {
      cmek_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cmek_settings, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cmek_settings_ = cmek_settings;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogBucket.cmek_settings)
}

// -------------------------------------------------------------------

// LogView

// string name = 1;
inline void LogView::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LogView::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogView.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogView::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.LogView.name)
}
inline std::string* LogView::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogView.name)
  return _s;
}
inline const std::string& LogView::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LogView::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LogView::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LogView::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogView.name)
  return _impl_.name_.Release();
}
inline void LogView::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogView.name)
}

// string description = 3;
inline void LogView::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& LogView::description() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogView.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogView::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.LogView.description)
}
inline std::string* LogView::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogView.description)
  return _s;
}
inline const std::string& LogView::_internal_description() const {
  return _impl_.description_.Get();
}
inline void LogView::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* LogView::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* LogView::release_description() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogView.description)
  return _impl_.description_.Release();
}
inline void LogView::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogView.description)
}

// .google.protobuf.Timestamp create_time = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool LogView::_internal_has_create_time() const {
  return this != internal_default_instance() && _impl_.create_time_ != nullptr;
}
inline bool LogView::has_create_time() const {
  return _internal_has_create_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogView::_internal_create_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.create_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogView::create_time() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogView.create_time)
  return _internal_create_time();
}
inline void LogView::unsafe_arena_set_allocated_create_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  _impl_.create_time_ = create_time;
  if (create_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.LogView.create_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogView::release_create_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogView::unsafe_arena_release_create_time() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogView.create_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogView::_internal_mutable_create_time() {
  
  if (_impl_.create_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.create_time_ = p;
  }
  return _impl_.create_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogView::mutable_create_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogView.create_time)
  return _msg;
}
inline void LogView::set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  if (create_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time));
    if (message_arena != submessage_arena) {
      create_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogView.create_time)
}

// .google.protobuf.Timestamp update_time = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool LogView::_internal_has_update_time() const {
  return this != internal_default_instance() && _impl_.update_time_ != nullptr;
}
inline bool LogView::has_update_time() const {
  return _internal_has_update_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogView::_internal_update_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.update_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogView::update_time() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogView.update_time)
  return _internal_update_time();
}
inline void LogView::unsafe_arena_set_allocated_update_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_time_);
  }
  _impl_.update_time_ = update_time;
  if (update_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.LogView.update_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogView::release_update_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.update_time_;
  _impl_.update_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogView::unsafe_arena_release_update_time() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogView.update_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.update_time_;
  _impl_.update_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogView::_internal_mutable_update_time() {
  
  if (_impl_.update_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.update_time_ = p;
  }
  return _impl_.update_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogView::mutable_update_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_update_time();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogView.update_time)
  return _msg;
}
inline void LogView::set_allocated_update_time(::PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_time_);
  }
  if (update_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_time));
    if (message_arena != submessage_arena) {
      update_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_time_ = update_time;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogView.update_time)
}

// string filter = 7;
inline void LogView::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& LogView::filter() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogView.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogView::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.LogView.filter)
}
inline std::string* LogView::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogView.filter)
  return _s;
}
inline const std::string& LogView::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void LogView::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* LogView::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* LogView::release_filter() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogView.filter)
  return _impl_.filter_.Release();
}
inline void LogView::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogView.filter)
}

// -------------------------------------------------------------------

// LogSink

// string name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void LogSink::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LogSink::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogSink.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogSink::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.LogSink.name)
}
inline std::string* LogSink::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogSink.name)
  return _s;
}
inline const std::string& LogSink::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LogSink::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LogSink::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LogSink::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogSink.name)
  return _impl_.name_.Release();
}
inline void LogSink::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogSink.name)
}

// string destination = 3 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void LogSink::clear_destination() {
  _impl_.destination_.ClearToEmpty();
}
inline const std::string& LogSink::destination() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogSink.destination)
  return _internal_destination();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogSink::set_destination(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destination_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.LogSink.destination)
}
inline std::string* LogSink::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogSink.destination)
  return _s;
}
inline const std::string& LogSink::_internal_destination() const {
  return _impl_.destination_.Get();
}
inline void LogSink::_internal_set_destination(const std::string& value) {
  
  _impl_.destination_.Set(value, GetArenaForAllocation());
}
inline std::string* LogSink::_internal_mutable_destination() {
  
  return _impl_.destination_.Mutable(GetArenaForAllocation());
}
inline std::string* LogSink::release_destination() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogSink.destination)
  return _impl_.destination_.Release();
}
inline void LogSink::set_allocated_destination(std::string* destination) {
  if (destination != nullptr) {
    
  } else {
    
  }
  _impl_.destination_.SetAllocated(destination, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destination_.IsDefault()) {
    _impl_.destination_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogSink.destination)
}

// string filter = 5 [(.google.api.field_behavior) = OPTIONAL];
inline void LogSink::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& LogSink::filter() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogSink.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogSink::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.LogSink.filter)
}
inline std::string* LogSink::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogSink.filter)
  return _s;
}
inline const std::string& LogSink::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void LogSink::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* LogSink::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* LogSink::release_filter() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogSink.filter)
  return _impl_.filter_.Release();
}
inline void LogSink::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogSink.filter)
}

// string description = 18 [(.google.api.field_behavior) = OPTIONAL];
inline void LogSink::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& LogSink::description() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogSink.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogSink::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.LogSink.description)
}
inline std::string* LogSink::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogSink.description)
  return _s;
}
inline const std::string& LogSink::_internal_description() const {
  return _impl_.description_.Get();
}
inline void LogSink::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* LogSink::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* LogSink::release_description() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogSink.description)
  return _impl_.description_.Release();
}
inline void LogSink::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogSink.description)
}

// bool disabled = 19 [(.google.api.field_behavior) = OPTIONAL];
inline void LogSink::clear_disabled() {
  _impl_.disabled_ = false;
}
inline bool LogSink::_internal_disabled() const {
  return _impl_.disabled_;
}
inline bool LogSink::disabled() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogSink.disabled)
  return _internal_disabled();
}
inline void LogSink::_internal_set_disabled(bool value) {
  
  _impl_.disabled_ = value;
}
inline void LogSink::set_disabled(bool value) {
  _internal_set_disabled(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.LogSink.disabled)
}

// repeated .google.logging.v2.LogExclusion exclusions = 16 [(.google.api.field_behavior) = OPTIONAL];
inline int LogSink::_internal_exclusions_size() const {
  return _impl_.exclusions_.size();
}
inline int LogSink::exclusions_size() const {
  return _internal_exclusions_size();
}
inline void LogSink::clear_exclusions() {
  _impl_.exclusions_.Clear();
}
inline ::google::logging::v2::LogExclusion* LogSink::mutable_exclusions(int index) {
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogSink.exclusions)
  return _impl_.exclusions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogExclusion >*
LogSink::mutable_exclusions() {
  // @@protoc_insertion_point(field_mutable_list:google.logging.v2.LogSink.exclusions)
  return &_impl_.exclusions_;
}
inline const ::google::logging::v2::LogExclusion& LogSink::_internal_exclusions(int index) const {
  return _impl_.exclusions_.Get(index);
}
inline const ::google::logging::v2::LogExclusion& LogSink::exclusions(int index) const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogSink.exclusions)
  return _internal_exclusions(index);
}
inline ::google::logging::v2::LogExclusion* LogSink::_internal_add_exclusions() {
  return _impl_.exclusions_.Add();
}
inline ::google::logging::v2::LogExclusion* LogSink::add_exclusions() {
  ::google::logging::v2::LogExclusion* _add = _internal_add_exclusions();
  // @@protoc_insertion_point(field_add:google.logging.v2.LogSink.exclusions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogExclusion >&
LogSink::exclusions() const {
  // @@protoc_insertion_point(field_list:google.logging.v2.LogSink.exclusions)
  return _impl_.exclusions_;
}

// .google.logging.v2.LogSink.VersionFormat output_version_format = 6 [deprecated = true];
inline void LogSink::clear_output_version_format() {
  _impl_.output_version_format_ = 0;
}
inline ::google::logging::v2::LogSink_VersionFormat LogSink::_internal_output_version_format() const {
  return static_cast< ::google::logging::v2::LogSink_VersionFormat >(_impl_.output_version_format_);
}
inline ::google::logging::v2::LogSink_VersionFormat LogSink::output_version_format() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogSink.output_version_format)
  return _internal_output_version_format();
}
inline void LogSink::_internal_set_output_version_format(::google::logging::v2::LogSink_VersionFormat value) {
  
  _impl_.output_version_format_ = value;
}
inline void LogSink::set_output_version_format(::google::logging::v2::LogSink_VersionFormat value) {
  _internal_set_output_version_format(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.LogSink.output_version_format)
}

// string writer_identity = 8 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void LogSink::clear_writer_identity() {
  _impl_.writer_identity_.ClearToEmpty();
}
inline const std::string& LogSink::writer_identity() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogSink.writer_identity)
  return _internal_writer_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogSink::set_writer_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.writer_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.LogSink.writer_identity)
}
inline std::string* LogSink::mutable_writer_identity() {
  std::string* _s = _internal_mutable_writer_identity();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogSink.writer_identity)
  return _s;
}
inline const std::string& LogSink::_internal_writer_identity() const {
  return _impl_.writer_identity_.Get();
}
inline void LogSink::_internal_set_writer_identity(const std::string& value) {
  
  _impl_.writer_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* LogSink::_internal_mutable_writer_identity() {
  
  return _impl_.writer_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* LogSink::release_writer_identity() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogSink.writer_identity)
  return _impl_.writer_identity_.Release();
}
inline void LogSink::set_allocated_writer_identity(std::string* writer_identity) {
  if (writer_identity != nullptr) {
    
  } else {
    
  }
  _impl_.writer_identity_.SetAllocated(writer_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.writer_identity_.IsDefault()) {
    _impl_.writer_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogSink.writer_identity)
}

// bool include_children = 9 [(.google.api.field_behavior) = OPTIONAL];
inline void LogSink::clear_include_children() {
  _impl_.include_children_ = false;
}
inline bool LogSink::_internal_include_children() const {
  return _impl_.include_children_;
}
inline bool LogSink::include_children() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogSink.include_children)
  return _internal_include_children();
}
inline void LogSink::_internal_set_include_children(bool value) {
  
  _impl_.include_children_ = value;
}
inline void LogSink::set_include_children(bool value) {
  _internal_set_include_children(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.LogSink.include_children)
}

// .google.logging.v2.BigQueryOptions bigquery_options = 12 [(.google.api.field_behavior) = OPTIONAL];
inline bool LogSink::_internal_has_bigquery_options() const {
  return options_case() == kBigqueryOptions;
}
inline bool LogSink::has_bigquery_options() const {
  return _internal_has_bigquery_options();
}
inline void LogSink::set_has_bigquery_options() {
  _impl_._oneof_case_[0] = kBigqueryOptions;
}
inline void LogSink::clear_bigquery_options() {
  if (_internal_has_bigquery_options()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.options_.bigquery_options_;
    }
    clear_has_options();
  }
}
inline ::google::logging::v2::BigQueryOptions* LogSink::release_bigquery_options() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogSink.bigquery_options)
  if (_internal_has_bigquery_options()) {
    clear_has_options();
    ::google::logging::v2::BigQueryOptions* temp = _impl_.options_.bigquery_options_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.bigquery_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::logging::v2::BigQueryOptions& LogSink::_internal_bigquery_options() const {
  return _internal_has_bigquery_options()
      ? *_impl_.options_.bigquery_options_
      : reinterpret_cast< ::google::logging::v2::BigQueryOptions&>(::google::logging::v2::_BigQueryOptions_default_instance_);
}
inline const ::google::logging::v2::BigQueryOptions& LogSink::bigquery_options() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogSink.bigquery_options)
  return _internal_bigquery_options();
}
inline ::google::logging::v2::BigQueryOptions* LogSink::unsafe_arena_release_bigquery_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.logging.v2.LogSink.bigquery_options)
  if (_internal_has_bigquery_options()) {
    clear_has_options();
    ::google::logging::v2::BigQueryOptions* temp = _impl_.options_.bigquery_options_;
    _impl_.options_.bigquery_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LogSink::unsafe_arena_set_allocated_bigquery_options(::google::logging::v2::BigQueryOptions* bigquery_options) {
  clear_options();
  if (bigquery_options) {
    set_has_bigquery_options();
    _impl_.options_.bigquery_options_ = bigquery_options;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.LogSink.bigquery_options)
}
inline ::google::logging::v2::BigQueryOptions* LogSink::_internal_mutable_bigquery_options() {
  if (!_internal_has_bigquery_options()) {
    clear_options();
    set_has_bigquery_options();
    _impl_.options_.bigquery_options_ = CreateMaybeMessage< ::google::logging::v2::BigQueryOptions >(GetArenaForAllocation());
  }
  return _impl_.options_.bigquery_options_;
}
inline ::google::logging::v2::BigQueryOptions* LogSink::mutable_bigquery_options() {
  ::google::logging::v2::BigQueryOptions* _msg = _internal_mutable_bigquery_options();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogSink.bigquery_options)
  return _msg;
}

// .google.protobuf.Timestamp create_time = 13 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool LogSink::_internal_has_create_time() const {
  return this != internal_default_instance() && _impl_.create_time_ != nullptr;
}
inline bool LogSink::has_create_time() const {
  return _internal_has_create_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogSink::_internal_create_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.create_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogSink::create_time() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogSink.create_time)
  return _internal_create_time();
}
inline void LogSink::unsafe_arena_set_allocated_create_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  _impl_.create_time_ = create_time;
  if (create_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.LogSink.create_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogSink::release_create_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogSink::unsafe_arena_release_create_time() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogSink.create_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogSink::_internal_mutable_create_time() {
  
  if (_impl_.create_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.create_time_ = p;
  }
  return _impl_.create_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogSink::mutable_create_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogSink.create_time)
  return _msg;
}
inline void LogSink::set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  if (create_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time));
    if (message_arena != submessage_arena) {
      create_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogSink.create_time)
}

// .google.protobuf.Timestamp update_time = 14 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool LogSink::_internal_has_update_time() const {
  return this != internal_default_instance() && _impl_.update_time_ != nullptr;
}
inline bool LogSink::has_update_time() const {
  return _internal_has_update_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogSink::_internal_update_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.update_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogSink::update_time() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogSink.update_time)
  return _internal_update_time();
}
inline void LogSink::unsafe_arena_set_allocated_update_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_time_);
  }
  _impl_.update_time_ = update_time;
  if (update_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.LogSink.update_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogSink::release_update_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.update_time_;
  _impl_.update_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogSink::unsafe_arena_release_update_time() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogSink.update_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.update_time_;
  _impl_.update_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogSink::_internal_mutable_update_time() {
  
  if (_impl_.update_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.update_time_ = p;
  }
  return _impl_.update_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogSink::mutable_update_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_update_time();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogSink.update_time)
  return _msg;
}
inline void LogSink::set_allocated_update_time(::PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_time_);
  }
  if (update_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_time));
    if (message_arena != submessage_arena) {
      update_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_time_ = update_time;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogSink.update_time)
}

inline bool LogSink::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void LogSink::clear_has_options() {
  _impl_._oneof_case_[0] = OPTIONS_NOT_SET;
}
inline LogSink::OptionsCase LogSink::options_case() const {
  return LogSink::OptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BigQueryOptions

// bool use_partitioned_tables = 1 [(.google.api.field_behavior) = OPTIONAL];
inline void BigQueryOptions::clear_use_partitioned_tables() {
  _impl_.use_partitioned_tables_ = false;
}
inline bool BigQueryOptions::_internal_use_partitioned_tables() const {
  return _impl_.use_partitioned_tables_;
}
inline bool BigQueryOptions::use_partitioned_tables() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.BigQueryOptions.use_partitioned_tables)
  return _internal_use_partitioned_tables();
}
inline void BigQueryOptions::_internal_set_use_partitioned_tables(bool value) {
  
  _impl_.use_partitioned_tables_ = value;
}
inline void BigQueryOptions::set_use_partitioned_tables(bool value) {
  _internal_set_use_partitioned_tables(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.BigQueryOptions.use_partitioned_tables)
}

// bool uses_timestamp_column_partitioning = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void BigQueryOptions::clear_uses_timestamp_column_partitioning() {
  _impl_.uses_timestamp_column_partitioning_ = false;
}
inline bool BigQueryOptions::_internal_uses_timestamp_column_partitioning() const {
  return _impl_.uses_timestamp_column_partitioning_;
}
inline bool BigQueryOptions::uses_timestamp_column_partitioning() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.BigQueryOptions.uses_timestamp_column_partitioning)
  return _internal_uses_timestamp_column_partitioning();
}
inline void BigQueryOptions::_internal_set_uses_timestamp_column_partitioning(bool value) {
  
  _impl_.uses_timestamp_column_partitioning_ = value;
}
inline void BigQueryOptions::set_uses_timestamp_column_partitioning(bool value) {
  _internal_set_uses_timestamp_column_partitioning(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.BigQueryOptions.uses_timestamp_column_partitioning)
}

// -------------------------------------------------------------------

// ListBucketsRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListBucketsRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListBucketsRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListBucketsRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListBucketsRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.ListBucketsRequest.parent)
}
inline std::string* ListBucketsRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListBucketsRequest.parent)
  return _s;
}
inline const std::string& ListBucketsRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListBucketsRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListBucketsRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListBucketsRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.logging.v2.ListBucketsRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListBucketsRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.ListBucketsRequest.parent)
}

// string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void ListBucketsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListBucketsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListBucketsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListBucketsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.ListBucketsRequest.page_token)
}
inline std::string* ListBucketsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListBucketsRequest.page_token)
  return _s;
}
inline const std::string& ListBucketsRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListBucketsRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListBucketsRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListBucketsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.logging.v2.ListBucketsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListBucketsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.ListBucketsRequest.page_token)
}

// int32 page_size = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void ListBucketsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListBucketsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListBucketsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListBucketsRequest.page_size)
  return _internal_page_size();
}
inline void ListBucketsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListBucketsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.ListBucketsRequest.page_size)
}

// -------------------------------------------------------------------

// ListBucketsResponse

// repeated .google.logging.v2.LogBucket buckets = 1;
inline int ListBucketsResponse::_internal_buckets_size() const {
  return _impl_.buckets_.size();
}
inline int ListBucketsResponse::buckets_size() const {
  return _internal_buckets_size();
}
inline void ListBucketsResponse::clear_buckets() {
  _impl_.buckets_.Clear();
}
inline ::google::logging::v2::LogBucket* ListBucketsResponse::mutable_buckets(int index) {
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListBucketsResponse.buckets)
  return _impl_.buckets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogBucket >*
ListBucketsResponse::mutable_buckets() {
  // @@protoc_insertion_point(field_mutable_list:google.logging.v2.ListBucketsResponse.buckets)
  return &_impl_.buckets_;
}
inline const ::google::logging::v2::LogBucket& ListBucketsResponse::_internal_buckets(int index) const {
  return _impl_.buckets_.Get(index);
}
inline const ::google::logging::v2::LogBucket& ListBucketsResponse::buckets(int index) const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListBucketsResponse.buckets)
  return _internal_buckets(index);
}
inline ::google::logging::v2::LogBucket* ListBucketsResponse::_internal_add_buckets() {
  return _impl_.buckets_.Add();
}
inline ::google::logging::v2::LogBucket* ListBucketsResponse::add_buckets() {
  ::google::logging::v2::LogBucket* _add = _internal_add_buckets();
  // @@protoc_insertion_point(field_add:google.logging.v2.ListBucketsResponse.buckets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogBucket >&
ListBucketsResponse::buckets() const {
  // @@protoc_insertion_point(field_list:google.logging.v2.ListBucketsResponse.buckets)
  return _impl_.buckets_;
}

// string next_page_token = 2;
inline void ListBucketsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListBucketsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListBucketsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListBucketsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.ListBucketsResponse.next_page_token)
}
inline std::string* ListBucketsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListBucketsResponse.next_page_token)
  return _s;
}
inline const std::string& ListBucketsResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListBucketsResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListBucketsResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListBucketsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.logging.v2.ListBucketsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListBucketsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.ListBucketsResponse.next_page_token)
}

// -------------------------------------------------------------------

// CreateBucketRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CreateBucketRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& CreateBucketRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CreateBucketRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateBucketRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.CreateBucketRequest.parent)
}
inline std::string* CreateBucketRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CreateBucketRequest.parent)
  return _s;
}
inline const std::string& CreateBucketRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void CreateBucketRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateBucketRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateBucketRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CreateBucketRequest.parent)
  return _impl_.parent_.Release();
}
inline void CreateBucketRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CreateBucketRequest.parent)
}

// string bucket_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void CreateBucketRequest::clear_bucket_id() {
  _impl_.bucket_id_.ClearToEmpty();
}
inline const std::string& CreateBucketRequest::bucket_id() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CreateBucketRequest.bucket_id)
  return _internal_bucket_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateBucketRequest::set_bucket_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bucket_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.CreateBucketRequest.bucket_id)
}
inline std::string* CreateBucketRequest::mutable_bucket_id() {
  std::string* _s = _internal_mutable_bucket_id();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CreateBucketRequest.bucket_id)
  return _s;
}
inline const std::string& CreateBucketRequest::_internal_bucket_id() const {
  return _impl_.bucket_id_.Get();
}
inline void CreateBucketRequest::_internal_set_bucket_id(const std::string& value) {
  
  _impl_.bucket_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateBucketRequest::_internal_mutable_bucket_id() {
  
  return _impl_.bucket_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateBucketRequest::release_bucket_id() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CreateBucketRequest.bucket_id)
  return _impl_.bucket_id_.Release();
}
inline void CreateBucketRequest::set_allocated_bucket_id(std::string* bucket_id) {
  if (bucket_id != nullptr) {
    
  } else {
    
  }
  _impl_.bucket_id_.SetAllocated(bucket_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bucket_id_.IsDefault()) {
    _impl_.bucket_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CreateBucketRequest.bucket_id)
}

// .google.logging.v2.LogBucket bucket = 3 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateBucketRequest::_internal_has_bucket() const {
  return this != internal_default_instance() && _impl_.bucket_ != nullptr;
}
inline bool CreateBucketRequest::has_bucket() const {
  return _internal_has_bucket();
}
inline void CreateBucketRequest::clear_bucket() {
  if (GetArenaForAllocation() == nullptr && _impl_.bucket_ != nullptr) {
    delete _impl_.bucket_;
  }
  _impl_.bucket_ = nullptr;
}
inline const ::google::logging::v2::LogBucket& CreateBucketRequest::_internal_bucket() const {
  const ::google::logging::v2::LogBucket* p = _impl_.bucket_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::logging::v2::LogBucket&>(
      ::google::logging::v2::_LogBucket_default_instance_);
}
inline const ::google::logging::v2::LogBucket& CreateBucketRequest::bucket() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CreateBucketRequest.bucket)
  return _internal_bucket();
}
inline void CreateBucketRequest::unsafe_arena_set_allocated_bucket(
    ::google::logging::v2::LogBucket* bucket) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bucket_);
  }
  _impl_.bucket_ = bucket;
  if (bucket) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.CreateBucketRequest.bucket)
}
inline ::google::logging::v2::LogBucket* CreateBucketRequest::release_bucket() {
  
  ::google::logging::v2::LogBucket* temp = _impl_.bucket_;
  _impl_.bucket_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::logging::v2::LogBucket* CreateBucketRequest::unsafe_arena_release_bucket() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CreateBucketRequest.bucket)
  
  ::google::logging::v2::LogBucket* temp = _impl_.bucket_;
  _impl_.bucket_ = nullptr;
  return temp;
}
inline ::google::logging::v2::LogBucket* CreateBucketRequest::_internal_mutable_bucket() {
  
  if (_impl_.bucket_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::logging::v2::LogBucket>(GetArenaForAllocation());
    _impl_.bucket_ = p;
  }
  return _impl_.bucket_;
}
inline ::google::logging::v2::LogBucket* CreateBucketRequest::mutable_bucket() {
  ::google::logging::v2::LogBucket* _msg = _internal_mutable_bucket();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CreateBucketRequest.bucket)
  return _msg;
}
inline void CreateBucketRequest::set_allocated_bucket(::google::logging::v2::LogBucket* bucket) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bucket_;
  }
  if (bucket) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bucket);
    if (message_arena != submessage_arena) {
      bucket = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bucket, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bucket_ = bucket;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CreateBucketRequest.bucket)
}

// -------------------------------------------------------------------

// UpdateBucketRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void UpdateBucketRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateBucketRequest::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateBucketRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateBucketRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.UpdateBucketRequest.name)
}
inline std::string* UpdateBucketRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateBucketRequest.name)
  return _s;
}
inline const std::string& UpdateBucketRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateBucketRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateBucketRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateBucketRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateBucketRequest.name)
  return _impl_.name_.Release();
}
inline void UpdateBucketRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateBucketRequest.name)
}

// .google.logging.v2.LogBucket bucket = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateBucketRequest::_internal_has_bucket() const {
  return this != internal_default_instance() && _impl_.bucket_ != nullptr;
}
inline bool UpdateBucketRequest::has_bucket() const {
  return _internal_has_bucket();
}
inline void UpdateBucketRequest::clear_bucket() {
  if (GetArenaForAllocation() == nullptr && _impl_.bucket_ != nullptr) {
    delete _impl_.bucket_;
  }
  _impl_.bucket_ = nullptr;
}
inline const ::google::logging::v2::LogBucket& UpdateBucketRequest::_internal_bucket() const {
  const ::google::logging::v2::LogBucket* p = _impl_.bucket_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::logging::v2::LogBucket&>(
      ::google::logging::v2::_LogBucket_default_instance_);
}
inline const ::google::logging::v2::LogBucket& UpdateBucketRequest::bucket() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateBucketRequest.bucket)
  return _internal_bucket();
}
inline void UpdateBucketRequest::unsafe_arena_set_allocated_bucket(
    ::google::logging::v2::LogBucket* bucket) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bucket_);
  }
  _impl_.bucket_ = bucket;
  if (bucket) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.UpdateBucketRequest.bucket)
}
inline ::google::logging::v2::LogBucket* UpdateBucketRequest::release_bucket() {
  
  ::google::logging::v2::LogBucket* temp = _impl_.bucket_;
  _impl_.bucket_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::logging::v2::LogBucket* UpdateBucketRequest::unsafe_arena_release_bucket() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateBucketRequest.bucket)
  
  ::google::logging::v2::LogBucket* temp = _impl_.bucket_;
  _impl_.bucket_ = nullptr;
  return temp;
}
inline ::google::logging::v2::LogBucket* UpdateBucketRequest::_internal_mutable_bucket() {
  
  if (_impl_.bucket_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::logging::v2::LogBucket>(GetArenaForAllocation());
    _impl_.bucket_ = p;
  }
  return _impl_.bucket_;
}
inline ::google::logging::v2::LogBucket* UpdateBucketRequest::mutable_bucket() {
  ::google::logging::v2::LogBucket* _msg = _internal_mutable_bucket();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateBucketRequest.bucket)
  return _msg;
}
inline void UpdateBucketRequest::set_allocated_bucket(::google::logging::v2::LogBucket* bucket) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bucket_;
  }
  if (bucket) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bucket);
    if (message_arena != submessage_arena) {
      bucket = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bucket, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bucket_ = bucket;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateBucketRequest.bucket)
}

// .google.protobuf.FieldMask update_mask = 4 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateBucketRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateBucketRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateBucketRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateBucketRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateBucketRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateBucketRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.UpdateBucketRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateBucketRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateBucketRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateBucketRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateBucketRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateBucketRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateBucketRequest.update_mask)
  return _msg;
}
inline void UpdateBucketRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateBucketRequest.update_mask)
}

// -------------------------------------------------------------------

// GetBucketRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetBucketRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetBucketRequest::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.GetBucketRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBucketRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.GetBucketRequest.name)
}
inline std::string* GetBucketRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.GetBucketRequest.name)
  return _s;
}
inline const std::string& GetBucketRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetBucketRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBucketRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBucketRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.GetBucketRequest.name)
  return _impl_.name_.Release();
}
inline void GetBucketRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.GetBucketRequest.name)
}

// -------------------------------------------------------------------

// DeleteBucketRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteBucketRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteBucketRequest::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.DeleteBucketRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteBucketRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.DeleteBucketRequest.name)
}
inline std::string* DeleteBucketRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.DeleteBucketRequest.name)
  return _s;
}
inline const std::string& DeleteBucketRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteBucketRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteBucketRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteBucketRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.DeleteBucketRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteBucketRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.DeleteBucketRequest.name)
}

// -------------------------------------------------------------------

// UndeleteBucketRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void UndeleteBucketRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UndeleteBucketRequest::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UndeleteBucketRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UndeleteBucketRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.UndeleteBucketRequest.name)
}
inline std::string* UndeleteBucketRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UndeleteBucketRequest.name)
  return _s;
}
inline const std::string& UndeleteBucketRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UndeleteBucketRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UndeleteBucketRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UndeleteBucketRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UndeleteBucketRequest.name)
  return _impl_.name_.Release();
}
inline void UndeleteBucketRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UndeleteBucketRequest.name)
}

// -------------------------------------------------------------------

// ListViewsRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED];
inline void ListViewsRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListViewsRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListViewsRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListViewsRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.ListViewsRequest.parent)
}
inline std::string* ListViewsRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListViewsRequest.parent)
  return _s;
}
inline const std::string& ListViewsRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListViewsRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListViewsRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListViewsRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.logging.v2.ListViewsRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListViewsRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.ListViewsRequest.parent)
}

// string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void ListViewsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListViewsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListViewsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListViewsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.ListViewsRequest.page_token)
}
inline std::string* ListViewsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListViewsRequest.page_token)
  return _s;
}
inline const std::string& ListViewsRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListViewsRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListViewsRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListViewsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.logging.v2.ListViewsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListViewsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.ListViewsRequest.page_token)
}

// int32 page_size = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void ListViewsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListViewsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListViewsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListViewsRequest.page_size)
  return _internal_page_size();
}
inline void ListViewsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListViewsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.ListViewsRequest.page_size)
}

// -------------------------------------------------------------------

// ListViewsResponse

// repeated .google.logging.v2.LogView views = 1;
inline int ListViewsResponse::_internal_views_size() const {
  return _impl_.views_.size();
}
inline int ListViewsResponse::views_size() const {
  return _internal_views_size();
}
inline void ListViewsResponse::clear_views() {
  _impl_.views_.Clear();
}
inline ::google::logging::v2::LogView* ListViewsResponse::mutable_views(int index) {
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListViewsResponse.views)
  return _impl_.views_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogView >*
ListViewsResponse::mutable_views() {
  // @@protoc_insertion_point(field_mutable_list:google.logging.v2.ListViewsResponse.views)
  return &_impl_.views_;
}
inline const ::google::logging::v2::LogView& ListViewsResponse::_internal_views(int index) const {
  return _impl_.views_.Get(index);
}
inline const ::google::logging::v2::LogView& ListViewsResponse::views(int index) const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListViewsResponse.views)
  return _internal_views(index);
}
inline ::google::logging::v2::LogView* ListViewsResponse::_internal_add_views() {
  return _impl_.views_.Add();
}
inline ::google::logging::v2::LogView* ListViewsResponse::add_views() {
  ::google::logging::v2::LogView* _add = _internal_add_views();
  // @@protoc_insertion_point(field_add:google.logging.v2.ListViewsResponse.views)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogView >&
ListViewsResponse::views() const {
  // @@protoc_insertion_point(field_list:google.logging.v2.ListViewsResponse.views)
  return _impl_.views_;
}

// string next_page_token = 2;
inline void ListViewsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListViewsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListViewsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListViewsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.ListViewsResponse.next_page_token)
}
inline std::string* ListViewsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListViewsResponse.next_page_token)
  return _s;
}
inline const std::string& ListViewsResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListViewsResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListViewsResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListViewsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.logging.v2.ListViewsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListViewsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.ListViewsResponse.next_page_token)
}

// -------------------------------------------------------------------

// CreateViewRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED];
inline void CreateViewRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& CreateViewRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CreateViewRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateViewRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.CreateViewRequest.parent)
}
inline std::string* CreateViewRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CreateViewRequest.parent)
  return _s;
}
inline const std::string& CreateViewRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void CreateViewRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateViewRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateViewRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CreateViewRequest.parent)
  return _impl_.parent_.Release();
}
inline void CreateViewRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CreateViewRequest.parent)
}

// string view_id = 2 [(.google.api.field_behavior) = REQUIRED];
inline void CreateViewRequest::clear_view_id() {
  _impl_.view_id_.ClearToEmpty();
}
inline const std::string& CreateViewRequest::view_id() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CreateViewRequest.view_id)
  return _internal_view_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateViewRequest::set_view_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.view_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.CreateViewRequest.view_id)
}
inline std::string* CreateViewRequest::mutable_view_id() {
  std::string* _s = _internal_mutable_view_id();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CreateViewRequest.view_id)
  return _s;
}
inline const std::string& CreateViewRequest::_internal_view_id() const {
  return _impl_.view_id_.Get();
}
inline void CreateViewRequest::_internal_set_view_id(const std::string& value) {
  
  _impl_.view_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateViewRequest::_internal_mutable_view_id() {
  
  return _impl_.view_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateViewRequest::release_view_id() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CreateViewRequest.view_id)
  return _impl_.view_id_.Release();
}
inline void CreateViewRequest::set_allocated_view_id(std::string* view_id) {
  if (view_id != nullptr) {
    
  } else {
    
  }
  _impl_.view_id_.SetAllocated(view_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.view_id_.IsDefault()) {
    _impl_.view_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CreateViewRequest.view_id)
}

// .google.logging.v2.LogView view = 3 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateViewRequest::_internal_has_view() const {
  return this != internal_default_instance() && _impl_.view_ != nullptr;
}
inline bool CreateViewRequest::has_view() const {
  return _internal_has_view();
}
inline void CreateViewRequest::clear_view() {
  if (GetArenaForAllocation() == nullptr && _impl_.view_ != nullptr) {
    delete _impl_.view_;
  }
  _impl_.view_ = nullptr;
}
inline const ::google::logging::v2::LogView& CreateViewRequest::_internal_view() const {
  const ::google::logging::v2::LogView* p = _impl_.view_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::logging::v2::LogView&>(
      ::google::logging::v2::_LogView_default_instance_);
}
inline const ::google::logging::v2::LogView& CreateViewRequest::view() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CreateViewRequest.view)
  return _internal_view();
}
inline void CreateViewRequest::unsafe_arena_set_allocated_view(
    ::google::logging::v2::LogView* view) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.view_);
  }
  _impl_.view_ = view;
  if (view) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.CreateViewRequest.view)
}
inline ::google::logging::v2::LogView* CreateViewRequest::release_view() {
  
  ::google::logging::v2::LogView* temp = _impl_.view_;
  _impl_.view_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::logging::v2::LogView* CreateViewRequest::unsafe_arena_release_view() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CreateViewRequest.view)
  
  ::google::logging::v2::LogView* temp = _impl_.view_;
  _impl_.view_ = nullptr;
  return temp;
}
inline ::google::logging::v2::LogView* CreateViewRequest::_internal_mutable_view() {
  
  if (_impl_.view_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::logging::v2::LogView>(GetArenaForAllocation());
    _impl_.view_ = p;
  }
  return _impl_.view_;
}
inline ::google::logging::v2::LogView* CreateViewRequest::mutable_view() {
  ::google::logging::v2::LogView* _msg = _internal_mutable_view();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CreateViewRequest.view)
  return _msg;
}
inline void CreateViewRequest::set_allocated_view(::google::logging::v2::LogView* view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.view_;
  }
  if (view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(view);
    if (message_arena != submessage_arena) {
      view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, view, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.view_ = view;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CreateViewRequest.view)
}

// -------------------------------------------------------------------

// UpdateViewRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void UpdateViewRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateViewRequest::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateViewRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateViewRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.UpdateViewRequest.name)
}
inline std::string* UpdateViewRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateViewRequest.name)
  return _s;
}
inline const std::string& UpdateViewRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateViewRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateViewRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateViewRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateViewRequest.name)
  return _impl_.name_.Release();
}
inline void UpdateViewRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateViewRequest.name)
}

// .google.logging.v2.LogView view = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateViewRequest::_internal_has_view() const {
  return this != internal_default_instance() && _impl_.view_ != nullptr;
}
inline bool UpdateViewRequest::has_view() const {
  return _internal_has_view();
}
inline void UpdateViewRequest::clear_view() {
  if (GetArenaForAllocation() == nullptr && _impl_.view_ != nullptr) {
    delete _impl_.view_;
  }
  _impl_.view_ = nullptr;
}
inline const ::google::logging::v2::LogView& UpdateViewRequest::_internal_view() const {
  const ::google::logging::v2::LogView* p = _impl_.view_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::logging::v2::LogView&>(
      ::google::logging::v2::_LogView_default_instance_);
}
inline const ::google::logging::v2::LogView& UpdateViewRequest::view() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateViewRequest.view)
  return _internal_view();
}
inline void UpdateViewRequest::unsafe_arena_set_allocated_view(
    ::google::logging::v2::LogView* view) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.view_);
  }
  _impl_.view_ = view;
  if (view) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.UpdateViewRequest.view)
}
inline ::google::logging::v2::LogView* UpdateViewRequest::release_view() {
  
  ::google::logging::v2::LogView* temp = _impl_.view_;
  _impl_.view_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::logging::v2::LogView* UpdateViewRequest::unsafe_arena_release_view() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateViewRequest.view)
  
  ::google::logging::v2::LogView* temp = _impl_.view_;
  _impl_.view_ = nullptr;
  return temp;
}
inline ::google::logging::v2::LogView* UpdateViewRequest::_internal_mutable_view() {
  
  if (_impl_.view_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::logging::v2::LogView>(GetArenaForAllocation());
    _impl_.view_ = p;
  }
  return _impl_.view_;
}
inline ::google::logging::v2::LogView* UpdateViewRequest::mutable_view() {
  ::google::logging::v2::LogView* _msg = _internal_mutable_view();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateViewRequest.view)
  return _msg;
}
inline void UpdateViewRequest::set_allocated_view(::google::logging::v2::LogView* view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.view_;
  }
  if (view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(view);
    if (message_arena != submessage_arena) {
      view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, view, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.view_ = view;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateViewRequest.view)
}

// .google.protobuf.FieldMask update_mask = 4 [(.google.api.field_behavior) = OPTIONAL];
inline bool UpdateViewRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateViewRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateViewRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateViewRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateViewRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateViewRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.UpdateViewRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateViewRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateViewRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateViewRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateViewRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateViewRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateViewRequest.update_mask)
  return _msg;
}
inline void UpdateViewRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateViewRequest.update_mask)
}

// -------------------------------------------------------------------

// GetViewRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetViewRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetViewRequest::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.GetViewRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetViewRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.GetViewRequest.name)
}
inline std::string* GetViewRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.GetViewRequest.name)
  return _s;
}
inline const std::string& GetViewRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetViewRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetViewRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetViewRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.GetViewRequest.name)
  return _impl_.name_.Release();
}
inline void GetViewRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.GetViewRequest.name)
}

// -------------------------------------------------------------------

// DeleteViewRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteViewRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteViewRequest::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.DeleteViewRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteViewRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.DeleteViewRequest.name)
}
inline std::string* DeleteViewRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.DeleteViewRequest.name)
  return _s;
}
inline const std::string& DeleteViewRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteViewRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteViewRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteViewRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.DeleteViewRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteViewRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.DeleteViewRequest.name)
}

// -------------------------------------------------------------------

// ListSinksRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListSinksRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListSinksRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListSinksRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListSinksRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.ListSinksRequest.parent)
}
inline std::string* ListSinksRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListSinksRequest.parent)
  return _s;
}
inline const std::string& ListSinksRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListSinksRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListSinksRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListSinksRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.logging.v2.ListSinksRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListSinksRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.ListSinksRequest.parent)
}

// string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void ListSinksRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListSinksRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListSinksRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListSinksRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.ListSinksRequest.page_token)
}
inline std::string* ListSinksRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListSinksRequest.page_token)
  return _s;
}
inline const std::string& ListSinksRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListSinksRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListSinksRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListSinksRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.logging.v2.ListSinksRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListSinksRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.ListSinksRequest.page_token)
}

// int32 page_size = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void ListSinksRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListSinksRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListSinksRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListSinksRequest.page_size)
  return _internal_page_size();
}
inline void ListSinksRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListSinksRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.ListSinksRequest.page_size)
}

// -------------------------------------------------------------------

// ListSinksResponse

// repeated .google.logging.v2.LogSink sinks = 1;
inline int ListSinksResponse::_internal_sinks_size() const {
  return _impl_.sinks_.size();
}
inline int ListSinksResponse::sinks_size() const {
  return _internal_sinks_size();
}
inline void ListSinksResponse::clear_sinks() {
  _impl_.sinks_.Clear();
}
inline ::google::logging::v2::LogSink* ListSinksResponse::mutable_sinks(int index) {
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListSinksResponse.sinks)
  return _impl_.sinks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogSink >*
ListSinksResponse::mutable_sinks() {
  // @@protoc_insertion_point(field_mutable_list:google.logging.v2.ListSinksResponse.sinks)
  return &_impl_.sinks_;
}
inline const ::google::logging::v2::LogSink& ListSinksResponse::_internal_sinks(int index) const {
  return _impl_.sinks_.Get(index);
}
inline const ::google::logging::v2::LogSink& ListSinksResponse::sinks(int index) const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListSinksResponse.sinks)
  return _internal_sinks(index);
}
inline ::google::logging::v2::LogSink* ListSinksResponse::_internal_add_sinks() {
  return _impl_.sinks_.Add();
}
inline ::google::logging::v2::LogSink* ListSinksResponse::add_sinks() {
  ::google::logging::v2::LogSink* _add = _internal_add_sinks();
  // @@protoc_insertion_point(field_add:google.logging.v2.ListSinksResponse.sinks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogSink >&
ListSinksResponse::sinks() const {
  // @@protoc_insertion_point(field_list:google.logging.v2.ListSinksResponse.sinks)
  return _impl_.sinks_;
}

// string next_page_token = 2;
inline void ListSinksResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListSinksResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListSinksResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListSinksResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.ListSinksResponse.next_page_token)
}
inline std::string* ListSinksResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListSinksResponse.next_page_token)
  return _s;
}
inline const std::string& ListSinksResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListSinksResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListSinksResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListSinksResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.logging.v2.ListSinksResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListSinksResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.ListSinksResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetSinkRequest

// string sink_name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetSinkRequest::clear_sink_name() {
  _impl_.sink_name_.ClearToEmpty();
}
inline const std::string& GetSinkRequest::sink_name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.GetSinkRequest.sink_name)
  return _internal_sink_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSinkRequest::set_sink_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sink_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.GetSinkRequest.sink_name)
}
inline std::string* GetSinkRequest::mutable_sink_name() {
  std::string* _s = _internal_mutable_sink_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.GetSinkRequest.sink_name)
  return _s;
}
inline const std::string& GetSinkRequest::_internal_sink_name() const {
  return _impl_.sink_name_.Get();
}
inline void GetSinkRequest::_internal_set_sink_name(const std::string& value) {
  
  _impl_.sink_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSinkRequest::_internal_mutable_sink_name() {
  
  return _impl_.sink_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSinkRequest::release_sink_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.GetSinkRequest.sink_name)
  return _impl_.sink_name_.Release();
}
inline void GetSinkRequest::set_allocated_sink_name(std::string* sink_name) {
  if (sink_name != nullptr) {
    
  } else {
    
  }
  _impl_.sink_name_.SetAllocated(sink_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sink_name_.IsDefault()) {
    _impl_.sink_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.GetSinkRequest.sink_name)
}

// -------------------------------------------------------------------

// CreateSinkRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CreateSinkRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& CreateSinkRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CreateSinkRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSinkRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.CreateSinkRequest.parent)
}
inline std::string* CreateSinkRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CreateSinkRequest.parent)
  return _s;
}
inline const std::string& CreateSinkRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void CreateSinkRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSinkRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSinkRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CreateSinkRequest.parent)
  return _impl_.parent_.Release();
}
inline void CreateSinkRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CreateSinkRequest.parent)
}

// .google.logging.v2.LogSink sink = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateSinkRequest::_internal_has_sink() const {
  return this != internal_default_instance() && _impl_.sink_ != nullptr;
}
inline bool CreateSinkRequest::has_sink() const {
  return _internal_has_sink();
}
inline void CreateSinkRequest::clear_sink() {
  if (GetArenaForAllocation() == nullptr && _impl_.sink_ != nullptr) {
    delete _impl_.sink_;
  }
  _impl_.sink_ = nullptr;
}
inline const ::google::logging::v2::LogSink& CreateSinkRequest::_internal_sink() const {
  const ::google::logging::v2::LogSink* p = _impl_.sink_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::logging::v2::LogSink&>(
      ::google::logging::v2::_LogSink_default_instance_);
}
inline const ::google::logging::v2::LogSink& CreateSinkRequest::sink() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CreateSinkRequest.sink)
  return _internal_sink();
}
inline void CreateSinkRequest::unsafe_arena_set_allocated_sink(
    ::google::logging::v2::LogSink* sink) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sink_);
  }
  _impl_.sink_ = sink;
  if (sink) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.CreateSinkRequest.sink)
}
inline ::google::logging::v2::LogSink* CreateSinkRequest::release_sink() {
  
  ::google::logging::v2::LogSink* temp = _impl_.sink_;
  _impl_.sink_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::logging::v2::LogSink* CreateSinkRequest::unsafe_arena_release_sink() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CreateSinkRequest.sink)
  
  ::google::logging::v2::LogSink* temp = _impl_.sink_;
  _impl_.sink_ = nullptr;
  return temp;
}
inline ::google::logging::v2::LogSink* CreateSinkRequest::_internal_mutable_sink() {
  
  if (_impl_.sink_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::logging::v2::LogSink>(GetArenaForAllocation());
    _impl_.sink_ = p;
  }
  return _impl_.sink_;
}
inline ::google::logging::v2::LogSink* CreateSinkRequest::mutable_sink() {
  ::google::logging::v2::LogSink* _msg = _internal_mutable_sink();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CreateSinkRequest.sink)
  return _msg;
}
inline void CreateSinkRequest::set_allocated_sink(::google::logging::v2::LogSink* sink) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sink_;
  }
  if (sink) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sink);
    if (message_arena != submessage_arena) {
      sink = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sink, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sink_ = sink;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CreateSinkRequest.sink)
}

// bool unique_writer_identity = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void CreateSinkRequest::clear_unique_writer_identity() {
  _impl_.unique_writer_identity_ = false;
}
inline bool CreateSinkRequest::_internal_unique_writer_identity() const {
  return _impl_.unique_writer_identity_;
}
inline bool CreateSinkRequest::unique_writer_identity() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CreateSinkRequest.unique_writer_identity)
  return _internal_unique_writer_identity();
}
inline void CreateSinkRequest::_internal_set_unique_writer_identity(bool value) {
  
  _impl_.unique_writer_identity_ = value;
}
inline void CreateSinkRequest::set_unique_writer_identity(bool value) {
  _internal_set_unique_writer_identity(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.CreateSinkRequest.unique_writer_identity)
}

// -------------------------------------------------------------------

// UpdateSinkRequest

// string sink_name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void UpdateSinkRequest::clear_sink_name() {
  _impl_.sink_name_.ClearToEmpty();
}
inline const std::string& UpdateSinkRequest::sink_name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateSinkRequest.sink_name)
  return _internal_sink_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSinkRequest::set_sink_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sink_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.UpdateSinkRequest.sink_name)
}
inline std::string* UpdateSinkRequest::mutable_sink_name() {
  std::string* _s = _internal_mutable_sink_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateSinkRequest.sink_name)
  return _s;
}
inline const std::string& UpdateSinkRequest::_internal_sink_name() const {
  return _impl_.sink_name_.Get();
}
inline void UpdateSinkRequest::_internal_set_sink_name(const std::string& value) {
  
  _impl_.sink_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateSinkRequest::_internal_mutable_sink_name() {
  
  return _impl_.sink_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateSinkRequest::release_sink_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateSinkRequest.sink_name)
  return _impl_.sink_name_.Release();
}
inline void UpdateSinkRequest::set_allocated_sink_name(std::string* sink_name) {
  if (sink_name != nullptr) {
    
  } else {
    
  }
  _impl_.sink_name_.SetAllocated(sink_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sink_name_.IsDefault()) {
    _impl_.sink_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateSinkRequest.sink_name)
}

// .google.logging.v2.LogSink sink = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateSinkRequest::_internal_has_sink() const {
  return this != internal_default_instance() && _impl_.sink_ != nullptr;
}
inline bool UpdateSinkRequest::has_sink() const {
  return _internal_has_sink();
}
inline void UpdateSinkRequest::clear_sink() {
  if (GetArenaForAllocation() == nullptr && _impl_.sink_ != nullptr) {
    delete _impl_.sink_;
  }
  _impl_.sink_ = nullptr;
}
inline const ::google::logging::v2::LogSink& UpdateSinkRequest::_internal_sink() const {
  const ::google::logging::v2::LogSink* p = _impl_.sink_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::logging::v2::LogSink&>(
      ::google::logging::v2::_LogSink_default_instance_);
}
inline const ::google::logging::v2::LogSink& UpdateSinkRequest::sink() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateSinkRequest.sink)
  return _internal_sink();
}
inline void UpdateSinkRequest::unsafe_arena_set_allocated_sink(
    ::google::logging::v2::LogSink* sink) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sink_);
  }
  _impl_.sink_ = sink;
  if (sink) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.UpdateSinkRequest.sink)
}
inline ::google::logging::v2::LogSink* UpdateSinkRequest::release_sink() {
  
  ::google::logging::v2::LogSink* temp = _impl_.sink_;
  _impl_.sink_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::logging::v2::LogSink* UpdateSinkRequest::unsafe_arena_release_sink() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateSinkRequest.sink)
  
  ::google::logging::v2::LogSink* temp = _impl_.sink_;
  _impl_.sink_ = nullptr;
  return temp;
}
inline ::google::logging::v2::LogSink* UpdateSinkRequest::_internal_mutable_sink() {
  
  if (_impl_.sink_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::logging::v2::LogSink>(GetArenaForAllocation());
    _impl_.sink_ = p;
  }
  return _impl_.sink_;
}
inline ::google::logging::v2::LogSink* UpdateSinkRequest::mutable_sink() {
  ::google::logging::v2::LogSink* _msg = _internal_mutable_sink();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateSinkRequest.sink)
  return _msg;
}
inline void UpdateSinkRequest::set_allocated_sink(::google::logging::v2::LogSink* sink) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sink_;
  }
  if (sink) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sink);
    if (message_arena != submessage_arena) {
      sink = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sink, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sink_ = sink;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateSinkRequest.sink)
}

// bool unique_writer_identity = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void UpdateSinkRequest::clear_unique_writer_identity() {
  _impl_.unique_writer_identity_ = false;
}
inline bool UpdateSinkRequest::_internal_unique_writer_identity() const {
  return _impl_.unique_writer_identity_;
}
inline bool UpdateSinkRequest::unique_writer_identity() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateSinkRequest.unique_writer_identity)
  return _internal_unique_writer_identity();
}
inline void UpdateSinkRequest::_internal_set_unique_writer_identity(bool value) {
  
  _impl_.unique_writer_identity_ = value;
}
inline void UpdateSinkRequest::set_unique_writer_identity(bool value) {
  _internal_set_unique_writer_identity(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.UpdateSinkRequest.unique_writer_identity)
}

// .google.protobuf.FieldMask update_mask = 4 [(.google.api.field_behavior) = OPTIONAL];
inline bool UpdateSinkRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateSinkRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateSinkRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateSinkRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateSinkRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateSinkRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.UpdateSinkRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateSinkRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateSinkRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateSinkRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateSinkRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateSinkRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateSinkRequest.update_mask)
  return _msg;
}
inline void UpdateSinkRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateSinkRequest.update_mask)
}

// -------------------------------------------------------------------

// DeleteSinkRequest

// string sink_name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteSinkRequest::clear_sink_name() {
  _impl_.sink_name_.ClearToEmpty();
}
inline const std::string& DeleteSinkRequest::sink_name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.DeleteSinkRequest.sink_name)
  return _internal_sink_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteSinkRequest::set_sink_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sink_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.DeleteSinkRequest.sink_name)
}
inline std::string* DeleteSinkRequest::mutable_sink_name() {
  std::string* _s = _internal_mutable_sink_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.DeleteSinkRequest.sink_name)
  return _s;
}
inline const std::string& DeleteSinkRequest::_internal_sink_name() const {
  return _impl_.sink_name_.Get();
}
inline void DeleteSinkRequest::_internal_set_sink_name(const std::string& value) {
  
  _impl_.sink_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteSinkRequest::_internal_mutable_sink_name() {
  
  return _impl_.sink_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteSinkRequest::release_sink_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.DeleteSinkRequest.sink_name)
  return _impl_.sink_name_.Release();
}
inline void DeleteSinkRequest::set_allocated_sink_name(std::string* sink_name) {
  if (sink_name != nullptr) {
    
  } else {
    
  }
  _impl_.sink_name_.SetAllocated(sink_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sink_name_.IsDefault()) {
    _impl_.sink_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.DeleteSinkRequest.sink_name)
}

// -------------------------------------------------------------------

// LogExclusion

// string name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void LogExclusion::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LogExclusion::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogExclusion.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogExclusion::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.LogExclusion.name)
}
inline std::string* LogExclusion::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogExclusion.name)
  return _s;
}
inline const std::string& LogExclusion::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LogExclusion::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LogExclusion::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LogExclusion::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogExclusion.name)
  return _impl_.name_.Release();
}
inline void LogExclusion::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogExclusion.name)
}

// string description = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void LogExclusion::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& LogExclusion::description() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogExclusion.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogExclusion::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.LogExclusion.description)
}
inline std::string* LogExclusion::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogExclusion.description)
  return _s;
}
inline const std::string& LogExclusion::_internal_description() const {
  return _impl_.description_.Get();
}
inline void LogExclusion::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* LogExclusion::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* LogExclusion::release_description() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogExclusion.description)
  return _impl_.description_.Release();
}
inline void LogExclusion::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogExclusion.description)
}

// string filter = 3 [(.google.api.field_behavior) = REQUIRED];
inline void LogExclusion::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& LogExclusion::filter() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogExclusion.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogExclusion::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.LogExclusion.filter)
}
inline std::string* LogExclusion::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogExclusion.filter)
  return _s;
}
inline const std::string& LogExclusion::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void LogExclusion::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* LogExclusion::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* LogExclusion::release_filter() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogExclusion.filter)
  return _impl_.filter_.Release();
}
inline void LogExclusion::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogExclusion.filter)
}

// bool disabled = 4 [(.google.api.field_behavior) = OPTIONAL];
inline void LogExclusion::clear_disabled() {
  _impl_.disabled_ = false;
}
inline bool LogExclusion::_internal_disabled() const {
  return _impl_.disabled_;
}
inline bool LogExclusion::disabled() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogExclusion.disabled)
  return _internal_disabled();
}
inline void LogExclusion::_internal_set_disabled(bool value) {
  
  _impl_.disabled_ = value;
}
inline void LogExclusion::set_disabled(bool value) {
  _internal_set_disabled(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.LogExclusion.disabled)
}

// .google.protobuf.Timestamp create_time = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool LogExclusion::_internal_has_create_time() const {
  return this != internal_default_instance() && _impl_.create_time_ != nullptr;
}
inline bool LogExclusion::has_create_time() const {
  return _internal_has_create_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogExclusion::_internal_create_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.create_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogExclusion::create_time() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogExclusion.create_time)
  return _internal_create_time();
}
inline void LogExclusion::unsafe_arena_set_allocated_create_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  _impl_.create_time_ = create_time;
  if (create_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.LogExclusion.create_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogExclusion::release_create_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogExclusion::unsafe_arena_release_create_time() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogExclusion.create_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.create_time_;
  _impl_.create_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogExclusion::_internal_mutable_create_time() {
  
  if (_impl_.create_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.create_time_ = p;
  }
  return _impl_.create_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogExclusion::mutable_create_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogExclusion.create_time)
  return _msg;
}
inline void LogExclusion::set_allocated_create_time(::PROTOBUF_NAMESPACE_ID::Timestamp* create_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.create_time_);
  }
  if (create_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_time));
    if (message_arena != submessage_arena) {
      create_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.create_time_ = create_time;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogExclusion.create_time)
}

// .google.protobuf.Timestamp update_time = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool LogExclusion::_internal_has_update_time() const {
  return this != internal_default_instance() && _impl_.update_time_ != nullptr;
}
inline bool LogExclusion::has_update_time() const {
  return _internal_has_update_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogExclusion::_internal_update_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.update_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogExclusion::update_time() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.LogExclusion.update_time)
  return _internal_update_time();
}
inline void LogExclusion::unsafe_arena_set_allocated_update_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_time_);
  }
  _impl_.update_time_ = update_time;
  if (update_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.LogExclusion.update_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogExclusion::release_update_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.update_time_;
  _impl_.update_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogExclusion::unsafe_arena_release_update_time() {
  // @@protoc_insertion_point(field_release:google.logging.v2.LogExclusion.update_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.update_time_;
  _impl_.update_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogExclusion::_internal_mutable_update_time() {
  
  if (_impl_.update_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.update_time_ = p;
  }
  return _impl_.update_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogExclusion::mutable_update_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_update_time();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.LogExclusion.update_time)
  return _msg;
}
inline void LogExclusion::set_allocated_update_time(::PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_time_);
  }
  if (update_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_time));
    if (message_arena != submessage_arena) {
      update_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_time_ = update_time;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.LogExclusion.update_time)
}

// -------------------------------------------------------------------

// ListExclusionsRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListExclusionsRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListExclusionsRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListExclusionsRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListExclusionsRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.ListExclusionsRequest.parent)
}
inline std::string* ListExclusionsRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListExclusionsRequest.parent)
  return _s;
}
inline const std::string& ListExclusionsRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListExclusionsRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListExclusionsRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListExclusionsRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.logging.v2.ListExclusionsRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListExclusionsRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.ListExclusionsRequest.parent)
}

// string page_token = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void ListExclusionsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListExclusionsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListExclusionsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListExclusionsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.ListExclusionsRequest.page_token)
}
inline std::string* ListExclusionsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListExclusionsRequest.page_token)
  return _s;
}
inline const std::string& ListExclusionsRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListExclusionsRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListExclusionsRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListExclusionsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:google.logging.v2.ListExclusionsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListExclusionsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.ListExclusionsRequest.page_token)
}

// int32 page_size = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void ListExclusionsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListExclusionsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListExclusionsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListExclusionsRequest.page_size)
  return _internal_page_size();
}
inline void ListExclusionsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListExclusionsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.ListExclusionsRequest.page_size)
}

// -------------------------------------------------------------------

// ListExclusionsResponse

// repeated .google.logging.v2.LogExclusion exclusions = 1;
inline int ListExclusionsResponse::_internal_exclusions_size() const {
  return _impl_.exclusions_.size();
}
inline int ListExclusionsResponse::exclusions_size() const {
  return _internal_exclusions_size();
}
inline void ListExclusionsResponse::clear_exclusions() {
  _impl_.exclusions_.Clear();
}
inline ::google::logging::v2::LogExclusion* ListExclusionsResponse::mutable_exclusions(int index) {
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListExclusionsResponse.exclusions)
  return _impl_.exclusions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogExclusion >*
ListExclusionsResponse::mutable_exclusions() {
  // @@protoc_insertion_point(field_mutable_list:google.logging.v2.ListExclusionsResponse.exclusions)
  return &_impl_.exclusions_;
}
inline const ::google::logging::v2::LogExclusion& ListExclusionsResponse::_internal_exclusions(int index) const {
  return _impl_.exclusions_.Get(index);
}
inline const ::google::logging::v2::LogExclusion& ListExclusionsResponse::exclusions(int index) const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListExclusionsResponse.exclusions)
  return _internal_exclusions(index);
}
inline ::google::logging::v2::LogExclusion* ListExclusionsResponse::_internal_add_exclusions() {
  return _impl_.exclusions_.Add();
}
inline ::google::logging::v2::LogExclusion* ListExclusionsResponse::add_exclusions() {
  ::google::logging::v2::LogExclusion* _add = _internal_add_exclusions();
  // @@protoc_insertion_point(field_add:google.logging.v2.ListExclusionsResponse.exclusions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::logging::v2::LogExclusion >&
ListExclusionsResponse::exclusions() const {
  // @@protoc_insertion_point(field_list:google.logging.v2.ListExclusionsResponse.exclusions)
  return _impl_.exclusions_;
}

// string next_page_token = 2;
inline void ListExclusionsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListExclusionsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.ListExclusionsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListExclusionsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.ListExclusionsResponse.next_page_token)
}
inline std::string* ListExclusionsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.ListExclusionsResponse.next_page_token)
  return _s;
}
inline const std::string& ListExclusionsResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListExclusionsResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListExclusionsResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListExclusionsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:google.logging.v2.ListExclusionsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListExclusionsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.ListExclusionsResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetExclusionRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetExclusionRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetExclusionRequest::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.GetExclusionRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetExclusionRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.GetExclusionRequest.name)
}
inline std::string* GetExclusionRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.GetExclusionRequest.name)
  return _s;
}
inline const std::string& GetExclusionRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetExclusionRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetExclusionRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetExclusionRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.GetExclusionRequest.name)
  return _impl_.name_.Release();
}
inline void GetExclusionRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.GetExclusionRequest.name)
}

// -------------------------------------------------------------------

// CreateExclusionRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CreateExclusionRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& CreateExclusionRequest::parent() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CreateExclusionRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateExclusionRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.CreateExclusionRequest.parent)
}
inline std::string* CreateExclusionRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CreateExclusionRequest.parent)
  return _s;
}
inline const std::string& CreateExclusionRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void CreateExclusionRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateExclusionRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateExclusionRequest::release_parent() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CreateExclusionRequest.parent)
  return _impl_.parent_.Release();
}
inline void CreateExclusionRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CreateExclusionRequest.parent)
}

// .google.logging.v2.LogExclusion exclusion = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateExclusionRequest::_internal_has_exclusion() const {
  return this != internal_default_instance() && _impl_.exclusion_ != nullptr;
}
inline bool CreateExclusionRequest::has_exclusion() const {
  return _internal_has_exclusion();
}
inline void CreateExclusionRequest::clear_exclusion() {
  if (GetArenaForAllocation() == nullptr && _impl_.exclusion_ != nullptr) {
    delete _impl_.exclusion_;
  }
  _impl_.exclusion_ = nullptr;
}
inline const ::google::logging::v2::LogExclusion& CreateExclusionRequest::_internal_exclusion() const {
  const ::google::logging::v2::LogExclusion* p = _impl_.exclusion_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::logging::v2::LogExclusion&>(
      ::google::logging::v2::_LogExclusion_default_instance_);
}
inline const ::google::logging::v2::LogExclusion& CreateExclusionRequest::exclusion() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CreateExclusionRequest.exclusion)
  return _internal_exclusion();
}
inline void CreateExclusionRequest::unsafe_arena_set_allocated_exclusion(
    ::google::logging::v2::LogExclusion* exclusion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.exclusion_);
  }
  _impl_.exclusion_ = exclusion;
  if (exclusion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.CreateExclusionRequest.exclusion)
}
inline ::google::logging::v2::LogExclusion* CreateExclusionRequest::release_exclusion() {
  
  ::google::logging::v2::LogExclusion* temp = _impl_.exclusion_;
  _impl_.exclusion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::logging::v2::LogExclusion* CreateExclusionRequest::unsafe_arena_release_exclusion() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CreateExclusionRequest.exclusion)
  
  ::google::logging::v2::LogExclusion* temp = _impl_.exclusion_;
  _impl_.exclusion_ = nullptr;
  return temp;
}
inline ::google::logging::v2::LogExclusion* CreateExclusionRequest::_internal_mutable_exclusion() {
  
  if (_impl_.exclusion_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::logging::v2::LogExclusion>(GetArenaForAllocation());
    _impl_.exclusion_ = p;
  }
  return _impl_.exclusion_;
}
inline ::google::logging::v2::LogExclusion* CreateExclusionRequest::mutable_exclusion() {
  ::google::logging::v2::LogExclusion* _msg = _internal_mutable_exclusion();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CreateExclusionRequest.exclusion)
  return _msg;
}
inline void CreateExclusionRequest::set_allocated_exclusion(::google::logging::v2::LogExclusion* exclusion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.exclusion_;
  }
  if (exclusion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(exclusion);
    if (message_arena != submessage_arena) {
      exclusion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exclusion, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.exclusion_ = exclusion;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CreateExclusionRequest.exclusion)
}

// -------------------------------------------------------------------

// UpdateExclusionRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void UpdateExclusionRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateExclusionRequest::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateExclusionRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateExclusionRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.UpdateExclusionRequest.name)
}
inline std::string* UpdateExclusionRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateExclusionRequest.name)
  return _s;
}
inline const std::string& UpdateExclusionRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateExclusionRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateExclusionRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateExclusionRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateExclusionRequest.name)
  return _impl_.name_.Release();
}
inline void UpdateExclusionRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateExclusionRequest.name)
}

// .google.logging.v2.LogExclusion exclusion = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateExclusionRequest::_internal_has_exclusion() const {
  return this != internal_default_instance() && _impl_.exclusion_ != nullptr;
}
inline bool UpdateExclusionRequest::has_exclusion() const {
  return _internal_has_exclusion();
}
inline void UpdateExclusionRequest::clear_exclusion() {
  if (GetArenaForAllocation() == nullptr && _impl_.exclusion_ != nullptr) {
    delete _impl_.exclusion_;
  }
  _impl_.exclusion_ = nullptr;
}
inline const ::google::logging::v2::LogExclusion& UpdateExclusionRequest::_internal_exclusion() const {
  const ::google::logging::v2::LogExclusion* p = _impl_.exclusion_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::logging::v2::LogExclusion&>(
      ::google::logging::v2::_LogExclusion_default_instance_);
}
inline const ::google::logging::v2::LogExclusion& UpdateExclusionRequest::exclusion() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateExclusionRequest.exclusion)
  return _internal_exclusion();
}
inline void UpdateExclusionRequest::unsafe_arena_set_allocated_exclusion(
    ::google::logging::v2::LogExclusion* exclusion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.exclusion_);
  }
  _impl_.exclusion_ = exclusion;
  if (exclusion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.UpdateExclusionRequest.exclusion)
}
inline ::google::logging::v2::LogExclusion* UpdateExclusionRequest::release_exclusion() {
  
  ::google::logging::v2::LogExclusion* temp = _impl_.exclusion_;
  _impl_.exclusion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::logging::v2::LogExclusion* UpdateExclusionRequest::unsafe_arena_release_exclusion() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateExclusionRequest.exclusion)
  
  ::google::logging::v2::LogExclusion* temp = _impl_.exclusion_;
  _impl_.exclusion_ = nullptr;
  return temp;
}
inline ::google::logging::v2::LogExclusion* UpdateExclusionRequest::_internal_mutable_exclusion() {
  
  if (_impl_.exclusion_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::logging::v2::LogExclusion>(GetArenaForAllocation());
    _impl_.exclusion_ = p;
  }
  return _impl_.exclusion_;
}
inline ::google::logging::v2::LogExclusion* UpdateExclusionRequest::mutable_exclusion() {
  ::google::logging::v2::LogExclusion* _msg = _internal_mutable_exclusion();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateExclusionRequest.exclusion)
  return _msg;
}
inline void UpdateExclusionRequest::set_allocated_exclusion(::google::logging::v2::LogExclusion* exclusion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.exclusion_;
  }
  if (exclusion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(exclusion);
    if (message_arena != submessage_arena) {
      exclusion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exclusion, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.exclusion_ = exclusion;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateExclusionRequest.exclusion)
}

// .google.protobuf.FieldMask update_mask = 3 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateExclusionRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateExclusionRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateExclusionRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateExclusionRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateExclusionRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateExclusionRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.UpdateExclusionRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateExclusionRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateExclusionRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateExclusionRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateExclusionRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateExclusionRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateExclusionRequest.update_mask)
  return _msg;
}
inline void UpdateExclusionRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateExclusionRequest.update_mask)
}

// -------------------------------------------------------------------

// DeleteExclusionRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteExclusionRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteExclusionRequest::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.DeleteExclusionRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteExclusionRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.DeleteExclusionRequest.name)
}
inline std::string* DeleteExclusionRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.DeleteExclusionRequest.name)
  return _s;
}
inline const std::string& DeleteExclusionRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteExclusionRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteExclusionRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteExclusionRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.DeleteExclusionRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteExclusionRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.DeleteExclusionRequest.name)
}

// -------------------------------------------------------------------

// GetCmekSettingsRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetCmekSettingsRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetCmekSettingsRequest::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.GetCmekSettingsRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCmekSettingsRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.GetCmekSettingsRequest.name)
}
inline std::string* GetCmekSettingsRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.GetCmekSettingsRequest.name)
  return _s;
}
inline const std::string& GetCmekSettingsRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetCmekSettingsRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetCmekSettingsRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetCmekSettingsRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.GetCmekSettingsRequest.name)
  return _impl_.name_.Release();
}
inline void GetCmekSettingsRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.GetCmekSettingsRequest.name)
}

// -------------------------------------------------------------------

// UpdateCmekSettingsRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void UpdateCmekSettingsRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateCmekSettingsRequest::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateCmekSettingsRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateCmekSettingsRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.UpdateCmekSettingsRequest.name)
}
inline std::string* UpdateCmekSettingsRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateCmekSettingsRequest.name)
  return _s;
}
inline const std::string& UpdateCmekSettingsRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateCmekSettingsRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateCmekSettingsRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateCmekSettingsRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateCmekSettingsRequest.name)
  return _impl_.name_.Release();
}
inline void UpdateCmekSettingsRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateCmekSettingsRequest.name)
}

// .google.logging.v2.CmekSettings cmek_settings = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateCmekSettingsRequest::_internal_has_cmek_settings() const {
  return this != internal_default_instance() && _impl_.cmek_settings_ != nullptr;
}
inline bool UpdateCmekSettingsRequest::has_cmek_settings() const {
  return _internal_has_cmek_settings();
}
inline void UpdateCmekSettingsRequest::clear_cmek_settings() {
  if (GetArenaForAllocation() == nullptr && _impl_.cmek_settings_ != nullptr) {
    delete _impl_.cmek_settings_;
  }
  _impl_.cmek_settings_ = nullptr;
}
inline const ::google::logging::v2::CmekSettings& UpdateCmekSettingsRequest::_internal_cmek_settings() const {
  const ::google::logging::v2::CmekSettings* p = _impl_.cmek_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::logging::v2::CmekSettings&>(
      ::google::logging::v2::_CmekSettings_default_instance_);
}
inline const ::google::logging::v2::CmekSettings& UpdateCmekSettingsRequest::cmek_settings() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateCmekSettingsRequest.cmek_settings)
  return _internal_cmek_settings();
}
inline void UpdateCmekSettingsRequest::unsafe_arena_set_allocated_cmek_settings(
    ::google::logging::v2::CmekSettings* cmek_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cmek_settings_);
  }
  _impl_.cmek_settings_ = cmek_settings;
  if (cmek_settings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.UpdateCmekSettingsRequest.cmek_settings)
}
inline ::google::logging::v2::CmekSettings* UpdateCmekSettingsRequest::release_cmek_settings() {
  
  ::google::logging::v2::CmekSettings* temp = _impl_.cmek_settings_;
  _impl_.cmek_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::logging::v2::CmekSettings* UpdateCmekSettingsRequest::unsafe_arena_release_cmek_settings() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateCmekSettingsRequest.cmek_settings)
  
  ::google::logging::v2::CmekSettings* temp = _impl_.cmek_settings_;
  _impl_.cmek_settings_ = nullptr;
  return temp;
}
inline ::google::logging::v2::CmekSettings* UpdateCmekSettingsRequest::_internal_mutable_cmek_settings() {
  
  if (_impl_.cmek_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::logging::v2::CmekSettings>(GetArenaForAllocation());
    _impl_.cmek_settings_ = p;
  }
  return _impl_.cmek_settings_;
}
inline ::google::logging::v2::CmekSettings* UpdateCmekSettingsRequest::mutable_cmek_settings() {
  ::google::logging::v2::CmekSettings* _msg = _internal_mutable_cmek_settings();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateCmekSettingsRequest.cmek_settings)
  return _msg;
}
inline void UpdateCmekSettingsRequest::set_allocated_cmek_settings(::google::logging::v2::CmekSettings* cmek_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cmek_settings_;
  }
  if (cmek_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cmek_settings);
    if (message_arena != submessage_arena) {
      cmek_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cmek_settings, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cmek_settings_ = cmek_settings;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateCmekSettingsRequest.cmek_settings)
}

// .google.protobuf.FieldMask update_mask = 3 [(.google.api.field_behavior) = OPTIONAL];
inline bool UpdateCmekSettingsRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateCmekSettingsRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateCmekSettingsRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateCmekSettingsRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateCmekSettingsRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateCmekSettingsRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.UpdateCmekSettingsRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateCmekSettingsRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateCmekSettingsRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateCmekSettingsRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateCmekSettingsRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateCmekSettingsRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateCmekSettingsRequest.update_mask)
  return _msg;
}
inline void UpdateCmekSettingsRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateCmekSettingsRequest.update_mask)
}

// -------------------------------------------------------------------

// CmekSettings

// string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void CmekSettings::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CmekSettings::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CmekSettings.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CmekSettings::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.CmekSettings.name)
}
inline std::string* CmekSettings::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CmekSettings.name)
  return _s;
}
inline const std::string& CmekSettings::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CmekSettings::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CmekSettings::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CmekSettings::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CmekSettings.name)
  return _impl_.name_.Release();
}
inline void CmekSettings::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CmekSettings.name)
}

// string kms_key_name = 2;
inline void CmekSettings::clear_kms_key_name() {
  _impl_.kms_key_name_.ClearToEmpty();
}
inline const std::string& CmekSettings::kms_key_name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CmekSettings.kms_key_name)
  return _internal_kms_key_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CmekSettings::set_kms_key_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.kms_key_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.CmekSettings.kms_key_name)
}
inline std::string* CmekSettings::mutable_kms_key_name() {
  std::string* _s = _internal_mutable_kms_key_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CmekSettings.kms_key_name)
  return _s;
}
inline const std::string& CmekSettings::_internal_kms_key_name() const {
  return _impl_.kms_key_name_.Get();
}
inline void CmekSettings::_internal_set_kms_key_name(const std::string& value) {
  
  _impl_.kms_key_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CmekSettings::_internal_mutable_kms_key_name() {
  
  return _impl_.kms_key_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CmekSettings::release_kms_key_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CmekSettings.kms_key_name)
  return _impl_.kms_key_name_.Release();
}
inline void CmekSettings::set_allocated_kms_key_name(std::string* kms_key_name) {
  if (kms_key_name != nullptr) {
    
  } else {
    
  }
  _impl_.kms_key_name_.SetAllocated(kms_key_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kms_key_name_.IsDefault()) {
    _impl_.kms_key_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CmekSettings.kms_key_name)
}

// string service_account_id = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void CmekSettings::clear_service_account_id() {
  _impl_.service_account_id_.ClearToEmpty();
}
inline const std::string& CmekSettings::service_account_id() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CmekSettings.service_account_id)
  return _internal_service_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CmekSettings::set_service_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.CmekSettings.service_account_id)
}
inline std::string* CmekSettings::mutable_service_account_id() {
  std::string* _s = _internal_mutable_service_account_id();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CmekSettings.service_account_id)
  return _s;
}
inline const std::string& CmekSettings::_internal_service_account_id() const {
  return _impl_.service_account_id_.Get();
}
inline void CmekSettings::_internal_set_service_account_id(const std::string& value) {
  
  _impl_.service_account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CmekSettings::_internal_mutable_service_account_id() {
  
  return _impl_.service_account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CmekSettings::release_service_account_id() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CmekSettings.service_account_id)
  return _impl_.service_account_id_.Release();
}
inline void CmekSettings::set_allocated_service_account_id(std::string* service_account_id) {
  if (service_account_id != nullptr) {
    
  } else {
    
  }
  _impl_.service_account_id_.SetAllocated(service_account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_account_id_.IsDefault()) {
    _impl_.service_account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CmekSettings.service_account_id)
}

// -------------------------------------------------------------------

// GetSettingsRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetSettingsRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetSettingsRequest::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.GetSettingsRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSettingsRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.GetSettingsRequest.name)
}
inline std::string* GetSettingsRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.GetSettingsRequest.name)
  return _s;
}
inline const std::string& GetSettingsRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetSettingsRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSettingsRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSettingsRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.GetSettingsRequest.name)
  return _impl_.name_.Release();
}
inline void GetSettingsRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.GetSettingsRequest.name)
}

// -------------------------------------------------------------------

// UpdateSettingsRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void UpdateSettingsRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateSettingsRequest::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateSettingsRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSettingsRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.UpdateSettingsRequest.name)
}
inline std::string* UpdateSettingsRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateSettingsRequest.name)
  return _s;
}
inline const std::string& UpdateSettingsRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateSettingsRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateSettingsRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateSettingsRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateSettingsRequest.name)
  return _impl_.name_.Release();
}
inline void UpdateSettingsRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateSettingsRequest.name)
}

// .google.logging.v2.Settings settings = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateSettingsRequest::_internal_has_settings() const {
  return this != internal_default_instance() && _impl_.settings_ != nullptr;
}
inline bool UpdateSettingsRequest::has_settings() const {
  return _internal_has_settings();
}
inline void UpdateSettingsRequest::clear_settings() {
  if (GetArenaForAllocation() == nullptr && _impl_.settings_ != nullptr) {
    delete _impl_.settings_;
  }
  _impl_.settings_ = nullptr;
}
inline const ::google::logging::v2::Settings& UpdateSettingsRequest::_internal_settings() const {
  const ::google::logging::v2::Settings* p = _impl_.settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::logging::v2::Settings&>(
      ::google::logging::v2::_Settings_default_instance_);
}
inline const ::google::logging::v2::Settings& UpdateSettingsRequest::settings() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateSettingsRequest.settings)
  return _internal_settings();
}
inline void UpdateSettingsRequest::unsafe_arena_set_allocated_settings(
    ::google::logging::v2::Settings* settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settings_);
  }
  _impl_.settings_ = settings;
  if (settings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.UpdateSettingsRequest.settings)
}
inline ::google::logging::v2::Settings* UpdateSettingsRequest::release_settings() {
  
  ::google::logging::v2::Settings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::logging::v2::Settings* UpdateSettingsRequest::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateSettingsRequest.settings)
  
  ::google::logging::v2::Settings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
  return temp;
}
inline ::google::logging::v2::Settings* UpdateSettingsRequest::_internal_mutable_settings() {
  
  if (_impl_.settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::logging::v2::Settings>(GetArenaForAllocation());
    _impl_.settings_ = p;
  }
  return _impl_.settings_;
}
inline ::google::logging::v2::Settings* UpdateSettingsRequest::mutable_settings() {
  ::google::logging::v2::Settings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateSettingsRequest.settings)
  return _msg;
}
inline void UpdateSettingsRequest::set_allocated_settings(::google::logging::v2::Settings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.settings_;
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateSettingsRequest.settings)
}

// .google.protobuf.FieldMask update_mask = 3 [(.google.api.field_behavior) = OPTIONAL];
inline bool UpdateSettingsRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateSettingsRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateSettingsRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateSettingsRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.UpdateSettingsRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateSettingsRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.UpdateSettingsRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateSettingsRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateSettingsRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:google.logging.v2.UpdateSettingsRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateSettingsRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateSettingsRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.UpdateSettingsRequest.update_mask)
  return _msg;
}
inline void UpdateSettingsRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.UpdateSettingsRequest.update_mask)
}

// -------------------------------------------------------------------

// Settings

// string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Settings::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Settings::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.Settings.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Settings::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.Settings.name)
}
inline std::string* Settings::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.Settings.name)
  return _s;
}
inline const std::string& Settings::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Settings::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Settings::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Settings::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.Settings.name)
  return _impl_.name_.Release();
}
inline void Settings::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.Settings.name)
}

// string kms_key_name = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void Settings::clear_kms_key_name() {
  _impl_.kms_key_name_.ClearToEmpty();
}
inline const std::string& Settings::kms_key_name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.Settings.kms_key_name)
  return _internal_kms_key_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Settings::set_kms_key_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.kms_key_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.Settings.kms_key_name)
}
inline std::string* Settings::mutable_kms_key_name() {
  std::string* _s = _internal_mutable_kms_key_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.Settings.kms_key_name)
  return _s;
}
inline const std::string& Settings::_internal_kms_key_name() const {
  return _impl_.kms_key_name_.Get();
}
inline void Settings::_internal_set_kms_key_name(const std::string& value) {
  
  _impl_.kms_key_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Settings::_internal_mutable_kms_key_name() {
  
  return _impl_.kms_key_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Settings::release_kms_key_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.Settings.kms_key_name)
  return _impl_.kms_key_name_.Release();
}
inline void Settings::set_allocated_kms_key_name(std::string* kms_key_name) {
  if (kms_key_name != nullptr) {
    
  } else {
    
  }
  _impl_.kms_key_name_.SetAllocated(kms_key_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kms_key_name_.IsDefault()) {
    _impl_.kms_key_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.Settings.kms_key_name)
}

// string kms_service_account_id = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Settings::clear_kms_service_account_id() {
  _impl_.kms_service_account_id_.ClearToEmpty();
}
inline const std::string& Settings::kms_service_account_id() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.Settings.kms_service_account_id)
  return _internal_kms_service_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Settings::set_kms_service_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.kms_service_account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.Settings.kms_service_account_id)
}
inline std::string* Settings::mutable_kms_service_account_id() {
  std::string* _s = _internal_mutable_kms_service_account_id();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.Settings.kms_service_account_id)
  return _s;
}
inline const std::string& Settings::_internal_kms_service_account_id() const {
  return _impl_.kms_service_account_id_.Get();
}
inline void Settings::_internal_set_kms_service_account_id(const std::string& value) {
  
  _impl_.kms_service_account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Settings::_internal_mutable_kms_service_account_id() {
  
  return _impl_.kms_service_account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Settings::release_kms_service_account_id() {
  // @@protoc_insertion_point(field_release:google.logging.v2.Settings.kms_service_account_id)
  return _impl_.kms_service_account_id_.Release();
}
inline void Settings::set_allocated_kms_service_account_id(std::string* kms_service_account_id) {
  if (kms_service_account_id != nullptr) {
    
  } else {
    
  }
  _impl_.kms_service_account_id_.SetAllocated(kms_service_account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kms_service_account_id_.IsDefault()) {
    _impl_.kms_service_account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.Settings.kms_service_account_id)
}

// string storage_location = 4 [(.google.api.field_behavior) = OPTIONAL];
inline void Settings::clear_storage_location() {
  _impl_.storage_location_.ClearToEmpty();
}
inline const std::string& Settings::storage_location() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.Settings.storage_location)
  return _internal_storage_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Settings::set_storage_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.storage_location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.Settings.storage_location)
}
inline std::string* Settings::mutable_storage_location() {
  std::string* _s = _internal_mutable_storage_location();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.Settings.storage_location)
  return _s;
}
inline const std::string& Settings::_internal_storage_location() const {
  return _impl_.storage_location_.Get();
}
inline void Settings::_internal_set_storage_location(const std::string& value) {
  
  _impl_.storage_location_.Set(value, GetArenaForAllocation());
}
inline std::string* Settings::_internal_mutable_storage_location() {
  
  return _impl_.storage_location_.Mutable(GetArenaForAllocation());
}
inline std::string* Settings::release_storage_location() {
  // @@protoc_insertion_point(field_release:google.logging.v2.Settings.storage_location)
  return _impl_.storage_location_.Release();
}
inline void Settings::set_allocated_storage_location(std::string* storage_location) {
  if (storage_location != nullptr) {
    
  } else {
    
  }
  _impl_.storage_location_.SetAllocated(storage_location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.storage_location_.IsDefault()) {
    _impl_.storage_location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.Settings.storage_location)
}

// bool disable_default_sink = 5 [(.google.api.field_behavior) = OPTIONAL];
inline void Settings::clear_disable_default_sink() {
  _impl_.disable_default_sink_ = false;
}
inline bool Settings::_internal_disable_default_sink() const {
  return _impl_.disable_default_sink_;
}
inline bool Settings::disable_default_sink() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.Settings.disable_default_sink)
  return _internal_disable_default_sink();
}
inline void Settings::_internal_set_disable_default_sink(bool value) {
  
  _impl_.disable_default_sink_ = value;
}
inline void Settings::set_disable_default_sink(bool value) {
  _internal_set_disable_default_sink(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.Settings.disable_default_sink)
}

// -------------------------------------------------------------------

// CopyLogEntriesRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED];
inline void CopyLogEntriesRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CopyLogEntriesRequest::name() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CopyLogEntriesRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CopyLogEntriesRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.CopyLogEntriesRequest.name)
}
inline std::string* CopyLogEntriesRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CopyLogEntriesRequest.name)
  return _s;
}
inline const std::string& CopyLogEntriesRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CopyLogEntriesRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CopyLogEntriesRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CopyLogEntriesRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CopyLogEntriesRequest.name)
  return _impl_.name_.Release();
}
inline void CopyLogEntriesRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CopyLogEntriesRequest.name)
}

// string filter = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void CopyLogEntriesRequest::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& CopyLogEntriesRequest::filter() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CopyLogEntriesRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CopyLogEntriesRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.CopyLogEntriesRequest.filter)
}
inline std::string* CopyLogEntriesRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CopyLogEntriesRequest.filter)
  return _s;
}
inline const std::string& CopyLogEntriesRequest::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void CopyLogEntriesRequest::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* CopyLogEntriesRequest::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* CopyLogEntriesRequest::release_filter() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CopyLogEntriesRequest.filter)
  return _impl_.filter_.Release();
}
inline void CopyLogEntriesRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CopyLogEntriesRequest.filter)
}

// string destination = 4 [(.google.api.field_behavior) = REQUIRED];
inline void CopyLogEntriesRequest::clear_destination() {
  _impl_.destination_.ClearToEmpty();
}
inline const std::string& CopyLogEntriesRequest::destination() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CopyLogEntriesRequest.destination)
  return _internal_destination();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CopyLogEntriesRequest::set_destination(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destination_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.CopyLogEntriesRequest.destination)
}
inline std::string* CopyLogEntriesRequest::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CopyLogEntriesRequest.destination)
  return _s;
}
inline const std::string& CopyLogEntriesRequest::_internal_destination() const {
  return _impl_.destination_.Get();
}
inline void CopyLogEntriesRequest::_internal_set_destination(const std::string& value) {
  
  _impl_.destination_.Set(value, GetArenaForAllocation());
}
inline std::string* CopyLogEntriesRequest::_internal_mutable_destination() {
  
  return _impl_.destination_.Mutable(GetArenaForAllocation());
}
inline std::string* CopyLogEntriesRequest::release_destination() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CopyLogEntriesRequest.destination)
  return _impl_.destination_.Release();
}
inline void CopyLogEntriesRequest::set_allocated_destination(std::string* destination) {
  if (destination != nullptr) {
    
  } else {
    
  }
  _impl_.destination_.SetAllocated(destination, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destination_.IsDefault()) {
    _impl_.destination_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CopyLogEntriesRequest.destination)
}

// -------------------------------------------------------------------

// CopyLogEntriesMetadata

// .google.protobuf.Timestamp start_time = 1;
inline bool CopyLogEntriesMetadata::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool CopyLogEntriesMetadata::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CopyLogEntriesMetadata::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CopyLogEntriesMetadata::start_time() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CopyLogEntriesMetadata.start_time)
  return _internal_start_time();
}
inline void CopyLogEntriesMetadata::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.CopyLogEntriesMetadata.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CopyLogEntriesMetadata::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CopyLogEntriesMetadata::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CopyLogEntriesMetadata.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CopyLogEntriesMetadata::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CopyLogEntriesMetadata::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CopyLogEntriesMetadata.start_time)
  return _msg;
}
inline void CopyLogEntriesMetadata::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CopyLogEntriesMetadata.start_time)
}

// .google.protobuf.Timestamp end_time = 2;
inline bool CopyLogEntriesMetadata::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool CopyLogEntriesMetadata::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CopyLogEntriesMetadata::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CopyLogEntriesMetadata::end_time() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CopyLogEntriesMetadata.end_time)
  return _internal_end_time();
}
inline void CopyLogEntriesMetadata::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.CopyLogEntriesMetadata.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CopyLogEntriesMetadata::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CopyLogEntriesMetadata::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CopyLogEntriesMetadata.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CopyLogEntriesMetadata::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CopyLogEntriesMetadata::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CopyLogEntriesMetadata.end_time)
  return _msg;
}
inline void CopyLogEntriesMetadata::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CopyLogEntriesMetadata.end_time)
}

// .google.logging.v2.OperationState state = 3;
inline void CopyLogEntriesMetadata::clear_state() {
  _impl_.state_ = 0;
}
inline ::google::logging::v2::OperationState CopyLogEntriesMetadata::_internal_state() const {
  return static_cast< ::google::logging::v2::OperationState >(_impl_.state_);
}
inline ::google::logging::v2::OperationState CopyLogEntriesMetadata::state() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CopyLogEntriesMetadata.state)
  return _internal_state();
}
inline void CopyLogEntriesMetadata::_internal_set_state(::google::logging::v2::OperationState value) {
  
  _impl_.state_ = value;
}
inline void CopyLogEntriesMetadata::set_state(::google::logging::v2::OperationState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.CopyLogEntriesMetadata.state)
}

// bool cancellation_requested = 4;
inline void CopyLogEntriesMetadata::clear_cancellation_requested() {
  _impl_.cancellation_requested_ = false;
}
inline bool CopyLogEntriesMetadata::_internal_cancellation_requested() const {
  return _impl_.cancellation_requested_;
}
inline bool CopyLogEntriesMetadata::cancellation_requested() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CopyLogEntriesMetadata.cancellation_requested)
  return _internal_cancellation_requested();
}
inline void CopyLogEntriesMetadata::_internal_set_cancellation_requested(bool value) {
  
  _impl_.cancellation_requested_ = value;
}
inline void CopyLogEntriesMetadata::set_cancellation_requested(bool value) {
  _internal_set_cancellation_requested(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.CopyLogEntriesMetadata.cancellation_requested)
}

// .google.logging.v2.CopyLogEntriesRequest request = 5;
inline bool CopyLogEntriesMetadata::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool CopyLogEntriesMetadata::has_request() const {
  return _internal_has_request();
}
inline void CopyLogEntriesMetadata::clear_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_ != nullptr) {
    delete _impl_.request_;
  }
  _impl_.request_ = nullptr;
}
inline const ::google::logging::v2::CopyLogEntriesRequest& CopyLogEntriesMetadata::_internal_request() const {
  const ::google::logging::v2::CopyLogEntriesRequest* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::logging::v2::CopyLogEntriesRequest&>(
      ::google::logging::v2::_CopyLogEntriesRequest_default_instance_);
}
inline const ::google::logging::v2::CopyLogEntriesRequest& CopyLogEntriesMetadata::request() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CopyLogEntriesMetadata.request)
  return _internal_request();
}
inline void CopyLogEntriesMetadata::unsafe_arena_set_allocated_request(
    ::google::logging::v2::CopyLogEntriesRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.logging.v2.CopyLogEntriesMetadata.request)
}
inline ::google::logging::v2::CopyLogEntriesRequest* CopyLogEntriesMetadata::release_request() {
  
  ::google::logging::v2::CopyLogEntriesRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::google::logging::v2::CopyLogEntriesRequest* CopyLogEntriesMetadata::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CopyLogEntriesMetadata.request)
  
  ::google::logging::v2::CopyLogEntriesRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::google::logging::v2::CopyLogEntriesRequest* CopyLogEntriesMetadata::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::logging::v2::CopyLogEntriesRequest>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::google::logging::v2::CopyLogEntriesRequest* CopyLogEntriesMetadata::mutable_request() {
  ::google::logging::v2::CopyLogEntriesRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CopyLogEntriesMetadata.request)
  return _msg;
}
inline void CopyLogEntriesMetadata::set_allocated_request(::google::logging::v2::CopyLogEntriesRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CopyLogEntriesMetadata.request)
}

// int32 progress = 6;
inline void CopyLogEntriesMetadata::clear_progress() {
  _impl_.progress_ = 0;
}
inline int32_t CopyLogEntriesMetadata::_internal_progress() const {
  return _impl_.progress_;
}
inline int32_t CopyLogEntriesMetadata::progress() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CopyLogEntriesMetadata.progress)
  return _internal_progress();
}
inline void CopyLogEntriesMetadata::_internal_set_progress(int32_t value) {
  
  _impl_.progress_ = value;
}
inline void CopyLogEntriesMetadata::set_progress(int32_t value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.CopyLogEntriesMetadata.progress)
}

// string writer_identity = 7;
inline void CopyLogEntriesMetadata::clear_writer_identity() {
  _impl_.writer_identity_.ClearToEmpty();
}
inline const std::string& CopyLogEntriesMetadata::writer_identity() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CopyLogEntriesMetadata.writer_identity)
  return _internal_writer_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CopyLogEntriesMetadata::set_writer_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.writer_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:google.logging.v2.CopyLogEntriesMetadata.writer_identity)
}
inline std::string* CopyLogEntriesMetadata::mutable_writer_identity() {
  std::string* _s = _internal_mutable_writer_identity();
  // @@protoc_insertion_point(field_mutable:google.logging.v2.CopyLogEntriesMetadata.writer_identity)
  return _s;
}
inline const std::string& CopyLogEntriesMetadata::_internal_writer_identity() const {
  return _impl_.writer_identity_.Get();
}
inline void CopyLogEntriesMetadata::_internal_set_writer_identity(const std::string& value) {
  
  _impl_.writer_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* CopyLogEntriesMetadata::_internal_mutable_writer_identity() {
  
  return _impl_.writer_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* CopyLogEntriesMetadata::release_writer_identity() {
  // @@protoc_insertion_point(field_release:google.logging.v2.CopyLogEntriesMetadata.writer_identity)
  return _impl_.writer_identity_.Release();
}
inline void CopyLogEntriesMetadata::set_allocated_writer_identity(std::string* writer_identity) {
  if (writer_identity != nullptr) {
    
  } else {
    
  }
  _impl_.writer_identity_.SetAllocated(writer_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.writer_identity_.IsDefault()) {
    _impl_.writer_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:google.logging.v2.CopyLogEntriesMetadata.writer_identity)
}

// -------------------------------------------------------------------

// CopyLogEntriesResponse

// int64 log_entries_copied_count = 1;
inline void CopyLogEntriesResponse::clear_log_entries_copied_count() {
  _impl_.log_entries_copied_count_ = int64_t{0};
}
inline int64_t CopyLogEntriesResponse::_internal_log_entries_copied_count() const {
  return _impl_.log_entries_copied_count_;
}
inline int64_t CopyLogEntriesResponse::log_entries_copied_count() const {
  // @@protoc_insertion_point(field_get:google.logging.v2.CopyLogEntriesResponse.log_entries_copied_count)
  return _internal_log_entries_copied_count();
}
inline void CopyLogEntriesResponse::_internal_set_log_entries_copied_count(int64_t value) {
  
  _impl_.log_entries_copied_count_ = value;
}
inline void CopyLogEntriesResponse::set_log_entries_copied_count(int64_t value) {
  _internal_set_log_entries_copied_count(value);
  // @@protoc_insertion_point(field_set:google.logging.v2.CopyLogEntriesResponse.log_entries_copied_count)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace logging
}  // namespace google

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::google::logging::v2::LogSink_VersionFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::logging::v2::LogSink_VersionFormat>() {
  return ::google::logging::v2::LogSink_VersionFormat_descriptor();
}
template <> struct is_proto_enum< ::google::logging::v2::LifecycleState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::logging::v2::LifecycleState>() {
  return ::google::logging::v2::LifecycleState_descriptor();
}
template <> struct is_proto_enum< ::google::logging::v2::OperationState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::logging::v2::OperationState>() {
  return ::google::logging::v2::OperationState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_google_2flogging_2fv2_2flogging_5fconfig_2eproto
